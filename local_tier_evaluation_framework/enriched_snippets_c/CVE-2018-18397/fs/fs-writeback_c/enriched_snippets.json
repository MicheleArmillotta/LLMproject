[
  {
    "function_name": "sync_inode_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2476-2484",
    "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_inode",
          "args": [
            "inode",
            "&wbc"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "sync_inode_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2476-2484",
          "snippet": "int sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode_metadata(struct inode *inode, int wait)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode = wait ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.nr_to_write = 0, /* metadata-only */\n\t};\n\n\treturn sync_inode(inode, &wbc);\n}"
  },
  {
    "function_name": "sync_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2461-2464",
    "snippet": "int sync_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn writeback_single_inode(inode, wbc);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_single_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_single_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1391-1446",
          "snippet": "static int writeback_single_inode(struct inode *inode,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb;\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\twbc_attach_and_unlock_inode(wbc, inode);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\twbc_detach_inode(wbc);\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int writeback_single_inode(struct inode *inode,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb;\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\twbc_attach_and_unlock_inode(wbc, inode);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\twbc_detach_inode(wbc);\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint sync_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn writeback_single_inode(inode, wbc);\n}"
  },
  {
    "function_name": "write_inode_now",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2433-2447",
    "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, &wbc);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_single_inode",
          "args": [
            "inode",
            "&wbc"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_single_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1391-1446",
          "snippet": "static int writeback_single_inode(struct inode *inode,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb;\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\twbc_attach_and_unlock_inode(wbc, inode);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\twbc_detach_inode(wbc);\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int writeback_single_inode(struct inode *inode,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb;\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\twbc_attach_and_unlock_inode(wbc, inode);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\twbc_detach_inode(wbc);\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_cap_writeback_dirty",
          "args": [
            "inode->i_mapping"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, &wbc);\n}"
  },
  {
    "function_name": "sync_inodes_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2393-2420",
    "snippet": "void sync_inodes_sb(struct super_block *sb)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\t/*\n\t * Can't skip on !bdi_has_dirty() because we should wait for !dirty\n\t * inodes under writeback and I_DIRTY_TIME inodes ignored by\n\t * bdi_has_dirty() need to be written out too.\n\t */\n\tif (bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(bdi, &work, false);\n\twb_wait_for_completion(bdi, &done);\n\n\twait_sb_inodes(sb);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_sb_inodes",
          "args": [
            "sb"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "wait_sb_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2229-2312",
          "snippet": "static void wait_sb_inodes(struct super_block *sb)\n{\n\tLIST_HEAD(sync_list);\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tmutex_lock(&sb->s_sync_lock);\n\n\t/*\n\t * Splice the writeback list onto a temporary list to avoid waiting on\n\t * inodes that have started writeback after this point.\n\t *\n\t * Use rcu_read_lock() to keep the inodes around until we have a\n\t * reference. s_inode_wblist_lock protects sb->s_inodes_wb as well as\n\t * the local list because inodes can be dropped from either by writeback\n\t * completion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\tlist_splice_init(&sb->s_inodes_wb, &sync_list);\n\n\t/*\n\t * Data integrity sync. Must wait for all pages under writeback, because\n\t * there may have been pages dirtied before our sync call, but which had\n\t * writeout started before we write it out.  In which case, the inode\n\t * may not be on the dirty list, but we still have to wait for that\n\t * writeout.\n\t */\n\twhile (!list_empty(&sync_list)) {\n\t\tstruct inode *inode = list_first_entry(&sync_list, struct inode,\n\t\t\t\t\t\t       i_wb_list);\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\t/*\n\t\t * Move each inode back to the wb list before we drop the lock\n\t\t * to preserve consistency between i_wb_list and the mapping\n\t\t * writeback tag. Writeback completion is responsible to remove\n\t\t * the inode from either list once the writeback tag is cleared.\n\t\t */\n\t\tlist_move_tail(&inode->i_wb_list, &sb->s_inodes_wb);\n\n\t\t/*\n\t\t * The mapping can appear untagged while still on-list since we\n\t\t * do not have the mapping lock. Skip it here, wb completion\n\t\t * will remove it.\n\t\t */\n\t\tif (!mapping_tagged(mapping, PAGECACHE_TAG_WRITEBACK))\n\t\t\tcontinue;\n\n\t\tspin_unlock_irq(&sb->s_inode_wblist_lock);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\n\t\t\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * We keep the error status of individual mapping so that\n\t\t * applications can catch the writeback error using fsync(2).\n\t\t * See filemap_fdatawait_keep_errors() for details.\n\t\t */\n\t\tfilemap_fdatawait_keep_errors(mapping);\n\n\t\tcond_resched();\n\n\t\tiput(inode);\n\n\t\trcu_read_lock();\n\t\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\t}\n\tspin_unlock_irq(&sb->s_inode_wblist_lock);\n\trcu_read_unlock();\n\tmutex_unlock(&sb->s_sync_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void wakeup_dirtytime_writeback(struct work_struct *w);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wakeup_dirtytime_writeback(struct work_struct *w);\n\nstatic void wait_sb_inodes(struct super_block *sb)\n{\n\tLIST_HEAD(sync_list);\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tmutex_lock(&sb->s_sync_lock);\n\n\t/*\n\t * Splice the writeback list onto a temporary list to avoid waiting on\n\t * inodes that have started writeback after this point.\n\t *\n\t * Use rcu_read_lock() to keep the inodes around until we have a\n\t * reference. s_inode_wblist_lock protects sb->s_inodes_wb as well as\n\t * the local list because inodes can be dropped from either by writeback\n\t * completion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\tlist_splice_init(&sb->s_inodes_wb, &sync_list);\n\n\t/*\n\t * Data integrity sync. Must wait for all pages under writeback, because\n\t * there may have been pages dirtied before our sync call, but which had\n\t * writeout started before we write it out.  In which case, the inode\n\t * may not be on the dirty list, but we still have to wait for that\n\t * writeout.\n\t */\n\twhile (!list_empty(&sync_list)) {\n\t\tstruct inode *inode = list_first_entry(&sync_list, struct inode,\n\t\t\t\t\t\t       i_wb_list);\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\t/*\n\t\t * Move each inode back to the wb list before we drop the lock\n\t\t * to preserve consistency between i_wb_list and the mapping\n\t\t * writeback tag. Writeback completion is responsible to remove\n\t\t * the inode from either list once the writeback tag is cleared.\n\t\t */\n\t\tlist_move_tail(&inode->i_wb_list, &sb->s_inodes_wb);\n\n\t\t/*\n\t\t * The mapping can appear untagged while still on-list since we\n\t\t * do not have the mapping lock. Skip it here, wb completion\n\t\t * will remove it.\n\t\t */\n\t\tif (!mapping_tagged(mapping, PAGECACHE_TAG_WRITEBACK))\n\t\t\tcontinue;\n\n\t\tspin_unlock_irq(&sb->s_inode_wblist_lock);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\n\t\t\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * We keep the error status of individual mapping so that\n\t\t * applications can catch the writeback error using fsync(2).\n\t\t * See filemap_fdatawait_keep_errors() for details.\n\t\t */\n\t\tfilemap_fdatawait_keep_errors(mapping);\n\n\t\tcond_resched();\n\n\t\tiput(inode);\n\n\t\trcu_read_lock();\n\t\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\t}\n\tspin_unlock_irq(&sb->s_inode_wblist_lock);\n\trcu_read_unlock();\n\tmutex_unlock(&sb->s_sync_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_wait_for_completion",
          "args": [
            "bdi",
            "&done"
          ],
          "line": 2417
        },
        "resolved": true,
        "details": {
          "function_name": "wb_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "217-222",
          "snippet": "static void wb_wait_for_completion(struct backing_dev_info *bdi,\n\t\t\t\t   struct wb_completion *done)\n{\n\tatomic_dec(&done->cnt);\t\t/* put down the initial count */\n\twait_event(bdi->wb_waitq, !atomic_read(&done->cnt));\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wait_for_completion(struct backing_dev_info *bdi,\n\t\t\t\t   struct wb_completion *done)\n{\n\tatomic_dec(&done->cnt);\t\t/* put down the initial count */\n\twait_event(bdi->wb_waitq, !atomic_read(&done->cnt));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_split_work_to_wbs",
          "args": [
            "bdi",
            "&work",
            "false"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_split_work_to_wbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "916-926",
          "snippet": "static void bdi_split_work_to_wbs(struct backing_dev_info *bdi,\n\t\t\t\t  struct wb_writeback_work *base_work,\n\t\t\t\t  bool skip_if_busy)\n{\n\tmight_sleep();\n\n\tif (!skip_if_busy || !writeback_in_progress(&bdi->wb)) {\n\t\tbase_work->auto_free = 0;\n\t\twb_queue_work(&bdi->wb, base_work);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_split_work_to_wbs(struct backing_dev_info *bdi,\n\t\t\t\t  struct wb_writeback_work *base_work,\n\t\t\t\t  bool skip_if_busy)\n{\n\tmight_sleep();\n\n\tif (!skip_if_busy || !writeback_in_progress(&bdi->wb)) {\n\t\tbase_work->auto_free = 0;\n\t\twb_queue_work(&bdi->wb, base_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rwsem_is_locked(&sb->s_umount)"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WB_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid sync_inodes_sb(struct super_block *sb)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t= sb,\n\t\t.sync_mode\t= WB_SYNC_ALL,\n\t\t.nr_pages\t= LONG_MAX,\n\t\t.range_cyclic\t= 0,\n\t\t.done\t\t= &done,\n\t\t.reason\t\t= WB_REASON_SYNC,\n\t\t.for_sync\t= 1,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\t/*\n\t * Can't skip on !bdi_has_dirty() because we should wait for !dirty\n\t * inodes under writeback and I_DIRTY_TIME inodes ignored by\n\t * bdi_has_dirty() need to be written out too.\n\t */\n\tif (bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(bdi, &work, false);\n\twb_wait_for_completion(bdi, &done);\n\n\twait_sb_inodes(sb);\n}"
  },
  {
    "function_name": "try_to_writeback_inodes_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2376-2383",
    "snippet": "void try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn;\n\n\t__writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason, true);\n\tup_read(&sb->s_umount);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__writeback_inodes_sb_nr",
          "args": [
            "sb",
            "get_nr_dirty_pages()",
            "reason",
            "true"
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_inodes_sb_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2314-2334",
          "snippet": "static void __writeback_inodes_sb_nr(struct super_block *sb, unsigned long nr,\n\t\t\t\t     enum wb_reason reason, bool skip_if_busy)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t\t= sb,\n\t\t.sync_mode\t\t= WB_SYNC_NONE,\n\t\t.tagged_writepages\t= 1,\n\t\t.done\t\t\t= &done,\n\t\t.nr_pages\t\t= nr,\n\t\t.reason\t\t\t= reason,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\tif (!bdi_has_dirty_io(bdi) || bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(sb->s_bdi, &work, skip_if_busy);\n\twb_wait_for_completion(bdi, &done);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __writeback_inodes_sb_nr(struct super_block *sb, unsigned long nr,\n\t\t\t\t     enum wb_reason reason, bool skip_if_busy)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t\t= sb,\n\t\t.sync_mode\t\t= WB_SYNC_NONE,\n\t\t.tagged_writepages\t= 1,\n\t\t.done\t\t\t= &done,\n\t\t.nr_pages\t\t= nr,\n\t\t.reason\t\t\t= reason,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\tif (!bdi_has_dirty_io(bdi) || bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(sb->s_bdi, &work, skip_if_busy);\n\twb_wait_for_completion(bdi, &done);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_dirty_pages",
          "args": [],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "934-939",
          "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid try_to_writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\tif (!down_read_trylock(&sb->s_umount))\n\t\treturn;\n\n\t__writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason, true);\n\tup_read(&sb->s_umount);\n}"
  },
  {
    "function_name": "writeback_inodes_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2363-2366",
    "snippet": "void writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\treturn writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "writeback_inodes_sb_nr",
          "args": [
            "sb",
            "get_nr_dirty_pages()",
            "reason"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_inodes_sb_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2346-2351",
          "snippet": "void writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t    unsigned long nr,\n\t\t\t    enum wb_reason reason)\n{\n\t__writeback_inodes_sb_nr(sb, nr, reason, false);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t    unsigned long nr,\n\t\t\t    enum wb_reason reason)\n{\n\t__writeback_inodes_sb_nr(sb, nr, reason, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_dirty_pages",
          "args": [],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "934-939",
          "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid writeback_inodes_sb(struct super_block *sb, enum wb_reason reason)\n{\n\treturn writeback_inodes_sb_nr(sb, get_nr_dirty_pages(), reason);\n}"
  },
  {
    "function_name": "writeback_inodes_sb_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2346-2351",
    "snippet": "void writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t    unsigned long nr,\n\t\t\t    enum wb_reason reason)\n{\n\t__writeback_inodes_sb_nr(sb, nr, reason, false);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__writeback_inodes_sb_nr",
          "args": [
            "sb",
            "nr",
            "reason",
            "false"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_inodes_sb_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2314-2334",
          "snippet": "static void __writeback_inodes_sb_nr(struct super_block *sb, unsigned long nr,\n\t\t\t\t     enum wb_reason reason, bool skip_if_busy)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t\t= sb,\n\t\t.sync_mode\t\t= WB_SYNC_NONE,\n\t\t.tagged_writepages\t= 1,\n\t\t.done\t\t\t= &done,\n\t\t.nr_pages\t\t= nr,\n\t\t.reason\t\t\t= reason,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\tif (!bdi_has_dirty_io(bdi) || bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(sb->s_bdi, &work, skip_if_busy);\n\twb_wait_for_completion(bdi, &done);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __writeback_inodes_sb_nr(struct super_block *sb, unsigned long nr,\n\t\t\t\t     enum wb_reason reason, bool skip_if_busy)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t\t= sb,\n\t\t.sync_mode\t\t= WB_SYNC_NONE,\n\t\t.tagged_writepages\t= 1,\n\t\t.done\t\t\t= &done,\n\t\t.nr_pages\t\t= nr,\n\t\t.reason\t\t\t= reason,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\tif (!bdi_has_dirty_io(bdi) || bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(sb->s_bdi, &work, skip_if_busy);\n\twb_wait_for_completion(bdi, &done);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid writeback_inodes_sb_nr(struct super_block *sb,\n\t\t\t    unsigned long nr,\n\t\t\t    enum wb_reason reason)\n{\n\t__writeback_inodes_sb_nr(sb, nr, reason, false);\n}"
  },
  {
    "function_name": "__writeback_inodes_sb_nr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2314-2334",
    "snippet": "static void __writeback_inodes_sb_nr(struct super_block *sb, unsigned long nr,\n\t\t\t\t     enum wb_reason reason, bool skip_if_busy)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t\t= sb,\n\t\t.sync_mode\t\t= WB_SYNC_NONE,\n\t\t.tagged_writepages\t= 1,\n\t\t.done\t\t\t= &done,\n\t\t.nr_pages\t\t= nr,\n\t\t.reason\t\t\t= reason,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\tif (!bdi_has_dirty_io(bdi) || bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(sb->s_bdi, &work, skip_if_busy);\n\twb_wait_for_completion(bdi, &done);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_wait_for_completion",
          "args": [
            "bdi",
            "&done"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "wb_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "217-222",
          "snippet": "static void wb_wait_for_completion(struct backing_dev_info *bdi,\n\t\t\t\t   struct wb_completion *done)\n{\n\tatomic_dec(&done->cnt);\t\t/* put down the initial count */\n\twait_event(bdi->wb_waitq, !atomic_read(&done->cnt));\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wait_for_completion(struct backing_dev_info *bdi,\n\t\t\t\t   struct wb_completion *done)\n{\n\tatomic_dec(&done->cnt);\t\t/* put down the initial count */\n\twait_event(bdi->wb_waitq, !atomic_read(&done->cnt));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_split_work_to_wbs",
          "args": [
            "sb->s_bdi",
            "&work",
            "skip_if_busy"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_split_work_to_wbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "916-926",
          "snippet": "static void bdi_split_work_to_wbs(struct backing_dev_info *bdi,\n\t\t\t\t  struct wb_writeback_work *base_work,\n\t\t\t\t  bool skip_if_busy)\n{\n\tmight_sleep();\n\n\tif (!skip_if_busy || !writeback_in_progress(&bdi->wb)) {\n\t\tbase_work->auto_free = 0;\n\t\twb_queue_work(&bdi->wb, base_work);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_split_work_to_wbs(struct backing_dev_info *bdi,\n\t\t\t\t  struct wb_writeback_work *base_work,\n\t\t\t\t  bool skip_if_busy)\n{\n\tmight_sleep();\n\n\tif (!skip_if_busy || !writeback_in_progress(&bdi->wb)) {\n\t\tbase_work->auto_free = 0;\n\t\twb_queue_work(&bdi->wb, base_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rwsem_is_locked(&sb->s_umount)"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_has_dirty_io",
          "args": [
            "bdi"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WB_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __writeback_inodes_sb_nr(struct super_block *sb, unsigned long nr,\n\t\t\t\t     enum wb_reason reason, bool skip_if_busy)\n{\n\tDEFINE_WB_COMPLETION_ONSTACK(done);\n\tstruct wb_writeback_work work = {\n\t\t.sb\t\t\t= sb,\n\t\t.sync_mode\t\t= WB_SYNC_NONE,\n\t\t.tagged_writepages\t= 1,\n\t\t.done\t\t\t= &done,\n\t\t.nr_pages\t\t= nr,\n\t\t.reason\t\t\t= reason,\n\t};\n\tstruct backing_dev_info *bdi = sb->s_bdi;\n\n\tif (!bdi_has_dirty_io(bdi) || bdi == &noop_backing_dev_info)\n\t\treturn;\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tbdi_split_work_to_wbs(sb->s_bdi, &work, skip_if_busy);\n\twb_wait_for_completion(bdi, &done);\n}"
  },
  {
    "function_name": "wait_sb_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2229-2312",
    "snippet": "static void wait_sb_inodes(struct super_block *sb)\n{\n\tLIST_HEAD(sync_list);\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tmutex_lock(&sb->s_sync_lock);\n\n\t/*\n\t * Splice the writeback list onto a temporary list to avoid waiting on\n\t * inodes that have started writeback after this point.\n\t *\n\t * Use rcu_read_lock() to keep the inodes around until we have a\n\t * reference. s_inode_wblist_lock protects sb->s_inodes_wb as well as\n\t * the local list because inodes can be dropped from either by writeback\n\t * completion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\tlist_splice_init(&sb->s_inodes_wb, &sync_list);\n\n\t/*\n\t * Data integrity sync. Must wait for all pages under writeback, because\n\t * there may have been pages dirtied before our sync call, but which had\n\t * writeout started before we write it out.  In which case, the inode\n\t * may not be on the dirty list, but we still have to wait for that\n\t * writeout.\n\t */\n\twhile (!list_empty(&sync_list)) {\n\t\tstruct inode *inode = list_first_entry(&sync_list, struct inode,\n\t\t\t\t\t\t       i_wb_list);\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\t/*\n\t\t * Move each inode back to the wb list before we drop the lock\n\t\t * to preserve consistency between i_wb_list and the mapping\n\t\t * writeback tag. Writeback completion is responsible to remove\n\t\t * the inode from either list once the writeback tag is cleared.\n\t\t */\n\t\tlist_move_tail(&inode->i_wb_list, &sb->s_inodes_wb);\n\n\t\t/*\n\t\t * The mapping can appear untagged while still on-list since we\n\t\t * do not have the mapping lock. Skip it here, wb completion\n\t\t * will remove it.\n\t\t */\n\t\tif (!mapping_tagged(mapping, PAGECACHE_TAG_WRITEBACK))\n\t\t\tcontinue;\n\n\t\tspin_unlock_irq(&sb->s_inode_wblist_lock);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\n\t\t\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * We keep the error status of individual mapping so that\n\t\t * applications can catch the writeback error using fsync(2).\n\t\t * See filemap_fdatawait_keep_errors() for details.\n\t\t */\n\t\tfilemap_fdatawait_keep_errors(mapping);\n\n\t\tcond_resched();\n\n\t\tiput(inode);\n\n\t\trcu_read_lock();\n\t\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\t}\n\tspin_unlock_irq(&sb->s_inode_wblist_lock);\n\trcu_read_unlock();\n\tmutex_unlock(&sb->s_sync_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void wakeup_dirtytime_writeback(struct work_struct *w);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sb->s_sync_lock"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&sb->s_inode_wblist_lock"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&sb->s_inode_wblist_lock"
          ],
          "line": 2307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_keep_errors",
          "args": [
            "mapping"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "394-397",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&sb->s_inode_wblist_lock"
          ],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&sb->s_inode_wblist_lock"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "mapping",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&inode->i_wb_list",
            "&sb->s_inodes_wb"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&sync_list",
            "structinode",
            "i_wb_list"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sync_list"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&sb->s_inodes_wb",
            "&sync_list"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&sb->s_inode_wblist_lock"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sb->s_sync_lock"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!rwsem_is_locked(&sb->s_umount)"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwsem_is_locked",
          "args": [
            "&sb->s_umount"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "sync_list"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wakeup_dirtytime_writeback(struct work_struct *w);\n\nstatic void wait_sb_inodes(struct super_block *sb)\n{\n\tLIST_HEAD(sync_list);\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\tmutex_lock(&sb->s_sync_lock);\n\n\t/*\n\t * Splice the writeback list onto a temporary list to avoid waiting on\n\t * inodes that have started writeback after this point.\n\t *\n\t * Use rcu_read_lock() to keep the inodes around until we have a\n\t * reference. s_inode_wblist_lock protects sb->s_inodes_wb as well as\n\t * the local list because inodes can be dropped from either by writeback\n\t * completion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\tlist_splice_init(&sb->s_inodes_wb, &sync_list);\n\n\t/*\n\t * Data integrity sync. Must wait for all pages under writeback, because\n\t * there may have been pages dirtied before our sync call, but which had\n\t * writeout started before we write it out.  In which case, the inode\n\t * may not be on the dirty list, but we still have to wait for that\n\t * writeout.\n\t */\n\twhile (!list_empty(&sync_list)) {\n\t\tstruct inode *inode = list_first_entry(&sync_list, struct inode,\n\t\t\t\t\t\t       i_wb_list);\n\t\tstruct address_space *mapping = inode->i_mapping;\n\n\t\t/*\n\t\t * Move each inode back to the wb list before we drop the lock\n\t\t * to preserve consistency between i_wb_list and the mapping\n\t\t * writeback tag. Writeback completion is responsible to remove\n\t\t * the inode from either list once the writeback tag is cleared.\n\t\t */\n\t\tlist_move_tail(&inode->i_wb_list, &sb->s_inodes_wb);\n\n\t\t/*\n\t\t * The mapping can appear untagged while still on-list since we\n\t\t * do not have the mapping lock. Skip it here, wb completion\n\t\t * will remove it.\n\t\t */\n\t\tif (!mapping_tagged(mapping, PAGECACHE_TAG_WRITEBACK))\n\t\t\tcontinue;\n\n\t\tspin_unlock_irq(&sb->s_inode_wblist_lock);\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\n\t\t\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\t\t\tcontinue;\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\trcu_read_unlock();\n\n\t\t/*\n\t\t * We keep the error status of individual mapping so that\n\t\t * applications can catch the writeback error using fsync(2).\n\t\t * See filemap_fdatawait_keep_errors() for details.\n\t\t */\n\t\tfilemap_fdatawait_keep_errors(mapping);\n\n\t\tcond_resched();\n\n\t\tiput(inode);\n\n\t\trcu_read_lock();\n\t\tspin_lock_irq(&sb->s_inode_wblist_lock);\n\t}\n\tspin_unlock_irq(&sb->s_inode_wblist_lock);\n\trcu_read_unlock();\n\tmutex_unlock(&sb->s_sync_lock);\n}"
  },
  {
    "function_name": "__mark_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2107-2217",
    "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_wakeup_delayed",
          "args": [
            "wb"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_cap_writeback_dirty",
          "args": [
            "wb->bdi"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_dirty_inode_enqueue",
          "args": [
            "inode"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_io_list_move_locked",
          "args": [
            "inode",
            "wb",
            "dirty_list"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_move_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "135-149",
          "snippet": "static bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state)",
            "\"bdi-%s not registered\\n\"",
            "wb->bdi->name"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WB_registered",
            "&wb->state"
          ],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_cap_writeback_dirty",
          "args": [
            "wb->bdi"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locked_inode_to_wb_and_lock_list",
          "args": [
            "inode"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "locked_inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "890-900",
          "snippet": "static struct bdi_writeback *\nlocked_inode_to_wb_and_lock_list(struct inode *inode)\n\t__releases(&inode->i_lock)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_unlock(&inode->i_lock);\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *\nlocked_inode_to_wb_and_lock_list(struct inode *inode)\n\t__releases(&inode->i_lock)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_unlock(&inode->i_lock);\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "inode"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_attach_wb",
          "args": [
            "inode",
            "NULL"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "__inode_attach_wb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "243-271",
          "snippet": "void __inode_attach_wb(struct inode *inode, struct page *page)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\n\tif (inode_cgwb_enabled(inode)) {\n\t\tstruct cgroup_subsys_state *memcg_css;\n\n\t\tif (page) {\n\t\t\tmemcg_css = mem_cgroup_css_from_page(page);\n\t\t\twb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\t\t} else {\n\t\t\t/* must pin memcg_css, see wb_get_create() */\n\t\t\tmemcg_css = task_get_css(current, memory_cgrp_id);\n\t\t\twb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\t\t\tcss_put(memcg_css);\n\t\t}\n\t}\n\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\t/*\n\t * There may be multiple instances of this function racing to\n\t * update the same inode.  Use cmpxchg() to tell the winner.\n\t */\n\tif (unlikely(cmpxchg(&inode->i_wb, NULL, wb)))\n\t\twb_put(wb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __inode_attach_wb(struct inode *inode, struct page *page)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\n\tif (inode_cgwb_enabled(inode)) {\n\t\tstruct cgroup_subsys_state *memcg_css;\n\n\t\tif (page) {\n\t\t\tmemcg_css = mem_cgroup_css_from_page(page);\n\t\t\twb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\t\t} else {\n\t\t\t/* must pin memcg_css, see wb_get_create() */\n\t\t\tmemcg_css = task_get_css(current, memory_cgrp_id);\n\t\t\twb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\t\t\tcss_put(memcg_css);\n\t\t}\n\t}\n\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\t/*\n\t * There may be multiple instances of this function racing to\n\t * update the same inode.  Use cmpxchg() to tell the winner.\n\t */\n\tif (unlikely(cmpxchg(&inode->i_wb, NULL, wb)))\n\t\twb_put(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_dump___mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2059-2079",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "block_dump"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_dirty_inode",
          "args": [
            "inode",
            "flags"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->dirty_inode",
          "args": [
            "inode",
            "flags"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_dirty_inode_start",
          "args": [
            "inode",
            "flags"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_mark_inode_dirty",
          "args": [
            "inode",
            "flags"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "block_dump___mark_inode_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2059-2079",
    "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "inode->i_ino",
            "name",
            "inode->i_sb->s_id"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_alias",
          "args": [
            "inode"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "951-961",
          "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "inode->i_sb->s_id",
            "\"bdev\""
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "27-35",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dirtytime_interval_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2048-2057",
    "snippet": "int dirtytime_interval_handler(struct ctl_table *table, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tmod_delayed_work(system_wq, &dirtytime_work, 0);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "system_wq",
            "&dirtytime_work",
            "0"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint dirtytime_interval_handler(struct ctl_table *table, int write,\n\t\t\t       void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint ret;\n\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (ret == 0 && write)\n\t\tmod_delayed_work(system_wq, &dirtytime_work, 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "start_dirtytime_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2041-2045",
    "snippet": "static int __init start_dirtytime_writeback(void)\n{\n\tschedule_delayed_work(&dirtytime_work, dirtytime_expire_interval * HZ);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int dirtytime_expire_interval = 12 * 60 * 60;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&dirtytime_work",
            "dirtytime_expire_interval * HZ"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned int dirtytime_expire_interval = 12 * 60 * 60;\n\nstatic int __init start_dirtytime_writeback(void)\n{\n\tschedule_delayed_work(&dirtytime_work, dirtytime_expire_interval * HZ);\n\treturn 0;\n}"
  },
  {
    "function_name": "wakeup_dirtytime_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "2025-2039",
    "snippet": "static void wakeup_dirtytime_writeback(struct work_struct *w)\n{\n\tstruct backing_dev_info *bdi;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list) {\n\t\tstruct bdi_writeback *wb;\n\n\t\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node)\n\t\t\tif (!list_empty(&wb->b_dirty_time))\n\t\t\t\twb_wakeup(wb);\n\t}\n\trcu_read_unlock();\n\tschedule_delayed_work(&dirtytime_work, dirtytime_expire_interval * HZ);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int dirtytime_expire_interval = 12 * 60 * 60;",
      "static void wakeup_dirtytime_writeback(struct work_struct *w);",
      "static DECLARE_DELAYED_WORK(dirtytime_work, wakeup_dirtytime_writeback);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&dirtytime_work",
            "dirtytime_expire_interval * HZ"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_wakeup",
          "args": [
            "wb"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "wb_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "168-174",
          "snippet": "static void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_dirty_time"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "wb",
            "&bdi->wb_list",
            "bdi_node"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "bdi",
            "&bdi_list",
            "bdi_list"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned int dirtytime_expire_interval = 12 * 60 * 60;\nstatic void wakeup_dirtytime_writeback(struct work_struct *w);\nstatic DECLARE_DELAYED_WORK(dirtytime_work, wakeup_dirtytime_writeback);\n\nstatic void wakeup_dirtytime_writeback(struct work_struct *w)\n{\n\tstruct backing_dev_info *bdi;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list) {\n\t\tstruct bdi_writeback *wb;\n\n\t\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node)\n\t\t\tif (!list_empty(&wb->b_dirty_time))\n\t\t\t\twb_wakeup(wb);\n\t}\n\trcu_read_unlock();\n\tschedule_delayed_work(&dirtytime_work, dirtytime_expire_interval * HZ);\n}"
  },
  {
    "function_name": "wakeup_flusher_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1991-2005",
    "snippet": "void wakeup_flusher_threads(enum wb_reason reason)\n{\n\tstruct backing_dev_info *bdi;\n\n\t/*\n\t * If we are expecting writeback progress we must submit plugged IO.\n\t */\n\tif (blk_needs_flush_plug(current))\n\t\tblk_schedule_flush_plug(current);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list)\n\t\t__wakeup_flusher_threads_bdi(bdi, reason);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wakeup_flusher_threads_bdi",
          "args": [
            "bdi",
            "reason"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_flusher_threads_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1968-1978",
          "snippet": "static void __wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\t\t enum wb_reason reason)\n{\n\tstruct bdi_writeback *wb;\n\n\tif (!bdi_has_dirty_io(bdi))\n\t\treturn;\n\n\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node)\n\t\twb_start_writeback(wb, reason);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\t\t enum wb_reason reason)\n{\n\tstruct bdi_writeback *wb;\n\n\tif (!bdi_has_dirty_io(bdi))\n\t\treturn;\n\n\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node)\n\t\twb_start_writeback(wb, reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "bdi",
            "&bdi_list",
            "bdi_list"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_schedule_flush_plug",
          "args": [
            "current"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_needs_flush_plug",
          "args": [
            "current"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wakeup_flusher_threads(enum wb_reason reason)\n{\n\tstruct backing_dev_info *bdi;\n\n\t/*\n\t * If we are expecting writeback progress we must submit plugged IO.\n\t */\n\tif (blk_needs_flush_plug(current))\n\t\tblk_schedule_flush_plug(current);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(bdi, &bdi_list, bdi_list)\n\t\t__wakeup_flusher_threads_bdi(bdi, reason);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "wakeup_flusher_threads_bdi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1980-1986",
    "snippet": "void wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\tenum wb_reason reason)\n{\n\trcu_read_lock();\n\t__wakeup_flusher_threads_bdi(bdi, reason);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wakeup_flusher_threads_bdi",
          "args": [
            "bdi",
            "reason"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "__wakeup_flusher_threads_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1968-1978",
          "snippet": "static void __wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\t\t enum wb_reason reason)\n{\n\tstruct bdi_writeback *wb;\n\n\tif (!bdi_has_dirty_io(bdi))\n\t\treturn;\n\n\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node)\n\t\twb_start_writeback(wb, reason);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\t\t enum wb_reason reason)\n{\n\tstruct bdi_writeback *wb;\n\n\tif (!bdi_has_dirty_io(bdi))\n\t\treturn;\n\n\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node)\n\t\twb_start_writeback(wb, reason);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\tenum wb_reason reason)\n{\n\trcu_read_lock();\n\t__wakeup_flusher_threads_bdi(bdi, reason);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "__wakeup_flusher_threads_bdi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1968-1978",
    "snippet": "static void __wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\t\t enum wb_reason reason)\n{\n\tstruct bdi_writeback *wb;\n\n\tif (!bdi_has_dirty_io(bdi))\n\t\treturn;\n\n\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node)\n\t\twb_start_writeback(wb, reason);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_start_writeback",
          "args": [
            "wb",
            "reason"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "wb_start_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "941-960",
          "snippet": "static void wb_start_writeback(struct bdi_writeback *wb, enum wb_reason reason)\n{\n\tif (!wb_has_dirty_io(wb))\n\t\treturn;\n\n\t/*\n\t * All callers of this function want to start writeback of all\n\t * dirty pages. Places like vmscan can call this at a very\n\t * high frequency, causing pointless allocations of tons of\n\t * work items and keeping the flusher threads busy retrieving\n\t * that work. Ensure that we only allow one of them pending and\n\t * inflight at the time.\n\t */\n\tif (test_bit(WB_start_all, &wb->state) ||\n\t    test_and_set_bit(WB_start_all, &wb->state))\n\t\treturn;\n\n\twb->start_all_reason = reason;\n\twb_wakeup(wb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_start_writeback(struct bdi_writeback *wb, enum wb_reason reason)\n{\n\tif (!wb_has_dirty_io(wb))\n\t\treturn;\n\n\t/*\n\t * All callers of this function want to start writeback of all\n\t * dirty pages. Places like vmscan can call this at a very\n\t * high frequency, causing pointless allocations of tons of\n\t * work items and keeping the flusher threads busy retrieving\n\t * that work. Ensure that we only allow one of them pending and\n\t * inflight at the time.\n\t */\n\tif (test_bit(WB_start_all, &wb->state) ||\n\t    test_and_set_bit(WB_start_all, &wb->state))\n\t\treturn;\n\n\twb->start_all_reason = reason;\n\twb_wakeup(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "wb",
            "&bdi->wb_list",
            "bdi_node"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_has_dirty_io",
          "args": [
            "bdi"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __wakeup_flusher_threads_bdi(struct backing_dev_info *bdi,\n\t\t\t\t\t enum wb_reason reason)\n{\n\tstruct bdi_writeback *wb;\n\n\tif (!bdi_has_dirty_io(bdi))\n\t\treturn;\n\n\tlist_for_each_entry_rcu(wb, &bdi->wb_list, bdi_node)\n\t\twb_start_writeback(wb, reason);\n}"
  },
  {
    "function_name": "wb_workfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1924-1962",
    "snippet": "void wb_workfn(struct work_struct *work)\n{\n\tstruct bdi_writeback *wb = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct bdi_writeback, dwork);\n\tlong pages_written;\n\n\tset_worker_desc(\"flush-%s\", dev_name(wb->bdi->dev));\n\tcurrent->flags |= PF_SWAPWRITE;\n\n\tif (likely(!current_is_workqueue_rescuer() ||\n\t\t   !test_bit(WB_registered, &wb->state))) {\n\t\t/*\n\t\t * The normal path.  Keep writing back @wb until its\n\t\t * work_list is empty.  Note that this path is also taken\n\t\t * if @wb is shutting down even when we're running off the\n\t\t * rescuer as work_list needs to be drained.\n\t\t */\n\t\tdo {\n\t\t\tpages_written = wb_do_writeback(wb);\n\t\t\ttrace_writeback_pages_written(pages_written);\n\t\t} while (!list_empty(&wb->work_list));\n\t} else {\n\t\t/*\n\t\t * bdi_wq can't get enough workers and we're running off\n\t\t * the emergency worker.  Don't hog it.  Hopefully, 1024 is\n\t\t * enough for efficient IO.\n\t\t */\n\t\tpages_written = writeback_inodes_wb(wb, 1024,\n\t\t\t\t\t\t    WB_REASON_FORKER_THREAD);\n\t\ttrace_writeback_pages_written(pages_written);\n\t}\n\n\tif (!list_empty(&wb->work_list))\n\t\twb_wakeup(wb);\n\telse if (wb_has_dirty_io(wb) && dirty_writeback_interval)\n\t\twb_wakeup_delayed(wb);\n\n\tcurrent->flags &= ~PF_SWAPWRITE;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_wakeup_delayed",
          "args": [
            "wb"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_has_dirty_io",
          "args": [
            "wb"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_wakeup",
          "args": [
            "wb"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "wb_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "168-174",
          "snippet": "static void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->work_list"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_pages_written",
          "args": [
            "pages_written"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_inodes_wb",
          "args": [
            "wb",
            "1024",
            "WB_REASON_FORKER_THREAD"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_inodes_wb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1664-1684",
          "snippet": "static long writeback_inodes_wb(struct bdi_writeback *wb, long nr_pages,\n\t\t\t\tenum wb_reason reason)\n{\n\tstruct wb_writeback_work work = {\n\t\t.nr_pages\t= nr_pages,\n\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t.range_cyclic\t= 1,\n\t\t.reason\t\t= reason,\n\t};\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tif (list_empty(&wb->b_io))\n\t\tqueue_io(wb, &work);\n\t__writeback_inodes_wb(wb, &work);\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work.nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_inodes_wb(struct bdi_writeback *wb, long nr_pages,\n\t\t\t\tenum wb_reason reason)\n{\n\tstruct wb_writeback_work work = {\n\t\t.nr_pages\t= nr_pages,\n\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t.range_cyclic\t= 1,\n\t\t.reason\t\t= reason,\n\t};\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tif (list_empty(&wb->b_io))\n\t\tqueue_io(wb, &work);\n\t__writeback_inodes_wb(wb, &work);\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work.nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_pages_written",
          "args": [
            "pages_written"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_do_writeback",
          "args": [
            "wb"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "wb_do_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1893-1918",
          "snippet": "static long wb_do_writeback(struct bdi_writeback *wb)\n{\n\tstruct wb_writeback_work *work;\n\tlong wrote = 0;\n\n\tset_bit(WB_writeback_running, &wb->state);\n\twhile ((work = get_next_work_item(wb)) != NULL) {\n\t\ttrace_writeback_exec(wb, work);\n\t\twrote += wb_writeback(wb, work);\n\t\tfinish_writeback_work(wb, work);\n\t}\n\n\t/*\n\t * Check for a flush-everything request\n\t */\n\twrote += wb_check_start_all(wb);\n\n\t/*\n\t * Check for periodic writeback, kupdated() style\n\t */\n\twrote += wb_check_old_data_flush(wb);\n\twrote += wb_check_background_flush(wb);\n\tclear_bit(WB_writeback_running, &wb->state);\n\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_do_writeback(struct bdi_writeback *wb)\n{\n\tstruct wb_writeback_work *work;\n\tlong wrote = 0;\n\n\tset_bit(WB_writeback_running, &wb->state);\n\twhile ((work = get_next_work_item(wb)) != NULL) {\n\t\ttrace_writeback_exec(wb, work);\n\t\twrote += wb_writeback(wb, work);\n\t\tfinish_writeback_work(wb, work);\n\t}\n\n\t/*\n\t * Check for a flush-everything request\n\t */\n\twrote += wb_check_start_all(wb);\n\n\t/*\n\t * Check for periodic writeback, kupdated() style\n\t */\n\twrote += wb_check_old_data_flush(wb);\n\twrote += wb_check_background_flush(wb);\n\tclear_bit(WB_writeback_running, &wb->state);\n\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!current_is_workqueue_rescuer() ||\n\t\t   !test_bit(WB_registered, &wb->state)"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WB_registered",
            "&wb->state"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_is_workqueue_rescuer",
          "args": [],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_worker_desc",
          "args": [
            "\"flush-%s\"",
            "dev_name(wb->bdi->dev)"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_name",
          "args": [
            "wb->bdi->dev"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/dev-replace.c",
          "lines": "385-391",
          "snippet": "static char* btrfs_dev_name(struct btrfs_device *device)\n{\n\tif (!device || test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\treturn \"<missing disk>\";\n\telse\n\t\treturn rcu_str_deref(device->name);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic char* btrfs_dev_name(struct btrfs_device *device)\n{\n\tif (!device || test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state))\n\t\treturn \"<missing disk>\";\n\telse\n\t\treturn rcu_str_deref(device->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_delayed_work(work)",
            "structbdi_writeback",
            "dwork"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_delayed_work",
          "args": [
            "work"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wb_workfn(struct work_struct *work)\n{\n\tstruct bdi_writeback *wb = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct bdi_writeback, dwork);\n\tlong pages_written;\n\n\tset_worker_desc(\"flush-%s\", dev_name(wb->bdi->dev));\n\tcurrent->flags |= PF_SWAPWRITE;\n\n\tif (likely(!current_is_workqueue_rescuer() ||\n\t\t   !test_bit(WB_registered, &wb->state))) {\n\t\t/*\n\t\t * The normal path.  Keep writing back @wb until its\n\t\t * work_list is empty.  Note that this path is also taken\n\t\t * if @wb is shutting down even when we're running off the\n\t\t * rescuer as work_list needs to be drained.\n\t\t */\n\t\tdo {\n\t\t\tpages_written = wb_do_writeback(wb);\n\t\t\ttrace_writeback_pages_written(pages_written);\n\t\t} while (!list_empty(&wb->work_list));\n\t} else {\n\t\t/*\n\t\t * bdi_wq can't get enough workers and we're running off\n\t\t * the emergency worker.  Don't hog it.  Hopefully, 1024 is\n\t\t * enough for efficient IO.\n\t\t */\n\t\tpages_written = writeback_inodes_wb(wb, 1024,\n\t\t\t\t\t\t    WB_REASON_FORKER_THREAD);\n\t\ttrace_writeback_pages_written(pages_written);\n\t}\n\n\tif (!list_empty(&wb->work_list))\n\t\twb_wakeup(wb);\n\telse if (wb_has_dirty_io(wb) && dirty_writeback_interval)\n\t\twb_wakeup_delayed(wb);\n\n\tcurrent->flags &= ~PF_SWAPWRITE;\n}"
  },
  {
    "function_name": "wb_do_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1893-1918",
    "snippet": "static long wb_do_writeback(struct bdi_writeback *wb)\n{\n\tstruct wb_writeback_work *work;\n\tlong wrote = 0;\n\n\tset_bit(WB_writeback_running, &wb->state);\n\twhile ((work = get_next_work_item(wb)) != NULL) {\n\t\ttrace_writeback_exec(wb, work);\n\t\twrote += wb_writeback(wb, work);\n\t\tfinish_writeback_work(wb, work);\n\t}\n\n\t/*\n\t * Check for a flush-everything request\n\t */\n\twrote += wb_check_start_all(wb);\n\n\t/*\n\t * Check for periodic writeback, kupdated() style\n\t */\n\twrote += wb_check_old_data_flush(wb);\n\twrote += wb_check_background_flush(wb);\n\tclear_bit(WB_writeback_running, &wb->state);\n\n\treturn wrote;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "WB_writeback_running",
            "&wb->state"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "920-924",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_check_background_flush",
          "args": [
            "wb"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "wb_check_background_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1814-1830",
          "snippet": "static long wb_check_background_flush(struct bdi_writeback *wb)\n{\n\tif (wb_over_bg_thresh(wb)) {\n\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= LONG_MAX,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_background\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_BACKGROUND,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_background_flush(struct bdi_writeback *wb)\n{\n\tif (wb_over_bg_thresh(wb)) {\n\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= LONG_MAX,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_background\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_BACKGROUND,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_check_old_data_flush",
          "args": [
            "wb"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "wb_check_old_data_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1832-1864",
          "snippet": "static long wb_check_old_data_flush(struct bdi_writeback *wb)\n{\n\tunsigned long expired;\n\tlong nr_pages;\n\n\t/*\n\t * When set to zero, disable periodic writeback\n\t */\n\tif (!dirty_writeback_interval)\n\t\treturn 0;\n\n\texpired = wb->last_old_flush +\n\t\t\tmsecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (time_before(jiffies, expired))\n\t\treturn 0;\n\n\twb->last_old_flush = jiffies;\n\tnr_pages = get_nr_dirty_pages();\n\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= nr_pages,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_kupdate\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_PERIODIC,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_old_data_flush(struct bdi_writeback *wb)\n{\n\tunsigned long expired;\n\tlong nr_pages;\n\n\t/*\n\t * When set to zero, disable periodic writeback\n\t */\n\tif (!dirty_writeback_interval)\n\t\treturn 0;\n\n\texpired = wb->last_old_flush +\n\t\t\tmsecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (time_before(jiffies, expired))\n\t\treturn 0;\n\n\twb->last_old_flush = jiffies;\n\tnr_pages = get_nr_dirty_pages();\n\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= nr_pages,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_kupdate\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_PERIODIC,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_check_start_all",
          "args": [
            "wb"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "wb_check_start_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1866-1887",
          "snippet": "static long wb_check_start_all(struct bdi_writeback *wb)\n{\n\tlong nr_pages;\n\n\tif (!test_bit(WB_start_all, &wb->state))\n\t\treturn 0;\n\n\tnr_pages = get_nr_dirty_pages();\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= wb_split_bdi_pages(wb, nr_pages),\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= wb->start_all_reason,\n\t\t};\n\n\t\tnr_pages = wb_writeback(wb, &work);\n\t}\n\n\tclear_bit(WB_start_all, &wb->state);\n\treturn nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_start_all(struct bdi_writeback *wb)\n{\n\tlong nr_pages;\n\n\tif (!test_bit(WB_start_all, &wb->state))\n\t\treturn 0;\n\n\tnr_pages = get_nr_dirty_pages();\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= wb_split_bdi_pages(wb, nr_pages),\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= wb->start_all_reason,\n\t\t};\n\n\t\tnr_pages = wb_writeback(wb, &work);\n\t}\n\n\tclear_bit(WB_start_all, &wb->state);\n\treturn nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_writeback_work",
          "args": [
            "wb",
            "work"
          ],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "finish_writeback_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "176-185",
          "snippet": "static void finish_writeback_work(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tstruct wb_completion *done = work->done;\n\n\tif (work->auto_free)\n\t\tkfree(work);\n\tif (done && atomic_dec_and_test(&done->cnt))\n\t\twake_up_all(&wb->bdi->wb_waitq);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void finish_writeback_work(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tstruct wb_completion *done = work->done;\n\n\tif (work->auto_free)\n\t\tkfree(work);\n\tif (done && atomic_dec_and_test(&done->cnt))\n\t\twake_up_all(&wb->bdi->wb_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_writeback",
          "args": [
            "wb",
            "work"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "wb_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1701-1795",
          "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_exec",
          "args": [
            "wb",
            "work"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_work_item",
          "args": [
            "wb"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_work_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1800-1812",
          "snippet": "static struct wb_writeback_work *get_next_work_item(struct bdi_writeback *wb)\n{\n\tstruct wb_writeback_work *work = NULL;\n\n\tspin_lock_bh(&wb->work_lock);\n\tif (!list_empty(&wb->work_list)) {\n\t\twork = list_entry(wb->work_list.next,\n\t\t\t\t  struct wb_writeback_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&wb->work_lock);\n\treturn work;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct wb_writeback_work *get_next_work_item(struct bdi_writeback *wb)\n{\n\tstruct wb_writeback_work *work = NULL;\n\n\tspin_lock_bh(&wb->work_lock);\n\tif (!list_empty(&wb->work_list)) {\n\t\twork = list_entry(wb->work_list.next,\n\t\t\t\t  struct wb_writeback_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&wb->work_lock);\n\treturn work;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "WB_writeback_running",
            "&wb->state"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "914-918",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_do_writeback(struct bdi_writeback *wb)\n{\n\tstruct wb_writeback_work *work;\n\tlong wrote = 0;\n\n\tset_bit(WB_writeback_running, &wb->state);\n\twhile ((work = get_next_work_item(wb)) != NULL) {\n\t\ttrace_writeback_exec(wb, work);\n\t\twrote += wb_writeback(wb, work);\n\t\tfinish_writeback_work(wb, work);\n\t}\n\n\t/*\n\t * Check for a flush-everything request\n\t */\n\twrote += wb_check_start_all(wb);\n\n\t/*\n\t * Check for periodic writeback, kupdated() style\n\t */\n\twrote += wb_check_old_data_flush(wb);\n\twrote += wb_check_background_flush(wb);\n\tclear_bit(WB_writeback_running, &wb->state);\n\n\treturn wrote;\n}"
  },
  {
    "function_name": "wb_check_start_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1866-1887",
    "snippet": "static long wb_check_start_all(struct bdi_writeback *wb)\n{\n\tlong nr_pages;\n\n\tif (!test_bit(WB_start_all, &wb->state))\n\t\treturn 0;\n\n\tnr_pages = get_nr_dirty_pages();\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= wb_split_bdi_pages(wb, nr_pages),\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= wb->start_all_reason,\n\t\t};\n\n\t\tnr_pages = wb_writeback(wb, &work);\n\t}\n\n\tclear_bit(WB_start_all, &wb->state);\n\treturn nr_pages;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "WB_start_all",
            "&wb->state"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "920-924",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_writeback",
          "args": [
            "wb",
            "&work"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "wb_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1701-1795",
          "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_split_bdi_pages",
          "args": [
            "wb",
            "nr_pages"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "wb_split_bdi_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "911-914",
          "snippet": "static long wb_split_bdi_pages(struct bdi_writeback *wb, long nr_pages)\n{\n\treturn nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_split_bdi_pages(struct bdi_writeback *wb, long nr_pages)\n{\n\treturn nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_dirty_pages",
          "args": [],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "934-939",
          "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WB_start_all",
            "&wb->state"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_start_all(struct bdi_writeback *wb)\n{\n\tlong nr_pages;\n\n\tif (!test_bit(WB_start_all, &wb->state))\n\t\treturn 0;\n\n\tnr_pages = get_nr_dirty_pages();\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= wb_split_bdi_pages(wb, nr_pages),\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= wb->start_all_reason,\n\t\t};\n\n\t\tnr_pages = wb_writeback(wb, &work);\n\t}\n\n\tclear_bit(WB_start_all, &wb->state);\n\treturn nr_pages;\n}"
  },
  {
    "function_name": "wb_check_old_data_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1832-1864",
    "snippet": "static long wb_check_old_data_flush(struct bdi_writeback *wb)\n{\n\tunsigned long expired;\n\tlong nr_pages;\n\n\t/*\n\t * When set to zero, disable periodic writeback\n\t */\n\tif (!dirty_writeback_interval)\n\t\treturn 0;\n\n\texpired = wb->last_old_flush +\n\t\t\tmsecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (time_before(jiffies, expired))\n\t\treturn 0;\n\n\twb->last_old_flush = jiffies;\n\tnr_pages = get_nr_dirty_pages();\n\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= nr_pages,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_kupdate\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_PERIODIC,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_writeback",
          "args": [
            "wb",
            "&work"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "wb_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1701-1795",
          "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nr_dirty_pages",
          "args": [],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "934-939",
          "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "expired"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "dirty_writeback_interval * 10"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_old_data_flush(struct bdi_writeback *wb)\n{\n\tunsigned long expired;\n\tlong nr_pages;\n\n\t/*\n\t * When set to zero, disable periodic writeback\n\t */\n\tif (!dirty_writeback_interval)\n\t\treturn 0;\n\n\texpired = wb->last_old_flush +\n\t\t\tmsecs_to_jiffies(dirty_writeback_interval * 10);\n\tif (time_before(jiffies, expired))\n\t\treturn 0;\n\n\twb->last_old_flush = jiffies;\n\tnr_pages = get_nr_dirty_pages();\n\n\tif (nr_pages) {\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= nr_pages,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_kupdate\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_PERIODIC,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "wb_check_background_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1814-1830",
    "snippet": "static long wb_check_background_flush(struct bdi_writeback *wb)\n{\n\tif (wb_over_bg_thresh(wb)) {\n\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= LONG_MAX,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_background\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_BACKGROUND,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_writeback",
          "args": [
            "wb",
            "&work"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "wb_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1701-1795",
          "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_over_bg_thresh",
          "args": [
            "wb"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_check_background_flush(struct bdi_writeback *wb)\n{\n\tif (wb_over_bg_thresh(wb)) {\n\n\t\tstruct wb_writeback_work work = {\n\t\t\t.nr_pages\t= LONG_MAX,\n\t\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t\t.for_background\t= 1,\n\t\t\t.range_cyclic\t= 1,\n\t\t\t.reason\t\t= WB_REASON_BACKGROUND,\n\t\t};\n\n\t\treturn wb_writeback(wb, &work);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_next_work_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1800-1812",
    "snippet": "static struct wb_writeback_work *get_next_work_item(struct bdi_writeback *wb)\n{\n\tstruct wb_writeback_work *work = NULL;\n\n\tspin_lock_bh(&wb->work_lock);\n\tif (!list_empty(&wb->work_list)) {\n\t\twork = list_entry(wb->work_list.next,\n\t\t\t\t  struct wb_writeback_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&wb->work_lock);\n\treturn work;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&wb->work_lock"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&work->list"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "wb->work_list.next",
            "structwb_writeback_work",
            "list"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->work_list"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&wb->work_lock"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct wb_writeback_work *get_next_work_item(struct bdi_writeback *wb)\n{\n\tstruct wb_writeback_work *work = NULL;\n\n\tspin_lock_bh(&wb->work_lock);\n\tif (!list_empty(&wb->work_list)) {\n\t\twork = list_entry(wb->work_list.next,\n\t\t\t\t  struct wb_writeback_work, list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&wb->work_lock);\n\treturn work;\n}"
  },
  {
    "function_name": "wb_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1701-1795",
    "snippet": "static long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sleep_on_writeback",
          "args": [
            "inode"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sleep_on_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1218-1231",
          "snippet": "static void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "wb->b_more_io.prev"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "87-90",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_wait",
          "args": [
            "wb",
            "work"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_more_io"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_update_bandwidth",
          "args": [
            "wb",
            "wb_start"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_written",
          "args": [
            "wb",
            "work"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__writeback_inodes_wb",
          "args": [
            "wb",
            "work"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_inodes_wb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1630-1662",
          "snippet": "static long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeback_sb_inodes",
          "args": [
            "work->sb",
            "wb",
            "work"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_sb_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1488-1628",
          "snippet": "static long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct bdi_writeback *tmp_wb;\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\twbc_attach_and_unlock_inode(&wbc, inode);\n\n\t\twrite_chunk = writeback_chunk_size(wb, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twbc_detach_inode(&wbc);\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\n\t\tif (need_resched()) {\n\t\t\t/*\n\t\t\t * We're trying to balance between building up a nice\n\t\t\t * long list of IOs to improve our merge rate, and\n\t\t\t * getting those IOs out quickly for anyone throttling\n\t\t\t * in balance_dirty_pages().  cond_resched() doesn't\n\t\t\t * unplug, so get our IOs out the door before we\n\t\t\t * give up the CPU.\n\t\t\t */\n\t\t\tblk_flush_plug(current);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Requeue @inode if still dirty.  Be careful as @inode may\n\t\t * have been switched to another wb in the meantime.\n\t\t */\n\t\ttmp_wb = inode_to_wb_and_lock_list(inode);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, tmp_wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (unlikely(tmp_wb != wb)) {\n\t\t\tspin_unlock(&tmp_wb->list_lock);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct bdi_writeback *tmp_wb;\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\twbc_attach_and_unlock_inode(&wbc, inode);\n\n\t\twrite_chunk = writeback_chunk_size(wb, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twbc_detach_inode(&wbc);\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\n\t\tif (need_resched()) {\n\t\t\t/*\n\t\t\t * We're trying to balance between building up a nice\n\t\t\t * long list of IOs to improve our merge rate, and\n\t\t\t * getting those IOs out quickly for anyone throttling\n\t\t\t * in balance_dirty_pages().  cond_resched() doesn't\n\t\t\t * unplug, so get our IOs out the door before we\n\t\t\t * give up the CPU.\n\t\t\t */\n\t\t\tblk_flush_plug(current);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Requeue @inode if still dirty.  Be careful as @inode may\n\t\t * have been switched to another wb in the meantime.\n\t\t */\n\t\ttmp_wb = inode_to_wb_and_lock_list(inode);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, tmp_wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (unlikely(tmp_wb != wb)) {\n\t\t\tspin_unlock(&tmp_wb->list_lock);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_io",
          "args": [
            "wb",
            "work"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "queue_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1156-1168",
          "snippet": "static void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\tif (moved)\n\t\twb_io_lists_populated(wb);\n\ttrace_writeback_queue_io(wb, work, moved);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define EXPIRE_DIRTY_ATIME 0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nstatic void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\tif (moved)\n\t\twb_io_lists_populated(wb);\n\ttrace_writeback_queue_io(wb, work, moved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_start",
          "args": [
            "wb",
            "work"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "dirty_expire_interval * 10"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_over_bg_thresh",
          "args": [
            "wb"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_writeback(struct bdi_writeback *wb,\n\t\t\t struct wb_writeback_work *work)\n{\n\tunsigned long wb_start = jiffies;\n\tlong nr_pages = work->nr_pages;\n\tunsigned long oldest_jif;\n\tstruct inode *inode;\n\tlong progress;\n\tstruct blk_plug plug;\n\n\toldest_jif = jiffies;\n\twork->older_than_this = &oldest_jif;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tfor (;;) {\n\t\t/*\n\t\t * Stop writeback when nr_pages has been consumed\n\t\t */\n\t\tif (work->nr_pages <= 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Background writeout and kupdate-style writeback may\n\t\t * run forever. Stop them if there is other work to do\n\t\t * so that e.g. sync can proceed. They'll be restarted\n\t\t * after the other works are all done.\n\t\t */\n\t\tif ((work->for_background || work->for_kupdate) &&\n\t\t    !list_empty(&wb->work_list))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For background writeout, stop when we are below the\n\t\t * background dirty threshold\n\t\t */\n\t\tif (work->for_background && !wb_over_bg_thresh(wb))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Kupdate and background works are special and we want to\n\t\t * include all inodes that need writing. Livelock avoidance is\n\t\t * handled by these works yielding to any other work so we are\n\t\t * safe.\n\t\t */\n\t\tif (work->for_kupdate) {\n\t\t\toldest_jif = jiffies -\n\t\t\t\tmsecs_to_jiffies(dirty_expire_interval * 10);\n\t\t} else if (work->for_background)\n\t\t\toldest_jif = jiffies;\n\n\t\ttrace_writeback_start(wb, work);\n\t\tif (list_empty(&wb->b_io))\n\t\t\tqueue_io(wb, work);\n\t\tif (work->sb)\n\t\t\tprogress = writeback_sb_inodes(work->sb, wb, work);\n\t\telse\n\t\t\tprogress = __writeback_inodes_wb(wb, work);\n\t\ttrace_writeback_written(wb, work);\n\n\t\twb_update_bandwidth(wb, wb_start);\n\n\t\t/*\n\t\t * Did we write something? Try for more\n\t\t *\n\t\t * Dirty inodes are moved to b_io for writeback in batches.\n\t\t * The completion of the current batch does not necessarily\n\t\t * mean the overall work is done. So we keep looping as long\n\t\t * as made some progress on cleaning pages or inodes.\n\t\t */\n\t\tif (progress)\n\t\t\tcontinue;\n\t\t/*\n\t\t * No more inodes for IO, bail\n\t\t */\n\t\tif (list_empty(&wb->b_more_io))\n\t\t\tbreak;\n\t\t/*\n\t\t * Nothing written. Wait for some inode to\n\t\t * become available for writeback. Otherwise\n\t\t * we'll just busyloop.\n\t\t */\n\t\ttrace_writeback_wait(wb, work);\n\t\tinode = wb_inode(wb->b_more_io.prev);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_unlock(&wb->list_lock);\n\t\t/* This function drops i_lock... */\n\t\tinode_sleep_on_writeback(inode);\n\t\tspin_lock(&wb->list_lock);\n\t}\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work->nr_pages;\n}"
  },
  {
    "function_name": "writeback_inodes_wb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1664-1684",
    "snippet": "static long writeback_inodes_wb(struct bdi_writeback *wb, long nr_pages,\n\t\t\t\tenum wb_reason reason)\n{\n\tstruct wb_writeback_work work = {\n\t\t.nr_pages\t= nr_pages,\n\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t.range_cyclic\t= 1,\n\t\t.reason\t\t= reason,\n\t};\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tif (list_empty(&wb->b_io))\n\t\tqueue_io(wb, &work);\n\t__writeback_inodes_wb(wb, &work);\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work.nr_pages;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__writeback_inodes_wb",
          "args": [
            "wb",
            "&work"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_inodes_wb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1630-1662",
          "snippet": "static long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_io",
          "args": [
            "wb",
            "&work"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "queue_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1156-1168",
          "snippet": "static void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\tif (moved)\n\t\twb_io_lists_populated(wb);\n\ttrace_writeback_queue_io(wb, work, moved);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define EXPIRE_DIRTY_ATIME 0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nstatic void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\tif (moved)\n\t\twb_io_lists_populated(wb);\n\ttrace_writeback_queue_io(wb, work, moved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_io"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_inodes_wb(struct bdi_writeback *wb, long nr_pages,\n\t\t\t\tenum wb_reason reason)\n{\n\tstruct wb_writeback_work work = {\n\t\t.nr_pages\t= nr_pages,\n\t\t.sync_mode\t= WB_SYNC_NONE,\n\t\t.range_cyclic\t= 1,\n\t\t.reason\t\t= reason,\n\t};\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tspin_lock(&wb->list_lock);\n\tif (list_empty(&wb->b_io))\n\t\tqueue_io(wb, &work);\n\t__writeback_inodes_wb(wb, &work);\n\tspin_unlock(&wb->list_lock);\n\tblk_finish_plug(&plug);\n\n\treturn nr_pages - work.nr_pages;\n}"
  },
  {
    "function_name": "__writeback_inodes_wb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1630-1662",
    "snippet": "static long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_is_before_jiffies",
          "args": [
            "start_time + HZ / 10UL"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writeback_sb_inodes",
          "args": [
            "sb",
            "wb",
            "work"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_sb_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1488-1628",
          "snippet": "static long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct bdi_writeback *tmp_wb;\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\twbc_attach_and_unlock_inode(&wbc, inode);\n\n\t\twrite_chunk = writeback_chunk_size(wb, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twbc_detach_inode(&wbc);\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\n\t\tif (need_resched()) {\n\t\t\t/*\n\t\t\t * We're trying to balance between building up a nice\n\t\t\t * long list of IOs to improve our merge rate, and\n\t\t\t * getting those IOs out quickly for anyone throttling\n\t\t\t * in balance_dirty_pages().  cond_resched() doesn't\n\t\t\t * unplug, so get our IOs out the door before we\n\t\t\t * give up the CPU.\n\t\t\t */\n\t\t\tblk_flush_plug(current);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Requeue @inode if still dirty.  Be careful as @inode may\n\t\t * have been switched to another wb in the meantime.\n\t\t */\n\t\ttmp_wb = inode_to_wb_and_lock_list(inode);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, tmp_wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (unlikely(tmp_wb != wb)) {\n\t\t\tspin_unlock(&tmp_wb->list_lock);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct bdi_writeback *tmp_wb;\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\twbc_attach_and_unlock_inode(&wbc, inode);\n\n\t\twrite_chunk = writeback_chunk_size(wb, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twbc_detach_inode(&wbc);\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\n\t\tif (need_resched()) {\n\t\t\t/*\n\t\t\t * We're trying to balance between building up a nice\n\t\t\t * long list of IOs to improve our merge rate, and\n\t\t\t * getting those IOs out quickly for anyone throttling\n\t\t\t * in balance_dirty_pages().  cond_resched() doesn't\n\t\t\t * unplug, so get our IOs out the door before we\n\t\t\t * give up the CPU.\n\t\t\t */\n\t\t\tblk_flush_plug(current);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Requeue @inode if still dirty.  Be careful as @inode may\n\t\t * have been switched to another wb in the meantime.\n\t\t */\n\t\ttmp_wb = inode_to_wb_and_lock_list(inode);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, tmp_wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (unlikely(tmp_wb != wb)) {\n\t\t\tspin_unlock(&tmp_wb->list_lock);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_tail",
          "args": [
            "inode",
            "wb"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "redirty_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1039-1049",
          "snippet": "static void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tinode_io_list_move_locked(inode, wb, &wb->b_dirty);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tinode_io_list_move_locked(inode, wb, &wb->b_dirty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trylock_super",
          "args": [
            "sb"
          ],
          "line": 1640
        },
        "resolved": true,
        "details": {
          "function_name": "trylock_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "410-420",
          "snippet": "bool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nbool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "wb->b_io.prev"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "87-90",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_io"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long __writeback_inodes_wb(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tunsigned long start_time = jiffies;\n\tlong wrote = 0;\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tif (!trylock_super(sb)) {\n\t\t\t/*\n\t\t\t * trylock_super() may fail consistently due to\n\t\t\t * s_umount being grabbed by someone else. Don't use\n\t\t\t * requeue_io() to avoid busy retrying the inode/sb.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\twrote += writeback_sb_inodes(sb, wb, work);\n\t\tup_read(&sb->s_umount);\n\n\t\t/* refer to the same tests at the end of writeback_sb_inodes */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* Leave any unwritten inodes on b_io */\n\treturn wrote;\n}"
  },
  {
    "function_name": "writeback_sb_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1488-1628",
    "snippet": "static long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct bdi_writeback *tmp_wb;\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\twbc_attach_and_unlock_inode(&wbc, inode);\n\n\t\twrite_chunk = writeback_chunk_size(wb, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twbc_detach_inode(&wbc);\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\n\t\tif (need_resched()) {\n\t\t\t/*\n\t\t\t * We're trying to balance between building up a nice\n\t\t\t * long list of IOs to improve our merge rate, and\n\t\t\t * getting those IOs out quickly for anyone throttling\n\t\t\t * in balance_dirty_pages().  cond_resched() doesn't\n\t\t\t * unplug, so get our IOs out the door before we\n\t\t\t * give up the CPU.\n\t\t\t */\n\t\t\tblk_flush_plug(current);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Requeue @inode if still dirty.  Be careful as @inode may\n\t\t * have been switched to another wb in the meantime.\n\t\t */\n\t\ttmp_wb = inode_to_wb_and_lock_list(inode);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, tmp_wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (unlikely(tmp_wb != wb)) {\n\t\t\tspin_unlock(&tmp_wb->list_lock);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_is_before_jiffies",
          "args": [
            "start_time + HZ / 10UL"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tmp_wb->list_lock"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tmp_wb != wb"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_sync_complete",
          "args": [
            "inode"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sync_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1059-1067",
          "snippet": "static void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "requeue_inode",
          "args": [
            "inode",
            "tmp_wb",
            "&wbc"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1241-1297",
          "snippet": "static void requeue_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t\t  struct writeback_control *wbc)\n{\n\tif (inode->i_state & I_FREEING)\n\t\treturn;\n\n\t/*\n\t * Sync livelock prevention. Each inode is tagged and synced in one\n\t * shot. If still dirty, it will be redirty_tail()'ed below.  Update\n\t * the dirty time to prevent enqueue and sync it again.\n\t */\n\tif ((inode->i_state & I_DIRTY) &&\n\t    (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages))\n\t\tinode->dirtied_when = jiffies;\n\n\tif (wbc->pages_skipped) {\n\t\t/*\n\t\t * writeback is not making progress due to locked\n\t\t * buffers. Skip this inode for now.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t\treturn;\n\t}\n\n\tif (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {\n\t\t/*\n\t\t * We didn't write back all the pages.  nfs_writepages()\n\t\t * sometimes bales out without doing anything.\n\t\t */\n\t\tif (wbc->nr_to_write <= 0) {\n\t\t\t/* Slice used up. Queue for next turn. */\n\t\t\trequeue_io(inode, wb);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Writeback blocked by something other than\n\t\t\t * congestion. Delay the inode for some time to\n\t\t\t * avoid spinning on the CPU (100% iowait)\n\t\t\t * retrying writeback of the dirty page/inode\n\t\t\t * that cannot be performed immediately.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t}\n\t} else if (inode->i_state & I_DIRTY) {\n\t\t/*\n\t\t * Filesystems can dirty the inode during writeback operations,\n\t\t * such as delayed allocation during submission or metadata\n\t\t * updates after data IO completion.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t} else if (inode->i_state & I_DIRTY_TIME) {\n\t\tinode->dirtied_when = jiffies;\n\t\tinode_io_list_move_locked(inode, wb, &wb->b_dirty_time);\n\t} else {\n\t\t/* The inode is clean. Remove from writeback lists. */\n\t\tinode_io_list_del_locked(inode, wb);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t\t  struct writeback_control *wbc)\n{\n\tif (inode->i_state & I_FREEING)\n\t\treturn;\n\n\t/*\n\t * Sync livelock prevention. Each inode is tagged and synced in one\n\t * shot. If still dirty, it will be redirty_tail()'ed below.  Update\n\t * the dirty time to prevent enqueue and sync it again.\n\t */\n\tif ((inode->i_state & I_DIRTY) &&\n\t    (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages))\n\t\tinode->dirtied_when = jiffies;\n\n\tif (wbc->pages_skipped) {\n\t\t/*\n\t\t * writeback is not making progress due to locked\n\t\t * buffers. Skip this inode for now.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t\treturn;\n\t}\n\n\tif (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {\n\t\t/*\n\t\t * We didn't write back all the pages.  nfs_writepages()\n\t\t * sometimes bales out without doing anything.\n\t\t */\n\t\tif (wbc->nr_to_write <= 0) {\n\t\t\t/* Slice used up. Queue for next turn. */\n\t\t\trequeue_io(inode, wb);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Writeback blocked by something other than\n\t\t\t * congestion. Delay the inode for some time to\n\t\t\t * avoid spinning on the CPU (100% iowait)\n\t\t\t * retrying writeback of the dirty page/inode\n\t\t\t * that cannot be performed immediately.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t}\n\t} else if (inode->i_state & I_DIRTY) {\n\t\t/*\n\t\t * Filesystems can dirty the inode during writeback operations,\n\t\t * such as delayed allocation during submission or metadata\n\t\t * updates after data IO completion.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t} else if (inode->i_state & I_DIRTY_TIME) {\n\t\tinode->dirtied_when = jiffies;\n\t\tinode_io_list_move_locked(inode, wb, &wb->b_dirty_time);\n\t} else {\n\t\t/* The inode is clean. Remove from writeback lists. */\n\t\tinode_io_list_del_locked(inode, wb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_wb_and_lock_list",
          "args": [
            "inode"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "902-909",
          "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_flush_plug",
          "args": [
            "current"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbc_detach_inode",
          "args": [
            "&wbc"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "wbc_detach_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "591-671",
          "snippet": "void wbc_detach_inode(struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb = wbc->wb;\n\tstruct inode *inode = wbc->inode;\n\tunsigned long avg_time, max_bytes, max_time;\n\tu16 history;\n\tint max_id;\n\n\tif (!wb)\n\t\treturn;\n\n\thistory = inode->i_wb_frn_history;\n\tavg_time = inode->i_wb_frn_avg_time;\n\n\t/* pick the winner of this round */\n\tif (wbc->wb_bytes >= wbc->wb_lcand_bytes &&\n\t    wbc->wb_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_id;\n\t\tmax_bytes = wbc->wb_bytes;\n\t} else if (wbc->wb_lcand_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_lcand_id;\n\t\tmax_bytes = wbc->wb_lcand_bytes;\n\t} else {\n\t\tmax_id = wbc->wb_tcand_id;\n\t\tmax_bytes = wbc->wb_tcand_bytes;\n\t}\n\n\t/*\n\t * Calculate the amount of IO time the winner consumed and fold it\n\t * into the running average kept per inode.  If the consumed IO\n\t * time is lower than avag / WB_FRN_TIME_CUT_DIV, ignore it for\n\t * deciding whether to switch or not.  This is to prevent one-off\n\t * small dirtiers from skewing the verdict.\n\t */\n\tmax_time = DIV_ROUND_UP((max_bytes >> PAGE_SHIFT) << WB_FRN_TIME_SHIFT,\n\t\t\t\twb->avg_write_bandwidth);\n\tif (avg_time)\n\t\tavg_time += (max_time >> WB_FRN_TIME_AVG_SHIFT) -\n\t\t\t    (avg_time >> WB_FRN_TIME_AVG_SHIFT);\n\telse\n\t\tavg_time = max_time;\t/* immediate catch up on first run */\n\n\tif (max_time >= avg_time / WB_FRN_TIME_CUT_DIV) {\n\t\tint slots;\n\n\t\t/*\n\t\t * The switch verdict is reached if foreign wb's consume\n\t\t * more than a certain proportion of IO time in a\n\t\t * WB_FRN_TIME_PERIOD.  This is loosely tracked by 16 slot\n\t\t * history mask where each bit represents one sixteenth of\n\t\t * the period.  Determine the number of slots to shift into\n\t\t * history from @max_time.\n\t\t */\n\t\tslots = min(DIV_ROUND_UP(max_time, WB_FRN_HIST_UNIT),\n\t\t\t    (unsigned long)WB_FRN_HIST_MAX_SLOTS);\n\t\thistory <<= slots;\n\t\tif (wbc->wb_id != max_id)\n\t\t\thistory |= (1U << slots) - 1;\n\n\t\t/*\n\t\t * Switch if the current wb isn't the consistent winner.\n\t\t * If there are multiple closely competing dirtiers, the\n\t\t * inode may switch across them repeatedly over time, which\n\t\t * is okay.  The main goal is avoiding keeping an inode on\n\t\t * the wrong wb for an extended period of time.\n\t\t */\n\t\tif (hweight32(history) > WB_FRN_HIST_THR_SLOTS)\n\t\t\tinode_switch_wbs(inode, max_id);\n\t}\n\n\t/*\n\t * Multiple instances of this function may race to update the\n\t * following fields but we don't mind occassional inaccuracies.\n\t */\n\tinode->i_wb_frn_winner = max_id;\n\tinode->i_wb_frn_avg_time = min(avg_time, (unsigned long)U16_MAX);\n\tinode->i_wb_frn_history = history;\n\n\twb_put(wbc->wb);\n\twbc->wb = NULL;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define WB_FRN_HIST_MAX_SLOTS\t(WB_FRN_HIST_THR_SLOTS / 2 + 1)",
            "#define WB_FRN_HIST_THR_SLOTS\t(WB_FRN_HIST_SLOTS / 2)",
            "#define WB_FRN_HIST_UNIT\t(WB_FRN_TIME_PERIOD / WB_FRN_HIST_SLOTS)",
            "#define WB_FRN_TIME_PERIOD\t(2 * (1 << WB_FRN_TIME_SHIFT))\t/* 2s */",
            "#define WB_FRN_TIME_CUT_DIV\t2\t/* ignore rounds < avg / 2 */",
            "#define WB_FRN_TIME_AVG_SHIFT\t3\t/* avg = avg * 7/8 + new * 1/8 */",
            "#define WB_FRN_TIME_SHIFT\t13\t/* 1s = 2^13, upto 8 secs w/ 16bit */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define WB_FRN_HIST_MAX_SLOTS\t(WB_FRN_HIST_THR_SLOTS / 2 + 1)\n#define WB_FRN_HIST_THR_SLOTS\t(WB_FRN_HIST_SLOTS / 2)\n#define WB_FRN_HIST_UNIT\t(WB_FRN_TIME_PERIOD / WB_FRN_HIST_SLOTS)\n#define WB_FRN_TIME_PERIOD\t(2 * (1 << WB_FRN_TIME_SHIFT))\t/* 2s */\n#define WB_FRN_TIME_CUT_DIV\t2\t/* ignore rounds < avg / 2 */\n#define WB_FRN_TIME_AVG_SHIFT\t3\t/* avg = avg * 7/8 + new * 1/8 */\n#define WB_FRN_TIME_SHIFT\t13\t/* 1s = 2^13, upto 8 secs w/ 16bit */\n\nvoid wbc_detach_inode(struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb = wbc->wb;\n\tstruct inode *inode = wbc->inode;\n\tunsigned long avg_time, max_bytes, max_time;\n\tu16 history;\n\tint max_id;\n\n\tif (!wb)\n\t\treturn;\n\n\thistory = inode->i_wb_frn_history;\n\tavg_time = inode->i_wb_frn_avg_time;\n\n\t/* pick the winner of this round */\n\tif (wbc->wb_bytes >= wbc->wb_lcand_bytes &&\n\t    wbc->wb_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_id;\n\t\tmax_bytes = wbc->wb_bytes;\n\t} else if (wbc->wb_lcand_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_lcand_id;\n\t\tmax_bytes = wbc->wb_lcand_bytes;\n\t} else {\n\t\tmax_id = wbc->wb_tcand_id;\n\t\tmax_bytes = wbc->wb_tcand_bytes;\n\t}\n\n\t/*\n\t * Calculate the amount of IO time the winner consumed and fold it\n\t * into the running average kept per inode.  If the consumed IO\n\t * time is lower than avag / WB_FRN_TIME_CUT_DIV, ignore it for\n\t * deciding whether to switch or not.  This is to prevent one-off\n\t * small dirtiers from skewing the verdict.\n\t */\n\tmax_time = DIV_ROUND_UP((max_bytes >> PAGE_SHIFT) << WB_FRN_TIME_SHIFT,\n\t\t\t\twb->avg_write_bandwidth);\n\tif (avg_time)\n\t\tavg_time += (max_time >> WB_FRN_TIME_AVG_SHIFT) -\n\t\t\t    (avg_time >> WB_FRN_TIME_AVG_SHIFT);\n\telse\n\t\tavg_time = max_time;\t/* immediate catch up on first run */\n\n\tif (max_time >= avg_time / WB_FRN_TIME_CUT_DIV) {\n\t\tint slots;\n\n\t\t/*\n\t\t * The switch verdict is reached if foreign wb's consume\n\t\t * more than a certain proportion of IO time in a\n\t\t * WB_FRN_TIME_PERIOD.  This is loosely tracked by 16 slot\n\t\t * history mask where each bit represents one sixteenth of\n\t\t * the period.  Determine the number of slots to shift into\n\t\t * history from @max_time.\n\t\t */\n\t\tslots = min(DIV_ROUND_UP(max_time, WB_FRN_HIST_UNIT),\n\t\t\t    (unsigned long)WB_FRN_HIST_MAX_SLOTS);\n\t\thistory <<= slots;\n\t\tif (wbc->wb_id != max_id)\n\t\t\thistory |= (1U << slots) - 1;\n\n\t\t/*\n\t\t * Switch if the current wb isn't the consistent winner.\n\t\t * If there are multiple closely competing dirtiers, the\n\t\t * inode may switch across them repeatedly over time, which\n\t\t * is okay.  The main goal is avoiding keeping an inode on\n\t\t * the wrong wb for an extended period of time.\n\t\t */\n\t\tif (hweight32(history) > WB_FRN_HIST_THR_SLOTS)\n\t\t\tinode_switch_wbs(inode, max_id);\n\t}\n\n\t/*\n\t * Multiple instances of this function may race to update the\n\t * following fields but we don't mind occassional inaccuracies.\n\t */\n\tinode->i_wb_frn_winner = max_id;\n\tinode->i_wb_frn_avg_time = min(avg_time, (unsigned long)U16_MAX);\n\tinode->i_wb_frn_history = history;\n\n\twb_put(wbc->wb);\n\twbc->wb = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__writeback_single_inode",
          "args": [
            "inode",
            "&wbc"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_single_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1304-1381",
          "snippet": "static int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (inode->i_state & I_DIRTY_TIME) {\n\t\tif ((dirty & I_DIRTY_INODE) ||\n\t\t    wbc->sync_mode == WB_SYNC_ALL ||\n\t\t    unlikely(inode->i_state & I_DIRTY_TIME_EXPIRED) ||\n\t\t    unlikely(time_after(jiffies,\n\t\t\t\t\t(inode->dirtied_time_when +\n\t\t\t\t\t dirtytime_expire_interval * HZ)))) {\n\t\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\t\ttrace_writeback_lazytime(inode);\n\t\t}\n\t} else\n\t\tinode->i_state &= ~I_DIRTY_TIME_EXPIRED;\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int dirtytime_expire_interval = 12 * 60 * 60;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned int dirtytime_expire_interval = 12 * 60 * 60;\n\nstatic int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (inode->i_state & I_DIRTY_TIME) {\n\t\tif ((dirty & I_DIRTY_INODE) ||\n\t\t    wbc->sync_mode == WB_SYNC_ALL ||\n\t\t    unlikely(inode->i_state & I_DIRTY_TIME_EXPIRED) ||\n\t\t    unlikely(time_after(jiffies,\n\t\t\t\t\t(inode->dirtied_time_when +\n\t\t\t\t\t dirtytime_expire_interval * HZ)))) {\n\t\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\t\ttrace_writeback_lazytime(inode);\n\t\t}\n\t} else\n\t\tinode->i_state &= ~I_DIRTY_TIME_EXPIRED;\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeback_chunk_size",
          "args": [
            "wb",
            "work"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "writeback_chunk_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1448-1477",
          "snippet": "static long writeback_chunk_size(struct bdi_writeback *wb,\n\t\t\t\t struct wb_writeback_work *work)\n{\n\tlong pages;\n\n\t/*\n\t * WB_SYNC_ALL mode does livelock avoidance by syncing dirty\n\t * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX\n\t * here avoids calling into writeback_inodes_wb() more than once.\n\t *\n\t * The intended call sequence for WB_SYNC_ALL writeback is:\n\t *\n\t *      wb_writeback()\n\t *          writeback_sb_inodes()       <== called only once\n\t *              write_cache_pages()     <== called once for each inode\n\t *                   (quickly) tag currently dirty pages\n\t *                   (maybe slowly) sync all tagged pages\n\t */\n\tif (work->sync_mode == WB_SYNC_ALL || work->tagged_writepages)\n\t\tpages = LONG_MAX;\n\telse {\n\t\tpages = min(wb->avg_write_bandwidth / 2,\n\t\t\t    global_wb_domain.dirty_limit / DIRTY_SCOPE);\n\t\tpages = min(pages, work->nr_pages);\n\t\tpages = round_down(pages + MIN_WRITEBACK_PAGES,\n\t\t\t\t   MIN_WRITEBACK_PAGES);\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MIN_WRITEBACK_PAGES\t(4096UL >> (PAGE_SHIFT - 10))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MIN_WRITEBACK_PAGES\t(4096UL >> (PAGE_SHIFT - 10))\n\nstatic long writeback_chunk_size(struct bdi_writeback *wb,\n\t\t\t\t struct wb_writeback_work *work)\n{\n\tlong pages;\n\n\t/*\n\t * WB_SYNC_ALL mode does livelock avoidance by syncing dirty\n\t * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX\n\t * here avoids calling into writeback_inodes_wb() more than once.\n\t *\n\t * The intended call sequence for WB_SYNC_ALL writeback is:\n\t *\n\t *      wb_writeback()\n\t *          writeback_sb_inodes()       <== called only once\n\t *              write_cache_pages()     <== called once for each inode\n\t *                   (quickly) tag currently dirty pages\n\t *                   (maybe slowly) sync all tagged pages\n\t */\n\tif (work->sync_mode == WB_SYNC_ALL || work->tagged_writepages)\n\t\tpages = LONG_MAX;\n\telse {\n\t\tpages = min(wb->avg_write_bandwidth / 2,\n\t\t\t    global_wb_domain.dirty_limit / DIRTY_SCOPE);\n\t\tpages = min(pages, work->nr_pages);\n\t\tpages = round_down(pages + MIN_WRITEBACK_PAGES,\n\t\t\t\t   MIN_WRITEBACK_PAGES);\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbc_attach_and_unlock_inode",
          "args": [
            "&wbc",
            "inode"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "wbc_attach_and_unlock_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "525-552",
          "snippet": "void wbc_attach_and_unlock_inode(struct writeback_control *wbc,\n\t\t\t\t struct inode *inode)\n{\n\tif (!inode_cgwb_enabled(inode)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\twbc->wb = inode_to_wb(inode);\n\twbc->inode = inode;\n\n\twbc->wb_id = wbc->wb->memcg_css->id;\n\twbc->wb_lcand_id = inode->i_wb_frn_winner;\n\twbc->wb_tcand_id = 0;\n\twbc->wb_bytes = 0;\n\twbc->wb_lcand_bytes = 0;\n\twbc->wb_tcand_bytes = 0;\n\n\twb_get(wbc->wb);\n\tspin_unlock(&inode->i_lock);\n\n\t/*\n\t * A dying wb indicates that the memcg-blkcg mapping has changed\n\t * and a new wb is already serving the memcg.  Switch immediately.\n\t */\n\tif (unlikely(wb_dying(wbc->wb)))\n\t\tinode_switch_wbs(inode, wbc->wb_id);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wbc_attach_and_unlock_inode(struct writeback_control *wbc,\n\t\t\t\t struct inode *inode)\n{\n\tif (!inode_cgwb_enabled(inode)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\twbc->wb = inode_to_wb(inode);\n\twbc->inode = inode;\n\n\twbc->wb_id = wbc->wb->memcg_css->id;\n\twbc->wb_lcand_id = inode->i_wb_frn_winner;\n\twbc->wb_tcand_id = 0;\n\twbc->wb_bytes = 0;\n\twbc->wb_lcand_bytes = 0;\n\twbc->wb_tcand_bytes = 0;\n\n\twb_get(wbc->wb);\n\tspin_unlock(&inode->i_lock);\n\n\t/*\n\t * A dying wb indicates that the memcg-blkcg mapping has changed\n\t * and a new wb is already serving the memcg.  Switch immediately.\n\t */\n\tif (unlikely(wb_dying(wbc->wb)))\n\t\tinode_switch_wbs(inode, wbc->wb_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sleep_on_writeback",
          "args": [
            "inode"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sleep_on_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1218-1231",
          "snippet": "static void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_sb_inodes_requeue",
          "args": [
            "inode"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "requeue_io",
          "args": [
            "inode",
            "wb"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1054-1057",
          "snippet": "static void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tinode_io_list_move_locked(inode, wb, &wb->b_more_io);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tinode_io_list_move_locked(inode, wb, &wb->b_more_io);\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_tail",
          "args": [
            "inode",
            "wb"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "redirty_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1039-1049",
          "snippet": "static void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tinode_io_list_move_locked(inode, wb, &wb->b_dirty);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tinode_io_list_move_locked(inode, wb, &wb->b_dirty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "wb->b_io.prev"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "87-90",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_io"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long writeback_sb_inodes(struct super_block *sb,\n\t\t\t\tstruct bdi_writeback *wb,\n\t\t\t\tstruct wb_writeback_work *work)\n{\n\tstruct writeback_control wbc = {\n\t\t.sync_mode\t\t= work->sync_mode,\n\t\t.tagged_writepages\t= work->tagged_writepages,\n\t\t.for_kupdate\t\t= work->for_kupdate,\n\t\t.for_background\t\t= work->for_background,\n\t\t.for_sync\t\t= work->for_sync,\n\t\t.range_cyclic\t\t= work->range_cyclic,\n\t\t.range_start\t\t= 0,\n\t\t.range_end\t\t= LLONG_MAX,\n\t};\n\tunsigned long start_time = jiffies;\n\tlong write_chunk;\n\tlong wrote = 0;  /* count both pages and inodes */\n\n\twhile (!list_empty(&wb->b_io)) {\n\t\tstruct inode *inode = wb_inode(wb->b_io.prev);\n\t\tstruct bdi_writeback *tmp_wb;\n\n\t\tif (inode->i_sb != sb) {\n\t\t\tif (work->sb) {\n\t\t\t\t/*\n\t\t\t\t * We only want to write back data for this\n\t\t\t\t * superblock, move all inodes not belonging\n\t\t\t\t * to it back onto the dirty list.\n\t\t\t\t */\n\t\t\t\tredirty_tail(inode, wb);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The inode belongs to a different superblock.\n\t\t\t * Bounce back to the caller to unpin this and\n\t\t\t * pin the next superblock.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Don't bother with new inodes or inodes being freed, first\n\t\t * kind does not need periodic writeout yet, and for the latter\n\t\t * kind writeout is handled by the freer.\n\t\t */\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tredirty_tail(inode, wb);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((inode->i_state & I_SYNC) && wbc.sync_mode != WB_SYNC_ALL) {\n\t\t\t/*\n\t\t\t * If this inode is locked for writeback and we are not\n\t\t\t * doing writeback-for-data-integrity, move it to\n\t\t\t * b_more_io so that writeback can proceed with the\n\t\t\t * other inodes on s_io.\n\t\t\t *\n\t\t\t * We'll have another go at writing back this inode\n\t\t\t * when we completed a full scan of b_io.\n\t\t\t */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\trequeue_io(inode, wb);\n\t\t\ttrace_writeback_sb_inodes_requeue(inode);\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&wb->list_lock);\n\n\t\t/*\n\t\t * We already requeued the inode if it had I_SYNC set and we\n\t\t * are doing WB_SYNC_NONE writeback. So this catches only the\n\t\t * WB_SYNC_ALL case.\n\t\t */\n\t\tif (inode->i_state & I_SYNC) {\n\t\t\t/* Wait for I_SYNC. This function drops i_lock... */\n\t\t\tinode_sleep_on_writeback(inode);\n\t\t\t/* Inode may be gone, start again */\n\t\t\tspin_lock(&wb->list_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tinode->i_state |= I_SYNC;\n\t\twbc_attach_and_unlock_inode(&wbc, inode);\n\n\t\twrite_chunk = writeback_chunk_size(wb, work);\n\t\twbc.nr_to_write = write_chunk;\n\t\twbc.pages_skipped = 0;\n\n\t\t/*\n\t\t * We use I_SYNC to pin the inode in memory. While it is set\n\t\t * evict_inode() will wait so the inode cannot be freed.\n\t\t */\n\t\t__writeback_single_inode(inode, &wbc);\n\n\t\twbc_detach_inode(&wbc);\n\t\twork->nr_pages -= write_chunk - wbc.nr_to_write;\n\t\twrote += write_chunk - wbc.nr_to_write;\n\n\t\tif (need_resched()) {\n\t\t\t/*\n\t\t\t * We're trying to balance between building up a nice\n\t\t\t * long list of IOs to improve our merge rate, and\n\t\t\t * getting those IOs out quickly for anyone throttling\n\t\t\t * in balance_dirty_pages().  cond_resched() doesn't\n\t\t\t * unplug, so get our IOs out the door before we\n\t\t\t * give up the CPU.\n\t\t\t */\n\t\t\tblk_flush_plug(current);\n\t\t\tcond_resched();\n\t\t}\n\n\t\t/*\n\t\t * Requeue @inode if still dirty.  Be careful as @inode may\n\t\t * have been switched to another wb in the meantime.\n\t\t */\n\t\ttmp_wb = inode_to_wb_and_lock_list(inode);\n\t\tspin_lock(&inode->i_lock);\n\t\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\t\twrote++;\n\t\trequeue_inode(inode, tmp_wb, &wbc);\n\t\tinode_sync_complete(inode);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tif (unlikely(tmp_wb != wb)) {\n\t\t\tspin_unlock(&tmp_wb->list_lock);\n\t\t\tspin_lock(&wb->list_lock);\n\t\t}\n\n\t\t/*\n\t\t * bail out to wb_writeback() often enough to check\n\t\t * background threshold and other termination conditions.\n\t\t */\n\t\tif (wrote) {\n\t\t\tif (time_is_before_jiffies(start_time + HZ / 10UL))\n\t\t\t\tbreak;\n\t\t\tif (work->nr_pages <= 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn wrote;\n}"
  },
  {
    "function_name": "writeback_chunk_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1448-1477",
    "snippet": "static long writeback_chunk_size(struct bdi_writeback *wb,\n\t\t\t\t struct wb_writeback_work *work)\n{\n\tlong pages;\n\n\t/*\n\t * WB_SYNC_ALL mode does livelock avoidance by syncing dirty\n\t * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX\n\t * here avoids calling into writeback_inodes_wb() more than once.\n\t *\n\t * The intended call sequence for WB_SYNC_ALL writeback is:\n\t *\n\t *      wb_writeback()\n\t *          writeback_sb_inodes()       <== called only once\n\t *              write_cache_pages()     <== called once for each inode\n\t *                   (quickly) tag currently dirty pages\n\t *                   (maybe slowly) sync all tagged pages\n\t */\n\tif (work->sync_mode == WB_SYNC_ALL || work->tagged_writepages)\n\t\tpages = LONG_MAX;\n\telse {\n\t\tpages = min(wb->avg_write_bandwidth / 2,\n\t\t\t    global_wb_domain.dirty_limit / DIRTY_SCOPE);\n\t\tpages = min(pages, work->nr_pages);\n\t\tpages = round_down(pages + MIN_WRITEBACK_PAGES,\n\t\t\t\t   MIN_WRITEBACK_PAGES);\n\t}\n\n\treturn pages;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MIN_WRITEBACK_PAGES\t(4096UL >> (PAGE_SHIFT - 10))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "pages + MIN_WRITEBACK_PAGES",
            "MIN_WRITEBACK_PAGES"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pages",
            "work->nr_pages"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define MIN_WRITEBACK_PAGES\t(4096UL >> (PAGE_SHIFT - 10))\n\nstatic long writeback_chunk_size(struct bdi_writeback *wb,\n\t\t\t\t struct wb_writeback_work *work)\n{\n\tlong pages;\n\n\t/*\n\t * WB_SYNC_ALL mode does livelock avoidance by syncing dirty\n\t * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX\n\t * here avoids calling into writeback_inodes_wb() more than once.\n\t *\n\t * The intended call sequence for WB_SYNC_ALL writeback is:\n\t *\n\t *      wb_writeback()\n\t *          writeback_sb_inodes()       <== called only once\n\t *              write_cache_pages()     <== called once for each inode\n\t *                   (quickly) tag currently dirty pages\n\t *                   (maybe slowly) sync all tagged pages\n\t */\n\tif (work->sync_mode == WB_SYNC_ALL || work->tagged_writepages)\n\t\tpages = LONG_MAX;\n\telse {\n\t\tpages = min(wb->avg_write_bandwidth / 2,\n\t\t\t    global_wb_domain.dirty_limit / DIRTY_SCOPE);\n\t\tpages = min(pages, work->nr_pages);\n\t\tpages = round_down(pages + MIN_WRITEBACK_PAGES,\n\t\t\t\t   MIN_WRITEBACK_PAGES);\n\t}\n\n\treturn pages;\n}"
  },
  {
    "function_name": "writeback_single_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1391-1446",
    "snippet": "static int writeback_single_inode(struct inode *inode,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb;\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\twbc_attach_and_unlock_inode(wbc, inode);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\twbc_detach_inode(wbc);\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sync_complete",
          "args": [
            "inode"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sync_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1059-1067",
          "snippet": "static void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_io_list_del_locked",
          "args": [
            "inode",
            "wb"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_del_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "159-166",
          "snippet": "static void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_wb_and_lock_list",
          "args": [
            "inode"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "902-909",
          "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbc_detach_inode",
          "args": [
            "wbc"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "wbc_detach_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "591-671",
          "snippet": "void wbc_detach_inode(struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb = wbc->wb;\n\tstruct inode *inode = wbc->inode;\n\tunsigned long avg_time, max_bytes, max_time;\n\tu16 history;\n\tint max_id;\n\n\tif (!wb)\n\t\treturn;\n\n\thistory = inode->i_wb_frn_history;\n\tavg_time = inode->i_wb_frn_avg_time;\n\n\t/* pick the winner of this round */\n\tif (wbc->wb_bytes >= wbc->wb_lcand_bytes &&\n\t    wbc->wb_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_id;\n\t\tmax_bytes = wbc->wb_bytes;\n\t} else if (wbc->wb_lcand_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_lcand_id;\n\t\tmax_bytes = wbc->wb_lcand_bytes;\n\t} else {\n\t\tmax_id = wbc->wb_tcand_id;\n\t\tmax_bytes = wbc->wb_tcand_bytes;\n\t}\n\n\t/*\n\t * Calculate the amount of IO time the winner consumed and fold it\n\t * into the running average kept per inode.  If the consumed IO\n\t * time is lower than avag / WB_FRN_TIME_CUT_DIV, ignore it for\n\t * deciding whether to switch or not.  This is to prevent one-off\n\t * small dirtiers from skewing the verdict.\n\t */\n\tmax_time = DIV_ROUND_UP((max_bytes >> PAGE_SHIFT) << WB_FRN_TIME_SHIFT,\n\t\t\t\twb->avg_write_bandwidth);\n\tif (avg_time)\n\t\tavg_time += (max_time >> WB_FRN_TIME_AVG_SHIFT) -\n\t\t\t    (avg_time >> WB_FRN_TIME_AVG_SHIFT);\n\telse\n\t\tavg_time = max_time;\t/* immediate catch up on first run */\n\n\tif (max_time >= avg_time / WB_FRN_TIME_CUT_DIV) {\n\t\tint slots;\n\n\t\t/*\n\t\t * The switch verdict is reached if foreign wb's consume\n\t\t * more than a certain proportion of IO time in a\n\t\t * WB_FRN_TIME_PERIOD.  This is loosely tracked by 16 slot\n\t\t * history mask where each bit represents one sixteenth of\n\t\t * the period.  Determine the number of slots to shift into\n\t\t * history from @max_time.\n\t\t */\n\t\tslots = min(DIV_ROUND_UP(max_time, WB_FRN_HIST_UNIT),\n\t\t\t    (unsigned long)WB_FRN_HIST_MAX_SLOTS);\n\t\thistory <<= slots;\n\t\tif (wbc->wb_id != max_id)\n\t\t\thistory |= (1U << slots) - 1;\n\n\t\t/*\n\t\t * Switch if the current wb isn't the consistent winner.\n\t\t * If there are multiple closely competing dirtiers, the\n\t\t * inode may switch across them repeatedly over time, which\n\t\t * is okay.  The main goal is avoiding keeping an inode on\n\t\t * the wrong wb for an extended period of time.\n\t\t */\n\t\tif (hweight32(history) > WB_FRN_HIST_THR_SLOTS)\n\t\t\tinode_switch_wbs(inode, max_id);\n\t}\n\n\t/*\n\t * Multiple instances of this function may race to update the\n\t * following fields but we don't mind occassional inaccuracies.\n\t */\n\tinode->i_wb_frn_winner = max_id;\n\tinode->i_wb_frn_avg_time = min(avg_time, (unsigned long)U16_MAX);\n\tinode->i_wb_frn_history = history;\n\n\twb_put(wbc->wb);\n\twbc->wb = NULL;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define WB_FRN_HIST_MAX_SLOTS\t(WB_FRN_HIST_THR_SLOTS / 2 + 1)",
            "#define WB_FRN_HIST_THR_SLOTS\t(WB_FRN_HIST_SLOTS / 2)",
            "#define WB_FRN_HIST_UNIT\t(WB_FRN_TIME_PERIOD / WB_FRN_HIST_SLOTS)",
            "#define WB_FRN_TIME_PERIOD\t(2 * (1 << WB_FRN_TIME_SHIFT))\t/* 2s */",
            "#define WB_FRN_TIME_CUT_DIV\t2\t/* ignore rounds < avg / 2 */",
            "#define WB_FRN_TIME_AVG_SHIFT\t3\t/* avg = avg * 7/8 + new * 1/8 */",
            "#define WB_FRN_TIME_SHIFT\t13\t/* 1s = 2^13, upto 8 secs w/ 16bit */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define WB_FRN_HIST_MAX_SLOTS\t(WB_FRN_HIST_THR_SLOTS / 2 + 1)\n#define WB_FRN_HIST_THR_SLOTS\t(WB_FRN_HIST_SLOTS / 2)\n#define WB_FRN_HIST_UNIT\t(WB_FRN_TIME_PERIOD / WB_FRN_HIST_SLOTS)\n#define WB_FRN_TIME_PERIOD\t(2 * (1 << WB_FRN_TIME_SHIFT))\t/* 2s */\n#define WB_FRN_TIME_CUT_DIV\t2\t/* ignore rounds < avg / 2 */\n#define WB_FRN_TIME_AVG_SHIFT\t3\t/* avg = avg * 7/8 + new * 1/8 */\n#define WB_FRN_TIME_SHIFT\t13\t/* 1s = 2^13, upto 8 secs w/ 16bit */\n\nvoid wbc_detach_inode(struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb = wbc->wb;\n\tstruct inode *inode = wbc->inode;\n\tunsigned long avg_time, max_bytes, max_time;\n\tu16 history;\n\tint max_id;\n\n\tif (!wb)\n\t\treturn;\n\n\thistory = inode->i_wb_frn_history;\n\tavg_time = inode->i_wb_frn_avg_time;\n\n\t/* pick the winner of this round */\n\tif (wbc->wb_bytes >= wbc->wb_lcand_bytes &&\n\t    wbc->wb_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_id;\n\t\tmax_bytes = wbc->wb_bytes;\n\t} else if (wbc->wb_lcand_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_lcand_id;\n\t\tmax_bytes = wbc->wb_lcand_bytes;\n\t} else {\n\t\tmax_id = wbc->wb_tcand_id;\n\t\tmax_bytes = wbc->wb_tcand_bytes;\n\t}\n\n\t/*\n\t * Calculate the amount of IO time the winner consumed and fold it\n\t * into the running average kept per inode.  If the consumed IO\n\t * time is lower than avag / WB_FRN_TIME_CUT_DIV, ignore it for\n\t * deciding whether to switch or not.  This is to prevent one-off\n\t * small dirtiers from skewing the verdict.\n\t */\n\tmax_time = DIV_ROUND_UP((max_bytes >> PAGE_SHIFT) << WB_FRN_TIME_SHIFT,\n\t\t\t\twb->avg_write_bandwidth);\n\tif (avg_time)\n\t\tavg_time += (max_time >> WB_FRN_TIME_AVG_SHIFT) -\n\t\t\t    (avg_time >> WB_FRN_TIME_AVG_SHIFT);\n\telse\n\t\tavg_time = max_time;\t/* immediate catch up on first run */\n\n\tif (max_time >= avg_time / WB_FRN_TIME_CUT_DIV) {\n\t\tint slots;\n\n\t\t/*\n\t\t * The switch verdict is reached if foreign wb's consume\n\t\t * more than a certain proportion of IO time in a\n\t\t * WB_FRN_TIME_PERIOD.  This is loosely tracked by 16 slot\n\t\t * history mask where each bit represents one sixteenth of\n\t\t * the period.  Determine the number of slots to shift into\n\t\t * history from @max_time.\n\t\t */\n\t\tslots = min(DIV_ROUND_UP(max_time, WB_FRN_HIST_UNIT),\n\t\t\t    (unsigned long)WB_FRN_HIST_MAX_SLOTS);\n\t\thistory <<= slots;\n\t\tif (wbc->wb_id != max_id)\n\t\t\thistory |= (1U << slots) - 1;\n\n\t\t/*\n\t\t * Switch if the current wb isn't the consistent winner.\n\t\t * If there are multiple closely competing dirtiers, the\n\t\t * inode may switch across them repeatedly over time, which\n\t\t * is okay.  The main goal is avoiding keeping an inode on\n\t\t * the wrong wb for an extended period of time.\n\t\t */\n\t\tif (hweight32(history) > WB_FRN_HIST_THR_SLOTS)\n\t\t\tinode_switch_wbs(inode, max_id);\n\t}\n\n\t/*\n\t * Multiple instances of this function may race to update the\n\t * following fields but we don't mind occassional inaccuracies.\n\t */\n\tinode->i_wb_frn_winner = max_id;\n\tinode->i_wb_frn_avg_time = min(avg_time, (unsigned long)U16_MAX);\n\tinode->i_wb_frn_history = history;\n\n\twb_put(wbc->wb);\n\twbc->wb = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__writeback_single_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "__writeback_single_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1304-1381",
          "snippet": "static int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (inode->i_state & I_DIRTY_TIME) {\n\t\tif ((dirty & I_DIRTY_INODE) ||\n\t\t    wbc->sync_mode == WB_SYNC_ALL ||\n\t\t    unlikely(inode->i_state & I_DIRTY_TIME_EXPIRED) ||\n\t\t    unlikely(time_after(jiffies,\n\t\t\t\t\t(inode->dirtied_time_when +\n\t\t\t\t\t dirtytime_expire_interval * HZ)))) {\n\t\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\t\ttrace_writeback_lazytime(inode);\n\t\t}\n\t} else\n\t\tinode->i_state &= ~I_DIRTY_TIME_EXPIRED;\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int dirtytime_expire_interval = 12 * 60 * 60;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned int dirtytime_expire_interval = 12 * 60 * 60;\n\nstatic int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (inode->i_state & I_DIRTY_TIME) {\n\t\tif ((dirty & I_DIRTY_INODE) ||\n\t\t    wbc->sync_mode == WB_SYNC_ALL ||\n\t\t    unlikely(inode->i_state & I_DIRTY_TIME_EXPIRED) ||\n\t\t    unlikely(time_after(jiffies,\n\t\t\t\t\t(inode->dirtied_time_when +\n\t\t\t\t\t dirtytime_expire_interval * HZ)))) {\n\t\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\t\ttrace_writeback_lazytime(inode);\n\t\t}\n\t} else\n\t\tinode->i_state &= ~I_DIRTY_TIME_EXPIRED;\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbc_attach_and_unlock_inode",
          "args": [
            "wbc",
            "inode"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "wbc_attach_and_unlock_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "525-552",
          "snippet": "void wbc_attach_and_unlock_inode(struct writeback_control *wbc,\n\t\t\t\t struct inode *inode)\n{\n\tif (!inode_cgwb_enabled(inode)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\twbc->wb = inode_to_wb(inode);\n\twbc->inode = inode;\n\n\twbc->wb_id = wbc->wb->memcg_css->id;\n\twbc->wb_lcand_id = inode->i_wb_frn_winner;\n\twbc->wb_tcand_id = 0;\n\twbc->wb_bytes = 0;\n\twbc->wb_lcand_bytes = 0;\n\twbc->wb_tcand_bytes = 0;\n\n\twb_get(wbc->wb);\n\tspin_unlock(&inode->i_lock);\n\n\t/*\n\t * A dying wb indicates that the memcg-blkcg mapping has changed\n\t * and a new wb is already serving the memcg.  Switch immediately.\n\t */\n\tif (unlikely(wb_dying(wbc->wb)))\n\t\tinode_switch_wbs(inode, wbc->wb_id);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wbc_attach_and_unlock_inode(struct writeback_control *wbc,\n\t\t\t\t struct inode *inode)\n{\n\tif (!inode_cgwb_enabled(inode)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\twbc->wb = inode_to_wb(inode);\n\twbc->inode = inode;\n\n\twbc->wb_id = wbc->wb->memcg_css->id;\n\twbc->wb_lcand_id = inode->i_wb_frn_winner;\n\twbc->wb_tcand_id = 0;\n\twbc->wb_bytes = 0;\n\twbc->wb_lcand_bytes = 0;\n\twbc->wb_tcand_bytes = 0;\n\n\twb_get(wbc->wb);\n\tspin_unlock(&inode->i_lock);\n\n\t/*\n\t * A dying wb indicates that the memcg-blkcg mapping has changed\n\t * and a new wb is already serving the memcg.  Switch immediately.\n\t */\n\tif (unlikely(wb_dying(wbc->wb)))\n\t\tinode_switch_wbs(inode, wbc->wb_id);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "inode->i_mapping",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_SYNC"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__inode_wait_for_writeback",
          "args": [
            "inode"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "__inode_wait_for_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1187-1201",
          "snippet": "static void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_WILL_FREE"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & (I_WILL_FREE|I_FREEING))"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int writeback_single_inode(struct inode *inode,\n\t\t\t\t  struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb;\n\tint ret = 0;\n\n\tspin_lock(&inode->i_lock);\n\tif (!atomic_read(&inode->i_count))\n\t\tWARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING)));\n\telse\n\t\tWARN_ON(inode->i_state & I_WILL_FREE);\n\n\tif (inode->i_state & I_SYNC) {\n\t\tif (wbc->sync_mode != WB_SYNC_ALL)\n\t\t\tgoto out;\n\t\t/*\n\t\t * It's a data-integrity sync. We must wait. Since callers hold\n\t\t * inode reference or inode has I_WILL_FREE set, it cannot go\n\t\t * away under us.\n\t\t */\n\t\t__inode_wait_for_writeback(inode);\n\t}\n\tWARN_ON(inode->i_state & I_SYNC);\n\t/*\n\t * Skip inode if it is clean and we have no outstanding writeback in\n\t * WB_SYNC_ALL mode. We don't want to mess with writeback lists in this\n\t * function since flusher thread may be doing for example sync in\n\t * parallel and if we move the inode, it could get skipped. So here we\n\t * make sure inode is on some writeback list and leave it there unless\n\t * we have completely cleaned the inode.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL) &&\n\t    (wbc->sync_mode != WB_SYNC_ALL ||\n\t     !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK)))\n\t\tgoto out;\n\tinode->i_state |= I_SYNC;\n\twbc_attach_and_unlock_inode(wbc, inode);\n\n\tret = __writeback_single_inode(inode, wbc);\n\n\twbc_detach_inode(wbc);\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * If inode is clean, remove it from writeback lists. Otherwise don't\n\t * touch it. See comment above for explanation.\n\t */\n\tif (!(inode->i_state & I_DIRTY_ALL))\n\t\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n\tinode_sync_complete(inode);\nout:\n\tspin_unlock(&inode->i_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__writeback_single_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1304-1381",
    "snippet": "static int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (inode->i_state & I_DIRTY_TIME) {\n\t\tif ((dirty & I_DIRTY_INODE) ||\n\t\t    wbc->sync_mode == WB_SYNC_ALL ||\n\t\t    unlikely(inode->i_state & I_DIRTY_TIME_EXPIRED) ||\n\t\t    unlikely(time_after(jiffies,\n\t\t\t\t\t(inode->dirtied_time_when +\n\t\t\t\t\t dirtytime_expire_interval * HZ)))) {\n\t\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\t\ttrace_writeback_lazytime(inode);\n\t\t}\n\t} else\n\t\tinode->i_state &= ~I_DIRTY_TIME_EXPIRED;\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int dirtytime_expire_interval = 12 * 60 * 60;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_writeback_single_inode",
          "args": [
            "inode",
            "wbc",
            "nr_to_write"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2433-2447",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/nilfs.h",
          "lines": "285-288",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_ondisk.h>",
            "#include <linux/nilfs2_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nilfs_init_gcinode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_ondisk.h>\n#include <linux/nilfs2_api.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nint nilfs_init_gcinode(struct inode *inode);\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_lazytime",
          "args": [
            "inode"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "time_after(jiffies,\n\t\t\t\t\t(inode->dirtied_time_when +\n\t\t\t\t\t dirtytime_expire_interval * HZ))"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "(inode->dirtied_time_when +\n\t\t\t\t\t dirtytime_expire_interval * HZ)"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_state & I_DIRTY_TIME_EXPIRED"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "mapping"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_writepages",
          "args": [
            "mapping",
            "wbc"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_single_inode_start",
          "args": [
            "inode",
            "wbc",
            "nr_to_write"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & I_SYNC)"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nunsigned int dirtytime_expire_interval = 12 * 60 * 60;\n\nstatic int\n__writeback_single_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tlong nr_to_write = wbc->nr_to_write;\n\tunsigned dirty;\n\tint ret;\n\n\tWARN_ON(!(inode->i_state & I_SYNC));\n\n\ttrace_writeback_single_inode_start(inode, wbc, nr_to_write);\n\n\tret = do_writepages(mapping, wbc);\n\n\t/*\n\t * Make sure to wait on the data before writing out the metadata.\n\t * This is important for filesystems that modify metadata on data\n\t * I/O completion. We don't do it for sync(2) writeback because it has a\n\t * separate, external IO completion path and ->sync_fs for guaranteeing\n\t * inode metadata is written back correctly.\n\t */\n\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync) {\n\t\tint err = filemap_fdatawait(mapping);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\n\t/*\n\t * Some filesystems may redirty the inode during the writeback\n\t * due to delalloc, clear dirty metadata flags right before\n\t * write_inode()\n\t */\n\tspin_lock(&inode->i_lock);\n\n\tdirty = inode->i_state & I_DIRTY;\n\tif (inode->i_state & I_DIRTY_TIME) {\n\t\tif ((dirty & I_DIRTY_INODE) ||\n\t\t    wbc->sync_mode == WB_SYNC_ALL ||\n\t\t    unlikely(inode->i_state & I_DIRTY_TIME_EXPIRED) ||\n\t\t    unlikely(time_after(jiffies,\n\t\t\t\t\t(inode->dirtied_time_when +\n\t\t\t\t\t dirtytime_expire_interval * HZ)))) {\n\t\t\tdirty |= I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED;\n\t\t\ttrace_writeback_lazytime(inode);\n\t\t}\n\t} else\n\t\tinode->i_state &= ~I_DIRTY_TIME_EXPIRED;\n\tinode->i_state &= ~dirty;\n\n\t/*\n\t * Paired with smp_mb() in __mark_inode_dirty().  This allows\n\t * __mark_inode_dirty() to test i_state without grabbing i_lock -\n\t * either they see the I_DIRTY bits cleared or we see the dirtied\n\t * inode.\n\t *\n\t * I_DIRTY_PAGES is always cleared together above even if @mapping\n\t * still has dirty pages.  The flag is reinstated after smp_mb() if\n\t * necessary.  This guarantees that either __mark_inode_dirty()\n\t * sees clear I_DIRTY_PAGES or we see PAGECACHE_TAG_DIRTY.\n\t */\n\tsmp_mb();\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tinode->i_state |= I_DIRTY_PAGES;\n\n\tspin_unlock(&inode->i_lock);\n\n\tif (dirty & I_DIRTY_TIME)\n\t\tmark_inode_dirty_sync(inode);\n\t/* Don't write the inode if only I_DIRTY_PAGES was set */\n\tif (dirty & ~I_DIRTY_PAGES) {\n\t\tint err = write_inode(inode, wbc);\n\t\tif (ret == 0)\n\t\t\tret = err;\n\t}\n\ttrace_writeback_single_inode(inode, wbc, nr_to_write);\n\treturn ret;\n}"
  },
  {
    "function_name": "requeue_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1241-1297",
    "snippet": "static void requeue_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t\t  struct writeback_control *wbc)\n{\n\tif (inode->i_state & I_FREEING)\n\t\treturn;\n\n\t/*\n\t * Sync livelock prevention. Each inode is tagged and synced in one\n\t * shot. If still dirty, it will be redirty_tail()'ed below.  Update\n\t * the dirty time to prevent enqueue and sync it again.\n\t */\n\tif ((inode->i_state & I_DIRTY) &&\n\t    (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages))\n\t\tinode->dirtied_when = jiffies;\n\n\tif (wbc->pages_skipped) {\n\t\t/*\n\t\t * writeback is not making progress due to locked\n\t\t * buffers. Skip this inode for now.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t\treturn;\n\t}\n\n\tif (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {\n\t\t/*\n\t\t * We didn't write back all the pages.  nfs_writepages()\n\t\t * sometimes bales out without doing anything.\n\t\t */\n\t\tif (wbc->nr_to_write <= 0) {\n\t\t\t/* Slice used up. Queue for next turn. */\n\t\t\trequeue_io(inode, wb);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Writeback blocked by something other than\n\t\t\t * congestion. Delay the inode for some time to\n\t\t\t * avoid spinning on the CPU (100% iowait)\n\t\t\t * retrying writeback of the dirty page/inode\n\t\t\t * that cannot be performed immediately.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t}\n\t} else if (inode->i_state & I_DIRTY) {\n\t\t/*\n\t\t * Filesystems can dirty the inode during writeback operations,\n\t\t * such as delayed allocation during submission or metadata\n\t\t * updates after data IO completion.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t} else if (inode->i_state & I_DIRTY_TIME) {\n\t\tinode->dirtied_when = jiffies;\n\t\tinode_io_list_move_locked(inode, wb, &wb->b_dirty_time);\n\t} else {\n\t\t/* The inode is clean. Remove from writeback lists. */\n\t\tinode_io_list_del_locked(inode, wb);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_io_list_del_locked",
          "args": [
            "inode",
            "wb"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_del_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "159-166",
          "snippet": "static void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_io_list_move_locked",
          "args": [
            "inode",
            "wb",
            "&wb->b_dirty_time"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_move_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "135-149",
          "snippet": "static bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "redirty_tail",
          "args": [
            "inode",
            "wb"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "redirty_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1039-1049",
          "snippet": "static void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tinode_io_list_move_locked(inode, wb, &wb->b_dirty);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tinode_io_list_move_locked(inode, wb, &wb->b_dirty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "requeue_io",
          "args": [
            "inode",
            "wb"
          ],
          "line": 1272
        },
        "resolved": true,
        "details": {
          "function_name": "requeue_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1054-1057",
          "snippet": "static void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tinode_io_list_move_locked(inode, wb, &wb->b_more_io);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tinode_io_list_move_locked(inode, wb, &wb->b_more_io);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapping_tagged",
          "args": [
            "inode->i_mapping",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_inode(struct inode *inode, struct bdi_writeback *wb,\n\t\t\t  struct writeback_control *wbc)\n{\n\tif (inode->i_state & I_FREEING)\n\t\treturn;\n\n\t/*\n\t * Sync livelock prevention. Each inode is tagged and synced in one\n\t * shot. If still dirty, it will be redirty_tail()'ed below.  Update\n\t * the dirty time to prevent enqueue and sync it again.\n\t */\n\tif ((inode->i_state & I_DIRTY) &&\n\t    (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages))\n\t\tinode->dirtied_when = jiffies;\n\n\tif (wbc->pages_skipped) {\n\t\t/*\n\t\t * writeback is not making progress due to locked\n\t\t * buffers. Skip this inode for now.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t\treturn;\n\t}\n\n\tif (mapping_tagged(inode->i_mapping, PAGECACHE_TAG_DIRTY)) {\n\t\t/*\n\t\t * We didn't write back all the pages.  nfs_writepages()\n\t\t * sometimes bales out without doing anything.\n\t\t */\n\t\tif (wbc->nr_to_write <= 0) {\n\t\t\t/* Slice used up. Queue for next turn. */\n\t\t\trequeue_io(inode, wb);\n\t\t} else {\n\t\t\t/*\n\t\t\t * Writeback blocked by something other than\n\t\t\t * congestion. Delay the inode for some time to\n\t\t\t * avoid spinning on the CPU (100% iowait)\n\t\t\t * retrying writeback of the dirty page/inode\n\t\t\t * that cannot be performed immediately.\n\t\t\t */\n\t\t\tredirty_tail(inode, wb);\n\t\t}\n\t} else if (inode->i_state & I_DIRTY) {\n\t\t/*\n\t\t * Filesystems can dirty the inode during writeback operations,\n\t\t * such as delayed allocation during submission or metadata\n\t\t * updates after data IO completion.\n\t\t */\n\t\tredirty_tail(inode, wb);\n\t} else if (inode->i_state & I_DIRTY_TIME) {\n\t\tinode->dirtied_when = jiffies;\n\t\tinode_io_list_move_locked(inode, wb, &wb->b_dirty_time);\n\t} else {\n\t\t/* The inode is clean. Remove from writeback lists. */\n\t\tinode_io_list_del_locked(inode, wb);\n\t}\n}"
  },
  {
    "function_name": "inode_sleep_on_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1218-1231",
    "snippet": "static void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wqh",
            "&wait"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wqh",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&inode->i_state",
            "__I_SYNC"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "inode->i_lock"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}"
  },
  {
    "function_name": "inode_wait_for_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1206-1211",
    "snippet": "void inode_wait_for_writeback(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_wait_for_writeback(inode);\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__inode_wait_for_writeback",
          "args": [
            "inode"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "__inode_wait_for_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1187-1201",
          "snippet": "static void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid inode_wait_for_writeback(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_wait_for_writeback(inode);\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "__inode_wait_for_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1187-1201",
    "snippet": "static void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_on_bit",
          "args": [
            "wqh",
            "&wq",
            "bit_wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&inode->i_state",
            "__I_SYNC"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wq",
            "&inode->i_state",
            "__I_SYNC"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "inode->i_lock"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "inode->i_lock"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void __inode_wait_for_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n\t__acquires(inode->i_lock)\n{\n\tDEFINE_WAIT_BIT(wq, &inode->i_state, __I_SYNC);\n\twait_queue_head_t *wqh;\n\n\twqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\twhile (inode->i_state & I_SYNC) {\n\t\tspin_unlock(&inode->i_lock);\n\t\t__wait_on_bit(wqh, &wq, bit_wait,\n\t\t\t      TASK_UNINTERRUPTIBLE);\n\t\tspin_lock(&inode->i_lock);\n\t}\n}"
  },
  {
    "function_name": "write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1170-1181",
    "snippet": "static int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_writeback_write_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_sb->s_op->write_inode",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1170-1181",
          "snippet": "static int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_write_inode_start",
          "args": [
            "inode",
            "wbc"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/bad_inode.c",
          "lines": "224-227",
          "snippet": "bool is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename\t\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.get_link\t= bad_inode_get_link,\n\t.get_acl\t= bad_inode_get_acl,\n\t.fiemap\t\t= bad_inode_fiemap,\n\t.update_time\t= bad_inode_update_time,\n\t.atomic_open\t= bad_inode_atomic_open,\n\t.tmpfile\t= bad_inode_tmpfile,\n\t.set_acl\t= bad_inode_set_acl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename\t\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.get_link\t= bad_inode_get_link,\n\t.get_acl\t= bad_inode_get_acl,\n\t.fiemap\t\t= bad_inode_fiemap,\n\t.update_time\t= bad_inode_update_time,\n\t.atomic_open\t= bad_inode_atomic_open,\n\t.tmpfile\t= bad_inode_tmpfile,\n\t.set_acl\t= bad_inode_set_acl,\n};\n\nbool is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\n\tif (inode->i_sb->s_op->write_inode && !is_bad_inode(inode)) {\n\t\ttrace_writeback_write_inode_start(inode, wbc);\n\t\tret = inode->i_sb->s_op->write_inode(inode, wbc);\n\t\ttrace_writeback_write_inode(inode, wbc);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "queue_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1156-1168",
    "snippet": "static void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\tif (moved)\n\t\twb_io_lists_populated(wb);\n\ttrace_writeback_queue_io(wb, work, moved);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define EXPIRE_DIRTY_ATIME 0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_writeback_queue_io",
          "args": [
            "wb",
            "work",
            "moved"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_io_lists_populated",
          "args": [
            "wb"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "wb_io_lists_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "102-113",
          "snippet": "static bool wb_io_lists_populated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb)) {\n\t\treturn false;\n\t} else {\n\t\tset_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(!wb->avg_write_bandwidth);\n\t\tatomic_long_add(wb->avg_write_bandwidth,\n\t\t\t\t&wb->bdi->tot_write_bandwidth);\n\t\treturn true;\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool wb_io_lists_populated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb)) {\n\t\treturn false;\n\t} else {\n\t\tset_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(!wb->avg_write_bandwidth);\n\t\tatomic_long_add(wb->avg_write_bandwidth,\n\t\t\t\t&wb->bdi->tot_write_bandwidth);\n\t\treturn true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_expired_inodes",
          "args": [
            "&wb->b_dirty_time",
            "&wb->b_io",
            "EXPIRE_DIRTY_ATIME",
            "work"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "move_expired_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1090-1143",
          "snippet": "static int move_expired_inodes(struct list_head *delaying_queue,\n\t\t\t       struct list_head *dispatch_queue,\n\t\t\t       int flags,\n\t\t\t       struct wb_writeback_work *work)\n{\n\tunsigned long *older_than_this = NULL;\n\tunsigned long expire_time;\n\tLIST_HEAD(tmp);\n\tstruct list_head *pos, *node;\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode;\n\tint do_sb_sort = 0;\n\tint moved = 0;\n\n\tif ((flags & EXPIRE_DIRTY_ATIME) == 0)\n\t\tolder_than_this = work->older_than_this;\n\telse if (!work->for_sync) {\n\t\texpire_time = jiffies - (dirtytime_expire_interval * HZ);\n\t\tolder_than_this = &expire_time;\n\t}\n\twhile (!list_empty(delaying_queue)) {\n\t\tinode = wb_inode(delaying_queue->prev);\n\t\tif (older_than_this &&\n\t\t    inode_dirtied_after(inode, *older_than_this))\n\t\t\tbreak;\n\t\tlist_move(&inode->i_io_list, &tmp);\n\t\tmoved++;\n\t\tif (flags & EXPIRE_DIRTY_ATIME)\n\t\t\tset_bit(__I_DIRTY_TIME_EXPIRED, &inode->i_state);\n\t\tif (sb_is_blkdev_sb(inode->i_sb))\n\t\t\tcontinue;\n\t\tif (sb && sb != inode->i_sb)\n\t\t\tdo_sb_sort = 1;\n\t\tsb = inode->i_sb;\n\t}\n\n\t/* just one sb in list, splice to dispatch_queue and we're done */\n\tif (!do_sb_sort) {\n\t\tlist_splice(&tmp, dispatch_queue);\n\t\tgoto out;\n\t}\n\n\t/* Move inodes from one superblock together */\n\twhile (!list_empty(&tmp)) {\n\t\tsb = wb_inode(tmp.prev)->i_sb;\n\t\tlist_for_each_prev_safe(pos, node, &tmp) {\n\t\t\tinode = wb_inode(pos);\n\t\t\tif (inode->i_sb == sb)\n\t\t\t\tlist_move(&inode->i_io_list, dispatch_queue);\n\t\t}\n\t}\nout:\n\treturn moved;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define EXPIRE_DIRTY_ATIME 0x0001"
          ],
          "globals_used": [
            "unsigned int dirtytime_expire_interval = 12 * 60 * 60;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nunsigned int dirtytime_expire_interval = 12 * 60 * 60;\n\nstatic int move_expired_inodes(struct list_head *delaying_queue,\n\t\t\t       struct list_head *dispatch_queue,\n\t\t\t       int flags,\n\t\t\t       struct wb_writeback_work *work)\n{\n\tunsigned long *older_than_this = NULL;\n\tunsigned long expire_time;\n\tLIST_HEAD(tmp);\n\tstruct list_head *pos, *node;\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode;\n\tint do_sb_sort = 0;\n\tint moved = 0;\n\n\tif ((flags & EXPIRE_DIRTY_ATIME) == 0)\n\t\tolder_than_this = work->older_than_this;\n\telse if (!work->for_sync) {\n\t\texpire_time = jiffies - (dirtytime_expire_interval * HZ);\n\t\tolder_than_this = &expire_time;\n\t}\n\twhile (!list_empty(delaying_queue)) {\n\t\tinode = wb_inode(delaying_queue->prev);\n\t\tif (older_than_this &&\n\t\t    inode_dirtied_after(inode, *older_than_this))\n\t\t\tbreak;\n\t\tlist_move(&inode->i_io_list, &tmp);\n\t\tmoved++;\n\t\tif (flags & EXPIRE_DIRTY_ATIME)\n\t\t\tset_bit(__I_DIRTY_TIME_EXPIRED, &inode->i_state);\n\t\tif (sb_is_blkdev_sb(inode->i_sb))\n\t\t\tcontinue;\n\t\tif (sb && sb != inode->i_sb)\n\t\t\tdo_sb_sort = 1;\n\t\tsb = inode->i_sb;\n\t}\n\n\t/* just one sb in list, splice to dispatch_queue and we're done */\n\tif (!do_sb_sort) {\n\t\tlist_splice(&tmp, dispatch_queue);\n\t\tgoto out;\n\t}\n\n\t/* Move inodes from one superblock together */\n\twhile (!list_empty(&tmp)) {\n\t\tsb = wb_inode(tmp.prev)->i_sb;\n\t\tlist_for_each_prev_safe(pos, node, &tmp) {\n\t\t\tinode = wb_inode(pos);\n\t\t\tif (inode->i_sb == sb)\n\t\t\t\tlist_move(&inode->i_io_list, dispatch_queue);\n\t\t}\n\t}\nout:\n\treturn moved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&wb->b_more_io",
            "&wb->b_io"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&wb->list_lock"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nstatic void queue_io(struct bdi_writeback *wb, struct wb_writeback_work *work)\n{\n\tint moved;\n\n\tassert_spin_locked(&wb->list_lock);\n\tlist_splice_init(&wb->b_more_io, &wb->b_io);\n\tmoved = move_expired_inodes(&wb->b_dirty, &wb->b_io, 0, work);\n\tmoved += move_expired_inodes(&wb->b_dirty_time, &wb->b_io,\n\t\t\t\t     EXPIRE_DIRTY_ATIME, work);\n\tif (moved)\n\t\twb_io_lists_populated(wb);\n\ttrace_writeback_queue_io(wb, work, moved);\n}"
  },
  {
    "function_name": "move_expired_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1090-1143",
    "snippet": "static int move_expired_inodes(struct list_head *delaying_queue,\n\t\t\t       struct list_head *dispatch_queue,\n\t\t\t       int flags,\n\t\t\t       struct wb_writeback_work *work)\n{\n\tunsigned long *older_than_this = NULL;\n\tunsigned long expire_time;\n\tLIST_HEAD(tmp);\n\tstruct list_head *pos, *node;\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode;\n\tint do_sb_sort = 0;\n\tint moved = 0;\n\n\tif ((flags & EXPIRE_DIRTY_ATIME) == 0)\n\t\tolder_than_this = work->older_than_this;\n\telse if (!work->for_sync) {\n\t\texpire_time = jiffies - (dirtytime_expire_interval * HZ);\n\t\tolder_than_this = &expire_time;\n\t}\n\twhile (!list_empty(delaying_queue)) {\n\t\tinode = wb_inode(delaying_queue->prev);\n\t\tif (older_than_this &&\n\t\t    inode_dirtied_after(inode, *older_than_this))\n\t\t\tbreak;\n\t\tlist_move(&inode->i_io_list, &tmp);\n\t\tmoved++;\n\t\tif (flags & EXPIRE_DIRTY_ATIME)\n\t\t\tset_bit(__I_DIRTY_TIME_EXPIRED, &inode->i_state);\n\t\tif (sb_is_blkdev_sb(inode->i_sb))\n\t\t\tcontinue;\n\t\tif (sb && sb != inode->i_sb)\n\t\t\tdo_sb_sort = 1;\n\t\tsb = inode->i_sb;\n\t}\n\n\t/* just one sb in list, splice to dispatch_queue and we're done */\n\tif (!do_sb_sort) {\n\t\tlist_splice(&tmp, dispatch_queue);\n\t\tgoto out;\n\t}\n\n\t/* Move inodes from one superblock together */\n\twhile (!list_empty(&tmp)) {\n\t\tsb = wb_inode(tmp.prev)->i_sb;\n\t\tlist_for_each_prev_safe(pos, node, &tmp) {\n\t\t\tinode = wb_inode(pos);\n\t\t\tif (inode->i_sb == sb)\n\t\t\t\tlist_move(&inode->i_io_list, dispatch_queue);\n\t\t}\n\t}\nout:\n\treturn moved;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define EXPIRE_DIRTY_ATIME 0x0001"
    ],
    "globals_used": [
      "unsigned int dirtytime_expire_interval = 12 * 60 * 60;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_io_list",
            "dispatch_queue"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "pos"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "87-90",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_prev_safe",
          "args": [
            "pos",
            "node",
            "&tmp"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tmp"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&tmp",
            "dispatch_queue"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_is_blkdev_sb",
          "args": [
            "inode->i_sb"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "__I_DIRTY_TIME_EXPIRED",
            "&inode->i_state"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "914-918",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_io_list",
            "&tmp"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dirtied_after",
          "args": [
            "inode",
            "*older_than_this"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dirtied_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1069-1082",
          "snippet": "static bool inode_dirtied_after(struct inode *inode, unsigned long t)\n{\n\tbool ret = time_after(inode->dirtied_when, t);\n#ifndef CONFIG_64BIT\n\t/*\n\t * For inodes being constantly redirtied, dirtied_when can get stuck.\n\t * It _appears_ to be in the future, but is actually in distant past.\n\t * This test is necessary to prevent such wrapped-around relative times\n\t * from permanently stopping the whole bdi writeback.\n\t */\n\tret = ret && time_before_eq(inode->dirtied_when, jiffies);\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_dirtied_after(struct inode *inode, unsigned long t)\n{\n\tbool ret = time_after(inode->dirtied_when, t);\n#ifndef CONFIG_64BIT\n\t/*\n\t * For inodes being constantly redirtied, dirtied_when can get stuck.\n\t * It _appears_ to be in the future, but is actually in distant past.\n\t * This test is necessary to prevent such wrapped-around relative times\n\t * from permanently stopping the whole bdi writeback.\n\t */\n\tret = ret && time_before_eq(inode->dirtied_when, jiffies);\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "tmp"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define EXPIRE_DIRTY_ATIME 0x0001\n\nunsigned int dirtytime_expire_interval = 12 * 60 * 60;\n\nstatic int move_expired_inodes(struct list_head *delaying_queue,\n\t\t\t       struct list_head *dispatch_queue,\n\t\t\t       int flags,\n\t\t\t       struct wb_writeback_work *work)\n{\n\tunsigned long *older_than_this = NULL;\n\tunsigned long expire_time;\n\tLIST_HEAD(tmp);\n\tstruct list_head *pos, *node;\n\tstruct super_block *sb = NULL;\n\tstruct inode *inode;\n\tint do_sb_sort = 0;\n\tint moved = 0;\n\n\tif ((flags & EXPIRE_DIRTY_ATIME) == 0)\n\t\tolder_than_this = work->older_than_this;\n\telse if (!work->for_sync) {\n\t\texpire_time = jiffies - (dirtytime_expire_interval * HZ);\n\t\tolder_than_this = &expire_time;\n\t}\n\twhile (!list_empty(delaying_queue)) {\n\t\tinode = wb_inode(delaying_queue->prev);\n\t\tif (older_than_this &&\n\t\t    inode_dirtied_after(inode, *older_than_this))\n\t\t\tbreak;\n\t\tlist_move(&inode->i_io_list, &tmp);\n\t\tmoved++;\n\t\tif (flags & EXPIRE_DIRTY_ATIME)\n\t\t\tset_bit(__I_DIRTY_TIME_EXPIRED, &inode->i_state);\n\t\tif (sb_is_blkdev_sb(inode->i_sb))\n\t\t\tcontinue;\n\t\tif (sb && sb != inode->i_sb)\n\t\t\tdo_sb_sort = 1;\n\t\tsb = inode->i_sb;\n\t}\n\n\t/* just one sb in list, splice to dispatch_queue and we're done */\n\tif (!do_sb_sort) {\n\t\tlist_splice(&tmp, dispatch_queue);\n\t\tgoto out;\n\t}\n\n\t/* Move inodes from one superblock together */\n\twhile (!list_empty(&tmp)) {\n\t\tsb = wb_inode(tmp.prev)->i_sb;\n\t\tlist_for_each_prev_safe(pos, node, &tmp) {\n\t\t\tinode = wb_inode(pos);\n\t\t\tif (inode->i_sb == sb)\n\t\t\t\tlist_move(&inode->i_io_list, dispatch_queue);\n\t\t}\n\t}\nout:\n\treturn moved;\n}"
  },
  {
    "function_name": "inode_dirtied_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1069-1082",
    "snippet": "static bool inode_dirtied_after(struct inode *inode, unsigned long t)\n{\n\tbool ret = time_after(inode->dirtied_when, t);\n#ifndef CONFIG_64BIT\n\t/*\n\t * For inodes being constantly redirtied, dirtied_when can get stuck.\n\t * It _appears_ to be in the future, but is actually in distant past.\n\t * This test is necessary to prevent such wrapped-around relative times\n\t * from permanently stopping the whole bdi writeback.\n\t */\n\tret = ret && time_before_eq(inode->dirtied_when, jiffies);\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before_eq",
          "args": [
            "inode->dirtied_when",
            "jiffies"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "inode->dirtied_when",
            "t"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_dirtied_after(struct inode *inode, unsigned long t)\n{\n\tbool ret = time_after(inode->dirtied_when, t);\n#ifndef CONFIG_64BIT\n\t/*\n\t * For inodes being constantly redirtied, dirtied_when can get stuck.\n\t * It _appears_ to be in the future, but is actually in distant past.\n\t * This test is necessary to prevent such wrapped-around relative times\n\t * from permanently stopping the whole bdi writeback.\n\t */\n\tret = ret && time_before_eq(inode->dirtied_when, jiffies);\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "inode_sync_complete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1059-1067",
    "snippet": "static void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_SYNC"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_add_lru",
          "args": [
            "inode"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "421-427",
          "snippet": "void inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & SB_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & SB_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sync_complete(struct inode *inode)\n{\n\tinode->i_state &= ~I_SYNC;\n\t/* If inode is clean an unused, put it into LRU now... */\n\tinode_add_lru(inode);\n\t/* Waiters must see I_SYNC cleared before being woken up */\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_SYNC);\n}"
  },
  {
    "function_name": "requeue_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1054-1057",
    "snippet": "static void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tinode_io_list_move_locked(inode, wb, &wb->b_more_io);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_io_list_move_locked",
          "args": [
            "inode",
            "wb",
            "&wb->b_more_io"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_move_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "135-149",
          "snippet": "static bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void requeue_io(struct inode *inode, struct bdi_writeback *wb)\n{\n\tinode_io_list_move_locked(inode, wb, &wb->b_more_io);\n}"
  },
  {
    "function_name": "redirty_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1039-1049",
    "snippet": "static void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tinode_io_list_move_locked(inode, wb, &wb->b_dirty);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_io_list_move_locked",
          "args": [
            "inode",
            "wb",
            "&wb->b_dirty"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_move_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "135-149",
          "snippet": "static bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "inode->dirtied_when",
            "tail->dirtied_when"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_inode",
          "args": [
            "wb->b_dirty.next"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "wb_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "87-90",
          "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_dirty"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void redirty_tail(struct inode *inode, struct bdi_writeback *wb)\n{\n\tif (!list_empty(&wb->b_dirty)) {\n\t\tstruct inode *tail;\n\n\t\ttail = wb_inode(wb->b_dirty.next);\n\t\tif (time_before(inode->dirtied_when, tail->dirtied_when))\n\t\t\tinode->dirtied_when = jiffies;\n\t}\n\tinode_io_list_move_locked(inode, wb, &wb->b_dirty);\n}"
  },
  {
    "function_name": "sb_clear_inode_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "1015-1028",
    "snippet": "void sb_clear_inode_writeback(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long flags;\n\n\tif (!list_empty(&inode->i_wb_list)) {\n\t\tspin_lock_irqsave(&sb->s_inode_wblist_lock, flags);\n\t\tif (!list_empty(&inode->i_wb_list)) {\n\t\t\tlist_del_init(&inode->i_wb_list);\n\t\t\ttrace_sb_clear_inode_writeback(inode);\n\t\t}\n\t\tspin_unlock_irqrestore(&sb->s_inode_wblist_lock, flags);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sb->s_inode_wblist_lock",
            "flags"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sb_clear_inode_writeback",
          "args": [
            "inode"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sb->s_inode_wblist_lock",
            "flags"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid sb_clear_inode_writeback(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long flags;\n\n\tif (!list_empty(&inode->i_wb_list)) {\n\t\tspin_lock_irqsave(&sb->s_inode_wblist_lock, flags);\n\t\tif (!list_empty(&inode->i_wb_list)) {\n\t\t\tlist_del_init(&inode->i_wb_list);\n\t\t\ttrace_sb_clear_inode_writeback(inode);\n\t\t}\n\t\tspin_unlock_irqrestore(&sb->s_inode_wblist_lock, flags);\n\t}\n}"
  },
  {
    "function_name": "sb_mark_inode_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "997-1010",
    "snippet": "void sb_mark_inode_writeback(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long flags;\n\n\tif (list_empty(&inode->i_wb_list)) {\n\t\tspin_lock_irqsave(&sb->s_inode_wblist_lock, flags);\n\t\tif (list_empty(&inode->i_wb_list)) {\n\t\t\tlist_add_tail(&inode->i_wb_list, &sb->s_inodes_wb);\n\t\t\ttrace_sb_mark_inode_writeback(inode);\n\t\t}\n\t\tspin_unlock_irqrestore(&sb->s_inode_wblist_lock, flags);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sb->s_inode_wblist_lock",
            "flags"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sb_mark_inode_writeback",
          "args": [
            "inode"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&inode->i_wb_list",
            "&sb->s_inodes_wb"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sb->s_inode_wblist_lock",
            "flags"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid sb_mark_inode_writeback(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long flags;\n\n\tif (list_empty(&inode->i_wb_list)) {\n\t\tspin_lock_irqsave(&sb->s_inode_wblist_lock, flags);\n\t\tif (list_empty(&inode->i_wb_list)) {\n\t\t\tlist_add_tail(&inode->i_wb_list, &sb->s_inodes_wb);\n\t\t\ttrace_sb_mark_inode_writeback(inode);\n\t\t}\n\t\tspin_unlock_irqrestore(&sb->s_inode_wblist_lock, flags);\n\t}\n}"
  },
  {
    "function_name": "inode_io_list_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "985-992",
    "snippet": "void inode_io_list_del(struct inode *inode)\n{\n\tstruct bdi_writeback *wb;\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_io_list_del_locked",
          "args": [
            "inode",
            "wb"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_del_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "159-166",
          "snippet": "static void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_wb_and_lock_list",
          "args": [
            "inode"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "902-909",
          "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid inode_io_list_del(struct inode *inode)\n{\n\tstruct bdi_writeback *wb;\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n}"
  },
  {
    "function_name": "wb_start_background_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "972-980",
    "snippet": "void wb_start_background_writeback(struct bdi_writeback *wb)\n{\n\t/*\n\t * We just wake up the flusher thread. It will perform background\n\t * writeback as soon as there is no other work to do.\n\t */\n\ttrace_writeback_wake_background(wb);\n\twb_wakeup(wb);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_wakeup",
          "args": [
            "wb"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "wb_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "168-174",
          "snippet": "static void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_wake_background",
          "args": [
            "wb"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wb_start_background_writeback(struct bdi_writeback *wb)\n{\n\t/*\n\t * We just wake up the flusher thread. It will perform background\n\t * writeback as soon as there is no other work to do.\n\t */\n\ttrace_writeback_wake_background(wb);\n\twb_wakeup(wb);\n}"
  },
  {
    "function_name": "wb_start_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "941-960",
    "snippet": "static void wb_start_writeback(struct bdi_writeback *wb, enum wb_reason reason)\n{\n\tif (!wb_has_dirty_io(wb))\n\t\treturn;\n\n\t/*\n\t * All callers of this function want to start writeback of all\n\t * dirty pages. Places like vmscan can call this at a very\n\t * high frequency, causing pointless allocations of tons of\n\t * work items and keeping the flusher threads busy retrieving\n\t * that work. Ensure that we only allow one of them pending and\n\t * inflight at the time.\n\t */\n\tif (test_bit(WB_start_all, &wb->state) ||\n\t    test_and_set_bit(WB_start_all, &wb->state))\n\t\treturn;\n\n\twb->start_all_reason = reason;\n\twb_wakeup(wb);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_wakeup",
          "args": [
            "wb"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "wb_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "168-174",
          "snippet": "static void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "WB_start_all",
            "&wb->state"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2231-2241",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WB_start_all",
            "&wb->state"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_has_dirty_io",
          "args": [
            "wb"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_start_writeback(struct bdi_writeback *wb, enum wb_reason reason)\n{\n\tif (!wb_has_dirty_io(wb))\n\t\treturn;\n\n\t/*\n\t * All callers of this function want to start writeback of all\n\t * dirty pages. Places like vmscan can call this at a very\n\t * high frequency, causing pointless allocations of tons of\n\t * work items and keeping the flusher threads busy retrieving\n\t * that work. Ensure that we only allow one of them pending and\n\t * inflight at the time.\n\t */\n\tif (test_bit(WB_start_all, &wb->state) ||\n\t    test_and_set_bit(WB_start_all, &wb->state))\n\t\treturn;\n\n\twb->start_all_reason = reason;\n\twb_wakeup(wb);\n}"
  },
  {
    "function_name": "get_nr_dirty_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "934-939",
    "snippet": "static unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_nr_dirty_inodes",
          "args": [],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dirty_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "97-102",
          "snippet": "long get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nlong get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_UNSTABLE_NFS"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_node_page_state",
          "args": [
            "NR_FILE_DIRTY"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_nr_dirty_pages(void)\n{\n\treturn global_node_page_state(NR_FILE_DIRTY) +\n\t\tglobal_node_page_state(NR_UNSTABLE_NFS) +\n\t\tget_nr_dirty_inodes();\n}"
  },
  {
    "function_name": "bdi_split_work_to_wbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "916-926",
    "snippet": "static void bdi_split_work_to_wbs(struct backing_dev_info *bdi,\n\t\t\t\t  struct wb_writeback_work *base_work,\n\t\t\t\t  bool skip_if_busy)\n{\n\tmight_sleep();\n\n\tif (!skip_if_busy || !writeback_in_progress(&bdi->wb)) {\n\t\tbase_work->auto_free = 0;\n\t\twb_queue_work(&bdi->wb, base_work);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_queue_work",
          "args": [
            "&bdi->wb",
            "base_work"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "wb_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "187-204",
          "snippet": "static void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeback_in_progress",
          "args": [
            "&bdi->wb"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_split_work_to_wbs(struct backing_dev_info *bdi,\n\t\t\t\t  struct wb_writeback_work *base_work,\n\t\t\t\t  bool skip_if_busy)\n{\n\tmight_sleep();\n\n\tif (!skip_if_busy || !writeback_in_progress(&bdi->wb)) {\n\t\tbase_work->auto_free = 0;\n\t\twb_queue_work(&bdi->wb, base_work);\n\t}\n}"
  },
  {
    "function_name": "wb_split_bdi_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "911-914",
    "snippet": "static long wb_split_bdi_pages(struct bdi_writeback *wb, long nr_pages)\n{\n\treturn nr_pages;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_split_bdi_pages(struct bdi_writeback *wb, long nr_pages)\n{\n\treturn nr_pages;\n}"
  },
  {
    "function_name": "inode_to_wb_and_lock_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "902-909",
    "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "inode"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "902-909",
          "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&wb->list_lock"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
  },
  {
    "function_name": "locked_inode_to_wb_and_lock_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "890-900",
    "snippet": "static struct bdi_writeback *\nlocked_inode_to_wb_and_lock_list(struct inode *inode)\n\t__releases(&inode->i_lock)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_unlock(&inode->i_lock);\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "inode"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "902-909",
          "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&wb->list_lock"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&inode->i_lock"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *\nlocked_inode_to_wb_and_lock_list(struct inode *inode)\n\t__releases(&inode->i_lock)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_unlock(&inode->i_lock);\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
  },
  {
    "function_name": "cgroup_writeback_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "879-885",
    "snippet": "static int __init cgroup_writeback_init(void)\n{\n\tisw_wq = alloc_workqueue(\"inode_switch_wbs\", 0, 0);\n\tif (!isw_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"inode_switch_wbs\"",
            "0",
            "0"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic int __init cgroup_writeback_init(void)\n{\n\tisw_wq = alloc_workqueue(\"inode_switch_wbs\", 0, 0);\n\tif (!isw_wq)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "cgroup_writeback_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "871-877",
    "snippet": "void cgroup_writeback_umount(void)\n{\n\tif (atomic_read(&isw_nr_in_flight)) {\n\t\tsynchronize_rcu();\n\t\tflush_workqueue(isw_wq);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "isw_wq"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&isw_nr_in_flight"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid cgroup_writeback_umount(void)\n{\n\tif (atomic_read(&isw_nr_in_flight)) {\n\t\tsynchronize_rcu();\n\t\tflush_workqueue(isw_wq);\n\t}\n}"
  },
  {
    "function_name": "bdi_split_work_to_wbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "793-859",
    "snippet": "static void bdi_split_work_to_wbs(struct backing_dev_info *bdi,\n\t\t\t\t  struct wb_writeback_work *base_work,\n\t\t\t\t  bool skip_if_busy)\n{\n\tstruct bdi_writeback *last_wb = NULL;\n\tstruct bdi_writeback *wb = list_entry(&bdi->wb_list,\n\t\t\t\t\t      struct bdi_writeback, bdi_node);\n\n\tmight_sleep();\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_continue_rcu(wb, &bdi->wb_list, bdi_node) {\n\t\tDEFINE_WB_COMPLETION_ONSTACK(fallback_work_done);\n\t\tstruct wb_writeback_work fallback_work;\n\t\tstruct wb_writeback_work *work;\n\t\tlong nr_pages;\n\n\t\tif (last_wb) {\n\t\t\twb_put(last_wb);\n\t\t\tlast_wb = NULL;\n\t\t}\n\n\t\t/* SYNC_ALL writes out I_DIRTY_TIME too */\n\t\tif (!wb_has_dirty_io(wb) &&\n\t\t    (base_work->sync_mode == WB_SYNC_NONE ||\n\t\t     list_empty(&wb->b_dirty_time)))\n\t\t\tcontinue;\n\t\tif (skip_if_busy && writeback_in_progress(wb))\n\t\t\tcontinue;\n\n\t\tnr_pages = wb_split_bdi_pages(wb, base_work->nr_pages);\n\n\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t\tif (work) {\n\t\t\t*work = *base_work;\n\t\t\twork->nr_pages = nr_pages;\n\t\t\twork->auto_free = 1;\n\t\t\twb_queue_work(wb, work);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* alloc failed, execute synchronously using on-stack fallback */\n\t\twork = &fallback_work;\n\t\t*work = *base_work;\n\t\twork->nr_pages = nr_pages;\n\t\twork->auto_free = 0;\n\t\twork->done = &fallback_work_done;\n\n\t\twb_queue_work(wb, work);\n\n\t\t/*\n\t\t * Pin @wb so that it stays on @bdi->wb_list.  This allows\n\t\t * continuing iteration from @wb after dropping and\n\t\t * regrabbing rcu read lock.\n\t\t */\n\t\twb_get(wb);\n\t\tlast_wb = wb;\n\n\t\trcu_read_unlock();\n\t\twb_wait_for_completion(bdi, &fallback_work_done);\n\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\n\tif (last_wb)\n\t\twb_put(last_wb);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "last_wb"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_wait_for_completion",
          "args": [
            "bdi",
            "&fallback_work_done"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "wb_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "217-222",
          "snippet": "static void wb_wait_for_completion(struct backing_dev_info *bdi,\n\t\t\t\t   struct wb_completion *done)\n{\n\tatomic_dec(&done->cnt);\t\t/* put down the initial count */\n\twait_event(bdi->wb_waitq, !atomic_read(&done->cnt));\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wait_for_completion(struct backing_dev_info *bdi,\n\t\t\t\t   struct wb_completion *done)\n{\n\tatomic_dec(&done->cnt);\t\t/* put down the initial count */\n\twait_event(bdi->wb_waitq, !atomic_read(&done->cnt));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_get",
          "args": [
            "wb"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_queue_work",
          "args": [
            "wb",
            "work"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "wb_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "187-204",
          "snippet": "static void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*work)",
            "GFP_ATOMIC"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_split_bdi_pages",
          "args": [
            "wb",
            "base_work->nr_pages"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "wb_split_bdi_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "911-914",
          "snippet": "static long wb_split_bdi_pages(struct bdi_writeback *wb, long nr_pages)\n{\n\treturn nr_pages;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_split_bdi_pages(struct bdi_writeback *wb, long nr_pages)\n{\n\treturn nr_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "writeback_in_progress",
          "args": [
            "wb"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_dirty_time"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_has_dirty_io",
          "args": [
            "wb"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "last_wb"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WB_COMPLETION_ONSTACK",
          "args": [
            "fallback_work_done"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue_rcu",
          "args": [
            "wb",
            "&bdi->wb_list",
            "bdi_node"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "&bdi->wb_list",
            "structbdi_writeback",
            "bdi_node"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_split_work_to_wbs(struct backing_dev_info *bdi,\n\t\t\t\t  struct wb_writeback_work *base_work,\n\t\t\t\t  bool skip_if_busy)\n{\n\tstruct bdi_writeback *last_wb = NULL;\n\tstruct bdi_writeback *wb = list_entry(&bdi->wb_list,\n\t\t\t\t\t      struct bdi_writeback, bdi_node);\n\n\tmight_sleep();\nrestart:\n\trcu_read_lock();\n\tlist_for_each_entry_continue_rcu(wb, &bdi->wb_list, bdi_node) {\n\t\tDEFINE_WB_COMPLETION_ONSTACK(fallback_work_done);\n\t\tstruct wb_writeback_work fallback_work;\n\t\tstruct wb_writeback_work *work;\n\t\tlong nr_pages;\n\n\t\tif (last_wb) {\n\t\t\twb_put(last_wb);\n\t\t\tlast_wb = NULL;\n\t\t}\n\n\t\t/* SYNC_ALL writes out I_DIRTY_TIME too */\n\t\tif (!wb_has_dirty_io(wb) &&\n\t\t    (base_work->sync_mode == WB_SYNC_NONE ||\n\t\t     list_empty(&wb->b_dirty_time)))\n\t\t\tcontinue;\n\t\tif (skip_if_busy && writeback_in_progress(wb))\n\t\t\tcontinue;\n\n\t\tnr_pages = wb_split_bdi_pages(wb, base_work->nr_pages);\n\n\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t\tif (work) {\n\t\t\t*work = *base_work;\n\t\t\twork->nr_pages = nr_pages;\n\t\t\twork->auto_free = 1;\n\t\t\twb_queue_work(wb, work);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* alloc failed, execute synchronously using on-stack fallback */\n\t\twork = &fallback_work;\n\t\t*work = *base_work;\n\t\twork->nr_pages = nr_pages;\n\t\twork->auto_free = 0;\n\t\twork->done = &fallback_work_done;\n\n\t\twb_queue_work(wb, work);\n\n\t\t/*\n\t\t * Pin @wb so that it stays on @bdi->wb_list.  This allows\n\t\t * continuing iteration from @wb after dropping and\n\t\t * regrabbing rcu read lock.\n\t\t */\n\t\twb_get(wb);\n\t\tlast_wb = wb;\n\n\t\trcu_read_unlock();\n\t\twb_wait_for_completion(bdi, &fallback_work_done);\n\t\tgoto restart;\n\t}\n\trcu_read_unlock();\n\n\tif (last_wb)\n\t\twb_put(last_wb);\n}"
  },
  {
    "function_name": "wb_split_bdi_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "763-780",
    "snippet": "static long wb_split_bdi_pages(struct bdi_writeback *wb, long nr_pages)\n{\n\tunsigned long this_bw = wb->avg_write_bandwidth;\n\tunsigned long tot_bw = atomic_long_read(&wb->bdi->tot_write_bandwidth);\n\n\tif (nr_pages == LONG_MAX)\n\t\treturn LONG_MAX;\n\n\t/*\n\t * This may be called on clean wb's and proportional distribution\n\t * may not make sense, just use the original @nr_pages in those\n\t * cases.  In general, we wanna err on the side of writing more.\n\t */\n\tif (!tot_bw || this_bw >= tot_bw)\n\t\treturn nr_pages;\n\telse\n\t\treturn DIV_ROUND_UP_ULL((u64)nr_pages * this_bw, tot_bw);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP_ULL",
          "args": [
            "(u64)nr_pages * this_bw",
            "tot_bw"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&wb->bdi->tot_write_bandwidth"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic long wb_split_bdi_pages(struct bdi_writeback *wb, long nr_pages)\n{\n\tunsigned long this_bw = wb->avg_write_bandwidth;\n\tunsigned long tot_bw = atomic_long_read(&wb->bdi->tot_write_bandwidth);\n\n\tif (nr_pages == LONG_MAX)\n\t\treturn LONG_MAX;\n\n\t/*\n\t * This may be called on clean wb's and proportional distribution\n\t * may not make sense, just use the original @nr_pages in those\n\t * cases.  In general, we wanna err on the side of writing more.\n\t */\n\tif (!tot_bw || this_bw >= tot_bw)\n\t\treturn nr_pages;\n\telse\n\t\treturn DIV_ROUND_UP_ULL((u64)nr_pages * this_bw, tot_bw);\n}"
  },
  {
    "function_name": "inode_congested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "733-751",
    "snippet": "int inode_congested(struct inode *inode, int cong_bits)\n{\n\t/*\n\t * Once set, ->i_wb never becomes NULL while the inode is alive.\n\t * Start transaction iff ->i_wb is visible.\n\t */\n\tif (inode && inode_to_wb_is_valid(inode)) {\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie lock_cookie = {};\n\t\tbool congested;\n\n\t\twb = unlocked_inode_to_wb_begin(inode, &lock_cookie);\n\t\tcongested = wb_congested(wb, cong_bits);\n\t\tunlocked_inode_to_wb_end(inode, &lock_cookie);\n\t\treturn congested;\n\t}\n\n\treturn wb_congested(&inode_to_bdi(inode)->wb, cong_bits);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_congested",
          "args": [
            "&inode_to_bdi(inode)->wb",
            "cong_bits"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlocked_inode_to_wb_end",
          "args": [
            "inode",
            "&lock_cookie"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_congested",
          "args": [
            "wb",
            "cong_bits"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlocked_inode_to_wb_begin",
          "args": [
            "inode",
            "&lock_cookie"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_wb_is_valid",
          "args": [
            "inode"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint inode_congested(struct inode *inode, int cong_bits)\n{\n\t/*\n\t * Once set, ->i_wb never becomes NULL while the inode is alive.\n\t * Start transaction iff ->i_wb is visible.\n\t */\n\tif (inode && inode_to_wb_is_valid(inode)) {\n\t\tstruct bdi_writeback *wb;\n\t\tstruct wb_lock_cookie lock_cookie = {};\n\t\tbool congested;\n\n\t\twb = unlocked_inode_to_wb_begin(inode, &lock_cookie);\n\t\tcongested = wb_congested(wb, cong_bits);\n\t\tunlocked_inode_to_wb_end(inode, &lock_cookie);\n\t\treturn congested;\n\t}\n\n\treturn wb_congested(&inode_to_bdi(inode)->wb, cong_bits);\n}"
  },
  {
    "function_name": "wbc_account_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "683-714",
    "snippet": "void wbc_account_io(struct writeback_control *wbc, struct page *page,\n\t\t    size_t bytes)\n{\n\tint id;\n\n\t/*\n\t * pageout() path doesn't attach @wbc to the inode being written\n\t * out.  This is intentional as we don't want the function to block\n\t * behind a slow cgroup.  Ultimately, we want pageout() to kick off\n\t * regular writeback instead of writing things out itself.\n\t */\n\tif (!wbc->wb)\n\t\treturn;\n\n\tid = mem_cgroup_css_from_page(page)->id;\n\n\tif (id == wbc->wb_id) {\n\t\twbc->wb_bytes += bytes;\n\t\treturn;\n\t}\n\n\tif (id == wbc->wb_lcand_id)\n\t\twbc->wb_lcand_bytes += bytes;\n\n\t/* Boyer-Moore majority vote algorithm */\n\tif (!wbc->wb_tcand_bytes)\n\t\twbc->wb_tcand_id = id;\n\tif (id == wbc->wb_tcand_id)\n\t\twbc->wb_tcand_bytes += bytes;\n\telse\n\t\twbc->wb_tcand_bytes -= min(bytes, wbc->wb_tcand_bytes);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "wbc->wb_tcand_bytes"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_css_from_page",
          "args": [
            "page"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wbc_account_io(struct writeback_control *wbc, struct page *page,\n\t\t    size_t bytes)\n{\n\tint id;\n\n\t/*\n\t * pageout() path doesn't attach @wbc to the inode being written\n\t * out.  This is intentional as we don't want the function to block\n\t * behind a slow cgroup.  Ultimately, we want pageout() to kick off\n\t * regular writeback instead of writing things out itself.\n\t */\n\tif (!wbc->wb)\n\t\treturn;\n\n\tid = mem_cgroup_css_from_page(page)->id;\n\n\tif (id == wbc->wb_id) {\n\t\twbc->wb_bytes += bytes;\n\t\treturn;\n\t}\n\n\tif (id == wbc->wb_lcand_id)\n\t\twbc->wb_lcand_bytes += bytes;\n\n\t/* Boyer-Moore majority vote algorithm */\n\tif (!wbc->wb_tcand_bytes)\n\t\twbc->wb_tcand_id = id;\n\tif (id == wbc->wb_tcand_id)\n\t\twbc->wb_tcand_bytes += bytes;\n\telse\n\t\twbc->wb_tcand_bytes -= min(bytes, wbc->wb_tcand_bytes);\n}"
  },
  {
    "function_name": "wbc_detach_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "591-671",
    "snippet": "void wbc_detach_inode(struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb = wbc->wb;\n\tstruct inode *inode = wbc->inode;\n\tunsigned long avg_time, max_bytes, max_time;\n\tu16 history;\n\tint max_id;\n\n\tif (!wb)\n\t\treturn;\n\n\thistory = inode->i_wb_frn_history;\n\tavg_time = inode->i_wb_frn_avg_time;\n\n\t/* pick the winner of this round */\n\tif (wbc->wb_bytes >= wbc->wb_lcand_bytes &&\n\t    wbc->wb_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_id;\n\t\tmax_bytes = wbc->wb_bytes;\n\t} else if (wbc->wb_lcand_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_lcand_id;\n\t\tmax_bytes = wbc->wb_lcand_bytes;\n\t} else {\n\t\tmax_id = wbc->wb_tcand_id;\n\t\tmax_bytes = wbc->wb_tcand_bytes;\n\t}\n\n\t/*\n\t * Calculate the amount of IO time the winner consumed and fold it\n\t * into the running average kept per inode.  If the consumed IO\n\t * time is lower than avag / WB_FRN_TIME_CUT_DIV, ignore it for\n\t * deciding whether to switch or not.  This is to prevent one-off\n\t * small dirtiers from skewing the verdict.\n\t */\n\tmax_time = DIV_ROUND_UP((max_bytes >> PAGE_SHIFT) << WB_FRN_TIME_SHIFT,\n\t\t\t\twb->avg_write_bandwidth);\n\tif (avg_time)\n\t\tavg_time += (max_time >> WB_FRN_TIME_AVG_SHIFT) -\n\t\t\t    (avg_time >> WB_FRN_TIME_AVG_SHIFT);\n\telse\n\t\tavg_time = max_time;\t/* immediate catch up on first run */\n\n\tif (max_time >= avg_time / WB_FRN_TIME_CUT_DIV) {\n\t\tint slots;\n\n\t\t/*\n\t\t * The switch verdict is reached if foreign wb's consume\n\t\t * more than a certain proportion of IO time in a\n\t\t * WB_FRN_TIME_PERIOD.  This is loosely tracked by 16 slot\n\t\t * history mask where each bit represents one sixteenth of\n\t\t * the period.  Determine the number of slots to shift into\n\t\t * history from @max_time.\n\t\t */\n\t\tslots = min(DIV_ROUND_UP(max_time, WB_FRN_HIST_UNIT),\n\t\t\t    (unsigned long)WB_FRN_HIST_MAX_SLOTS);\n\t\thistory <<= slots;\n\t\tif (wbc->wb_id != max_id)\n\t\t\thistory |= (1U << slots) - 1;\n\n\t\t/*\n\t\t * Switch if the current wb isn't the consistent winner.\n\t\t * If there are multiple closely competing dirtiers, the\n\t\t * inode may switch across them repeatedly over time, which\n\t\t * is okay.  The main goal is avoiding keeping an inode on\n\t\t * the wrong wb for an extended period of time.\n\t\t */\n\t\tif (hweight32(history) > WB_FRN_HIST_THR_SLOTS)\n\t\t\tinode_switch_wbs(inode, max_id);\n\t}\n\n\t/*\n\t * Multiple instances of this function may race to update the\n\t * following fields but we don't mind occassional inaccuracies.\n\t */\n\tinode->i_wb_frn_winner = max_id;\n\tinode->i_wb_frn_avg_time = min(avg_time, (unsigned long)U16_MAX);\n\tinode->i_wb_frn_history = history;\n\n\twb_put(wbc->wb);\n\twbc->wb = NULL;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define WB_FRN_HIST_MAX_SLOTS\t(WB_FRN_HIST_THR_SLOTS / 2 + 1)",
      "#define WB_FRN_HIST_THR_SLOTS\t(WB_FRN_HIST_SLOTS / 2)",
      "#define WB_FRN_HIST_UNIT\t(WB_FRN_TIME_PERIOD / WB_FRN_HIST_SLOTS)",
      "#define WB_FRN_TIME_PERIOD\t(2 * (1 << WB_FRN_TIME_SHIFT))\t/* 2s */",
      "#define WB_FRN_TIME_CUT_DIV\t2\t/* ignore rounds < avg / 2 */",
      "#define WB_FRN_TIME_AVG_SHIFT\t3\t/* avg = avg * 7/8 + new * 1/8 */",
      "#define WB_FRN_TIME_SHIFT\t13\t/* 1s = 2^13, upto 8 secs w/ 16bit */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "wbc->wb"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "avg_time",
            "(unsigned long)U16_MAX"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_switch_wbs",
          "args": [
            "inode",
            "max_id"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "inode_switch_wbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "461-513",
          "snippet": "static void inode_switch_wbs(struct inode *inode, int new_wb_id)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct cgroup_subsys_state *memcg_css;\n\tstruct inode_switch_wbs_context *isw;\n\n\t/* noop if seems to be already in progress */\n\tif (inode->i_state & I_WB_SWITCH)\n\t\treturn;\n\n\tisw = kzalloc(sizeof(*isw), GFP_ATOMIC);\n\tif (!isw)\n\t\treturn;\n\n\t/* find and pin the new wb */\n\trcu_read_lock();\n\tmemcg_css = css_from_id(new_wb_id, &memory_cgrp_subsys);\n\tif (memcg_css)\n\t\tisw->new_wb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\trcu_read_unlock();\n\tif (!isw->new_wb)\n\t\tgoto out_free;\n\n\t/* while holding I_WB_SWITCH, no one else can update the association */\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_sb->s_flags & SB_ACTIVE) ||\n\t    inode->i_state & (I_WB_SWITCH | I_FREEING) ||\n\t    inode_to_wb(inode) == isw->new_wb) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out_free;\n\t}\n\tinode->i_state |= I_WB_SWITCH;\n\t__iget(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tisw->inode = inode;\n\n\tatomic_inc(&isw_nr_in_flight);\n\n\t/*\n\t * In addition to synchronizing among switchers, I_WB_SWITCH tells\n\t * the RCU protected stat update paths to grab the i_page\n\t * lock so that stat transfer can synchronize against them.\n\t * Let's continue after I_WB_SWITCH is guaranteed to be visible.\n\t */\n\tcall_rcu(&isw->rcu_head, inode_switch_wbs_rcu_fn);\n\treturn;\n\nout_free:\n\tif (isw->new_wb)\n\t\twb_put(isw->new_wb);\n\tkfree(isw);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_switch_wbs(struct inode *inode, int new_wb_id)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct cgroup_subsys_state *memcg_css;\n\tstruct inode_switch_wbs_context *isw;\n\n\t/* noop if seems to be already in progress */\n\tif (inode->i_state & I_WB_SWITCH)\n\t\treturn;\n\n\tisw = kzalloc(sizeof(*isw), GFP_ATOMIC);\n\tif (!isw)\n\t\treturn;\n\n\t/* find and pin the new wb */\n\trcu_read_lock();\n\tmemcg_css = css_from_id(new_wb_id, &memory_cgrp_subsys);\n\tif (memcg_css)\n\t\tisw->new_wb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\trcu_read_unlock();\n\tif (!isw->new_wb)\n\t\tgoto out_free;\n\n\t/* while holding I_WB_SWITCH, no one else can update the association */\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_sb->s_flags & SB_ACTIVE) ||\n\t    inode->i_state & (I_WB_SWITCH | I_FREEING) ||\n\t    inode_to_wb(inode) == isw->new_wb) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out_free;\n\t}\n\tinode->i_state |= I_WB_SWITCH;\n\t__iget(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tisw->inode = inode;\n\n\tatomic_inc(&isw_nr_in_flight);\n\n\t/*\n\t * In addition to synchronizing among switchers, I_WB_SWITCH tells\n\t * the RCU protected stat update paths to grab the i_page\n\t * lock so that stat transfer can synchronize against them.\n\t * Let's continue after I_WB_SWITCH is guaranteed to be visible.\n\t */\n\tcall_rcu(&isw->rcu_head, inode_switch_wbs_rcu_fn);\n\treturn;\n\nout_free:\n\tif (isw->new_wb)\n\t\twb_put(isw->new_wb);\n\tkfree(isw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "history"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "max_time",
            "WB_FRN_HIST_UNIT"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "(max_bytes >> PAGE_SHIFT) << WB_FRN_TIME_SHIFT",
            "wb->avg_write_bandwidth"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define WB_FRN_HIST_MAX_SLOTS\t(WB_FRN_HIST_THR_SLOTS / 2 + 1)\n#define WB_FRN_HIST_THR_SLOTS\t(WB_FRN_HIST_SLOTS / 2)\n#define WB_FRN_HIST_UNIT\t(WB_FRN_TIME_PERIOD / WB_FRN_HIST_SLOTS)\n#define WB_FRN_TIME_PERIOD\t(2 * (1 << WB_FRN_TIME_SHIFT))\t/* 2s */\n#define WB_FRN_TIME_CUT_DIV\t2\t/* ignore rounds < avg / 2 */\n#define WB_FRN_TIME_AVG_SHIFT\t3\t/* avg = avg * 7/8 + new * 1/8 */\n#define WB_FRN_TIME_SHIFT\t13\t/* 1s = 2^13, upto 8 secs w/ 16bit */\n\nvoid wbc_detach_inode(struct writeback_control *wbc)\n{\n\tstruct bdi_writeback *wb = wbc->wb;\n\tstruct inode *inode = wbc->inode;\n\tunsigned long avg_time, max_bytes, max_time;\n\tu16 history;\n\tint max_id;\n\n\tif (!wb)\n\t\treturn;\n\n\thistory = inode->i_wb_frn_history;\n\tavg_time = inode->i_wb_frn_avg_time;\n\n\t/* pick the winner of this round */\n\tif (wbc->wb_bytes >= wbc->wb_lcand_bytes &&\n\t    wbc->wb_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_id;\n\t\tmax_bytes = wbc->wb_bytes;\n\t} else if (wbc->wb_lcand_bytes >= wbc->wb_tcand_bytes) {\n\t\tmax_id = wbc->wb_lcand_id;\n\t\tmax_bytes = wbc->wb_lcand_bytes;\n\t} else {\n\t\tmax_id = wbc->wb_tcand_id;\n\t\tmax_bytes = wbc->wb_tcand_bytes;\n\t}\n\n\t/*\n\t * Calculate the amount of IO time the winner consumed and fold it\n\t * into the running average kept per inode.  If the consumed IO\n\t * time is lower than avag / WB_FRN_TIME_CUT_DIV, ignore it for\n\t * deciding whether to switch or not.  This is to prevent one-off\n\t * small dirtiers from skewing the verdict.\n\t */\n\tmax_time = DIV_ROUND_UP((max_bytes >> PAGE_SHIFT) << WB_FRN_TIME_SHIFT,\n\t\t\t\twb->avg_write_bandwidth);\n\tif (avg_time)\n\t\tavg_time += (max_time >> WB_FRN_TIME_AVG_SHIFT) -\n\t\t\t    (avg_time >> WB_FRN_TIME_AVG_SHIFT);\n\telse\n\t\tavg_time = max_time;\t/* immediate catch up on first run */\n\n\tif (max_time >= avg_time / WB_FRN_TIME_CUT_DIV) {\n\t\tint slots;\n\n\t\t/*\n\t\t * The switch verdict is reached if foreign wb's consume\n\t\t * more than a certain proportion of IO time in a\n\t\t * WB_FRN_TIME_PERIOD.  This is loosely tracked by 16 slot\n\t\t * history mask where each bit represents one sixteenth of\n\t\t * the period.  Determine the number of slots to shift into\n\t\t * history from @max_time.\n\t\t */\n\t\tslots = min(DIV_ROUND_UP(max_time, WB_FRN_HIST_UNIT),\n\t\t\t    (unsigned long)WB_FRN_HIST_MAX_SLOTS);\n\t\thistory <<= slots;\n\t\tif (wbc->wb_id != max_id)\n\t\t\thistory |= (1U << slots) - 1;\n\n\t\t/*\n\t\t * Switch if the current wb isn't the consistent winner.\n\t\t * If there are multiple closely competing dirtiers, the\n\t\t * inode may switch across them repeatedly over time, which\n\t\t * is okay.  The main goal is avoiding keeping an inode on\n\t\t * the wrong wb for an extended period of time.\n\t\t */\n\t\tif (hweight32(history) > WB_FRN_HIST_THR_SLOTS)\n\t\t\tinode_switch_wbs(inode, max_id);\n\t}\n\n\t/*\n\t * Multiple instances of this function may race to update the\n\t * following fields but we don't mind occassional inaccuracies.\n\t */\n\tinode->i_wb_frn_winner = max_id;\n\tinode->i_wb_frn_avg_time = min(avg_time, (unsigned long)U16_MAX);\n\tinode->i_wb_frn_history = history;\n\n\twb_put(wbc->wb);\n\twbc->wb = NULL;\n}"
  },
  {
    "function_name": "wbc_attach_and_unlock_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "525-552",
    "snippet": "void wbc_attach_and_unlock_inode(struct writeback_control *wbc,\n\t\t\t\t struct inode *inode)\n{\n\tif (!inode_cgwb_enabled(inode)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\twbc->wb = inode_to_wb(inode);\n\twbc->inode = inode;\n\n\twbc->wb_id = wbc->wb->memcg_css->id;\n\twbc->wb_lcand_id = inode->i_wb_frn_winner;\n\twbc->wb_tcand_id = 0;\n\twbc->wb_bytes = 0;\n\twbc->wb_lcand_bytes = 0;\n\twbc->wb_tcand_bytes = 0;\n\n\twb_get(wbc->wb);\n\tspin_unlock(&inode->i_lock);\n\n\t/*\n\t * A dying wb indicates that the memcg-blkcg mapping has changed\n\t * and a new wb is already serving the memcg.  Switch immediately.\n\t */\n\tif (unlikely(wb_dying(wbc->wb)))\n\t\tinode_switch_wbs(inode, wbc->wb_id);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_switch_wbs",
          "args": [
            "inode",
            "wbc->wb_id"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "inode_switch_wbs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "461-513",
          "snippet": "static void inode_switch_wbs(struct inode *inode, int new_wb_id)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct cgroup_subsys_state *memcg_css;\n\tstruct inode_switch_wbs_context *isw;\n\n\t/* noop if seems to be already in progress */\n\tif (inode->i_state & I_WB_SWITCH)\n\t\treturn;\n\n\tisw = kzalloc(sizeof(*isw), GFP_ATOMIC);\n\tif (!isw)\n\t\treturn;\n\n\t/* find and pin the new wb */\n\trcu_read_lock();\n\tmemcg_css = css_from_id(new_wb_id, &memory_cgrp_subsys);\n\tif (memcg_css)\n\t\tisw->new_wb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\trcu_read_unlock();\n\tif (!isw->new_wb)\n\t\tgoto out_free;\n\n\t/* while holding I_WB_SWITCH, no one else can update the association */\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_sb->s_flags & SB_ACTIVE) ||\n\t    inode->i_state & (I_WB_SWITCH | I_FREEING) ||\n\t    inode_to_wb(inode) == isw->new_wb) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out_free;\n\t}\n\tinode->i_state |= I_WB_SWITCH;\n\t__iget(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tisw->inode = inode;\n\n\tatomic_inc(&isw_nr_in_flight);\n\n\t/*\n\t * In addition to synchronizing among switchers, I_WB_SWITCH tells\n\t * the RCU protected stat update paths to grab the i_page\n\t * lock so that stat transfer can synchronize against them.\n\t * Let's continue after I_WB_SWITCH is guaranteed to be visible.\n\t */\n\tcall_rcu(&isw->rcu_head, inode_switch_wbs_rcu_fn);\n\treturn;\n\nout_free:\n\tif (isw->new_wb)\n\t\twb_put(isw->new_wb);\n\tkfree(isw);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_switch_wbs(struct inode *inode, int new_wb_id)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct cgroup_subsys_state *memcg_css;\n\tstruct inode_switch_wbs_context *isw;\n\n\t/* noop if seems to be already in progress */\n\tif (inode->i_state & I_WB_SWITCH)\n\t\treturn;\n\n\tisw = kzalloc(sizeof(*isw), GFP_ATOMIC);\n\tif (!isw)\n\t\treturn;\n\n\t/* find and pin the new wb */\n\trcu_read_lock();\n\tmemcg_css = css_from_id(new_wb_id, &memory_cgrp_subsys);\n\tif (memcg_css)\n\t\tisw->new_wb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\trcu_read_unlock();\n\tif (!isw->new_wb)\n\t\tgoto out_free;\n\n\t/* while holding I_WB_SWITCH, no one else can update the association */\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_sb->s_flags & SB_ACTIVE) ||\n\t    inode->i_state & (I_WB_SWITCH | I_FREEING) ||\n\t    inode_to_wb(inode) == isw->new_wb) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out_free;\n\t}\n\tinode->i_state |= I_WB_SWITCH;\n\t__iget(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tisw->inode = inode;\n\n\tatomic_inc(&isw_nr_in_flight);\n\n\t/*\n\t * In addition to synchronizing among switchers, I_WB_SWITCH tells\n\t * the RCU protected stat update paths to grab the i_page\n\t * lock so that stat transfer can synchronize against them.\n\t * Let's continue after I_WB_SWITCH is guaranteed to be visible.\n\t */\n\tcall_rcu(&isw->rcu_head, inode_switch_wbs_rcu_fn);\n\treturn;\n\nout_free:\n\tif (isw->new_wb)\n\t\twb_put(isw->new_wb);\n\tkfree(isw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "wb_dying(wbc->wb)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_dying",
          "args": [
            "wbc->wb"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_get",
          "args": [
            "wbc->wb"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "inode"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "902-909",
          "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_cgwb_enabled",
          "args": [
            "inode"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid wbc_attach_and_unlock_inode(struct writeback_control *wbc,\n\t\t\t\t struct inode *inode)\n{\n\tif (!inode_cgwb_enabled(inode)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\twbc->wb = inode_to_wb(inode);\n\twbc->inode = inode;\n\n\twbc->wb_id = wbc->wb->memcg_css->id;\n\twbc->wb_lcand_id = inode->i_wb_frn_winner;\n\twbc->wb_tcand_id = 0;\n\twbc->wb_bytes = 0;\n\twbc->wb_lcand_bytes = 0;\n\twbc->wb_tcand_bytes = 0;\n\n\twb_get(wbc->wb);\n\tspin_unlock(&inode->i_lock);\n\n\t/*\n\t * A dying wb indicates that the memcg-blkcg mapping has changed\n\t * and a new wb is already serving the memcg.  Switch immediately.\n\t */\n\tif (unlikely(wb_dying(wbc->wb)))\n\t\tinode_switch_wbs(inode, wbc->wb_id);\n}"
  },
  {
    "function_name": "inode_switch_wbs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "461-513",
    "snippet": "static void inode_switch_wbs(struct inode *inode, int new_wb_id)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct cgroup_subsys_state *memcg_css;\n\tstruct inode_switch_wbs_context *isw;\n\n\t/* noop if seems to be already in progress */\n\tif (inode->i_state & I_WB_SWITCH)\n\t\treturn;\n\n\tisw = kzalloc(sizeof(*isw), GFP_ATOMIC);\n\tif (!isw)\n\t\treturn;\n\n\t/* find and pin the new wb */\n\trcu_read_lock();\n\tmemcg_css = css_from_id(new_wb_id, &memory_cgrp_subsys);\n\tif (memcg_css)\n\t\tisw->new_wb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\trcu_read_unlock();\n\tif (!isw->new_wb)\n\t\tgoto out_free;\n\n\t/* while holding I_WB_SWITCH, no one else can update the association */\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_sb->s_flags & SB_ACTIVE) ||\n\t    inode->i_state & (I_WB_SWITCH | I_FREEING) ||\n\t    inode_to_wb(inode) == isw->new_wb) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out_free;\n\t}\n\tinode->i_state |= I_WB_SWITCH;\n\t__iget(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tisw->inode = inode;\n\n\tatomic_inc(&isw_nr_in_flight);\n\n\t/*\n\t * In addition to synchronizing among switchers, I_WB_SWITCH tells\n\t * the RCU protected stat update paths to grab the i_page\n\t * lock so that stat transfer can synchronize against them.\n\t * Let's continue after I_WB_SWITCH is guaranteed to be visible.\n\t */\n\tcall_rcu(&isw->rcu_head, inode_switch_wbs_rcu_fn);\n\treturn;\n\nout_free:\n\tif (isw->new_wb)\n\t\twb_put(isw->new_wb);\n\tkfree(isw);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "isw"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "isw->new_wb"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&isw->rcu_head",
            "inode_switch_wbs_rcu_fn"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&isw_nr_in_flight"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "394-397",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "inode"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "902-909",
          "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_get_create",
          "args": [
            "bdi",
            "memcg_css",
            "GFP_ATOMIC"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_from_id",
          "args": [
            "new_wb_id",
            "&memory_cgrp_subsys"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*isw)",
            "GFP_ATOMIC"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_switch_wbs(struct inode *inode, int new_wb_id)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct cgroup_subsys_state *memcg_css;\n\tstruct inode_switch_wbs_context *isw;\n\n\t/* noop if seems to be already in progress */\n\tif (inode->i_state & I_WB_SWITCH)\n\t\treturn;\n\n\tisw = kzalloc(sizeof(*isw), GFP_ATOMIC);\n\tif (!isw)\n\t\treturn;\n\n\t/* find and pin the new wb */\n\trcu_read_lock();\n\tmemcg_css = css_from_id(new_wb_id, &memory_cgrp_subsys);\n\tif (memcg_css)\n\t\tisw->new_wb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\trcu_read_unlock();\n\tif (!isw->new_wb)\n\t\tgoto out_free;\n\n\t/* while holding I_WB_SWITCH, no one else can update the association */\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_sb->s_flags & SB_ACTIVE) ||\n\t    inode->i_state & (I_WB_SWITCH | I_FREEING) ||\n\t    inode_to_wb(inode) == isw->new_wb) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tgoto out_free;\n\t}\n\tinode->i_state |= I_WB_SWITCH;\n\t__iget(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tisw->inode = inode;\n\n\tatomic_inc(&isw_nr_in_flight);\n\n\t/*\n\t * In addition to synchronizing among switchers, I_WB_SWITCH tells\n\t * the RCU protected stat update paths to grab the i_page\n\t * lock so that stat transfer can synchronize against them.\n\t * Let's continue after I_WB_SWITCH is guaranteed to be visible.\n\t */\n\tcall_rcu(&isw->rcu_head, inode_switch_wbs_rcu_fn);\n\treturn;\n\nout_free:\n\tif (isw->new_wb)\n\t\twb_put(isw->new_wb);\n\tkfree(isw);\n}"
  },
  {
    "function_name": "inode_switch_wbs_rcu_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "443-451",
    "snippet": "static void inode_switch_wbs_rcu_fn(struct rcu_head *rcu_head)\n{\n\tstruct inode_switch_wbs_context *isw = container_of(rcu_head,\n\t\t\t\tstruct inode_switch_wbs_context, rcu_head);\n\n\t/* needs to grab bh-unsafe locks, bounce to work item */\n\tINIT_WORK(&isw->work, inode_switch_wbs_work_fn);\n\tqueue_work(isw_wq, &isw->work);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "isw_wq",
            "&isw->work"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "wb_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "187-204",
          "snippet": "static void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&isw->work",
            "inode_switch_wbs_work_fn"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu_head",
            "structinode_switch_wbs_context",
            "rcu_head"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_switch_wbs_rcu_fn(struct rcu_head *rcu_head)\n{\n\tstruct inode_switch_wbs_context *isw = container_of(rcu_head,\n\t\t\t\tstruct inode_switch_wbs_context, rcu_head);\n\n\t/* needs to grab bh-unsafe locks, bounce to work item */\n\tINIT_WORK(&isw->work, inode_switch_wbs_work_fn);\n\tqueue_work(isw_wq, &isw->work);\n}"
  },
  {
    "function_name": "inode_switch_wbs_work_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "334-441",
    "snippet": "static void inode_switch_wbs_work_fn(struct work_struct *work)\n{\n\tstruct inode_switch_wbs_context *isw =\n\t\tcontainer_of(work, struct inode_switch_wbs_context, work);\n\tstruct inode *inode = isw->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct bdi_writeback *old_wb = inode->i_wb;\n\tstruct bdi_writeback *new_wb = isw->new_wb;\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tstruct page *page;\n\tbool switched = false;\n\n\t/*\n\t * By the time control reaches here, RCU grace period has passed\n\t * since I_WB_SWITCH assertion and all wb stat update transactions\n\t * between unlocked_inode_to_wb_begin/end() are guaranteed to be\n\t * synchronizing against the i_pages lock.\n\t *\n\t * Grabbing old_wb->list_lock, inode->i_lock and the i_pages lock\n\t * gives us exclusion against all wb related operations on @inode\n\t * including IO list manipulations and stat updates.\n\t */\n\tif (old_wb < new_wb) {\n\t\tspin_lock(&old_wb->list_lock);\n\t\tspin_lock_nested(&new_wb->list_lock, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tspin_lock(&new_wb->list_lock);\n\t\tspin_lock_nested(&old_wb->list_lock, SINGLE_DEPTH_NESTING);\n\t}\n\tspin_lock(&inode->i_lock);\n\txa_lock_irq(&mapping->i_pages);\n\n\t/*\n\t * Once I_FREEING is visible under i_lock, the eviction path owns\n\t * the inode and we shouldn't modify ->i_io_list.\n\t */\n\tif (unlikely(inode->i_state & I_FREEING))\n\t\tgoto skip_switch;\n\n\t/*\n\t * Count and transfer stats.  Note that PAGECACHE_TAG_DIRTY points\n\t * to possibly dirty pages while PAGECACHE_TAG_WRITEBACK points to\n\t * pages actually under writeback.\n\t */\n\txas_for_each_marked(&xas, page, ULONG_MAX, PAGECACHE_TAG_DIRTY) {\n\t\tif (PageDirty(page)) {\n\t\t\tdec_wb_stat(old_wb, WB_RECLAIMABLE);\n\t\t\tinc_wb_stat(new_wb, WB_RECLAIMABLE);\n\t\t}\n\t}\n\n\txas_set(&xas, 0);\n\txas_for_each_marked(&xas, page, ULONG_MAX, PAGECACHE_TAG_WRITEBACK) {\n\t\tWARN_ON_ONCE(!PageWriteback(page));\n\t\tdec_wb_stat(old_wb, WB_WRITEBACK);\n\t\tinc_wb_stat(new_wb, WB_WRITEBACK);\n\t}\n\n\twb_get(new_wb);\n\n\t/*\n\t * Transfer to @new_wb's IO list if necessary.  The specific list\n\t * @inode was on is ignored and the inode is put on ->b_dirty which\n\t * is always correct including from ->b_dirty_time.  The transfer\n\t * preserves @inode->dirtied_when ordering.\n\t */\n\tif (!list_empty(&inode->i_io_list)) {\n\t\tstruct inode *pos;\n\n\t\tinode_io_list_del_locked(inode, old_wb);\n\t\tinode->i_wb = new_wb;\n\t\tlist_for_each_entry(pos, &new_wb->b_dirty, i_io_list)\n\t\t\tif (time_after_eq(inode->dirtied_when,\n\t\t\t\t\t  pos->dirtied_when))\n\t\t\t\tbreak;\n\t\tinode_io_list_move_locked(inode, new_wb, pos->i_io_list.prev);\n\t} else {\n\t\tinode->i_wb = new_wb;\n\t}\n\n\t/* ->i_wb_frn updates may race wbc_detach_inode() but doesn't matter */\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n\tswitched = true;\nskip_switch:\n\t/*\n\t * Paired with load_acquire in unlocked_inode_to_wb_begin() and\n\t * ensures that the new wb is visible if they see !I_WB_SWITCH.\n\t */\n\tsmp_store_release(&inode->i_state, inode->i_state & ~I_WB_SWITCH);\n\n\txa_unlock_irq(&mapping->i_pages);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&new_wb->list_lock);\n\tspin_unlock(&old_wb->list_lock);\n\n\tif (switched) {\n\t\twb_wakeup(new_wb);\n\t\twb_put(old_wb);\n\t}\n\twb_put(new_wb);\n\n\tiput(inode);\n\tkfree(isw);\n\n\tatomic_dec(&isw_nr_in_flight);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&isw_nr_in_flight"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "isw"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "new_wb"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "old_wb"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_wakeup",
          "args": [
            "new_wb"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "wb_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "168-174",
          "snippet": "static void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&old_wb->list_lock"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xa_unlock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&inode->i_state",
            "inode->i_state & ~I_WB_SWITCH"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_io_list_move_locked",
          "args": [
            "inode",
            "new_wb",
            "pos->i_io_list.prev"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_move_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "135-149",
          "snippet": "static bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "inode->dirtied_when",
            "pos->dirtied_when"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pos",
            "&new_wb->b_dirty",
            "i_io_list"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_io_list_del_locked",
          "args": [
            "inode",
            "old_wb"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_del_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "159-166",
          "snippet": "static void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_io_list"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_get",
          "args": [
            "new_wb"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_wb_stat",
          "args": [
            "new_wb",
            "WB_WRITEBACK"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_wb_stat",
          "args": [
            "old_wb",
            "WB_WRITEBACK"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!PageWriteback(page)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageWriteback",
          "args": [
            "page"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each_marked",
          "args": [
            "&xas",
            "page",
            "ULONG_MAX",
            "PAGECACHE_TAG_WRITEBACK"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_set",
          "args": [
            "&xas",
            "0"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_wb_stat",
          "args": [
            "new_wb",
            "WB_RECLAIMABLE"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_wb_stat",
          "args": [
            "old_wb",
            "WB_RECLAIMABLE"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xas_for_each_marked",
          "args": [
            "&xas",
            "page",
            "ULONG_MAX",
            "PAGECACHE_TAG_DIRTY"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_state & I_FREEING"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irq",
          "args": [
            "&mapping->i_pages"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&old_wb->list_lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&new_wb->list_lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XA_STATE",
          "args": [
            "xas",
            "&mapping->i_pages",
            "0"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structinode_switch_wbs_context",
            "work"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_switch_wbs_work_fn(struct work_struct *work)\n{\n\tstruct inode_switch_wbs_context *isw =\n\t\tcontainer_of(work, struct inode_switch_wbs_context, work);\n\tstruct inode *inode = isw->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct bdi_writeback *old_wb = inode->i_wb;\n\tstruct bdi_writeback *new_wb = isw->new_wb;\n\tXA_STATE(xas, &mapping->i_pages, 0);\n\tstruct page *page;\n\tbool switched = false;\n\n\t/*\n\t * By the time control reaches here, RCU grace period has passed\n\t * since I_WB_SWITCH assertion and all wb stat update transactions\n\t * between unlocked_inode_to_wb_begin/end() are guaranteed to be\n\t * synchronizing against the i_pages lock.\n\t *\n\t * Grabbing old_wb->list_lock, inode->i_lock and the i_pages lock\n\t * gives us exclusion against all wb related operations on @inode\n\t * including IO list manipulations and stat updates.\n\t */\n\tif (old_wb < new_wb) {\n\t\tspin_lock(&old_wb->list_lock);\n\t\tspin_lock_nested(&new_wb->list_lock, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tspin_lock(&new_wb->list_lock);\n\t\tspin_lock_nested(&old_wb->list_lock, SINGLE_DEPTH_NESTING);\n\t}\n\tspin_lock(&inode->i_lock);\n\txa_lock_irq(&mapping->i_pages);\n\n\t/*\n\t * Once I_FREEING is visible under i_lock, the eviction path owns\n\t * the inode and we shouldn't modify ->i_io_list.\n\t */\n\tif (unlikely(inode->i_state & I_FREEING))\n\t\tgoto skip_switch;\n\n\t/*\n\t * Count and transfer stats.  Note that PAGECACHE_TAG_DIRTY points\n\t * to possibly dirty pages while PAGECACHE_TAG_WRITEBACK points to\n\t * pages actually under writeback.\n\t */\n\txas_for_each_marked(&xas, page, ULONG_MAX, PAGECACHE_TAG_DIRTY) {\n\t\tif (PageDirty(page)) {\n\t\t\tdec_wb_stat(old_wb, WB_RECLAIMABLE);\n\t\t\tinc_wb_stat(new_wb, WB_RECLAIMABLE);\n\t\t}\n\t}\n\n\txas_set(&xas, 0);\n\txas_for_each_marked(&xas, page, ULONG_MAX, PAGECACHE_TAG_WRITEBACK) {\n\t\tWARN_ON_ONCE(!PageWriteback(page));\n\t\tdec_wb_stat(old_wb, WB_WRITEBACK);\n\t\tinc_wb_stat(new_wb, WB_WRITEBACK);\n\t}\n\n\twb_get(new_wb);\n\n\t/*\n\t * Transfer to @new_wb's IO list if necessary.  The specific list\n\t * @inode was on is ignored and the inode is put on ->b_dirty which\n\t * is always correct including from ->b_dirty_time.  The transfer\n\t * preserves @inode->dirtied_when ordering.\n\t */\n\tif (!list_empty(&inode->i_io_list)) {\n\t\tstruct inode *pos;\n\n\t\tinode_io_list_del_locked(inode, old_wb);\n\t\tinode->i_wb = new_wb;\n\t\tlist_for_each_entry(pos, &new_wb->b_dirty, i_io_list)\n\t\t\tif (time_after_eq(inode->dirtied_when,\n\t\t\t\t\t  pos->dirtied_when))\n\t\t\t\tbreak;\n\t\tinode_io_list_move_locked(inode, new_wb, pos->i_io_list.prev);\n\t} else {\n\t\tinode->i_wb = new_wb;\n\t}\n\n\t/* ->i_wb_frn updates may race wbc_detach_inode() but doesn't matter */\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n\tswitched = true;\nskip_switch:\n\t/*\n\t * Paired with load_acquire in unlocked_inode_to_wb_begin() and\n\t * ensures that the new wb is visible if they see !I_WB_SWITCH.\n\t */\n\tsmp_store_release(&inode->i_state, inode->i_state & ~I_WB_SWITCH);\n\n\txa_unlock_irq(&mapping->i_pages);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&new_wb->list_lock);\n\tspin_unlock(&old_wb->list_lock);\n\n\tif (switched) {\n\t\twb_wakeup(new_wb);\n\t\twb_put(old_wb);\n\t}\n\twb_put(new_wb);\n\n\tiput(inode);\n\tkfree(isw);\n\n\tatomic_dec(&isw_nr_in_flight);\n}"
  },
  {
    "function_name": "inode_to_wb_and_lock_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "319-324",
    "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tspin_lock(&inode->i_lock);\n\treturn locked_inode_to_wb_and_lock_list(inode);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "locked_inode_to_wb_and_lock_list",
          "args": [
            "inode"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "locked_inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "890-900",
          "snippet": "static struct bdi_writeback *\nlocked_inode_to_wb_and_lock_list(struct inode *inode)\n\t__releases(&inode->i_lock)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_unlock(&inode->i_lock);\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *\nlocked_inode_to_wb_and_lock_list(struct inode *inode)\n\t__releases(&inode->i_lock)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_unlock(&inode->i_lock);\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&wb->list_lock"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tspin_lock(&inode->i_lock);\n\treturn locked_inode_to_wb_and_lock_list(inode);\n}"
  },
  {
    "function_name": "locked_inode_to_wb_and_lock_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "281-310",
    "snippet": "static struct bdi_writeback *\nlocked_inode_to_wb_and_lock_list(struct inode *inode)\n\t__releases(&inode->i_lock)\n\t__acquires(&wb->list_lock)\n{\n\twhile (true) {\n\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t/*\n\t\t * inode_to_wb() association is protected by both\n\t\t * @inode->i_lock and @wb->list_lock but list_lock nests\n\t\t * outside i_lock.  Drop i_lock and verify that the\n\t\t * association hasn't changed after acquiring list_lock.\n\t\t */\n\t\twb_get(wb);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_lock(&wb->list_lock);\n\n\t\t/* i_wb may have changed inbetween, can't use inode_to_wb() */\n\t\tif (likely(wb == inode->i_wb)) {\n\t\t\twb_put(wb);\t/* @inode already has ref */\n\t\t\treturn wb;\n\t\t}\n\n\t\tspin_unlock(&wb->list_lock);\n\t\twb_put(wb);\n\t\tcpu_relax();\n\t\tspin_lock(&inode->i_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "wb"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&wb->list_lock"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "wb"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "wb == inode->i_wb"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_get",
          "args": [
            "wb"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_wb",
          "args": [
            "inode"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_wb_and_lock_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "902-909",
          "snippet": "static struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *inode_to_wb_and_lock_list(struct inode *inode)\n\t__acquires(&wb->list_lock)\n{\n\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\tspin_lock(&wb->list_lock);\n\treturn wb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&wb->list_lock"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&inode->i_lock"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic struct bdi_writeback *\nlocked_inode_to_wb_and_lock_list(struct inode *inode)\n\t__releases(&inode->i_lock)\n\t__acquires(&wb->list_lock)\n{\n\twhile (true) {\n\t\tstruct bdi_writeback *wb = inode_to_wb(inode);\n\n\t\t/*\n\t\t * inode_to_wb() association is protected by both\n\t\t * @inode->i_lock and @wb->list_lock but list_lock nests\n\t\t * outside i_lock.  Drop i_lock and verify that the\n\t\t * association hasn't changed after acquiring list_lock.\n\t\t */\n\t\twb_get(wb);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_lock(&wb->list_lock);\n\n\t\t/* i_wb may have changed inbetween, can't use inode_to_wb() */\n\t\tif (likely(wb == inode->i_wb)) {\n\t\t\twb_put(wb);\t/* @inode already has ref */\n\t\t\treturn wb;\n\t\t}\n\n\t\tspin_unlock(&wb->list_lock);\n\t\twb_put(wb);\n\t\tcpu_relax();\n\t\tspin_lock(&inode->i_lock);\n\t}\n}"
  },
  {
    "function_name": "__inode_attach_wb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "243-271",
    "snippet": "void __inode_attach_wb(struct inode *inode, struct page *page)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\n\tif (inode_cgwb_enabled(inode)) {\n\t\tstruct cgroup_subsys_state *memcg_css;\n\n\t\tif (page) {\n\t\t\tmemcg_css = mem_cgroup_css_from_page(page);\n\t\t\twb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\t\t} else {\n\t\t\t/* must pin memcg_css, see wb_get_create() */\n\t\t\tmemcg_css = task_get_css(current, memory_cgrp_id);\n\t\t\twb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\t\t\tcss_put(memcg_css);\n\t\t}\n\t}\n\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\t/*\n\t * There may be multiple instances of this function racing to\n\t * update the same inode.  Use cmpxchg() to tell the winner.\n\t */\n\tif (unlikely(cmpxchg(&inode->i_wb, NULL, wb)))\n\t\twb_put(wb);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_put",
          "args": [
            "wb"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cmpxchg(&inode->i_wb, NULL, wb)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&inode->i_wb",
            "NULL",
            "wb"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "css_put",
          "args": [
            "memcg_css"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_get_create",
          "args": [
            "bdi",
            "memcg_css",
            "GFP_ATOMIC"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_get_css",
          "args": [
            "current",
            "memory_cgrp_id"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wb_get_create",
          "args": [
            "bdi",
            "memcg_css",
            "GFP_ATOMIC"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mem_cgroup_css_from_page",
          "args": [
            "page"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_cgwb_enabled",
          "args": [
            "inode"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __inode_attach_wb(struct inode *inode, struct page *page)\n{\n\tstruct backing_dev_info *bdi = inode_to_bdi(inode);\n\tstruct bdi_writeback *wb = NULL;\n\n\tif (inode_cgwb_enabled(inode)) {\n\t\tstruct cgroup_subsys_state *memcg_css;\n\n\t\tif (page) {\n\t\t\tmemcg_css = mem_cgroup_css_from_page(page);\n\t\t\twb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\t\t} else {\n\t\t\t/* must pin memcg_css, see wb_get_create() */\n\t\t\tmemcg_css = task_get_css(current, memory_cgrp_id);\n\t\t\twb = wb_get_create(bdi, memcg_css, GFP_ATOMIC);\n\t\t\tcss_put(memcg_css);\n\t\t}\n\t}\n\n\tif (!wb)\n\t\twb = &bdi->wb;\n\n\t/*\n\t * There may be multiple instances of this function racing to\n\t * update the same inode.  Use cmpxchg() to tell the winner.\n\t */\n\tif (unlikely(cmpxchg(&inode->i_wb, NULL, wb)))\n\t\twb_put(wb);\n}"
  },
  {
    "function_name": "wb_wait_for_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "217-222",
    "snippet": "static void wb_wait_for_completion(struct backing_dev_info *bdi,\n\t\t\t\t   struct wb_completion *done)\n{\n\tatomic_dec(&done->cnt);\t\t/* put down the initial count */\n\twait_event(bdi->wb_waitq, !atomic_read(&done->cnt));\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "bdi->wb_waitq",
            "!atomic_read(&done->cnt)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&done->cnt"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&done->cnt"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wait_for_completion(struct backing_dev_info *bdi,\n\t\t\t\t   struct wb_completion *done)\n{\n\tatomic_dec(&done->cnt);\t\t/* put down the initial count */\n\twait_event(bdi->wb_waitq, !atomic_read(&done->cnt));\n}"
  },
  {
    "function_name": "wb_queue_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "187-204",
    "snippet": "static void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&wb->work_lock"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_writeback_work",
          "args": [
            "wb",
            "work"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "finish_writeback_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "176-185",
          "snippet": "static void finish_writeback_work(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tstruct wb_completion *done = work->done;\n\n\tif (work->auto_free)\n\t\tkfree(work);\n\tif (done && atomic_dec_and_test(&done->cnt))\n\t\twake_up_all(&wb->bdi->wb_waitq);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void finish_writeback_work(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tstruct wb_completion *done = work->done;\n\n\tif (work->auto_free)\n\t\tkfree(work);\n\tif (done && atomic_dec_and_test(&done->cnt))\n\t\twake_up_all(&wb->bdi->wb_waitq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "bdi_wq",
            "&wb->dwork",
            "0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&work->list",
            "&wb->work_list"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WB_registered",
            "&wb->state"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&wb->work_lock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&work->done->cnt"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_writeback_queue",
          "args": [
            "wb",
            "work"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_queue_work(struct bdi_writeback *wb,\n\t\t\t  struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(wb, work);\n\n\tif (work->done)\n\t\tatomic_inc(&work->done->cnt);\n\n\tspin_lock_bh(&wb->work_lock);\n\n\tif (test_bit(WB_registered, &wb->state)) {\n\t\tlist_add_tail(&work->list, &wb->work_list);\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\t} else\n\t\tfinish_writeback_work(wb, work);\n\n\tspin_unlock_bh(&wb->work_lock);\n}"
  },
  {
    "function_name": "finish_writeback_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "176-185",
    "snippet": "static void finish_writeback_work(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tstruct wb_completion *done = work->done;\n\n\tif (work->auto_free)\n\t\tkfree(work);\n\tif (done && atomic_dec_and_test(&done->cnt))\n\t\twake_up_all(&wb->bdi->wb_waitq);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&wb->bdi->wb_waitq"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&done->cnt"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "work"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void finish_writeback_work(struct bdi_writeback *wb,\n\t\t\t\t  struct wb_writeback_work *work)\n{\n\tstruct wb_completion *done = work->done;\n\n\tif (work->auto_free)\n\t\tkfree(work);\n\tif (done && atomic_dec_and_test(&done->cnt))\n\t\twake_up_all(&wb->bdi->wb_waitq);\n}"
  },
  {
    "function_name": "wb_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "168-174",
    "snippet": "static void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&wb->work_lock"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_delayed_work",
          "args": [
            "bdi_wq",
            "&wb->dwork",
            "0"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "WB_registered",
            "&wb->state"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&wb->work_lock"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_wakeup(struct bdi_writeback *wb)\n{\n\tspin_lock_bh(&wb->work_lock);\n\tif (test_bit(WB_registered, &wb->state))\n\t\tmod_delayed_work(bdi_wq, &wb->dwork, 0);\n\tspin_unlock_bh(&wb->work_lock);\n}"
  },
  {
    "function_name": "inode_io_list_del_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "159-166",
    "snippet": "static void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_io_lists_depopulated",
          "args": [
            "wb"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "wb_io_lists_depopulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "115-123",
          "snippet": "static void wb_io_lists_depopulated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb) && list_empty(&wb->b_dirty) &&\n\t    list_empty(&wb->b_io) && list_empty(&wb->b_more_io)) {\n\t\tclear_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(atomic_long_sub_return(wb->avg_write_bandwidth,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) < 0);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_io_lists_depopulated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb) && list_empty(&wb->b_dirty) &&\n\t    list_empty(&wb->b_io) && list_empty(&wb->b_more_io)) {\n\t\tclear_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(atomic_long_sub_return(wb->avg_write_bandwidth,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) < 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_io_list"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&wb->list_lock"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_io_list_del_locked(struct inode *inode,\n\t\t\t\t     struct bdi_writeback *wb)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_del_init(&inode->i_io_list);\n\twb_io_lists_depopulated(wb);\n}"
  },
  {
    "function_name": "inode_io_list_move_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "135-149",
    "snippet": "static bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wb_io_lists_depopulated",
          "args": [
            "wb"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "wb_io_lists_depopulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "115-123",
          "snippet": "static void wb_io_lists_depopulated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb) && list_empty(&wb->b_dirty) &&\n\t    list_empty(&wb->b_io) && list_empty(&wb->b_more_io)) {\n\t\tclear_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(atomic_long_sub_return(wb->avg_write_bandwidth,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) < 0);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_io_lists_depopulated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb) && list_empty(&wb->b_dirty) &&\n\t    list_empty(&wb->b_io) && list_empty(&wb->b_more_io)) {\n\t\tclear_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(atomic_long_sub_return(wb->avg_write_bandwidth,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) < 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_io_lists_populated",
          "args": [
            "wb"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "wb_io_lists_populated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "102-113",
          "snippet": "static bool wb_io_lists_populated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb)) {\n\t\treturn false;\n\t} else {\n\t\tset_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(!wb->avg_write_bandwidth);\n\t\tatomic_long_add(wb->avg_write_bandwidth,\n\t\t\t\t&wb->bdi->tot_write_bandwidth);\n\t\treturn true;\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool wb_io_lists_populated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb)) {\n\t\treturn false;\n\t} else {\n\t\tset_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(!wb->avg_write_bandwidth);\n\t\tatomic_long_add(wb->avg_write_bandwidth,\n\t\t\t\t&wb->bdi->tot_write_bandwidth);\n\t\treturn true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&inode->i_io_list",
            "head"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&wb->list_lock"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool inode_io_list_move_locked(struct inode *inode,\n\t\t\t\t      struct bdi_writeback *wb,\n\t\t\t\t      struct list_head *head)\n{\n\tassert_spin_locked(&wb->list_lock);\n\n\tlist_move(&inode->i_io_list, head);\n\n\t/* dirty_time doesn't count as dirty_io until expiration */\n\tif (head != &wb->b_dirty_time)\n\t\treturn wb_io_lists_populated(wb);\n\n\twb_io_lists_depopulated(wb);\n\treturn false;\n}"
  },
  {
    "function_name": "wb_io_lists_depopulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "115-123",
    "snippet": "static void wb_io_lists_depopulated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb) && list_empty(&wb->b_dirty) &&\n\t    list_empty(&wb->b_io) && list_empty(&wb->b_more_io)) {\n\t\tclear_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(atomic_long_sub_return(wb->avg_write_bandwidth,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) < 0);\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_long_sub_return(wb->avg_write_bandwidth,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) < 0"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_sub_return",
          "args": [
            "wb->avg_write_bandwidth",
            "&wb->bdi->tot_write_bandwidth"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "WB_has_dirty_io",
            "&wb->state"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "920-924",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&wb->b_more_io"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_has_dirty_io",
          "args": [
            "wb"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void wb_io_lists_depopulated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb) && list_empty(&wb->b_dirty) &&\n\t    list_empty(&wb->b_io) && list_empty(&wb->b_more_io)) {\n\t\tclear_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(atomic_long_sub_return(wb->avg_write_bandwidth,\n\t\t\t\t\t&wb->bdi->tot_write_bandwidth) < 0);\n\t}\n}"
  },
  {
    "function_name": "wb_io_lists_populated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "102-113",
    "snippet": "static bool wb_io_lists_populated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb)) {\n\t\treturn false;\n\t} else {\n\t\tset_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(!wb->avg_write_bandwidth);\n\t\tatomic_long_add(wb->avg_write_bandwidth,\n\t\t\t\t&wb->bdi->tot_write_bandwidth);\n\t\treturn true;\n\t}\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_add",
          "args": [
            "wb->avg_write_bandwidth",
            "&wb->bdi->tot_write_bandwidth"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!wb->avg_write_bandwidth"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "WB_has_dirty_io",
            "&wb->state"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "914-918",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wb_has_dirty_io",
          "args": [
            "wb"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic bool wb_io_lists_populated(struct bdi_writeback *wb)\n{\n\tif (wb_has_dirty_io(wb)) {\n\t\treturn false;\n\t} else {\n\t\tset_bit(WB_has_dirty_io, &wb->state);\n\t\tWARN_ON_ONCE(!wb->avg_write_bandwidth);\n\t\tatomic_long_add(wb->avg_write_bandwidth,\n\t\t\t\t&wb->bdi->tot_write_bandwidth);\n\t\treturn true;\n\t}\n}"
  },
  {
    "function_name": "wb_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
    "lines": "87-90",
    "snippet": "static inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}",
    "includes": [
      "#include <trace/events/writeback.h>",
      "#include \"internal.h\"",
      "#include <linux/memcontrol.h>",
      "#include <linux/device.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "head",
            "structinode",
            "i_io_list"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic inline struct inode *wb_inode(struct list_head *head)\n{\n\treturn list_entry(head, struct inode, i_io_list);\n}"
  }
]