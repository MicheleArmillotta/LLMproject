[
  {
    "function_name": "current_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "2150-2160",
    "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_trunc",
          "args": [
            "now",
            "inode->i_sb->s_time_gran"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "timespec64_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2124-2137",
          "snippet": "struct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran)\n{\n\t/* Avoid division in the common cases 1 ns and 1 s. */\n\tif (gran == 1) {\n\t\t/* nothing */\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran)\n{\n\t/* Avoid division in the common cases 1 ns and 1 s. */\n\tif (gran == 1) {\n\t\t/* nothing */\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"current_time() called with uninitialized super_block in the inode\""
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode->i_sb"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_kernel_time64",
          "args": [],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
  },
  {
    "function_name": "timespec64_trunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "2124-2137",
    "snippet": "struct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran)\n{\n\t/* Avoid division in the common cases 1 ns and 1 s. */\n\tif (gran == 1) {\n\t\t/* nothing */\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"illegal file time granularity: %u\"",
            "gran"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstruct timespec64 timespec64_trunc(struct timespec64 t, unsigned gran)\n{\n\t/* Avoid division in the common cases 1 ns and 1 s. */\n\tif (gran == 1) {\n\t\t/* nothing */\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}"
  },
  {
    "function_name": "inode_nohighmem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "2110-2113",
    "snippet": "void inode_nohighmem(struct inode *inode)\n{\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_USER);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "inode->i_mapping",
            "GFP_USER"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_nohighmem(struct inode *inode)\n{\n\tmapping_set_gfp_mask(inode->i_mapping, GFP_USER);\n}"
  },
  {
    "function_name": "inode_set_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "2096-2107",
    "snippet": "void inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = READ_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&inode->i_flags",
            "old_flags",
            "new_flags"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "inode->i_flags"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "flags & ~mask"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_set_flags(struct inode *inode, unsigned int flags,\n\t\t     unsigned int mask)\n{\n\tunsigned int old_flags, new_flags;\n\n\tWARN_ON_ONCE(flags & ~mask);\n\tdo {\n\t\told_flags = READ_ONCE(inode->i_flags);\n\t\tnew_flags = (old_flags & ~mask) | flags;\n\t} while (unlikely(cmpxchg(&inode->i_flags, old_flags,\n\t\t\t\t  new_flags) != old_flags));\n}"
  },
  {
    "function_name": "inode_dio_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "2073-2077",
    "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "__inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2050-2061",
          "snippet": "static void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wq_entry, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wq_entry);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wq_entry, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wq_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
  },
  {
    "function_name": "__inode_dio_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "2050-2061",
    "snippet": "static void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wq_entry, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wq_entry);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&q.wq_entry"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&q.wq_entry",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "q",
            "&inode->i_state",
            "__I_DIO_WAKEUP"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&inode->i_state",
            "__I_DIO_WAKEUP"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __inode_dio_wait(struct inode *inode)\n{\n\twait_queue_head_t *wq = bit_waitqueue(&inode->i_state, __I_DIO_WAKEUP);\n\tDEFINE_WAIT_BIT(q, &inode->i_state, __I_DIO_WAKEUP);\n\n\tdo {\n\t\tprepare_to_wait(wq, &q.wq_entry, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&inode->i_dio_count))\n\t\t\tschedule();\n\t} while (atomic_read(&inode->i_dio_count));\n\tfinish_wait(wq, &q.wq_entry);\n}"
  },
  {
    "function_name": "inode_owner_or_capable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "2033-2044",
    "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns",
            "CAP_FOWNER"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "ns",
            "inode->i_uid"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "inode->i_uid"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "inode_init_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "2006-2023",
    "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\n\t\t/* Directories are special, and always inherit S_ISGID */\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable_wrt_inode_uidgid",
          "args": [
            "dir",
            "CAP_FSETID"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "inode->i_gid"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\n\t\t/* Directories are special, and always inherit S_ISGID */\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
  },
  {
    "function_name": "init_special_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1980-1997",
    "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\"",
            "mode",
            "inode->i_sb->s_id",
            "inode->i_ino"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "mode"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
  },
  {
    "function_name": "inode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1954-1978",
    "snippet": "void __init inode_init(void)\n{\n\t/* inode slab cache */\n\tinode_cachep = kmem_cache_create(\"inode_cache\",\n\t\t\t\t\t sizeof(struct inode),\n\t\t\t\t\t 0,\n\t\t\t\t\t (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t init_once);\n\n\t/* Hash may have been set up in inode_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int i_hash_mask",
      "static unsigned int i_hash_shift",
      "static struct hlist_head *inode_hashtable",
      "static struct kmem_cache *inode_cachep",
      "static void __wait_on_freeing_inode(struct inode *inode);",
      "static __initdata unsigned long ihash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"Inode-cache\"",
            "sizeof(struct hlist_head)",
            "ihash_entries",
            "14",
            "HASH_ZERO",
            "&i_hash_shift",
            "&i_hash_mask",
            "0",
            "0"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"inode_cache\"",
            "sizeof(struct inode)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD|SLAB_ACCOUNT)",
            "init_once"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic unsigned int i_hash_mask;\nstatic unsigned int i_hash_shift;\nstatic struct hlist_head *inode_hashtable;\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\nstatic __initdata unsigned long ihash_entries;\n\nvoid __init inode_init(void)\n{\n\t/* inode slab cache */\n\tinode_cachep = kmem_cache_create(\"inode_cache\",\n\t\t\t\t\t sizeof(struct inode),\n\t\t\t\t\t 0,\n\t\t\t\t\t (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t init_once);\n\n\t/* Hash may have been set up in inode_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}"
  },
  {
    "function_name": "inode_init_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1934-1952",
    "snippet": "void __init inode_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int i_hash_mask",
      "static unsigned int i_hash_shift",
      "static struct hlist_head *inode_hashtable",
      "static __initdata unsigned long ihash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"Inode-cache\"",
            "sizeof(struct hlist_head)",
            "ihash_entries",
            "14",
            "HASH_EARLY | HASH_ZERO",
            "&i_hash_shift",
            "&i_hash_mask",
            "0",
            "0"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic unsigned int i_hash_mask;\nstatic unsigned int i_hash_shift;\nstatic struct hlist_head *inode_hashtable;\nstatic __initdata unsigned long ihash_entries;\n\nvoid __init inode_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}"
  },
  {
    "function_name": "set_ihash_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1922-1928",
    "snippet": "static int __init set_ihash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tihash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __initdata unsigned long ihash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "0"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __initdata unsigned long ihash_entries;\n\nstatic int __init set_ihash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tihash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "__wait_on_freeing_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1908-1919",
    "snippet": "static void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n\tspin_lock(&inode_hash_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&wait.wq_entry"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&wait.wq_entry",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wait",
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n\tspin_lock(&inode_hash_lock);\n}"
  },
  {
    "function_name": "inode_needs_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1887-1894",
    "snippet": "int inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "inode"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_needs_sync(struct inode *inode)\n{\n\tif (IS_SYNC(inode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode) && IS_DIRSYNC(inode))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "file_update_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1852-1884",
    "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec64_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode) && inode_iversion_need_inc(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "456-459",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_time",
          "args": [
            "inode",
            "&now",
            "sync_it"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1663-1671",
          "snippet": "static int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "399-405",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_iversion_need_inc",
          "args": [
            "inode"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_I_VERSION",
          "args": [
            "inode"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_equal",
          "args": [
            "&inode->i_ctime",
            "&now"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_equal",
          "args": [
            "&inode->i_mtime",
            "&now"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NOCMTIME",
          "args": [
            "inode"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec64 now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_time(inode);\n\tif (!timespec64_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec64_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode) && inode_iversion_need_inc(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "file_remove_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1816-1836",
    "snippet": "int file_remove_privs(struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = file_inode(file);\n\tint kill;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkill = dentry_needs_remove_privs(dentry);\n\tif (kill < 0)\n\t\treturn kill;\n\tif (kill)\n\t\terror = __remove_privs(dentry, kill);\n\tif (!error)\n\t\tinode_has_no_xattr(inode);\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_has_no_xattr",
          "args": [
            "inode"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_privs",
          "args": [
            "dentry",
            "kill"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1800-1810",
          "snippet": "static int __remove_privs(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic int __remove_privs(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_needs_remove_privs",
          "args": [
            "dentry"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_needs_remove_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1782-1798",
          "snippet": "int dentry_needs_remove_privs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint mask = 0;\n\tint ret;\n\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tmask = should_remove_suid(dentry);\n\tret = security_inode_need_killpriv(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tmask |= ATTR_KILL_PRIV;\n\treturn mask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint dentry_needs_remove_privs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint mask = 0;\n\tint ret;\n\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tmask = should_remove_suid(dentry);\n\tret = security_inode_need_killpriv(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tmask |= ATTR_KILL_PRIV;\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NOSEC",
          "args": [
            "inode"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_dentry",
          "args": [
            "file"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_remove_privs(struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = file_inode(file);\n\tint kill;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkill = dentry_needs_remove_privs(dentry);\n\tif (kill < 0)\n\t\treturn kill;\n\tif (kill)\n\t\terror = __remove_privs(dentry, kill);\n\tif (!error)\n\t\tinode_has_no_xattr(inode);\n\n\treturn error;\n}"
  },
  {
    "function_name": "__remove_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1800-1810",
    "snippet": "static int __remove_privs(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "dentry",
            "&newattrs",
            "NULL"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/attr.c",
          "lines": "226-345",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/sched/signal.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec64 now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!inode_is_locked(inode));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If utimes(2) and friends are called with times == NULL (or both\n\t * times are UTIME_NOW), then we need to check for write permission\n\t */\n\tif (ia_valid & ATTR_TOUCH) {\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\tif (!inode_owner_or_capable(inode)) {\n\t\t\terror = inode_permission(inode, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_time(inode);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tia_valid = attr->ia_valid &= ~ATTR_KILL_PRIV;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\t/*\n\t * Verify that uid/gid changes are valid in the target\n\t * namespace of the superblock.\n\t */\n\tif (ia_valid & ATTR_UID &&\n\t    !kuid_has_mapping(inode->i_sb->s_user_ns, attr->ia_uid))\n\t\treturn -EOVERFLOW;\n\tif (ia_valid & ATTR_GID &&\n\t    !kgid_has_mapping(inode->i_sb->s_user_ns, attr->ia_gid))\n\t\treturn -EOVERFLOW;\n\n\t/* Don't allow modifications of files with invalid uids or\n\t * gids unless those uids & gids are being made valid.\n\t */\n\tif (!(ia_valid & ATTR_UID) && !uid_valid(inode->i_uid))\n\t\treturn -EOVERFLOW;\n\tif (!(ia_valid & ATTR_GID) && !gid_valid(inode->i_gid))\n\t\treturn -EOVERFLOW;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic int __remove_privs(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\t/*\n\t * Note we call this on write, so notify_change will not\n\t * encounter any conflicting delegations:\n\t */\n\treturn notify_change(dentry, &newattrs, NULL);\n}"
  },
  {
    "function_name": "dentry_needs_remove_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1782-1798",
    "snippet": "int dentry_needs_remove_privs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint mask = 0;\n\tint ret;\n\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tmask = should_remove_suid(dentry);\n\tret = security_inode_need_killpriv(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tmask |= ATTR_KILL_PRIV;\n\treturn mask;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_need_killpriv",
          "args": [
            "dentry"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_remove_suid",
          "args": [
            "dentry"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "should_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1754-1774",
          "snippet": "int should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = d_inode(dentry)->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = d_inode(dentry)->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NOSEC",
          "args": [
            "inode"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_inode_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/inode.c",
          "lines": "1766-2186",
          "snippet": "int ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);",
            "static struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\nstatic struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;\n\nint ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint dentry_needs_remove_privs(struct dentry *dentry)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint mask = 0;\n\tint ret;\n\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tmask = should_remove_suid(dentry);\n\tret = security_inode_need_killpriv(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tmask |= ATTR_KILL_PRIV;\n\treturn mask;\n}"
  },
  {
    "function_name": "should_remove_suid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1754-1774",
    "snippet": "int should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = d_inode(dentry)->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kill && !capable(CAP_FSETID) && S_ISREG(mode)"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_FSETID"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(mode & S_ISGID) && (mode & S_IXGRP)"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mode & S_ISUID"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_inode_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/inode.c",
          "lines": "1766-2186",
          "snippet": "int ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);",
            "static struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\nstatic struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;\n\nint ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = d_inode(dentry)->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "touch_atime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1717-1745",
    "snippet": "void touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct timespec64 now;\n\n\tif (!atime_needs_update(path, inode))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt) != 0)\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tnow = current_time(inode);\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_write",
          "args": [
            "inode->i_sb"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__mnt_drop_write",
          "args": [
            "mnt"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "456-459",
          "snippet": "void __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid __mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_time",
          "args": [
            "inode",
            "&now",
            "S_ATIME"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1663-1671",
          "snippet": "static int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_want_write",
          "args": [
            "mnt"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "399-405",
          "snippet": "int __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nint __mnt_want_write_file(struct file *file)\n{\n\tif (!(file->f_mode & FMODE_WRITER))\n\t\treturn __mnt_want_write(file->f_path.mnt);\n\telse\n\t\treturn mnt_clone_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_write_trylock",
          "args": [
            "inode->i_sb"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atime_needs_update",
          "args": [
            "path",
            "inode"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "atime_needs_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1682-1715",
          "snippet": "bool atime_needs_update(const struct path *path, struct inode *inode)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct timespec64 now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn false;\n\n\t/* Atime updates will likely cause i_uid and i_gid to be written\n\t * back improprely if their true value is unknown to the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn false;\n\n\tif (IS_NOATIME(inode))\n\t\treturn false;\n\tif ((inode->i_sb->s_flags & SB_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn false;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tnow = current_time(inode);\n\n\tif (!relatime_need_update(mnt, inode, timespec64_to_timespec(now)))\n\t\treturn false;\n\n\tif (timespec64_equal(&inode->i_atime, &now))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool atime_needs_update(const struct path *path, struct inode *inode)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct timespec64 now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn false;\n\n\t/* Atime updates will likely cause i_uid and i_gid to be written\n\t * back improprely if their true value is unknown to the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn false;\n\n\tif (IS_NOATIME(inode))\n\t\treturn false;\n\tif ((inode->i_sb->s_flags & SB_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn false;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tnow = current_time(inode);\n\n\tif (!relatime_need_update(mnt, inode, timespec64_to_timespec(now)))\n\t\treturn false;\n\n\tif (timespec64_equal(&inode->i_atime, &now))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "path->dentry"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_inode_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ntfs/inode.c",
          "lines": "1766-2186",
          "snippet": "int ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);",
            "static struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\nstatic struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;\n\nint ntfs_read_inode_mount(struct inode *vi)\n{\n\tVCN next_vcn, last_vcn, highest_vcn;\n\ts64 block;\n\tstruct super_block *sb = vi->i_sb;\n\tntfs_volume *vol = NTFS_SB(sb);\n\tstruct buffer_head *bh;\n\tntfs_inode *ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\tunsigned int i, nr_blocks;\n\tint err;\n\n\tntfs_debug(\"Entering.\");\n\n\t/* Initialize the ntfs specific part of @vi. */\n\tntfs_init_big_inode(vi);\n\n\tni = NTFS_I(vi);\n\n\t/* Setup the data attribute. It is special as it is mst protected. */\n\tNInoSetNonResident(ni);\n\tNInoSetMstProtected(ni);\n\tNInoSetSparseDisabled(ni);\n\tni->type = AT_DATA;\n\tni->name = NULL;\n\tni->name_len = 0;\n\t/*\n\t * This sets up our little cheat allowing us to reuse the async read io\n\t * completion handler for directories.\n\t */\n\tni->itype.index.block_size = vol->mft_record_size;\n\tni->itype.index.block_size_bits = vol->mft_record_size_bits;\n\n\t/* Very important! Needed to be able to call map_mft_record*(). */\n\tvol->mft_ino = vi;\n\n\t/* Allocate enough memory to read the first mft record. */\n\tif (vol->mft_record_size > 64 * 1024) {\n\t\tntfs_error(sb, \"Unsupported mft record size %i (max 64kiB).\",\n\t\t\t\tvol->mft_record_size);\n\t\tgoto err_out;\n\t}\n\ti = vol->mft_record_size;\n\tif (i < sb->s_blocksize)\n\t\ti = sb->s_blocksize;\n\tm = (MFT_RECORD*)ntfs_malloc_nofs(i);\n\tif (!m) {\n\t\tntfs_error(sb, \"Failed to allocate buffer for $MFT record 0.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Determine the first block of the $MFT/$DATA attribute. */\n\tblock = vol->mft_lcn << vol->cluster_size_bits >>\n\t\t\tsb->s_blocksize_bits;\n\tnr_blocks = vol->mft_record_size >> sb->s_blocksize_bits;\n\tif (!nr_blocks)\n\t\tnr_blocks = 1;\n\n\t/* Load $MFT/$DATA's first mft record. */\n\tfor (i = 0; i < nr_blocks; i++) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh) {\n\t\t\tntfs_error(sb, \"Device read failed.\");\n\t\t\tgoto err_out;\n\t\t}\n\t\tmemcpy((char*)m + (i << sb->s_blocksize_bits), bh->b_data,\n\t\t\t\tsb->s_blocksize);\n\t\tbrelse(bh);\n\t}\n\n\t/* Apply the mst fixups. */\n\tif (post_read_mst_fixup((NTFS_RECORD*)m, vol->mft_record_size)) {\n\t\t/* FIXME: Try to use the $MFTMirr now. */\n\t\tntfs_error(sb, \"MST fixup failed. $MFT is corrupt.\");\n\t\tgoto err_out;\n\t}\n\n\t/* Need this to sanity check attribute list references to $MFT. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/* Provides readpage() for map_mft_record(). */\n\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\t/* Find the attribute list attribute if present. */\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute. You should run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tATTR_LIST_ENTRY *al_entry, *next_al_entry;\n\t\tu8 *al_end;\n\t\tstatic const char *es = \"  Not allowed.  $MFT is corrupt.  \"\n\t\t\t\t\"You should run chkdsk.\";\n\n\t\tntfs_debug(\"Attribute list attribute found in $MFT.\");\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.%s\", es);\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(sb, \"Non-resident attribute list \"\n\t\t\t\t\t\t\"attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.%s\", es);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\tntfs_warning(sb, \"Resident attribute list attribute \"\n\t\t\t\t\t\"in $MFT system file is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\");\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(sb, \"Not enough memory to allocate buffer \"\n\t\t\t\t\t\"for attribute list.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"Attribute list has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Setup the runlist. */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(sb, \"Mapping pairs decompression \"\n\t\t\t\t\t\t\"failed with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.\n\t\t\t\t\tnon_resident.initialized_size)))) {\n\t\t\t\tntfs_error(sb, \"Failed to load attribute list \"\n\t\t\t\t\t\t\"attribute with error code %i.\",\n\t\t\t\t\t\t-err);\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t} else /* if (!ctx.attr->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset) +\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t\t/* The attribute list is now setup in memory. */\n\t\t/*\n\t\t * FIXME: I don't know if this case is actually possible.\n\t\t * According to logic it is not possible but I have seen too\n\t\t * many weird things in MS software to rely on logic... Thus we\n\t\t * perform a manual search and make sure the first $MFT/$DATA\n\t\t * extent is in the base inode. If it is not we abort with an\n\t\t * error and if we ever see a report of this error we will need\n\t\t * to do some magic in order to have the necessary mft record\n\t\t * loaded and in the right place in the page cache. But\n\t\t * hopefully logic will prevail and this never happens...\n\t\t */\n\t\tal_entry = (ATTR_LIST_ENTRY*)ni->attr_list;\n\t\tal_end = (u8*)al_entry + ni->attr_list_size;\n\t\tfor (;; al_entry = next_al_entry) {\n\t\t\t/* Out of bounds check. */\n\t\t\tif ((u8*)al_entry < ni->attr_list ||\n\t\t\t\t\t(u8*)al_entry > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Catch the end of the attribute list. */\n\t\t\tif ((u8*)al_entry == al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (!al_entry->length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif ((u8*)al_entry + 6 > al_end || (u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length) > al_end)\n\t\t\t\tgoto em_put_err_out;\n\t\t\tnext_al_entry = (ATTR_LIST_ENTRY*)((u8*)al_entry +\n\t\t\t\t\tle16_to_cpu(al_entry->length));\n\t\t\tif (le32_to_cpu(al_entry->type) > le32_to_cpu(AT_DATA))\n\t\t\t\tgoto em_put_err_out;\n\t\t\tif (AT_DATA != al_entry->type)\n\t\t\t\tcontinue;\n\t\t\t/* We want an unnamed attribute. */\n\t\t\tif (al_entry->name_length)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* Want the first entry, i.e. lowest_vcn == 0. */\n\t\t\tif (al_entry->lowest_vcn)\n\t\t\t\tgoto em_put_err_out;\n\t\t\t/* First entry has to be in the base mft record. */\n\t\t\tif (MREF_LE(al_entry->mft_reference) != vi->i_ino) {\n\t\t\t\t/* MFT references do not match, logic fails. */\n\t\t\t\tntfs_error(sb, \"BUG: The first $DATA extent \"\n\t\t\t\t\t\t\"of $MFT is not in the base \"\n\t\t\t\t\t\t\"mft record. Please report \"\n\t\t\t\t\t\t\"you saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tgoto put_err_out;\n\t\t\t} else {\n\t\t\t\t/* Sequence numbers must match. */\n\t\t\t\tif (MSEQNO_LE(al_entry->mft_reference) !=\n\t\t\t\t\t\tni->seq_no)\n\t\t\t\t\tgoto em_put_err_out;\n\t\t\t\t/* Got it. All is ok. We can stop now. */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tntfs_attr_reinit_search_ctx(ctx);\n\n\t/* Now load all attribute extents. */\n\ta = NULL;\n\tnext_vcn = last_vcn = highest_vcn = 0;\n\twhile (!(err = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, next_vcn, NULL, 0,\n\t\t\tctx))) {\n\t\trunlist_element *nrl;\n\n\t\t/* Cache the current attribute. */\n\t\ta = ctx->attr;\n\t\t/* $MFT must be non-resident. */\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(sb, \"$MFT must be non-resident but a \"\n\t\t\t\t\t\"resident extent was found. $MFT is \"\n\t\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/* $MFT must be uncompressed and unencrypted. */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK ||\n\t\t\t\ta->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(sb, \"$MFT must be uncompressed, \"\n\t\t\t\t\t\"non-sparse, and unencrypted but a \"\n\t\t\t\t\t\"compressed/sparse/encrypted extent \"\n\t\t\t\t\t\"was found. $MFT is corrupt. Run \"\n\t\t\t\t\t\"chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t\t/*\n\t\t * Decompress the mapping pairs array of this extent and merge\n\t\t * the result into the existing runlist. No need for locking\n\t\t * as we have exclusive access to the inode at this time and we\n\t\t * are a mount in progress task, too.\n\t\t */\n\t\tnrl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(nrl)) {\n\t\t\tntfs_error(sb, \"ntfs_mapping_pairs_decompress() \"\n\t\t\t\t\t\"failed with error code %ld.  $MFT is \"\n\t\t\t\t\t\"corrupt.\", PTR_ERR(nrl));\n\t\t\tgoto put_err_out;\n\t\t}\n\t\tni->runlist.rl = nrl;\n\n\t\t/* Are we in the first extent? */\n\t\tif (!next_vcn) {\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn. $MFT is corrupt. \"\n\t\t\t\t\t\t\"You should run chkdsk.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/* Get the last vcn in the $DATA attribute. */\n\t\t\tlast_vcn = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size)\n\t\t\t\t\t>> vol->cluster_size_bits;\n\t\t\t/* Fill in the inode size. */\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t\t/*\n\t\t\t * Verify the number of mft records does not exceed\n\t\t\t * 2^32 - 1.\n\t\t\t */\n\t\t\tif ((vi->i_size >> vol->mft_record_size_bits) >=\n\t\t\t\t\t(1ULL << 32)) {\n\t\t\t\tntfs_error(sb, \"$MFT is too big! Aborting.\");\n\t\t\t\tgoto put_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We have got the first extent of the runlist for\n\t\t\t * $MFT which means it is now relatively safe to call\n\t\t\t * the normal ntfs_read_inode() function.\n\t\t\t * Complete reading the inode, this will actually\n\t\t\t * re-read the mft record for $MFT, this time entering\n\t\t\t * it into the page cache with which we complete the\n\t\t\t * kick start of the volume. It should be safe to do\n\t\t\t * this now as the first extent of $MFT/$DATA is\n\t\t\t * already known and we would hope that we don't need\n\t\t\t * further extents in order to find the other\n\t\t\t * attributes belonging to $MFT. Only time will tell if\n\t\t\t * this is really the case. If not we will have to play\n\t\t\t * magic at this point, possibly duplicating a lot of\n\t\t\t * ntfs_read_inode() at this point. We will need to\n\t\t\t * ensure we do enough of its work to be able to call\n\t\t\t * ntfs_read_inode() on extents of $MFT/$DATA. But lets\n\t\t\t * hope this never happens...\n\t\t\t */\n\t\t\tntfs_read_locked_inode(vi);\n\t\t\tif (is_bad_inode(vi)) {\n\t\t\t\tntfs_error(sb, \"ntfs_read_inode() of $MFT \"\n\t\t\t\t\t\t\"failed. BUG or corrupt $MFT. \"\n\t\t\t\t\t\t\"Run chkdsk and if no errors \"\n\t\t\t\t\t\t\"are found, please report you \"\n\t\t\t\t\t\t\"saw this message to \"\n\t\t\t\t\t\t\"linux-ntfs-dev@lists.\"\n\t\t\t\t\t\t\"sourceforge.net\");\n\t\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\t\t/* Revert to the safe super operations. */\n\t\t\t\tntfs_free(m);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Re-initialize some specifics about $MFT's inode as\n\t\t\t * ntfs_read_inode() will have set up the default ones.\n\t\t\t */\n\t\t\t/* Set uid and gid to root. */\n\t\t\tvi->i_uid = GLOBAL_ROOT_UID;\n\t\t\tvi->i_gid = GLOBAL_ROOT_GID;\n\t\t\t/* Regular file. No access for anyone. */\n\t\t\tvi->i_mode = S_IFREG;\n\t\t\t/* No VFS initiated operations allowed for $MFT. */\n\t\t\tvi->i_op = &ntfs_empty_inode_ops;\n\t\t\tvi->i_fop = &ntfs_empty_file_ops;\n\t\t}\n\n\t\t/* Get the lowest vcn for the next extent. */\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tnext_vcn = highest_vcn + 1;\n\n\t\t/* Only one extent or error, which we catch below. */\n\t\tif (next_vcn <= 0)\n\t\t\tbreak;\n\n\t\t/* Avoid endless loops due to corruption. */\n\t\tif (next_vcn < sle64_to_cpu(\n\t\t\t\ta->data.non_resident.lowest_vcn)) {\n\t\t\tntfs_error(sb, \"$MFT has corrupt attribute list \"\n\t\t\t\t\t\"attribute. Run chkdsk.\");\n\t\t\tgoto put_err_out;\n\t\t}\n\t}\n\tif (err != -ENOENT) {\n\t\tntfs_error(sb, \"Failed to lookup $MFT/$DATA attribute extent. \"\n\t\t\t\t\"$MFT is corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (!a) {\n\t\tntfs_error(sb, \"$MFT/$DATA attribute not found. $MFT is \"\n\t\t\t\t\"corrupt. Run chkdsk.\");\n\t\tgoto put_err_out;\n\t}\n\tif (highest_vcn && highest_vcn != last_vcn - 1) {\n\t\tntfs_error(sb, \"Failed to load the complete runlist for \"\n\t\t\t\t\"$MFT/$DATA. Driver bug or corrupt $MFT. \"\n\t\t\t\t\"Run chkdsk.\");\n\t\tntfs_debug(\"highest_vcn = 0x%llx, last_vcn - 1 = 0x%llx\",\n\t\t\t\t(unsigned long long)highest_vcn,\n\t\t\t\t(unsigned long long)last_vcn - 1);\n\t\tgoto put_err_out;\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\tntfs_debug(\"Done.\");\n\tntfs_free(m);\n\n\t/*\n\t * Split the locking rules of the MFT inode from the\n\t * locking rules of other inodes:\n\t */\n\tlockdep_set_class(&ni->runlist.lock, &mft_ni_runlist_lock_key);\n\tlockdep_set_class(&ni->mrec_lock, &mft_ni_mrec_lock_key);\n\n\treturn 0;\n\nem_put_err_out:\n\tntfs_error(sb, \"Couldn't find first extent of $DATA attribute in \"\n\t\t\t\"attribute list. $MFT is corrupt. Run chkdsk.\");\nput_err_out:\n\tntfs_attr_put_search_ctx(ctx);\nerr_out:\n\tntfs_error(sb, \"Failed. Marking inode as bad.\");\n\tmake_bad_inode(vi);\n\tntfs_free(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid touch_atime(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct inode *inode = d_inode(path->dentry);\n\tstruct timespec64 now;\n\n\tif (!atime_needs_update(path, inode))\n\t\treturn;\n\n\tif (!sb_start_write_trylock(inode->i_sb))\n\t\treturn;\n\n\tif (__mnt_want_write(mnt) != 0)\n\t\tgoto skip_update;\n\t/*\n\t * File systems can error out when updating inodes if they need to\n\t * allocate new space to modify an inode (such is the case for\n\t * Btrfs), but since we touch atime while walking down the path we\n\t * really don't care if we failed to update the atime of the file,\n\t * so just ignore the return value.\n\t * We may also fail on filesystems that have the ability to make parts\n\t * of the fs read only, e.g. subvolumes in Btrfs.\n\t */\n\tnow = current_time(inode);\n\tupdate_time(inode, &now, S_ATIME);\n\t__mnt_drop_write(mnt);\nskip_update:\n\tsb_end_write(inode->i_sb);\n}"
  },
  {
    "function_name": "atime_needs_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1682-1715",
    "snippet": "bool atime_needs_update(const struct path *path, struct inode *inode)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct timespec64 now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn false;\n\n\t/* Atime updates will likely cause i_uid and i_gid to be written\n\t * back improprely if their true value is unknown to the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn false;\n\n\tif (IS_NOATIME(inode))\n\t\treturn false;\n\tif ((inode->i_sb->s_flags & SB_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn false;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tnow = current_time(inode);\n\n\tif (!relatime_need_update(mnt, inode, timespec64_to_timespec(now)))\n\t\treturn false;\n\n\tif (timespec64_equal(&inode->i_atime, &now))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_equal",
          "args": [
            "&inode->i_atime",
            "&now"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "relatime_need_update",
          "args": [
            "mnt",
            "inode",
            "timespec64_to_timespec(now)"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "relatime_need_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1606-1633",
          "snippet": "static int relatime_need_update(struct vfsmount *mnt, struct inode *inode,\n\t\t\t     struct timespec now)\n{\n\n\tif (!(mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int relatime_need_update(struct vfsmount *mnt, struct inode *inode,\n\t\t\t     struct timespec now)\n{\n\n\tif (!(mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_timespec",
          "args": [
            "now"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2150-2160",
          "snippet": "struct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct timespec64 current_time(struct inode *inode)\n{\n\tstruct timespec64 now = current_kernel_time64();\n\n\tif (unlikely(!inode->i_sb)) {\n\t\tWARN(1, \"current_time() called with uninitialized super_block in the inode\");\n\t\treturn now;\n\t}\n\n\treturn timespec64_trunc(now, inode->i_sb->s_time_gran);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_NOATIME",
          "args": [
            "inode"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_UNMAPPED_ID",
          "args": [
            "inode"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool atime_needs_update(const struct path *path, struct inode *inode)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tstruct timespec64 now;\n\n\tif (inode->i_flags & S_NOATIME)\n\t\treturn false;\n\n\t/* Atime updates will likely cause i_uid and i_gid to be written\n\t * back improprely if their true value is unknown to the vfs.\n\t */\n\tif (HAS_UNMAPPED_ID(inode))\n\t\treturn false;\n\n\tif (IS_NOATIME(inode))\n\t\treturn false;\n\tif ((inode->i_sb->s_flags & SB_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tif (mnt->mnt_flags & MNT_NOATIME)\n\t\treturn false;\n\tif ((mnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode))\n\t\treturn false;\n\n\tnow = current_time(inode);\n\n\tif (!relatime_need_update(mnt, inode, timespec64_to_timespec(now)))\n\t\treturn false;\n\n\tif (timespec64_equal(&inode->i_atime, &now))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "update_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1663-1671",
    "snippet": "static int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_time",
          "args": [
            "inode",
            "time",
            "flags"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1663-1671",
          "snippet": "static int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint (*update_time)(struct inode *, struct timespec64 *, int);\n\n\tupdate_time = inode->i_op->update_time ? inode->i_op->update_time :\n\t\tgeneric_update_time;\n\n\treturn update_time(inode, time, flags);\n}"
  },
  {
    "function_name": "generic_update_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1635-1656",
    "snippet": "int generic_update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint iflags = I_DIRTY_TIME;\n\tbool dirty = false;\n\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *time;\n\tif (flags & S_VERSION)\n\t\tdirty = inode_maybe_inc_iversion(inode, false);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *time;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *time;\n\tif ((flags & (S_ATIME | S_CTIME | S_MTIME)) &&\n\t    !(inode->i_sb->s_flags & SB_LAZYTIME))\n\t\tdirty = true;\n\n\tif (dirty)\n\t\tiflags |= I_DIRTY_SYNC;\n\t__mark_inode_dirty(inode, iflags);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "iflags"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2107-2217",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_INODE | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tinode_attach_wb(inode, NULL);\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tstruct bdi_writeback *wb;\n\t\t\tstruct list_head *dirty_list;\n\t\t\tbool wakeup_bdi = false;\n\n\t\t\twb = locked_inode_to_wb_and_lock_list(inode);\n\n\t\t\tWARN(bdi_cap_writeback_dirty(wb->bdi) &&\n\t\t\t     !test_bit(WB_registered, &wb->state),\n\t\t\t     \"bdi-%s not registered\\n\", wb->bdi->name);\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tif (dirtytime)\n\t\t\t\tinode->dirtied_time_when = jiffies;\n\n\t\t\tif (inode->i_state & I_DIRTY)\n\t\t\t\tdirty_list = &wb->b_dirty;\n\t\t\telse\n\t\t\t\tdirty_list = &wb->b_dirty_time;\n\n\t\t\twakeup_bdi = inode_io_list_move_locked(inode, wb,\n\t\t\t\t\t\t\t       dirty_list);\n\n\t\t\tspin_unlock(&wb->list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\t/*\n\t\t\t * If this is the first dirty inode for this bdi,\n\t\t\t * we have to wake-up the corresponding bdi thread\n\t\t\t * to make sure background write-back happens\n\t\t\t * later.\n\t\t\t */\n\t\t\tif (bdi_cap_writeback_dirty(wb->bdi) && wakeup_bdi)\n\t\t\t\twb_wakeup_delayed(wb);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_maybe_inc_iversion",
          "args": [
            "inode",
            "false"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint generic_update_time(struct inode *inode, struct timespec64 *time, int flags)\n{\n\tint iflags = I_DIRTY_TIME;\n\tbool dirty = false;\n\n\tif (flags & S_ATIME)\n\t\tinode->i_atime = *time;\n\tif (flags & S_VERSION)\n\t\tdirty = inode_maybe_inc_iversion(inode, false);\n\tif (flags & S_CTIME)\n\t\tinode->i_ctime = *time;\n\tif (flags & S_MTIME)\n\t\tinode->i_mtime = *time;\n\tif ((flags & (S_ATIME | S_CTIME | S_MTIME)) &&\n\t    !(inode->i_sb->s_flags & SB_LAZYTIME))\n\t\tdirty = true;\n\n\tif (dirty)\n\t\tiflags |= I_DIRTY_SYNC;\n\t__mark_inode_dirty(inode, iflags);\n\treturn 0;\n}"
  },
  {
    "function_name": "relatime_need_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1606-1633",
    "snippet": "static int relatime_need_update(struct vfsmount *mnt, struct inode *inode,\n\t\t\t     struct timespec now)\n{\n\n\tif (!(mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&inode->i_ctime",
            "&inode->i_atime"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_compare",
          "args": [
            "&inode->i_mtime",
            "&inode->i_atime"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int relatime_need_update(struct vfsmount *mnt, struct inode *inode,\n\t\t\t     struct timespec now)\n{\n\n\tif (!(mnt->mnt_flags & MNT_RELATIME))\n\t\treturn 1;\n\t/*\n\t * Is mtime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_mtime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\t/*\n\t * Is ctime younger than atime? If yes, update atime:\n\t */\n\tif (timespec64_compare(&inode->i_ctime, &inode->i_atime) >= 0)\n\t\treturn 1;\n\n\t/*\n\t * Is the previous atime value older than a day? If yes,\n\t * update atime:\n\t */\n\tif ((long)(now.tv_sec - inode->i_atime.tv_sec) >= 24*60*60)\n\t\treturn 1;\n\t/*\n\t * Good, we can skip the atime update:\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1592-1598",
    "snippet": "sector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode->i_mapping->a_ops->bmap",
          "args": [
            "inode->i_mapping",
            "block"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1592-1598",
          "snippet": "sector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nsector_t bmap(struct inode *inode, sector_t block)\n{\n\tsector_t res = 0;\n\tif (inode->i_mapping->a_ops->bmap)\n\t\tres = inode->i_mapping->a_ops->bmap(inode->i_mapping, block);\n\treturn res;\n}"
  },
  {
    "function_name": "iput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1562-1578",
    "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput_final",
          "args": [
            "inode"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "iput_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1517-1551",
          "snippet": "static void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & SB_ACTIVE)) {\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & SB_ACTIVE)) {\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty_sync",
          "args": [
            "inode"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_mark_inode_dirty_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/nilfs.h",
          "lines": "285-288",
          "snippet": "static inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}",
          "includes": [
            "#include \"bmap.h\"",
            "#include \"the_nilfs.h\"",
            "#include <linux/nilfs2_ondisk.h>",
            "#include <linux/nilfs2_api.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nilfs_init_gcinode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"bmap.h\"\n#include \"the_nilfs.h\"\n#include <linux/nilfs2_ondisk.h>\n#include <linux/nilfs2_api.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/buffer_head.h>\n#include <linux/kernel.h>\n\nint nilfs_init_gcinode(struct inode *inode);\n\nstatic inline int nilfs_mark_inode_dirty_sync(struct inode *inode)\n{\n\treturn __nilfs_mark_inode_dirty(inode, I_DIRTY_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_writeback_lazytime_iput",
          "args": [
            "inode"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&inode->i_count"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_lock",
          "args": [
            "&inode->i_count",
            "&inode->i_lock"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_state & I_CLEAR"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
  },
  {
    "function_name": "iput_final",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1517-1551",
    "snippet": "static void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & SB_ACTIVE)) {\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "evict",
          "args": [
            "inode"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "evict_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "607-644",
          "snippet": "void evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lru_list_del",
          "args": [
            "inode"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "inode_lru_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "430-435",
          "snippet": "static void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_lru"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_NEW"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "inode",
            "1"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "2433-2447",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_add_lru",
          "args": [
            "inode"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "inode_add_lru",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "421-427",
          "snippet": "void inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & SB_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & SB_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->drop_inode",
          "args": [
            "inode"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_NEW"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void iput_final(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\tint drop;\n\n\tWARN_ON(inode->i_state & I_NEW);\n\n\tif (op->drop_inode)\n\t\tdrop = op->drop_inode(inode);\n\telse\n\t\tdrop = generic_drop_inode(inode);\n\n\tif (!drop && (sb->s_flags & SB_ACTIVE)) {\n\t\tinode_add_lru(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn;\n\t}\n\n\tif (!drop) {\n\t\tinode->i_state |= I_WILL_FREE;\n\t\tspin_unlock(&inode->i_lock);\n\t\twrite_inode_now(inode, 1);\n\t\tspin_lock(&inode->i_lock);\n\t\tWARN_ON(inode->i_state & I_NEW);\n\t\tinode->i_state &= ~I_WILL_FREE;\n\t}\n\n\tinode->i_state |= I_FREEING;\n\tif (!list_empty(&inode->i_lru))\n\t\tinode_lru_list_del(inode);\n\tspin_unlock(&inode->i_lock);\n\n\tevict(inode);\n}"
  },
  {
    "function_name": "generic_delete_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1501-1504",
    "snippet": "int generic_delete_inode(struct inode *inode)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint generic_delete_inode(struct inode *inode)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "insert_inode_locked4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1484-1497",
    "snippet": "int insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *old;\n\n\tinode->i_state |= I_CREATING;\n\told = inode_insert5(inode, hashval, test, NULL, data);\n\n\tif (old != inode) {\n\t\tiput(old);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "old"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_insert5",
          "args": [
            "inode",
            "hashval",
            "test",
            "NULL",
            "data"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "inode_insert5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1050-1096",
          "snippet": "struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\tbool creating = inode->i_state & I_CREATING;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tif (IS_ERR(old))\n\t\t\treturn NULL;\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\n\tif (!creating)\n\t\tinode_sb_list_add(inode);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\tbool creating = inode->i_state & I_CREATING;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tif (IS_ERR(old))\n\t\t\treturn NULL;\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\n\tif (!creating)\n\t\tinode_sb_list_add(inode);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked4(struct inode *inode, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *old;\n\n\tinode->i_state |= I_CREATING;\n\told = inode_insert5(inode, hashval, test, NULL, data);\n\n\tif (old != inode) {\n\t\tiput(old);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "insert_inode_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1437-1481",
    "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "old"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode_unhashed(old)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "old"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "old"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "old"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "394-397",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "old->i_state & I_CREATING"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "head"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!old"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "old",
            "head",
            "i_hash"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "476-485",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
  },
  {
    "function_name": "find_inode_nowait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1410-1434",
    "snippet": "struct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match",
          "args": [
            "inode",
            "hashval",
            "data"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "other_inode_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/inode.c",
          "lines": "5139-5169",
          "snippet": "static int other_inode_match(struct inode * inode, unsigned long ino,\n\t\t\t     void *data)\n{\n\tstruct other_inode *oi = (struct other_inode *) data;\n\n\tif ((inode->i_ino != ino) ||\n\t    (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t       I_DIRTY_INODE)) ||\n\t    ((inode->i_state & I_DIRTY_TIME) == 0))\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tif (((inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t\tI_DIRTY_INODE)) == 0) &&\n\t    (inode->i_state & I_DIRTY_TIME)) {\n\t\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\n\t\tinode->i_state &= ~(I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tspin_lock(&ei->i_raw_lock);\n\t\tEXT4_INODE_SET_XTIME(i_ctime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_mtime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_atime, inode, oi->raw_inode);\n\t\text4_inode_csum_set(inode, oi->raw_inode, ei);\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\ttrace_ext4_other_inode_update_time(inode, oi->orig_ino);\n\t\treturn -1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn -1;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/iomap.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/dax.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/iversion.h>\n#include <linux/iomap.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/dax.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic int other_inode_match(struct inode * inode, unsigned long ino,\n\t\t\t     void *data)\n{\n\tstruct other_inode *oi = (struct other_inode *) data;\n\n\tif ((inode->i_ino != ino) ||\n\t    (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t       I_DIRTY_INODE)) ||\n\t    ((inode->i_state & I_DIRTY_TIME) == 0))\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tif (((inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t\tI_DIRTY_INODE)) == 0) &&\n\t    (inode->i_state & I_DIRTY_TIME)) {\n\t\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\n\t\tinode->i_state &= ~(I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tspin_lock(&ei->i_raw_lock);\n\t\tEXT4_INODE_SET_XTIME(i_ctime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_mtime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_atime, inode, oi->raw_inode);\n\t\text4_inode_csum_set(inode, oi->raw_inode, ei);\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\ttrace_ext4_other_inode_update_time(inode, oi->orig_ino);\n\t\treturn -1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "inode",
            "head",
            "i_hash"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "hashval"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "476-485",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}"
  },
  {
    "function_name": "ilookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1365-1384",
    "snippet": "struct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\tif (IS_ERR(inode))\n\t\t\treturn NULL;\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode_unhashed(inode)"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "inode"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inode_fast",
          "args": [
            "sb",
            "head",
            "ino"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "825-850",
          "snippet": "static struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(inode->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(inode->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "476-485",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\tif (IS_ERR(inode))\n\t\t\treturn NULL;\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "ilookup5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1340-1354",
    "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode;\nagain:\n\tinode = ilookup5_nowait(sb, hashval, test, data);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode_unhashed(inode)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "inode"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ilookup5_nowait",
          "args": [
            "sb",
            "hashval",
            "test",
            "data"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1309-1320",
          "snippet": "struct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn IS_ERR(inode) ? NULL : inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn IS_ERR(inode) ? NULL : inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode;\nagain:\n\tinode = ilookup5_nowait(sb, hashval, test, data);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "ilookup5_nowait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1309-1320",
    "snippet": "struct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn IS_ERR(inode) ? NULL : inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inode",
          "args": [
            "sb",
            "head",
            "test",
            "data"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1410-1434",
          "snippet": "struct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "hashval"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "476-485",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5_nowait(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\treturn IS_ERR(inode) ? NULL : inode;\n}"
  },
  {
    "function_name": "igrab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1274-1290",
    "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "394-397",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "iunique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1251-1271",
    "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&iunique_lock"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_inode_iunique",
          "args": [
            "sb",
            "res"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "test_inode_iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1220-1235",
          "snippet": "static int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&iunique_lock"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
  },
  {
    "function_name": "test_inode_iunique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1220-1235",
    "snippet": "static int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "inode",
            "b",
            "i_hash"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "476-485",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "iget_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1152-1210",
    "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\tif (IS_ERR(inode))\n\t\t\treturn NULL;\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tif (IS_ERR(old))\n\t\t\treturn NULL;\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode_unhashed(inode)"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "inode"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_inode",
          "args": [
            "inode"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "262-270",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sb_list_add",
          "args": [
            "inode"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "441-446",
          "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "head"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_inode_fast",
          "args": [
            "sb",
            "head",
            "ino"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "825-850",
          "snippet": "static struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(inode->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(inode->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode",
          "args": [
            "sb"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "205-226",
          "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inode_cachep",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode_unhashed(inode)"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "inode"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "inode"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "sb",
            "ino"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "476-485",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\nagain:\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\tif (IS_ERR(inode))\n\t\t\treturn NULL;\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tif (IS_ERR(old))\n\t\t\treturn NULL;\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "iget5_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1119-1136",
    "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5(sb, hashval, test, data);\n\n\tif (!inode) {\n\t\tstruct inode *new = alloc_inode(sb);\n\n\t\tif (new) {\n\t\t\tnew->i_state = 0;\n\t\t\tinode = inode_insert5(new, hashval, test, set, data);\n\t\t\tif (unlikely(inode != new))\n\t\t\t\tdestroy_inode(new);\n\t\t}\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inode",
          "args": [
            "new"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "262-270",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode != new"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_insert5",
          "args": [
            "new",
            "hashval",
            "test",
            "set",
            "data"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "inode_insert5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1050-1096",
          "snippet": "struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\tbool creating = inode->i_state & I_CREATING;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tif (IS_ERR(old))\n\t\t\treturn NULL;\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\n\tif (!creating)\n\t\tinode_sb_list_add(inode);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\tbool creating = inode->i_state & I_CREATING;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tif (IS_ERR(old))\n\t\t\treturn NULL;\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\n\tif (!creating)\n\t\tinode_sb_list_add(inode);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode",
          "args": [
            "sb"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "205-226",
          "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inode_cachep",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ilookup5",
          "args": [
            "sb",
            "hashval",
            "test",
            "data"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "ilookup5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1340-1354",
          "snippet": "struct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode;\nagain:\n\tinode = ilookup5_nowait(sb, hashval, test, data);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *ilookup5(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode;\nagain:\n\tinode = ilookup5_nowait(sb, hashval, test, data);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\tif (unlikely(inode_unhashed(inode))) {\n\t\t\tiput(inode);\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct inode *inode = ilookup5(sb, hashval, test, data);\n\n\tif (!inode) {\n\t\tstruct inode *new = alloc_inode(sb);\n\n\t\tif (new) {\n\t\t\tnew->i_state = 0;\n\t\t\tinode = inode_insert5(new, hashval, test, set, data);\n\t\t\tif (unlikely(inode != new))\n\t\t\t\tdestroy_inode(new);\n\t\t}\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "inode_insert5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1050-1096",
    "snippet": "struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\tbool creating = inode->i_state & I_CREATING;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tif (IS_ERR(old))\n\t\t\treturn NULL;\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\n\tif (!creating)\n\t\tinode_sb_list_add(inode);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sb_list_add",
          "args": [
            "inode"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "441-446",
          "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "head"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "set(inode, data)"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set",
          "args": [
            "inode",
            "data"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "317-328",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "old"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode_unhashed(old)"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unhashed",
          "args": [
            "old"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_inode",
          "args": [
            "old"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "old"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_inode",
          "args": [
            "inode->i_sb",
            "head",
            "test",
            "data"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "find_inode_nowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1410-1434",
          "snippet": "struct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *find_inode_nowait(struct super_block *sb,\n\t\t\t\tunsigned long hashval,\n\t\t\t\tint (*match)(struct inode *, unsigned long,\n\t\t\t\t\t     void *),\n\t\t\t\tvoid *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode, *ret_inode = NULL;\n\tint mval;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tmval = match(inode, hashval, data);\n\t\tif (mval == 0)\n\t\t\tcontinue;\n\t\tif (mval == 1)\n\t\t\tret_inode = inode;\n\t\tgoto out;\n\t}\nout:\n\tspin_unlock(&inode_hash_lock);\n\treturn ret_inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "inode->i_sb",
            "hashval"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "476-485",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\tbool creating = inode->i_state & I_CREATING;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tif (IS_ERR(old))\n\t\t\treturn NULL;\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\n\tif (!creating)\n\t\tinode_sb_list_add(inode);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "unlock_two_nondirectories",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1021-1027",
    "snippet": "void unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tinode_unlock(inode1);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tinode_unlock(inode2);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode2"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode2->i_mode"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode1->i_mode"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tinode_unlock(inode1);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tinode_unlock(inode2);\n}"
  },
  {
    "function_name": "lock_two_nondirectories",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "1004-1013",
    "snippet": "void lock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 > inode2)\n\t\tswap(inode1, inode2);\n\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tinode_lock(inode1);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tinode_lock_nested(inode2, I_MUTEX_NONDIR2);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_lock_nested",
          "args": [
            "inode2",
            "I_MUTEX_NONDIR2"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode2->i_mode"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode1"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode1->i_mode"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "inode1",
            "inode2"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2632-2673",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lock_two_nondirectories(struct inode *inode1, struct inode *inode2)\n{\n\tif (inode1 > inode2)\n\t\tswap(inode1, inode2);\n\n\tif (inode1 && !S_ISDIR(inode1->i_mode))\n\t\tinode_lock(inode1);\n\tif (inode2 && !S_ISDIR(inode2->i_mode) && inode2 != inode1)\n\t\tinode_lock_nested(inode2, I_MUTEX_NONDIR2);\n}"
  },
  {
    "function_name": "discard_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "982-992",
    "snippet": "void discard_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n\tiput(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & I_NEW)"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_annotate_inode_mutex_key",
          "args": [
            "inode"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_annotate_inode_mutex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "943-959",
          "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid discard_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n\tiput(inode);\n}"
  },
  {
    "function_name": "unlock_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "970-979",
    "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW & ~I_CREATING;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & I_NEW)"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_annotate_inode_mutex_key",
          "args": [
            "inode"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_annotate_inode_mutex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "943-959",
          "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW & ~I_CREATING;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "lockdep_annotate_inode_mutex_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "943-959",
    "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_rwsem",
            "&type->i_mutex_dir_key"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&inode->i_rwsem"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_match_class",
          "args": [
            "&inode->i_rwsem",
            "&type->i_mutex_key"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "929-939",
    "snippet": "struct inode *new_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tspin_lock_prefetch(&sb->s_inode_list_lock);\n\n\tinode = new_inode_pseudo(sb);\n\tif (inode)\n\t\tinode_sb_list_add(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_sb_list_add",
          "args": [
            "inode"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "441-446",
          "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode_pseudo",
          "args": [
            "sb"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_pseudo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "904-915",
          "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_prefetch",
          "args": [
            "&sb->s_inode_list_lock"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tspin_lock_prefetch(&sb->s_inode_list_lock);\n\n\tinode = new_inode_pseudo(sb);\n\tif (inode)\n\t\tinode_sb_list_add(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "new_inode_pseudo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "904-915",
    "snippet": "struct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_sb_list"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_inode",
          "args": [
            "sb"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "205-226",
          "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *inode_cachep",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *new_inode_pseudo(struct super_block *sb)\n{\n\tstruct inode *inode = alloc_inode(sb);\n\n\tif (inode) {\n\t\tspin_lock(&inode->i_lock);\n\t\tinode->i_state = 0;\n\t\tspin_unlock(&inode->i_lock);\n\t\tINIT_LIST_HEAD(&inode->i_sb_list);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "get_next_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "870-891",
    "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define LAST_INO_BATCH 1024"
    ],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);",
      "static DEFINE_PER_CPU(unsigned int, last_ino);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_var",
          "args": [
            "last_ino"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!res"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "LAST_INO_BATCH",
            "&shared_last_ino"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(res & (LAST_INO_BATCH-1)) == 0"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_var",
          "args": [
            "last_ino"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\tres++;\n\t/* get_next_ino should not provide a 0 inode number */\n\tif (unlikely(!res))\n\t\tres++;\n\t*p = res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
  },
  {
    "function_name": "find_inode_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "825-850",
    "snippet": "static struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(inode->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "394-397",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_state & I_CREATING"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wait_on_freeing_inode",
          "args": [
            "inode"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_freeing_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1908-1919",
          "snippet": "static void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n\tspin_lock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n\tspin_lock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "inode",
            "head",
            "i_hash"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *find_inode_fast(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head, unsigned long ino)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_ino != ino)\n\t\t\tcontinue;\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(inode->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "792-819",
    "snippet": "static struct inode *find_inode(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head,\n\t\t\t\tint (*test)(struct inode *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tif (!test(inode, data))\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(inode->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "394-397",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_state & I_CREATING"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wait_on_freeing_inode",
          "args": [
            "inode"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_freeing_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1908-1919",
          "snippet": "static void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n\tspin_lock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void __wait_on_freeing_inode(struct inode *inode)\n{\n\twait_queue_head_t *wq;\n\tDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\n\twq = bit_waitqueue(&inode->i_state, __I_NEW);\n\tprepare_to_wait(wq, &wait.wq_entry, TASK_UNINTERRUPTIBLE);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n\tschedule();\n\tfinish_wait(wq, &wait.wq_entry);\n\tspin_lock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test",
          "args": [
            "inode",
            "data"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "test_inode_iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1220-1235",
          "snippet": "static int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int test_inode_iunique(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\thlist_for_each_entry(inode, b, i_hash) {\n\t\tif (inode->i_ino == ino && inode->i_sb == sb) {\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tspin_unlock(&inode_hash_lock);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "inode",
            "head",
            "i_hash"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *find_inode(struct super_block *sb,\n\t\t\t\tstruct hlist_head *head,\n\t\t\t\tint (*test)(struct inode *, void *),\n\t\t\t\tvoid *data)\n{\n\tstruct inode *inode = NULL;\n\nrepeat:\n\thlist_for_each_entry(inode, head, i_hash) {\n\t\tif (inode->i_sb != sb)\n\t\t\tcontinue;\n\t\tif (!test(inode, data))\n\t\t\tcontinue;\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t__wait_on_freeing_inode(inode);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(inode->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn ERR_PTR(-ESTALE);\n\t\t}\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn inode;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "prune_icache_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "777-786",
    "snippet": "long prune_icache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_inode_lru, sc,\n\t\t\t\t     inode_lru_isolate, &freeable);\n\tdispose_list(&freeable);\n\treturn freed;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispose_list",
          "args": [
            "&freeable"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "585-596",
          "snippet": "static void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_walk",
          "args": [
            "&sb->s_inode_lru",
            "sc",
            "inode_lru_isolate",
            "&freeable"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "freeable"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nlong prune_icache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_inode_lru, sc,\n\t\t\t\t     inode_lru_isolate, &freeable);\n\tdispose_list(&freeable);\n\treturn freed;\n}"
  },
  {
    "function_name": "inode_lru_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "708-769",
    "snippet": "static enum lru_status inode_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct inode\t*inode = container_of(item, struct inode, i_lru);\n\n\t/*\n\t * we are inverting the lru lock/inode->i_lock here, so use a trylock.\n\t * If we fail to get the lock, just skip it.\n\t */\n\tif (!spin_trylock(&inode->i_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * Referenced or dirty inodes are still in use. Give them another pass\n\t * through the LRU as we canot reclaim them now.\n\t */\n\tif (atomic_read(&inode->i_count) ||\n\t    (inode->i_state & ~I_REFERENCED)) {\n\t\tlist_lru_isolate(lru, &inode->i_lru);\n\t\tspin_unlock(&inode->i_lock);\n\t\tthis_cpu_dec(nr_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t/*\n\t * Recently referenced inodes and inodes with many attached pages\n\t * get one more pass.\n\t */\n\tif (inode->i_state & I_REFERENCED || inode->i_data.nrpages > 1) {\n\t\tinode->i_state &= ~I_REFERENCED;\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn LRU_ROTATE;\n\t}\n\n\tif (inode_has_buffers(inode) || inode->i_data.nrpages) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(lru_lock);\n\t\tif (remove_inode_buffers(inode)) {\n\t\t\tunsigned long reap;\n\t\t\treap = invalidate_mapping_pages(&inode->i_data, 0, -1);\n\t\t\tif (current_is_kswapd())\n\t\t\t\t__count_vm_events(KSWAPD_INODESTEAL, reap);\n\t\t\telse\n\t\t\t\t__count_vm_events(PGINODESTEAL, reap);\n\t\t\tif (current->reclaim_state)\n\t\t\t\tcurrent->reclaim_state->reclaimed_slab += reap;\n\t\t}\n\t\tiput(inode);\n\t\tspin_lock(lru_lock);\n\t\treturn LRU_RETRY;\n\t}\n\n\tWARN_ON(inode->i_state & I_NEW);\n\tinode->i_state |= I_FREEING;\n\tlist_lru_isolate_move(lru, &inode->i_lru, freeable);\n\tspin_unlock(&inode->i_lock);\n\n\tthis_cpu_dec(nr_unused);\n\treturn LRU_REMOVED;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_unused);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_unused"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_isolate_move",
          "args": [
            "lru",
            "&inode->i_lru",
            "freeable"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_state & I_NEW"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "lru_lock"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "PGINODESTEAL",
            "reap"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__count_vm_events",
          "args": [
            "KSWAPD_INODESTEAL",
            "reap"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_kswapd",
          "args": [],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "&inode->i_data",
            "0",
            "-1"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "remove_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "780-801",
          "snippet": "int remove_inode_buffers(struct inode *inode)\n{\n\tint ret = 1;\n\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct buffer_head *bh = BH_ENTRY(list->next);\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__remove_assoc_queue(bh);\n\t\t}\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nint remove_inode_buffers(struct inode *inode)\n{\n\tint ret = 1;\n\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list)) {\n\t\t\tstruct buffer_head *bh = BH_ENTRY(list->next);\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__remove_assoc_queue(bh);\n\t\t}\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iget",
          "args": [
            "inode"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "__iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "394-397",
          "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_has_buffers",
          "args": [
            "inode"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "inode_has_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "457-460",
          "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_unused"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_isolate",
          "args": [
            "lru",
            "&inode->i_lru"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structinode",
            "i_lru"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic enum lru_status inode_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct inode\t*inode = container_of(item, struct inode, i_lru);\n\n\t/*\n\t * we are inverting the lru lock/inode->i_lock here, so use a trylock.\n\t * If we fail to get the lock, just skip it.\n\t */\n\tif (!spin_trylock(&inode->i_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * Referenced or dirty inodes are still in use. Give them another pass\n\t * through the LRU as we canot reclaim them now.\n\t */\n\tif (atomic_read(&inode->i_count) ||\n\t    (inode->i_state & ~I_REFERENCED)) {\n\t\tlist_lru_isolate(lru, &inode->i_lru);\n\t\tspin_unlock(&inode->i_lock);\n\t\tthis_cpu_dec(nr_unused);\n\t\treturn LRU_REMOVED;\n\t}\n\n\t/*\n\t * Recently referenced inodes and inodes with many attached pages\n\t * get one more pass.\n\t */\n\tif (inode->i_state & I_REFERENCED || inode->i_data.nrpages > 1) {\n\t\tinode->i_state &= ~I_REFERENCED;\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn LRU_ROTATE;\n\t}\n\n\tif (inode_has_buffers(inode) || inode->i_data.nrpages) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tspin_unlock(lru_lock);\n\t\tif (remove_inode_buffers(inode)) {\n\t\t\tunsigned long reap;\n\t\t\treap = invalidate_mapping_pages(&inode->i_data, 0, -1);\n\t\t\tif (current_is_kswapd())\n\t\t\t\t__count_vm_events(KSWAPD_INODESTEAL, reap);\n\t\t\telse\n\t\t\t\t__count_vm_events(PGINODESTEAL, reap);\n\t\t\tif (current->reclaim_state)\n\t\t\t\tcurrent->reclaim_state->reclaimed_slab += reap;\n\t\t}\n\t\tiput(inode);\n\t\tspin_lock(lru_lock);\n\t\treturn LRU_RETRY;\n\t}\n\n\tWARN_ON(inode->i_state & I_NEW);\n\tinode->i_state |= I_FREEING;\n\tlist_lru_isolate_move(lru, &inode->i_lru, freeable);\n\tspin_unlock(&inode->i_lock);\n\n\tthis_cpu_dec(nr_unused);\n\treturn LRU_REMOVED;\n}"
  },
  {
    "function_name": "invalidate_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "657-691",
    "snippet": "int invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "585-596",
          "snippet": "static void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb->s_inode_list_lock"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&inode->i_lru",
            "&dispose"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lru_list_del",
          "args": [
            "inode"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "inode_lru_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "430-435",
          "snippet": "static void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "inode",
            "next",
            "&sb->s_inodes",
            "i_sb_list"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint invalidate_inodes(struct super_block *sb, bool kill_dirty)\n{\n\tint busy = 0;\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tif (inode->i_state & I_DIRTY_ALL && !kill_dirty) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (atomic_read(&inode->i_count)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tbusy = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n\n\treturn busy;\n}"
  },
  {
    "function_name": "evict_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "607-644",
    "snippet": "void evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dispose_list",
          "args": [
            "&dispose"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "dispose_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "585-596",
          "snippet": "static void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb->s_inode_list_lock"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&inode->i_lru",
            "&dispose"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_lru_list_del",
          "args": [
            "inode"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "inode_lru_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "430-435",
          "snippet": "static void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "inode",
            "next",
            "&sb->s_inodes",
            "i_sb_list"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}"
  },
  {
    "function_name": "dispose_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "585-596",
    "snippet": "static void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evict",
          "args": [
            "inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "evict_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "607-644",
          "snippet": "void evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_lru"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structinode",
            "i_lru"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void dispose_list(struct list_head *head)\n{\n\twhile (!list_empty(head)) {\n\t\tstruct inode *inode;\n\n\t\tinode = list_first_entry(head, struct inode, i_lru);\n\t\tlist_del_init(&inode->i_lru);\n\n\t\tevict(inode);\n\t\tcond_resched();\n\t}\n}"
  },
  {
    "function_name": "evict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "537-576",
    "snippet": "static void evict(struct inode *inode)\n{\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(!list_empty(&inode->i_lru));\n\n\tif (!list_empty(&inode->i_io_list))\n\t\tinode_io_list_del(inode);\n\n\tinode_sb_list_del(inode);\n\n\t/*\n\t * Wait for flusher thread to be done with the inode so that filesystem\n\t * does not start destroying it while writeback is still running. Since\n\t * the inode has I_FREEING set, flusher thread won't start new work on\n\t * the inode.  We just have to wait for running writeback to finish.\n\t */\n\tinode_wait_for_writeback(inode);\n\n\tif (op->evict_inode) {\n\t\top->evict_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t}\n\tif (S_ISBLK(inode->i_mode) && inode->i_bdev)\n\t\tbd_forget(inode);\n\tif (S_ISCHR(inode->i_mode) && inode->i_cdev)\n\t\tcd_forget(inode);\n\n\tremove_inode_hash(inode);\n\n\tspin_lock(&inode->i_lock);\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tBUG_ON(inode->i_state != (I_FREEING | I_CLEAR));\n\tspin_unlock(&inode->i_lock);\n\n\tdestroy_inode(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inode",
          "args": [
            "inode"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "262-270",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_state != (I_FREEING | I_CLEAR)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_inode_hash",
          "args": [
            "inode"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__remove_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "494-501",
          "snippet": "void __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cd_forget",
          "args": [
            "inode"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "cd_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/char_dev.c",
          "lines": "429-436",
          "snippet": "void cd_forget(struct inode *inode)\n{\n\tspin_lock(&cdev_lock);\n\tlist_del_init(&inode->i_devices);\n\tinode->i_cdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&cdev_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(cdev_lock);\n\nvoid cd_forget(struct inode *inode)\n{\n\tspin_lock(&cdev_lock);\n\tlist_del_init(&inode->i_devices);\n\tinode->i_cdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&cdev_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bd_forget",
          "args": [
            "inode"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "bd_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "974-987",
          "snippet": "void bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tbdput(bdev);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid bd_forget(struct inode *inode)\n{\n\tstruct block_device *bdev = NULL;\n\n\tspin_lock(&bdev_lock);\n\tif (!sb_is_blkdev_sb(inode->i_sb))\n\t\tbdev = inode->i_bdev;\n\tinode->i_bdev = NULL;\n\tinode->i_mapping = &inode->i_data;\n\tspin_unlock(&bdev_lock);\n\n\tif (bdev)\n\t\tbdput(bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "504-521",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "op->evict_inode",
          "args": [
            "inode"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_wait_for_writeback",
          "args": [
            "inode"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "inode_wait_for_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "1206-1211",
          "snippet": "void inode_wait_for_writeback(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_wait_for_writeback(inode);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid inode_wait_for_writeback(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\t__inode_wait_for_writeback(inode);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_sb_list_del",
          "args": [
            "inode"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_io_list_del",
          "args": [
            "inode"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "inode_io_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "985-992",
          "snippet": "void inode_io_list_del(struct inode *inode)\n{\n\tstruct bdi_writeback *wb;\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid inode_io_list_del(struct inode *inode)\n{\n\tstruct bdi_writeback *wb;\n\n\twb = inode_to_wb_and_lock_list(inode);\n\tinode_io_list_del_locked(inode, wb);\n\tspin_unlock(&wb->list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_io_list"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&inode->i_lru)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(inode->i_state & I_FREEING)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void evict(struct inode *inode)\n{\n\tconst struct super_operations *op = inode->i_sb->s_op;\n\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(!list_empty(&inode->i_lru));\n\n\tif (!list_empty(&inode->i_io_list))\n\t\tinode_io_list_del(inode);\n\n\tinode_sb_list_del(inode);\n\n\t/*\n\t * Wait for flusher thread to be done with the inode so that filesystem\n\t * does not start destroying it while writeback is still running. Since\n\t * the inode has I_FREEING set, flusher thread won't start new work on\n\t * the inode.  We just have to wait for running writeback to finish.\n\t */\n\tinode_wait_for_writeback(inode);\n\n\tif (op->evict_inode) {\n\t\top->evict_inode(inode);\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\tclear_inode(inode);\n\t}\n\tif (S_ISBLK(inode->i_mode) && inode->i_bdev)\n\t\tbd_forget(inode);\n\tif (S_ISCHR(inode->i_mode) && inode->i_cdev)\n\t\tcd_forget(inode);\n\n\tremove_inode_hash(inode);\n\n\tspin_lock(&inode->i_lock);\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tBUG_ON(inode->i_state != (I_FREEING | I_CLEAR));\n\tspin_unlock(&inode->i_lock);\n\n\tdestroy_inode(inode);\n}"
  },
  {
    "function_name": "clear_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "504-521",
    "snippet": "void clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&inode->i_wb_list)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_state & I_CLEAR"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(inode->i_state & I_FREEING)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&inode->i_data.private_list)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_unlock_irq",
          "args": [
            "&inode->i_data.i_pages"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_data.nrexceptional"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode->i_data.nrpages"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_lock_irq",
          "args": [
            "&inode->i_data.i_pages"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\t/*\n\t * We have to cycle the i_pages lock here because reclaim can be in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free the mapping under it.\n\t */\n\txa_lock_irq(&inode->i_data.i_pages);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrexceptional);\n\txa_unlock_irq(&inode->i_data.i_pages);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\tBUG_ON(!list_empty(&inode->i_wb_list));\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
  },
  {
    "function_name": "__remove_inode_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "494-501",
    "snippet": "void __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&inode->i_hash"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __remove_inode_hash(struct inode *inode)\n{\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_del_init(&inode->i_hash);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
  },
  {
    "function_name": "__insert_inode_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "476-485",
    "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *inode_hashtable",
      "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode_hash_lock"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&inode->i_hash",
            "b"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash",
          "args": [
            "inode->i_sb",
            "hashval"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "__insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "476-485",
          "snippet": "void __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __insert_inode_hash(struct inode *inode, unsigned long hashval)\n{\n\tstruct hlist_head *b = inode_hashtable + hash(inode->i_sb, hashval);\n\n\tspin_lock(&inode_hash_lock);\n\tspin_lock(&inode->i_lock);\n\thlist_add_head(&inode->i_hash, b);\n\tspin_unlock(&inode->i_lock);\n\tspin_unlock(&inode_hash_lock);\n}"
  },
  {
    "function_name": "hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "458-466",
    "snippet": "static unsigned long hash(struct super_block *sb, unsigned long hashval)\n{\n\tunsigned long tmp;\n\n\ttmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) /\n\t\t\tL1_CACHE_BYTES;\n\ttmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) >> i_hash_shift);\n\treturn tmp & i_hash_mask;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int i_hash_mask",
      "static unsigned int i_hash_shift"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic unsigned int i_hash_mask;\nstatic unsigned int i_hash_shift;\n\nstatic unsigned long hash(struct super_block *sb, unsigned long hashval)\n{\n\tunsigned long tmp;\n\n\ttmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) /\n\t\t\tL1_CACHE_BYTES;\n\ttmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) >> i_hash_shift);\n\treturn tmp & i_hash_mask;\n}"
  },
  {
    "function_name": "inode_sb_list_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "449-456",
    "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_sb->s_inode_list_lock"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&inode->i_sb_list"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_sb->s_inode_list_lock"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_sb_list"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
  },
  {
    "function_name": "inode_sb_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "441-446",
    "snippet": "void inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_sb->s_inode_list_lock"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&inode->i_sb_list",
            "&inode->i_sb->s_inodes"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_sb->s_inode_list_lock"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_sb_list_add(struct inode *inode)\n{\n\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\tlist_add(&inode->i_sb_list, &inode->i_sb->s_inodes);\n\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n}"
  },
  {
    "function_name": "inode_lru_list_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "430-435",
    "snippet": "static void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_unused);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_unused"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&inode->i_sb->s_inode_lru",
            "&inode->i_lru"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_del(struct inode *inode)\n{\n\n\tif (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_dec(nr_unused);\n}"
  },
  {
    "function_name": "inode_add_lru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "421-427",
    "snippet": "void inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & SB_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_lru_list_add",
          "args": [
            "inode"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "inode_lru_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "408-414",
          "snippet": "static void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n\telse\n\t\tinode->i_state |= I_REFERENCED;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n\telse\n\t\tinode->i_state |= I_REFERENCED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&inode->i_count"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_add_lru(struct inode *inode)\n{\n\tif (!(inode->i_state & (I_DIRTY_ALL | I_SYNC |\n\t\t\t\tI_FREEING | I_WILL_FREE)) &&\n\t    !atomic_read(&inode->i_count) && inode->i_sb->s_flags & SB_ACTIVE)\n\t\tinode_lru_list_add(inode);\n}"
  },
  {
    "function_name": "inode_lru_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "408-414",
    "snippet": "static void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n\telse\n\t\tinode->i_state |= I_REFERENCED;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_unused);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "nr_unused"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_add",
          "args": [
            "&inode->i_sb->s_inode_lru",
            "&inode->i_lru"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void inode_lru_list_add(struct inode *inode)\n{\n\tif (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))\n\t\tthis_cpu_inc(nr_unused);\n\telse\n\t\tinode->i_state |= I_REFERENCED;\n}"
  },
  {
    "function_name": "ihold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "402-405",
    "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_inc_return(&inode->i_count) < 2"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&inode->i_count"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
  },
  {
    "function_name": "__iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "394-397",
    "snippet": "void __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&inode->i_count"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __iget(struct inode *inode)\n{\n\tatomic_inc(&inode->i_count);\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "384-389",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct inode *inode = (struct inode *) foo;\n\n\tinode_init_once(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "inode"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "371-381",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_io_list);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\t__address_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_io_list);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\t__address_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void init_once(void *foo)\n{\n\tstruct inode *inode = (struct inode *) foo;\n\n\tinode_init_once(inode);\n}"
  },
  {
    "function_name": "inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "371-381",
    "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_io_list);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\t__address_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_ordered_init",
          "args": [
            "inode"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__address_space_init_once",
          "args": [
            "&inode->i_data"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__address_space_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "350-357",
          "snippet": "static void __address_space_init_once(struct address_space *mapping)\n{\n\txa_init_flags(&mapping->i_pages, XA_FLAGS_LOCK_IRQ);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT_CACHED;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __address_space_init_once(struct address_space *mapping)\n{\n\txa_init_flags(&mapping->i_pages, XA_FLAGS_LOCK_IRQ);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT_CACHED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_lru"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_wb_list"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_io_list"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&inode->i_devices"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&inode->i_hash"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "inode",
            "0",
            "sizeof(*inode)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_io_list);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\t__address_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n}"
  },
  {
    "function_name": "address_space_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "359-363",
    "snippet": "void address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\t__address_space_init_once(mapping);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__address_space_init_once",
          "args": [
            "mapping"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__address_space_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "350-357",
          "snippet": "static void __address_space_init_once(struct address_space *mapping)\n{\n\txa_init_flags(&mapping->i_pages, XA_FLAGS_LOCK_IRQ);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT_CACHED;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __address_space_init_once(struct address_space *mapping)\n{\n\txa_init_flags(&mapping->i_pages, XA_FLAGS_LOCK_IRQ);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT_CACHED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mapping",
            "0",
            "sizeof(*mapping)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nvoid address_space_init_once(struct address_space *mapping)\n{\n\tmemset(mapping, 0, sizeof(*mapping));\n\t__address_space_init_once(mapping);\n}"
  },
  {
    "function_name": "__address_space_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "350-357",
    "snippet": "static void __address_space_init_once(struct address_space *mapping)\n{\n\txa_init_flags(&mapping->i_pages, XA_FLAGS_LOCK_IRQ);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT_CACHED;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mapping->private_lock"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mapping->private_list"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&mapping->i_mmap_rwsem"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xa_init_flags",
          "args": [
            "&mapping->i_pages",
            "XA_FLAGS_LOCK_IRQ"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __address_space_init_once(struct address_space *mapping)\n{\n\txa_init_flags(&mapping->i_pages, XA_FLAGS_LOCK_IRQ);\n\tinit_rwsem(&mapping->i_mmap_rwsem);\n\tINIT_LIST_HEAD(&mapping->private_list);\n\tspin_lock_init(&mapping->private_lock);\n\tmapping->i_mmap = RB_ROOT_CACHED;\n}"
  },
  {
    "function_name": "inc_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "339-347",
    "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & I_LINKABLE)"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_nlink == 0"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
  },
  {
    "function_name": "set_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "317-328",
    "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "300-306",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
  },
  {
    "function_name": "clear_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "300-306",
    "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
  },
  {
    "function_name": "drop_nlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "283-289",
    "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "inode->i_nlink == 0"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
  },
  {
    "function_name": "destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "262-270",
    "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "i_callback"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_sb->s_op->destroy_inode",
          "args": [
            "inode"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "262-270",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__destroy_inode",
          "args": [
            "inode"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "__destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "234-253",
          "snippet": "void __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tinode_detach_wb(inode);\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && !is_uncached_acl(inode->i_acl))\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && !is_uncached_acl(inode->i_default_acl))\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tinode_detach_wb(inode);\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && !is_uncached_acl(inode->i_acl))\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && !is_uncached_acl(inode->i_default_acl))\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!list_empty(&inode->i_lru)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&inode->i_lru"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
  },
  {
    "function_name": "i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "256-260",
    "snippet": "static void i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(inode_cachep, inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inode_cachep",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_cachep",
            "inode"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(inode_cachep, inode);\n}"
  },
  {
    "function_name": "__destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "234-253",
    "snippet": "void __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tinode_detach_wb(inode);\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && !is_uncached_acl(inode->i_acl))\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && !is_uncached_acl(inode->i_default_acl))\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_inodes"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "inode->i_default_acl"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_uncached_acl",
          "args": [
            "inode->i_default_acl"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "inode->i_acl"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_uncached_acl",
          "args": [
            "inode->i_acl"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_long_read(&inode->i_sb->s_remove_count) == 0"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&inode->i_sb->s_remove_count"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locks_free_lock_context",
          "args": [
            "inode"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "locks_free_lock_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "281-290",
          "snippet": "void\nlocks_free_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(ctx)) {\n\t\tlocks_check_ctx_lists(inode);\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *flctx_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic struct kmem_cache *flctx_cache;\n\nvoid\nlocks_free_lock_context(struct inode *inode)\n{\n\tstruct file_lock_context *ctx = inode->i_flctx;\n\n\tif (unlikely(ctx)) {\n\t\tlocks_check_ctx_lists(inode);\n\t\tkmem_cache_free(flctx_cache, ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_inode_delete",
          "args": [
            "inode"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_inode_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/notify/fsnotify.c",
          "lines": "33-36",
          "snippet": "void __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_inode_delete(struct inode *inode)\n{\n\tfsnotify_clear_marks_by_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_free",
          "args": [
            "inode"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_detach_wb",
          "args": [
            "inode"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "inode_has_buffers(inode)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_has_buffers",
          "args": [
            "inode"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "inode_has_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "457-460",
          "snippet": "int inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint inode_has_buffers(struct inode *inode)\n{\n\treturn !list_empty(&inode->i_data.private_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid __destroy_inode(struct inode *inode)\n{\n\tBUG_ON(inode_has_buffers(inode));\n\tinode_detach_wb(inode);\n\tsecurity_inode_free(inode);\n\tfsnotify_inode_delete(inode);\n\tlocks_free_lock_context(inode);\n\tif (!inode->i_nlink) {\n\t\tWARN_ON(atomic_long_read(&inode->i_sb->s_remove_count) == 0);\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (inode->i_acl && !is_uncached_acl(inode->i_acl))\n\t\tposix_acl_release(inode->i_acl);\n\tif (inode->i_default_acl && !is_uncached_acl(inode->i_default_acl))\n\t\tposix_acl_release(inode->i_default_acl);\n#endif\n\tthis_cpu_dec(nr_inodes);\n}"
  },
  {
    "function_name": "free_inode_nonrcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "228-231",
    "snippet": "void free_inode_nonrcu(struct inode *inode)\n{\n\tkmem_cache_free(inode_cachep, inode);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inode_cachep",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_cachep",
            "inode"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid free_inode_nonrcu(struct inode *inode)\n{\n\tkmem_cache_free(inode_cachep, inode);\n}"
  },
  {
    "function_name": "alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "205-226",
    "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *inode_cachep",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "inode_cachep",
            "inode"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_sb->s_op->destroy_inode",
          "args": [
            "inode"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "262-270",
          "snippet": "static void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic void destroy_inode(struct inode *inode)\n{\n\tBUG_ON(!list_empty(&inode->i_lru));\n\t__destroy_inode(inode);\n\tif (inode->i_sb->s_op->destroy_inode)\n\t\tinode->i_sb->s_op->destroy_inode(inode);\n\telse\n\t\tcall_rcu(&inode->i_rcu, i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode_init_always(sb, inode)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_init_always",
          "args": [
            "sb",
            "inode"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_always",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "130-202",
          "snippet": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\tif (sb->s_xattr)\n\t\tinode->i_opflags |= IOP_XATTR;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_write_hint = WRITE_LIFE_NOT_SET;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_link = NULL;\n\tinode->i_dir_seq = 0;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n#endif\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tinit_rwsem(&inode->i_rwsem);\n\tlockdep_set_class(&inode->i_rwsem, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping->wb_err = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations empty_aops = {\n};",
            "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nconst struct address_space_operations empty_aops = {\n};\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\tif (sb->s_xattr)\n\t\tinode->i_opflags |= IOP_XATTR;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_write_hint = WRITE_LIFE_NOT_SET;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_link = NULL;\n\tinode->i_dir_seq = 0;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n#endif\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tinit_rwsem(&inode->i_rwsem);\n\tlockdep_set_class(&inode->i_rwsem, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping->wb_err = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->alloc_inode",
          "args": [
            "sb"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "205-226",
          "snippet": "static struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic struct inode *alloc_inode(struct super_block *sb)\n{\n\tstruct inode *inode;\n\n\tif (sb->s_op->alloc_inode)\n\t\tinode = sb->s_op->alloc_inode(sb);\n\telse\n\t\tinode = kmem_cache_alloc(inode_cachep, GFP_KERNEL);\n\n\tif (!inode)\n\t\treturn NULL;\n\n\tif (unlikely(inode_init_always(sb, inode))) {\n\t\tif (inode->i_sb->s_op->destroy_inode)\n\t\t\tinode->i_sb->s_op->destroy_inode(inode);\n\t\telse\n\t\t\tkmem_cache_free(inode_cachep, inode);\n\t\treturn NULL;\n\t}\n\n\treturn inode;\n}"
  },
  {
    "function_name": "inode_init_always",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "130-202",
    "snippet": "int inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\tif (sb->s_xattr)\n\t\tinode->i_opflags |= IOP_XATTR;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_write_hint = WRITE_LIFE_NOT_SET;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_link = NULL;\n\tinode->i_dir_seq = 0;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n#endif\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tinit_rwsem(&inode->i_rwsem);\n\tlockdep_set_class(&inode->i_rwsem, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping->wb_err = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations empty_aops = {\n};",
      "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "nr_inodes"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&inode->i_dentry"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "mapping",
            "GFP_HIGHUSER_MOVABLE"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&mapping->i_mmap_writable",
            "0"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&inode->i_dio_count",
            "0"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_rwsem",
            "&sb->s_type->i_mutex_key"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&inode->i_rwsem"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&inode->i_lock",
            "&sb->s_type->i_lock_key"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&inode->i_lock"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_alloc",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&inode->i_writecount",
            "0"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&inode->i_count",
            "1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nconst struct address_space_operations empty_aops = {\n};\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint inode_init_always(struct super_block *sb, struct inode *inode)\n{\n\tstatic const struct inode_operations empty_iops;\n\tstatic const struct file_operations no_open_fops = {.open = no_open};\n\tstruct address_space *const mapping = &inode->i_data;\n\n\tinode->i_sb = sb;\n\tinode->i_blkbits = sb->s_blocksize_bits;\n\tinode->i_flags = 0;\n\tatomic_set(&inode->i_count, 1);\n\tinode->i_op = &empty_iops;\n\tinode->i_fop = &no_open_fops;\n\tinode->__i_nlink = 1;\n\tinode->i_opflags = 0;\n\tif (sb->s_xattr)\n\t\tinode->i_opflags |= IOP_XATTR;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tatomic_set(&inode->i_writecount, 0);\n\tinode->i_size = 0;\n\tinode->i_write_hint = WRITE_LIFE_NOT_SET;\n\tinode->i_blocks = 0;\n\tinode->i_bytes = 0;\n\tinode->i_generation = 0;\n\tinode->i_pipe = NULL;\n\tinode->i_bdev = NULL;\n\tinode->i_cdev = NULL;\n\tinode->i_link = NULL;\n\tinode->i_dir_seq = 0;\n\tinode->i_rdev = 0;\n\tinode->dirtied_when = 0;\n\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tinode->i_wb_frn_winner = 0;\n\tinode->i_wb_frn_avg_time = 0;\n\tinode->i_wb_frn_history = 0;\n#endif\n\n\tif (security_inode_alloc(inode))\n\t\tgoto out;\n\tspin_lock_init(&inode->i_lock);\n\tlockdep_set_class(&inode->i_lock, &sb->s_type->i_lock_key);\n\n\tinit_rwsem(&inode->i_rwsem);\n\tlockdep_set_class(&inode->i_rwsem, &sb->s_type->i_mutex_key);\n\n\tatomic_set(&inode->i_dio_count, 0);\n\n\tmapping->a_ops = &empty_aops;\n\tmapping->host = inode;\n\tmapping->flags = 0;\n\tmapping->wb_err = 0;\n\tatomic_set(&mapping->i_mmap_writable, 0);\n\tmapping_set_gfp_mask(mapping, GFP_HIGHUSER_MOVABLE);\n\tmapping->private_data = NULL;\n\tmapping->writeback_index = 0;\n\tinode->i_private = NULL;\n\tinode->i_mapping = mapping;\n\tINIT_HLIST_HEAD(&inode->i_dentry);\t/* buggered by rcu freeing */\n#ifdef CONFIG_FS_POSIX_ACL\n\tinode->i_acl = inode->i_default_acl = ACL_NOT_CACHED;\n#endif\n\n#ifdef CONFIG_FSNOTIFY\n\tinode->i_fsnotify_mask = 0;\n#endif\n\tinode->i_flctx = NULL;\n\tthis_cpu_inc(nr_inodes);\n\n\treturn 0;\nout:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "no_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "117-120",
    "snippet": "static int no_open(struct inode *inode, struct file *file)\n{\n\treturn -ENXIO;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __wait_on_freeing_inode(struct inode *inode);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic int no_open(struct inode *inode, struct file *file)\n{\n\treturn -ENXIO;\n}"
  },
  {
    "function_name": "proc_nr_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "108-114",
    "snippet": "int proc_nr_inodes(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tinodes_stat.nr_inodes = get_nr_inodes();\n\tinodes_stat.nr_unused = get_nr_inodes_unused();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct inodes_stat_t inodes_stat;",
      "static DEFINE_PER_CPU(unsigned long, nr_inodes);",
      "static DEFINE_PER_CPU(unsigned long, nr_unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_inodes_unused",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_inodes_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "88-95",
          "snippet": "static inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nstatic inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstruct inodes_stat_t inodes_stat;\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nint proc_nr_inodes(struct ctl_table *table, int write,\n\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tinodes_stat.nr_inodes = get_nr_inodes();\n\tinodes_stat.nr_unused = get_nr_inodes_unused();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "get_nr_dirty_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "97-102",
    "snippet": "long get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_nr_inodes_unused",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_inodes_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "88-95",
          "snippet": "static inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, nr_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nstatic inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nlong get_nr_dirty_inodes(void)\n{\n\t/* not actually dirty inodes, but a wild approximation */\n\tlong nr_dirty = get_nr_inodes() - get_nr_inodes_unused();\n\treturn nr_dirty > 0 ? nr_dirty : 0;\n}"
  },
  {
    "function_name": "get_nr_inodes_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "88-95",
    "snippet": "static inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_unused);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_unused);\n\nstatic inline long get_nr_inodes_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}"
  },
  {
    "function_name": "get_nr_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
    "lines": "79-86",
    "snippet": "static long get_nr_inodes(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_inodes, i);\n\treturn sum < 0 ? 0 : sum;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <trace/events/writeback.h>",
      "#include <linux/iversion.h>",
      "#include <linux/list_lru.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/buffer_head.h> /* for inode_has_buffers */",
      "#include <linux/prefetch.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cdev.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/hash.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(unsigned long, nr_inodes);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(unsigned long, nr_inodes);\n\nstatic long get_nr_inodes(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_inodes, i);\n\treturn sum < 0 ? 0 : sum;\n}"
  }
]