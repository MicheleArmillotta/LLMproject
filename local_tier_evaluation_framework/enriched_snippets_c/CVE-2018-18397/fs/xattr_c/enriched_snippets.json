[
  {
    "function_name": "simple_xattr_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "985-991",
    "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_xattr->list",
            "&xattrs->head"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
  },
  {
    "function_name": "simple_xattr_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "942-980",
    "snippet": "ssize_t simple_xattr_list(struct inode *inode, struct simple_xattrs *xattrs,\n\t\t\t  char *buffer, size_t size)\n{\n\tbool trusted = capable(CAP_SYS_ADMIN);\n\tstruct simple_xattr *xattr;\n\tssize_t remaining_size = size;\n\tint err = 0;\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (IS_POSIXACL(inode)) {\n\t\tif (inode->i_acl) {\n\t\t\terr = xattr_list_one(&buffer, &remaining_size,\n\t\t\t\t\t     XATTR_NAME_POSIX_ACL_ACCESS);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (inode->i_default_acl) {\n\t\t\terr = xattr_list_one(&buffer, &remaining_size,\n\t\t\t\t\t     XATTR_NAME_POSIX_ACL_DEFAULT);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n#endif\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\t/* skip \"trusted.\" attributes for unprivileged callers */\n\t\tif (!trusted && xattr_is_trusted(xattr->name))\n\t\t\tcontinue;\n\n\t\terr = xattr_list_one(&buffer, &remaining_size, xattr->name);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&xattrs->lock);\n\n\treturn err ? err : size - remaining_size;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_list_one",
          "args": [
            "&buffer",
            "&remaining_size",
            "xattr->name"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_list_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "925-937",
          "snippet": "static int xattr_list_one(char **buffer, ssize_t *remaining_size,\n\t\t\t  const char *name)\n{\n\tsize_t len = strlen(name) + 1;\n\tif (*buffer) {\n\t\tif (*remaining_size < len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(*buffer, name, len);\n\t\t*buffer += len;\n\t}\n\t*remaining_size -= len;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int xattr_list_one(char **buffer, ssize_t *remaining_size,\n\t\t\t  const char *name)\n{\n\tsize_t len = strlen(name) + 1;\n\tif (*buffer) {\n\t\tif (*remaining_size < len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(*buffer, name, len);\n\t\t*buffer += len;\n\t}\n\t*remaining_size -= len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_is_trusted",
          "args": [
            "xattr->name"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_is_trusted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "920-923",
          "snippet": "static bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "xattr",
            "&xattrs->head",
            "list"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "inode"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t simple_xattr_list(struct inode *inode, struct simple_xattrs *xattrs,\n\t\t\t  char *buffer, size_t size)\n{\n\tbool trusted = capable(CAP_SYS_ADMIN);\n\tstruct simple_xattr *xattr;\n\tssize_t remaining_size = size;\n\tint err = 0;\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tif (IS_POSIXACL(inode)) {\n\t\tif (inode->i_acl) {\n\t\t\terr = xattr_list_one(&buffer, &remaining_size,\n\t\t\t\t\t     XATTR_NAME_POSIX_ACL_ACCESS);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (inode->i_default_acl) {\n\t\t\terr = xattr_list_one(&buffer, &remaining_size,\n\t\t\t\t\t     XATTR_NAME_POSIX_ACL_DEFAULT);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n#endif\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\t/* skip \"trusted.\" attributes for unprivileged callers */\n\t\tif (!trusted && xattr_is_trusted(xattr->name))\n\t\t\tcontinue;\n\n\t\terr = xattr_list_one(&buffer, &remaining_size, xattr->name);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&xattrs->lock);\n\n\treturn err ? err : size - remaining_size;\n}"
  },
  {
    "function_name": "xattr_list_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "925-937",
    "snippet": "static int xattr_list_one(char **buffer, ssize_t *remaining_size,\n\t\t\t  const char *name)\n{\n\tsize_t len = strlen(name) + 1;\n\tif (*buffer) {\n\t\tif (*remaining_size < len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(*buffer, name, len);\n\t\t*buffer += len;\n\t}\n\t*remaining_size -= len;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*buffer",
            "name",
            "len"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int xattr_list_one(char **buffer, ssize_t *remaining_size,\n\t\t\t  const char *name)\n{\n\tsize_t len = strlen(name) + 1;\n\tif (*buffer) {\n\t\tif (*remaining_size < len)\n\t\t\treturn -ERANGE;\n\t\tmemcpy(*buffer, name, len);\n\t\t*buffer += len;\n\t}\n\t*remaining_size -= len;\n\treturn 0;\n}"
  },
  {
    "function_name": "xattr_is_trusted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "920-923",
    "snippet": "static bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic bool xattr_is_trusted(const char *name)\n{\n\treturn !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN);\n}"
  },
  {
    "function_name": "simple_xattr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "869-918",
    "snippet": "int simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *xattr;\n\tstruct simple_xattr *new_xattr = NULL;\n\tint err = 0;\n\n\t/* value == NULL means remove */\n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!new_xattr->name) {\n\t\t\tkfree(new_xattr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (!strcmp(name, xattr->name)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\txattr = new_xattr;\n\t\t\t\terr = -EEXIST;\n\t\t\t} else if (new_xattr) {\n\t\t\t\tlist_replace(&xattr->list, &new_xattr->list);\n\t\t\t} else {\n\t\t\t\tlist_del(&xattr->list);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & XATTR_REPLACE) {\n\t\txattr = new_xattr;\n\t\terr = -ENODATA;\n\t} else {\n\t\tlist_add(&new_xattr->list, &xattrs->head);\n\t\txattr = NULL;\n\t}\nout:\n\tspin_unlock(&xattrs->lock);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_xattr->list",
            "&xattrs->head"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&xattr->list"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace",
          "args": [
            "&xattr->list",
            "&new_xattr->list"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "nilfs_list_replace_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nilfs2/segment.c",
          "lines": "1532-1539",
          "snippet": "static void nilfs_list_replace_buffer(struct buffer_head *old_bh,\n\t\t\t\t      struct buffer_head *new_bh)\n{\n\tBUG_ON(!list_empty(&new_bh->b_assoc_buffers));\n\n\tlist_replace_init(&old_bh->b_assoc_buffers, &new_bh->b_assoc_buffers);\n\t/* The caller must release old_bh */\n}",
          "includes": [
            "#include <trace/events/nilfs2.h>",
            "#include \"segbuf.h\"",
            "#include \"ifile.h\"",
            "#include \"cpfile.h\"",
            "#include \"sufile.h\"",
            "#include \"segment.h\"",
            "#include \"page.h\"",
            "#include \"btnode.h\"",
            "#include \"nilfs.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/crc32.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/completion.h>",
            "#include <linux/bio.h>",
            "#include <linux/bitops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/nilfs2.h>\n#include \"segbuf.h\"\n#include \"ifile.h\"\n#include \"cpfile.h\"\n#include \"sufile.h\"\n#include \"segment.h\"\n#include \"page.h\"\n#include \"btnode.h\"\n#include \"nilfs.h\"\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/pagevec.h>\n#include <linux/crc32.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/bio.h>\n#include <linux/bitops.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n\nstatic void nilfs_list_replace_buffer(struct buffer_head *old_bh,\n\t\t\t\t      struct buffer_head *new_bh)\n{\n\tBUG_ON(!list_empty(&new_bh->b_assoc_buffers));\n\n\tlist_replace_init(&old_bh->b_assoc_buffers, &new_bh->b_assoc_buffers);\n\t/* The caller must release old_bh */\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "xattr->name"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "27-35",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "xattr",
            "&xattrs->head",
            "list"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_xattr_alloc",
          "args": [
            "value",
            "size"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "809-826",
          "snippet": "struct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t/* wrap around? */\n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kmalloc(len, GFP_KERNEL);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t/* wrap around? */\n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kmalloc(len, GFP_KERNEL);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint simple_xattr_set(struct simple_xattrs *xattrs, const char *name,\n\t\t     const void *value, size_t size, int flags)\n{\n\tstruct simple_xattr *xattr;\n\tstruct simple_xattr *new_xattr = NULL;\n\tint err = 0;\n\n\t/* value == NULL means remove */\n\tif (value) {\n\t\tnew_xattr = simple_xattr_alloc(value, size);\n\t\tif (!new_xattr)\n\t\t\treturn -ENOMEM;\n\n\t\tnew_xattr->name = kstrdup(name, GFP_KERNEL);\n\t\tif (!new_xattr->name) {\n\t\t\tkfree(new_xattr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (!strcmp(name, xattr->name)) {\n\t\t\tif (flags & XATTR_CREATE) {\n\t\t\t\txattr = new_xattr;\n\t\t\t\terr = -EEXIST;\n\t\t\t} else if (new_xattr) {\n\t\t\t\tlist_replace(&xattr->list, &new_xattr->list);\n\t\t\t} else {\n\t\t\t\tlist_del(&xattr->list);\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (flags & XATTR_REPLACE) {\n\t\txattr = new_xattr;\n\t\terr = -ENODATA;\n\t} else {\n\t\tlist_add(&new_xattr->list, &xattrs->head);\n\t\txattr = NULL;\n\t}\nout:\n\tspin_unlock(&xattrs->lock);\n\tif (xattr) {\n\t\tkfree(xattr->name);\n\t\tkfree(xattr);\n\t}\n\treturn err;\n\n}"
  },
  {
    "function_name": "simple_xattr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "831-853",
    "snippet": "int simple_xattr_get(struct simple_xattrs *xattrs, const char *name,\n\t\t     void *buffer, size_t size)\n{\n\tstruct simple_xattr *xattr;\n\tint ret = -ENODATA;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (strcmp(name, xattr->name))\n\t\t\tcontinue;\n\n\t\tret = xattr->size;\n\t\tif (buffer) {\n\t\t\tif (size < xattr->size)\n\t\t\t\tret = -ERANGE;\n\t\t\telse\n\t\t\t\tmemcpy(buffer, xattr->value, xattr->size);\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&xattrs->lock);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "xattr->value",
            "xattr->size"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "xattr->name"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "27-35",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "xattr",
            "&xattrs->head",
            "list"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&xattrs->lock"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint simple_xattr_get(struct simple_xattrs *xattrs, const char *name,\n\t\t     void *buffer, size_t size)\n{\n\tstruct simple_xattr *xattr;\n\tint ret = -ENODATA;\n\n\tspin_lock(&xattrs->lock);\n\tlist_for_each_entry(xattr, &xattrs->head, list) {\n\t\tif (strcmp(name, xattr->name))\n\t\t\tcontinue;\n\n\t\tret = xattr->size;\n\t\tif (buffer) {\n\t\t\tif (size < xattr->size)\n\t\t\t\tret = -ERANGE;\n\t\t\telse\n\t\t\t\tmemcpy(buffer, xattr->value, xattr->size);\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock(&xattrs->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "simple_xattr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "809-826",
    "snippet": "struct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t/* wrap around? */\n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kmalloc(len, GFP_KERNEL);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_xattr->value",
            "value",
            "size"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct simple_xattr *simple_xattr_alloc(const void *value, size_t size)\n{\n\tstruct simple_xattr *new_xattr;\n\tsize_t len;\n\n\t/* wrap around? */\n\tlen = sizeof(*new_xattr) + size;\n\tif (len < sizeof(*new_xattr))\n\t\treturn NULL;\n\n\tnew_xattr = kmalloc(len, GFP_KERNEL);\n\tif (!new_xattr)\n\t\treturn NULL;\n\n\tnew_xattr->size = size;\n\tmemcpy(new_xattr->value, value, size);\n\treturn new_xattr;\n}"
  },
  {
    "function_name": "xattr_full_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "797-803",
    "snippet": "const char *xattr_full_name(const struct xattr_handler *handler,\n\t\t\t    const char *name)\n{\n\tsize_t prefix_len = strlen(xattr_prefix(handler));\n\n\treturn name - prefix_len;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "xattr_prefix(handler)"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_prefix",
          "args": [
            "handler"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/xattr.c",
          "lines": "541-548",
          "snippet": "static inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\treturn handler ? xattr_prefix(handler) : NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};\n\nstatic inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\treturn handler ? xattr_prefix(handler) : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nconst char *xattr_full_name(const struct xattr_handler *handler,\n\t\t\t    const char *name)\n{\n\tsize_t prefix_len = strlen(xattr_prefix(handler));\n\n\treturn name - prefix_len;\n}"
  },
  {
    "function_name": "generic_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "748-779",
    "snippet": "ssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tunsigned int size = 0;\n\n\tif (!buffer) {\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tif (!handler->name ||\n\t\t\t    (handler->list && !handler->list(dentry)))\n\t\t\t\tcontinue;\n\t\t\tsize += strlen(handler->name) + 1;\n\t\t}\n\t} else {\n\t\tchar *buf = buffer;\n\t\tsize_t len;\n\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tif (!handler->name ||\n\t\t\t    (handler->list && !handler->list(dentry)))\n\t\t\t\tcontinue;\n\t\t\tlen = strlen(handler->name);\n\t\t\tif (len + 1 > buffer_size)\n\t\t\t\treturn -ERANGE;\n\t\t\tmemcpy(buf, handler->name, len + 1);\n\t\t\tbuf += len + 1;\n\t\t\tbuffer_size -= len + 1;\n\t\t}\n\t\tsize = buf - buffer;\n\t}\n\treturn size;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "handler->name",
            "len + 1"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "handler->name"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "xdr_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/afs/yfsclient.c",
          "lines": "67-70",
          "snippet": "static size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}",
          "includes": [
            "#include \"protocol_yfs.h\"",
            "#include \"xdr_fs.h\"",
            "#include \"afs_fs.h\"",
            "#include \"internal.h\"",
            "#include <linux/iversion.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"protocol_yfs.h\"\n#include \"xdr_fs.h\"\n#include \"afs_fs.h\"\n#include \"internal.h\"\n#include <linux/iversion.h>\n#include <linux/circ_buf.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstatic size_t xdr_strlen(unsigned int len)\n{\n\treturn sizeof(__be32) + round_up(len, sizeof(__be32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "dentry"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_xattr_handler",
          "args": [
            "handlers",
            "handler"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler->list",
          "args": [
            "dentry"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_xattr_handler",
          "args": [
            "handlers",
            "handler"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tunsigned int size = 0;\n\n\tif (!buffer) {\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tif (!handler->name ||\n\t\t\t    (handler->list && !handler->list(dentry)))\n\t\t\t\tcontinue;\n\t\t\tsize += strlen(handler->name) + 1;\n\t\t}\n\t} else {\n\t\tchar *buf = buffer;\n\t\tsize_t len;\n\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tif (!handler->name ||\n\t\t\t    (handler->list && !handler->list(dentry)))\n\t\t\t\tcontinue;\n\t\t\tlen = strlen(handler->name);\n\t\t\tif (len + 1 > buffer_size)\n\t\t\t\treturn -ERANGE;\n\t\t\tmemcpy(buf, handler->name, len + 1);\n\t\t\tbuf += len + 1;\n\t\t\tbuffer_size -= len + 1;\n\t\t}\n\t\tsize = buf - buffer;\n\t}\n\treturn size;\n}"
  },
  {
    "function_name": "path_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "693-713",
    "snippet": "static int path_removexattr(const char __user *pathname,\n\t\t\t    const char __user *name, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = removexattr(path.dentry, name);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path.mnt"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "removexattr",
          "args": [
            "path.dentry",
            "name"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "678-691",
          "snippet": "static long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path.mnt"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int path_removexattr(const char __user *pathname,\n\t\t\t    const char __user *name, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = removexattr(path.dentry, name);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "678-691",
    "snippet": "static long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_removexattr",
          "args": [
            "d",
            "kname"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "380-405",
          "snippet": "int\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_removexattr(dentry, name);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\nout:\n\tinode_unlock(inode);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_removexattr(dentry, name);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\nout:\n\tinode_unlock(inode);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "kname",
            "name",
            "sizeof(kname)"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nremovexattr(struct dentry *d, const char __user *name)\n{\n\tint error;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\treturn vfs_removexattr(d, kname);\n}"
  },
  {
    "function_name": "path_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "632-648",
    "snippet": "static ssize_t path_listxattr(const char __user *pathname, char __user *list,\n\t\t\t      size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = listxattr(path.dentry, list, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "listxattr",
          "args": [
            "path.dentry",
            "list",
            "size"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "generic_listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "748-779",
          "snippet": "ssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tunsigned int size = 0;\n\n\tif (!buffer) {\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tif (!handler->name ||\n\t\t\t    (handler->list && !handler->list(dentry)))\n\t\t\t\tcontinue;\n\t\t\tsize += strlen(handler->name) + 1;\n\t\t}\n\t} else {\n\t\tchar *buf = buffer;\n\t\tsize_t len;\n\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tif (!handler->name ||\n\t\t\t    (handler->list && !handler->list(dentry)))\n\t\t\t\tcontinue;\n\t\t\tlen = strlen(handler->name);\n\t\t\tif (len + 1 > buffer_size)\n\t\t\t\treturn -ERANGE;\n\t\t\tmemcpy(buf, handler->name, len + 1);\n\t\t\tbuf += len + 1;\n\t\t\tbuffer_size -= len + 1;\n\t\t}\n\t\tsize = buf - buffer;\n\t}\n\treturn size;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\ngeneric_listxattr(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tconst struct xattr_handler *handler, **handlers = dentry->d_sb->s_xattr;\n\tunsigned int size = 0;\n\n\tif (!buffer) {\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tif (!handler->name ||\n\t\t\t    (handler->list && !handler->list(dentry)))\n\t\t\t\tcontinue;\n\t\t\tsize += strlen(handler->name) + 1;\n\t\t}\n\t} else {\n\t\tchar *buf = buffer;\n\t\tsize_t len;\n\n\t\tfor_each_xattr_handler(handlers, handler) {\n\t\t\tif (!handler->name ||\n\t\t\t    (handler->list && !handler->list(dentry)))\n\t\t\t\tcontinue;\n\t\t\tlen = strlen(handler->name);\n\t\t\tif (len + 1 > buffer_size)\n\t\t\t\treturn -ERANGE;\n\t\t\tmemcpy(buf, handler->name, len + 1);\n\t\t\tbuf += len + 1;\n\t\t\tbuffer_size -= len + 1;\n\t\t}\n\t\tsize = buf - buffer;\n\t}\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t path_listxattr(const char __user *pathname, char __user *list,\n\t\t\t      size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = listxattr(path.dentry, list, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "603-630",
    "snippet": "static ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kvmalloc(size, GFP_KERNEL);\n\t\tif (!klist)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(klist);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "klist"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "list",
            "klist",
            "error"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_listxattr",
          "args": [
            "d",
            "klist",
            "size"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "345-362",
          "snippet": "ssize_t\nvfs_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tssize_t error;\n\n\terror = security_inode_listxattr(dentry);\n\tif (error)\n\t\treturn error;\n\tif (inode->i_op->listxattr && (inode->i_opflags & IOP_XATTR)) {\n\t\terror = inode->i_op->listxattr(dentry, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tssize_t error;\n\n\terror = security_inode_listxattr(dentry);\n\tif (error)\n\t\treturn error;\n\tif (inode->i_op->listxattr && (inode->i_opflags & IOP_XATTR)) {\n\t\terror = inode->i_op->listxattr(dentry, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/super.c",
          "lines": "183-191",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"fsmap.h\"",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/iversion.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/dax.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/iversion.h>\n#include <linux/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/dax.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kvmalloc(size, GFP_KERNEL);\n\t\tif (!klist)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(klist);\n\n\treturn error;\n}"
  },
  {
    "function_name": "path_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "555-572",
    "snippet": "static ssize_t path_getxattr(const char __user *pathname,\n\t\t\t     const char __user *name, void __user *value,\n\t\t\t     size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = getxattr(path.dentry, name, value, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getxattr",
          "args": [
            "path.dentry",
            "name",
            "value",
            "size"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "515-553",
          "snippet": "static ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kvzalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, error);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(kvalue);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kvzalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, error);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(kvalue);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t path_getxattr(const char __user *pathname,\n\t\t\t     const char __user *name, void __user *value,\n\t\t\t     size_t size, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tssize_t error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = getxattr(path.dentry, name, value, size);\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "515-553",
    "snippet": "static ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kvzalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, error);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(kvalue);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "kvalue"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "value",
            "kvalue",
            "error"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_fix_xattr_to_user",
          "args": [
            "kvalue",
            "error"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_fix_xattr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "712-718",
          "snippet": "void posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid posix_acl_fix_xattr_to_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kname",
            "XATTR_NAME_POSIX_ACL_DEFAULT"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "27-35",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_getxattr",
          "args": [
            "d",
            "kname",
            "kvalue",
            "size"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "314-342",
          "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\treturn __vfs_getxattr(dentry, inode, name, value, size);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\treturn __vfs_getxattr(dentry, inode, name, value, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvzalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/super.c",
          "lines": "193-201",
          "snippet": "void *ext4_kvzalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kzalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags | __GFP_ZERO, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"fsmap.h\"",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/iversion.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/dax.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/iversion.h>\n#include <linux/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/dax.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvzalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kzalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags | __GFP_ZERO, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "kname",
            "name",
            "sizeof(kname)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\ngetxattr(struct dentry *d, const char __user *name, void __user *value,\n\t size_t size)\n{\n\tssize_t error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\tsize = XATTR_SIZE_MAX;\n\t\tkvalue = kvzalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_getxattr(d, kname, kvalue, size);\n\tif (error > 0) {\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_to_user(kvalue, error);\n\t\tif (size && copy_to_user(value, kvalue, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_SIZE_MAX) {\n\t\t/* The file system tried to returned a value bigger\n\t\t   than XATTR_SIZE_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(kvalue);\n\n\treturn error;\n}"
  },
  {
    "function_name": "path_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "457-478",
    "snippet": "static int path_setxattr(const char __user *pathname,\n\t\t\t const char __user *name, const void __user *value,\n\t\t\t size_t size, int flags, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = setxattr(path.dentry, name, value, size, flags);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retry_estale",
          "args": [
            "error",
            "lookup_flags"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write",
          "args": [
            "path.mnt"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "461-465",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\t__mnt_drop_write_file(file);\n\tsb_end_write(file_inode(file)->i_sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setxattr",
          "args": [
            "path.dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "412-455",
          "snippet": "static long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kvmalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t\telse if (strcmp(kname, XATTR_NAME_CAPS) == 0) {\n\t\t\terror = cap_convert_nscap(d, &kvalue, size);\n\t\t\tif (error < 0)\n\t\t\t\tgoto out;\n\t\t\tsize = error;\n\t\t}\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tkvfree(kvalue);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kvmalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t\telse if (strcmp(kname, XATTR_NAME_CAPS) == 0) {\n\t\t\terror = cap_convert_nscap(d, &kvalue, size);\n\t\t\tif (error < 0)\n\t\t\t\tgoto out;\n\t\t\tsize = error;\n\t\t}\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tkvfree(kvalue);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write",
          "args": [
            "path.mnt"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "414-423",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\n__latent_entropy\nstruct;\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file_inode(file)->i_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file_inode(file)->i_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "pathname",
            "lookup_flags",
            "&path"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int path_setxattr(const char __user *pathname,\n\t\t\t const char __user *name, const void __user *value,\n\t\t\t size_t size, int flags, unsigned int lookup_flags)\n{\n\tstruct path path;\n\tint error;\nretry:\n\terror = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);\n\tif (error)\n\t\treturn error;\n\terror = mnt_want_write(path.mnt);\n\tif (!error) {\n\t\terror = setxattr(path.dentry, name, value, size, flags);\n\t\tmnt_drop_write(path.mnt);\n\t}\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tgoto retry;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "412-455",
    "snippet": "static long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kvmalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t\telse if (strcmp(kname, XATTR_NAME_CAPS) == 0) {\n\t\t\terror = cap_convert_nscap(d, &kvalue, size);\n\t\t\tif (error < 0)\n\t\t\t\tgoto out;\n\t\t\tsize = error;\n\t\t}\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tkvfree(kvalue);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "kvalue"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setxattr",
          "args": [
            "d",
            "kname",
            "kvalue",
            "size",
            "flags"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "207-228",
          "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tinode_unlock(inode);\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tinode_unlock(inode);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_convert_nscap",
          "args": [
            "d",
            "&kvalue",
            "size"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kname",
            "XATTR_NAME_CAPS"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "27-35",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_fix_xattr_from_user",
          "args": [
            "kvalue",
            "size"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_fix_xattr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/posix_acl.c",
          "lines": "704-710",
          "snippet": "void posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid posix_acl_fix_xattr_from_user(void *value, size_t size)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tif (user_ns == &init_user_ns)\n\t\treturn;\n\tposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kvalue",
            "value",
            "size"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/super.c",
          "lines": "183-191",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"fsmap.h\"",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/iversion.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/dax.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/iversion.h>\n#include <linux/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/dax.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "kname",
            "name",
            "sizeof(kname)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic long\nsetxattr(struct dentry *d, const char __user *name, const void __user *value,\n\t size_t size, int flags)\n{\n\tint error;\n\tvoid *kvalue = NULL;\n\tchar kname[XATTR_NAME_MAX + 1];\n\n\tif (flags & ~(XATTR_CREATE|XATTR_REPLACE))\n\t\treturn -EINVAL;\n\n\terror = strncpy_from_user(kname, name, sizeof(kname));\n\tif (error == 0 || error == sizeof(kname))\n\t\terror = -ERANGE;\n\tif (error < 0)\n\t\treturn error;\n\n\tif (size) {\n\t\tif (size > XATTR_SIZE_MAX)\n\t\t\treturn -E2BIG;\n\t\tkvalue = kvmalloc(size, GFP_KERNEL);\n\t\tif (!kvalue)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(kvalue, value, size)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((strcmp(kname, XATTR_NAME_POSIX_ACL_ACCESS) == 0) ||\n\t\t    (strcmp(kname, XATTR_NAME_POSIX_ACL_DEFAULT) == 0))\n\t\t\tposix_acl_fix_xattr_from_user(kvalue, size);\n\t\telse if (strcmp(kname, XATTR_NAME_CAPS) == 0) {\n\t\t\terror = cap_convert_nscap(d, &kvalue, size);\n\t\t\tif (error < 0)\n\t\t\t\tgoto out;\n\t\t\tsize = error;\n\t\t}\n\t}\n\n\terror = vfs_setxattr(d, kname, kvalue, size, flags);\nout:\n\tkvfree(kvalue);\n\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "380-405",
    "snippet": "int\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_removexattr(dentry, name);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\nout:\n\tinode_unlock(inode);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "evm_inode_post_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_xattr",
          "args": [
            "dentry"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_removexattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "365-377",
          "snippet": "int\n__vfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(handler, dentry, inode, name, NULL, 0, XATTR_REPLACE);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\n__vfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(handler, dentry, inode, name, NULL, 0, XATTR_REPLACE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_removexattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_permission",
          "args": [
            "inode",
            "name",
            "MAY_WRITE"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "84-134",
          "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\terror = security_inode_removexattr(dentry, name);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_removexattr(dentry, name);\n\n\tif (!error) {\n\t\tfsnotify_xattr(dentry);\n\t\tevm_inode_post_removexattr(dentry, name);\n\t}\n\nout:\n\tinode_unlock(inode);\n\treturn error;\n}"
  },
  {
    "function_name": "__vfs_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "365-377",
    "snippet": "int\n__vfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(handler, dentry, inode, name, NULL, 0, XATTR_REPLACE);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->set",
          "args": [
            "handler",
            "dentry",
            "inode",
            "name",
            "NULL",
            "0",
            "XATTR_REPLACE"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handler"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handler"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_resolve_name",
          "args": [
            "inode",
            "&name"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_resolve_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "52-78",
          "snippet": "static const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\n__vfs_removexattr(struct dentry *dentry, const char *name)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->set(handler, dentry, inode, name, NULL, 0, XATTR_REPLACE);\n}"
  },
  {
    "function_name": "vfs_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "345-362",
    "snippet": "ssize_t\nvfs_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tssize_t error;\n\n\terror = security_inode_listxattr(dentry);\n\tif (error)\n\t\treturn error;\n\tif (inode->i_op->listxattr && (inode->i_opflags & IOP_XATTR)) {\n\t\terror = inode->i_op->listxattr(dentry, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_inode_listsecurity",
          "args": [
            "inode",
            "list",
            "size"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_op->listxattr",
          "args": [
            "dentry",
            "list",
            "size"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "603-630",
          "snippet": "static ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kvmalloc(size, GFP_KERNEL);\n\t\tif (!klist)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(klist);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nlistxattr(struct dentry *d, char __user *list, size_t size)\n{\n\tssize_t error;\n\tchar *klist = NULL;\n\n\tif (size) {\n\t\tif (size > XATTR_LIST_MAX)\n\t\t\tsize = XATTR_LIST_MAX;\n\t\tklist = kvmalloc(size, GFP_KERNEL);\n\t\tif (!klist)\n\t\t\treturn -ENOMEM;\n\t}\n\n\terror = vfs_listxattr(d, klist, size);\n\tif (error > 0) {\n\t\tif (size && copy_to_user(list, klist, error))\n\t\t\terror = -EFAULT;\n\t} else if (error == -ERANGE && size >= XATTR_LIST_MAX) {\n\t\t/* The file system tried to returned a list bigger\n\t\t   than XATTR_LIST_MAX bytes. Not possible. */\n\t\terror = -E2BIG;\n\t}\n\n\tkvfree(klist);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_listxattr",
          "args": [
            "dentry"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_listxattr(struct dentry *dentry, char *list, size_t size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tssize_t error;\n\n\terror = security_inode_listxattr(dentry);\n\tif (error)\n\t\treturn error;\n\tif (inode->i_op->listxattr && (inode->i_opflags & IOP_XATTR)) {\n\t\terror = inode->i_op->listxattr(dentry, list, size);\n\t} else {\n\t\terror = security_inode_listsecurity(inode, list, size);\n\t\tif (size && error > size)\n\t\t\terror = -ERANGE;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "vfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "314-342",
    "snippet": "ssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\treturn __vfs_getxattr(dentry, inode, name, value, size);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfs_getxattr",
          "args": [
            "dentry",
            "inode",
            "name",
            "value",
            "size"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "299-311",
          "snippet": "ssize_t\n__vfs_getxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       void *value, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->get)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(handler, dentry, inode, name, value, size);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\n__vfs_getxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       void *value, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->get)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(handler, dentry, inode, name, value, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_getsecurity",
          "args": [
            "inode",
            "suffix",
            "value",
            "size"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_getsecurity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "231-255",
          "snippet": "static ssize_t\nxattr_getsecurity(struct inode *inode, const char *name, void *value,\n\t\t\tsize_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(inode, name, &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(inode, name, &buffer, true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tkfree(buffer);\nout_noalloc:\n\treturn len;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nxattr_getsecurity(struct inode *inode, const char *name, void *value,\n\t\t\tsize_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(inode, name, &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(inode, name, &buffer, true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tkfree(buffer);\nout_noalloc:\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getxattr",
          "args": [
            "dentry",
            "name"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_permission",
          "args": [
            "inode",
            "name",
            "MAY_READ"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "84-134",
          "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr(struct dentry *dentry, const char *name, void *value, size_t size)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\terror = security_inode_getxattr(dentry, name);\n\tif (error)\n\t\treturn error;\n\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\tXATTR_SECURITY_PREFIX_LEN)) {\n\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\t\tint ret = xattr_getsecurity(inode, suffix, value, size);\n\t\t/*\n\t\t * Only overwrite the return value if a security module\n\t\t * is actually active.\n\t\t */\n\t\tif (ret == -EOPNOTSUPP)\n\t\t\tgoto nolsm;\n\t\treturn ret;\n\t}\nnolsm:\n\treturn __vfs_getxattr(dentry, inode, name, value, size);\n}"
  },
  {
    "function_name": "__vfs_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "299-311",
    "snippet": "ssize_t\n__vfs_getxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       void *value, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->get)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(handler, dentry, inode, name, value, size);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->get",
          "args": [
            "handler",
            "dentry",
            "inode",
            "name",
            "value",
            "size"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handler"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handler"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_resolve_name",
          "args": [
            "inode",
            "&name"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_resolve_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "52-78",
          "snippet": "static const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\n__vfs_getxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       void *value, size_t size)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->get)\n\t\treturn -EOPNOTSUPP;\n\treturn handler->get(handler, dentry, inode, name, value, size);\n}"
  },
  {
    "function_name": "vfs_getxattr_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "265-297",
    "snippet": "ssize_t\nvfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,\n\t\t   size_t xattr_size, gfp_t flags)\n{\n\tconst struct xattr_handler *handler;\n\tstruct inode *inode = dentry->d_inode;\n\tchar *value = *xattr_value;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->get)\n\t\treturn -EOPNOTSUPP;\n\terror = handler->get(handler, dentry, inode, name, NULL, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!value || (error > xattr_size)) {\n\t\tvalue = krealloc(*xattr_value, error + 1, flags);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\tmemset(value, 0, error + 1);\n\t}\n\n\terror = handler->get(handler, dentry, inode, name, value, error);\n\t*xattr_value = value;\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->get",
          "args": [
            "handler",
            "dentry",
            "inode",
            "name",
            "value",
            "error"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "value",
            "0",
            "error + 1"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "*xattr_value",
            "error + 1",
            "flags"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handler->get",
          "args": [
            "handler",
            "dentry",
            "inode",
            "name",
            "NULL",
            "0"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handler"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handler"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_resolve_name",
          "args": [
            "inode",
            "&name"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_resolve_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "52-78",
          "snippet": "static const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_permission",
          "args": [
            "inode",
            "name",
            "MAY_READ"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "84-134",
          "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nssize_t\nvfs_getxattr_alloc(struct dentry *dentry, const char *name, char **xattr_value,\n\t\t   size_t xattr_size, gfp_t flags)\n{\n\tconst struct xattr_handler *handler;\n\tstruct inode *inode = dentry->d_inode;\n\tchar *value = *xattr_value;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_READ);\n\tif (error)\n\t\treturn error;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->get)\n\t\treturn -EOPNOTSUPP;\n\terror = handler->get(handler, dentry, inode, name, NULL, 0);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (!value || (error > xattr_size)) {\n\t\tvalue = krealloc(*xattr_value, error + 1, flags);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\tmemset(value, 0, error + 1);\n\t}\n\n\terror = handler->get(handler, dentry, inode, name, value, error);\n\t*xattr_value = value;\n\treturn error;\n}"
  },
  {
    "function_name": "xattr_getsecurity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "231-255",
    "snippet": "static ssize_t\nxattr_getsecurity(struct inode *inode, const char *name, void *value,\n\t\t\tsize_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(inode, name, &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(inode, name, &buffer, true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tkfree(buffer);\nout_noalloc:\n\treturn len;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "buffer",
            "len"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getsecurity",
          "args": [
            "inode",
            "name",
            "&buffer",
            "true"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_getsecurity",
          "args": [
            "inode",
            "name",
            "&buffer",
            "false"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic ssize_t\nxattr_getsecurity(struct inode *inode, const char *name, void *value,\n\t\t\tsize_t size)\n{\n\tvoid *buffer = NULL;\n\tssize_t len;\n\n\tif (!value || !size) {\n\t\tlen = security_inode_getsecurity(inode, name, &buffer, false);\n\t\tgoto out_noalloc;\n\t}\n\n\tlen = security_inode_getsecurity(inode, name, &buffer, true);\n\tif (len < 0)\n\t\treturn len;\n\tif (size < len) {\n\t\tlen = -ERANGE;\n\t\tgoto out;\n\t}\n\tmemcpy(value, buffer, len);\nout:\n\tkfree(buffer);\nout_noalloc:\n\treturn len;\n}"
  },
  {
    "function_name": "vfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "207-228",
    "snippet": "int\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tinode_unlock(inode);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "inode"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/overlayfs.h",
          "lines": "298-301",
          "snippet": "static inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}",
          "includes": [
            "#include \"ovl_entry.h\"",
            "#include <linux/fs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct dentry *ovl_i_dentry_upper(struct inode *inode);",
            "struct inode *ovl_inode_upper(struct inode *inode);",
            "struct inode *ovl_inode_lower(struct inode *inode);",
            "struct inode *ovl_inode_lowerdata(struct inode *inode);",
            "struct inode *ovl_inode_real(struct inode *inode);",
            "struct inode *ovl_inode_realdata(struct inode *inode);",
            "struct ovl_dir_cache *ovl_dir_cache(struct inode *inode);",
            "bool ovl_has_upperdata(struct inode *inode);",
            "void ovl_set_upperdata(struct inode *inode);",
            "void ovl_set_flag(unsigned long flag, struct inode *inode);",
            "void ovl_clear_flag(unsigned long flag, struct inode *inode);",
            "bool ovl_test_flag(unsigned long flag, struct inode *inode);",
            "void ovl_dir_cache_free(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ovl_entry.h\"\n#include <linux/fs.h>\n#include <linux/uuid.h>\n#include <linux/kernel.h>\n\nstruct dentry *ovl_i_dentry_upper(struct inode *inode);\nstruct inode *ovl_inode_upper(struct inode *inode);\nstruct inode *ovl_inode_lower(struct inode *inode);\nstruct inode *ovl_inode_lowerdata(struct inode *inode);\nstruct inode *ovl_inode_real(struct inode *inode);\nstruct inode *ovl_inode_realdata(struct inode *inode);\nstruct ovl_dir_cache *ovl_dir_cache(struct inode *inode);\nbool ovl_has_upperdata(struct inode *inode);\nvoid ovl_set_upperdata(struct inode *inode);\nvoid ovl_set_flag(unsigned long flag, struct inode *inode);\nvoid ovl_clear_flag(unsigned long flag, struct inode *inode);\nbool ovl_test_flag(unsigned long flag, struct inode *inode);\nvoid ovl_dir_cache_free(struct inode *inode);\n\nstatic inline void ovl_inode_unlock(struct inode *inode)\n{\n\tmutex_unlock(&OVL_I(inode)->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vfs_setxattr_noperm",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_setxattr_noperm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "169-204",
          "snippet": "int __vfs_setxattr_noperm(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EAGAIN;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_opflags & IOP_XATTR) {\n\t\terror = __vfs_setxattr(dentry, inode, name, value, size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn -EIO;\n\t}\n\tif (error == -EAGAIN) {\n\t\terror = -EOPNOTSUPP;\n\n\t\tif (issec) {\n\t\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\n\t\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t\t   size, flags);\n\t\t\tif (!error)\n\t\t\t\tfsnotify_xattr(dentry);\n\t\t}\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint __vfs_setxattr_noperm(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EAGAIN;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_opflags & IOP_XATTR) {\n\t\terror = __vfs_setxattr(dentry, inode, name, value, size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn -EIO;\n\t}\n\tif (error == -EAGAIN) {\n\t\terror = -EOPNOTSUPP;\n\n\t\tif (issec) {\n\t\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\n\t\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t\t   size, flags);\n\t\t\tif (!error)\n\t\t\t\tfsnotify_xattr(dentry);\n\t\t}\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "inode"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "insert_inode_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1437-1481",
          "snippet": "int insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint insert_inode_locked(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tino_t ino = inode->i_ino;\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\n\twhile (1) {\n\t\tstruct inode *old = NULL;\n\t\tspin_lock(&inode_hash_lock);\n\t\thlist_for_each_entry(old, head, i_hash) {\n\t\t\tif (old->i_ino != ino)\n\t\t\t\tcontinue;\n\t\t\tif (old->i_sb != sb)\n\t\t\t\tcontinue;\n\t\t\tspin_lock(&old->i_lock);\n\t\t\tif (old->i_state & (I_FREEING|I_WILL_FREE)) {\n\t\t\t\tspin_unlock(&old->i_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (likely(!old)) {\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state |= I_NEW | I_CREATING;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tif (unlikely(old->i_state & I_CREATING)) {\n\t\t\tspin_unlock(&old->i_lock);\n\t\t\tspin_unlock(&inode_hash_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t__iget(old);\n\t\tspin_unlock(&old->i_lock);\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(!inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tiput(old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_permission",
          "args": [
            "inode",
            "name",
            "MAY_WRITE"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "84-134",
          "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\nvfs_setxattr(struct dentry *dentry, const char *name, const void *value,\n\t\tsize_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error;\n\n\terror = xattr_permission(inode, name, MAY_WRITE);\n\tif (error)\n\t\treturn error;\n\n\tinode_lock(inode);\n\terror = security_inode_setxattr(dentry, name, value, size, flags);\n\tif (error)\n\t\tgoto out;\n\n\terror = __vfs_setxattr_noperm(dentry, name, value, size, flags);\n\nout:\n\tinode_unlock(inode);\n\treturn error;\n}"
  },
  {
    "function_name": "__vfs_setxattr_noperm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "169-204",
    "snippet": "int __vfs_setxattr_noperm(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EAGAIN;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_opflags & IOP_XATTR) {\n\t\terror = __vfs_setxattr(dentry, inode, name, value, size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn -EIO;\n\t}\n\tif (error == -EAGAIN) {\n\t\terror = -EOPNOTSUPP;\n\n\t\tif (issec) {\n\t\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\n\t\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t\t   size, flags);\n\t\t\tif (!error)\n\t\t\t\tfsnotify_xattr(dentry);\n\t\t}\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_xattr",
          "args": [
            "dentry"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_inode_setsecurity",
          "args": [
            "inode",
            "suffix",
            "value",
            "size",
            "flags"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_bad_inode(inode)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/bad_inode.c",
          "lines": "224-227",
          "snippet": "bool is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename\t\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.get_link\t= bad_inode_get_link,\n\t.get_acl\t= bad_inode_get_acl,\n\t.fiemap\t\t= bad_inode_fiemap,\n\t.update_time\t= bad_inode_update_time,\n\t.atomic_open\t= bad_inode_atomic_open,\n\t.tmpfile\t= bad_inode_tmpfile,\n\t.set_acl\t= bad_inode_set_acl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename\t\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.get_link\t= bad_inode_get_link,\n\t.get_acl\t= bad_inode_get_acl,\n\t.fiemap\t\t= bad_inode_fiemap,\n\t.update_time\t= bad_inode_update_time,\n\t.atomic_open\t= bad_inode_atomic_open,\n\t.tmpfile\t= bad_inode_tmpfile,\n\t.set_acl\t= bad_inode_set_acl,\n};\n\nbool is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_post_setxattr",
          "args": [
            "dentry",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_xattr",
          "args": [
            "dentry"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_setxattr",
          "args": [
            "dentry",
            "inode",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__vfs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "136-150",
          "snippet": "int\n__vfs_setxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\treturn handler->set(handler, dentry, inode, name, value, size, flags);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\n__vfs_setxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\treturn handler->set(handler, dentry, inode, name, value, size, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint __vfs_setxattr_noperm(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EAGAIN;\n\tint issec = !strncmp(name, XATTR_SECURITY_PREFIX,\n\t\t\t\t   XATTR_SECURITY_PREFIX_LEN);\n\n\tif (issec)\n\t\tinode->i_flags &= ~S_NOSEC;\n\tif (inode->i_opflags & IOP_XATTR) {\n\t\terror = __vfs_setxattr(dentry, inode, name, value, size, flags);\n\t\tif (!error) {\n\t\t\tfsnotify_xattr(dentry);\n\t\t\tsecurity_inode_post_setxattr(dentry, name, value,\n\t\t\t\t\t\t     size, flags);\n\t\t}\n\t} else {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn -EIO;\n\t}\n\tif (error == -EAGAIN) {\n\t\terror = -EOPNOTSUPP;\n\n\t\tif (issec) {\n\t\t\tconst char *suffix = name + XATTR_SECURITY_PREFIX_LEN;\n\n\t\t\terror = security_inode_setsecurity(inode, suffix, value,\n\t\t\t\t\t\t\t   size, flags);\n\t\t\tif (!error)\n\t\t\t\tfsnotify_xattr(dentry);\n\t\t}\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "__vfs_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "136-150",
    "snippet": "int\n__vfs_setxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\treturn handler->set(handler, dentry, inode, name, value, size, flags);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler->set",
          "args": [
            "handler",
            "dentry",
            "inode",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handler"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handler"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xattr_resolve_name",
          "args": [
            "inode",
            "&name"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "xattr_resolve_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "52-78",
          "snippet": "static const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint\n__vfs_setxattr(struct dentry *dentry, struct inode *inode, const char *name,\n\t       const void *value, size_t size, int flags)\n{\n\tconst struct xattr_handler *handler;\n\n\thandler = xattr_resolve_name(inode, &name);\n\tif (IS_ERR(handler))\n\t\treturn PTR_ERR(handler);\n\tif (!handler->set)\n\t\treturn -EOPNOTSUPP;\n\tif (size == 0)\n\t\tvalue = \"\";  /* empty EA, do not remove */\n\treturn handler->set(handler, dentry, inode, name, value, size, flags);\n}"
  },
  {
    "function_name": "xattr_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "84-134",
    "snippet": "static int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "427-460",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tif (unlikely(mask & MAY_WRITE)) {\n\t\t/*\n\t\t * Nobody gets write access to an immutable file.\n\t\t */\n\t\tif (IS_IMMUTABLE(inode))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * Updating mtime will likely cause i_uid and i_gid to be\n\t\t * written back improperly if their true value is unknown\n\t\t * to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EACCES;\n\t}\n\n\tretval = do_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = devcgroup_inode_permission(inode, mask);\n\tif (retval)\n\t\treturn retval;\n\n\treturn security_inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_owner_or_capable",
          "args": [
            "inode"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_USER_PREFIX",
            "XATTR_USER_PREFIX_LEN"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_TRUSTED_PREFIX",
            "XATTR_TRUSTED_PREFIX_LEN"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SYSTEM_PREFIX",
            "XATTR_SYSTEM_PREFIX_LEN"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "XATTR_SECURITY_PREFIX",
            "XATTR_SECURITY_PREFIX_LEN"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HAS_UNMAPPED_ID",
          "args": [
            "inode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic int\nxattr_permission(struct inode *inode, const char *name, int mask)\n{\n\t/*\n\t * We can never set or remove an extended attribute on a read-only\n\t * filesystem  or on an immutable / append-only inode.\n\t */\n\tif (mask & MAY_WRITE) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t\t/*\n\t\t * Updating an xattr will likely cause i_uid and i_gid\n\t\t * to be writen back improperly if their true value is\n\t\t * unknown to the vfs.\n\t\t */\n\t\tif (HAS_UNMAPPED_ID(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * No restriction for security.* and system.* from the VFS.  Decision\n\t * on these is left to the underlying filesystem / security module.\n\t */\n\tif (!strncmp(name, XATTR_SECURITY_PREFIX, XATTR_SECURITY_PREFIX_LEN) ||\n\t    !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))\n\t\treturn 0;\n\n\t/*\n\t * The trusted.* namespace can only be accessed by privileged users.\n\t */\n\tif (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN)) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * In the user.* namespace, only regular files and directories can have\n\t * extended attributes. For sticky directories, only the owner and\n\t * privileged users can write attributes.\n\t */\n\tif (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN)) {\n\t\tif (!S_ISREG(inode->i_mode) && !S_ISDIR(inode->i_mode))\n\t\t\treturn (mask & MAY_WRITE) ? -EPERM : -ENODATA;\n\t\tif (S_ISDIR(inode->i_mode) && (inode->i_mode & S_ISVTX) &&\n\t\t    (mask & MAY_WRITE) && !inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn inode_permission(inode, mask);\n}"
  },
  {
    "function_name": "xattr_resolve_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "52-78",
    "snippet": "static const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp_prefix",
          "args": [
            "*name",
            "xattr_prefix(handler)"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "27-35",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xattr_prefix",
          "args": [
            "handler"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/xattr.c",
          "lines": "541-548",
          "snippet": "static inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\treturn handler ? xattr_prefix(handler) : NULL;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic const struct xattr_handler *ocfs2_xattr_handler_map[OCFS2_XATTR_MAX] = {\n\t[OCFS2_XATTR_INDEX_USER]\t= &ocfs2_xattr_user_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS]\n\t\t\t\t\t= &posix_acl_access_xattr_handler,\n\t[OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT]\n\t\t\t\t\t= &posix_acl_default_xattr_handler,\n\t[OCFS2_XATTR_INDEX_TRUSTED]\t= &ocfs2_xattr_trusted_handler,\n\t[OCFS2_XATTR_INDEX_SECURITY]\t= &ocfs2_xattr_security_handler,\n};\n\nstatic inline const char *ocfs2_xattr_prefix(int name_index)\n{\n\tconst struct xattr_handler *handler = NULL;\n\n\tif (name_index > 0 && name_index < OCFS2_XATTR_MAX)\n\t\thandler = ocfs2_xattr_handler_map[name_index];\n\treturn handler ? xattr_prefix(handler) : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_xattr_handler",
          "args": [
            "handlers",
            "handler"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_bad_inode(inode)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/bad_inode.c",
          "lines": "224-227",
          "snippet": "bool is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename\t\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.get_link\t= bad_inode_get_link,\n\t.get_acl\t= bad_inode_get_acl,\n\t.fiemap\t\t= bad_inode_fiemap,\n\t.update_time\t= bad_inode_update_time,\n\t.atomic_open\t= bad_inode_atomic_open,\n\t.tmpfile\t= bad_inode_tmpfile,\n\t.set_acl\t= bad_inode_set_acl,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename\t\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.get_link\t= bad_inode_get_link,\n\t.get_acl\t= bad_inode_get_acl,\n\t.fiemap\t\t= bad_inode_fiemap,\n\t.update_time\t= bad_inode_update_time,\n\t.atomic_open\t= bad_inode_atomic_open,\n\t.tmpfile\t= bad_inode_tmpfile,\n\t.set_acl\t= bad_inode_set_acl,\n};\n\nbool is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const struct xattr_handler *\nxattr_resolve_name(struct inode *inode, const char **name)\n{\n\tconst struct xattr_handler **handlers = inode->i_sb->s_xattr;\n\tconst struct xattr_handler *handler;\n\n\tif (!(inode->i_opflags & IOP_XATTR)) {\n\t\tif (unlikely(is_bad_inode(inode)))\n\t\t\treturn ERR_PTR(-EIO);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\tfor_each_xattr_handler(handlers, handler) {\n\t\tconst char *n;\n\n\t\tn = strcmp_prefix(*name, xattr_prefix(handler));\n\t\tif (n) {\n\t\t\tif (!handler->prefix ^ !*n) {\n\t\t\t\tif (*n)\n\t\t\t\t\tcontinue;\n\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t}\n\t\t\t*name = n;\n\t\t\treturn handler;\n\t\t}\n\t}\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
  },
  {
    "function_name": "strcmp_prefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "27-35",
    "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
  },
  {
    "function_name": "setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "480-485",
    "snippet": "SYSCALL_DEFINE5(setxattr, const char __user *, pathname,\n\t\tconst char __user *, name, const void __user *, value,\n\t\tsize_t, size, int, flags)\n{\n\treturn path_setxattr(pathname, name, value, size, flags, LOOKUP_FOLLOW);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE5(setxattr, const char __user *, pathname,\n\t\tconst char __user *, name, const void __user *, value,\n\t\tsize_t, size, int, flags)\n{\n\treturn path_setxattr(pathname, name, value, size, flags, LOOKUP_FOLLOW);\n}"
  },
  {
    "function_name": "lsetxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "487-492",
    "snippet": "SYSCALL_DEFINE5(lsetxattr, const char __user *, pathname,\n\t\tconst char __user *, name, const void __user *, value,\n\t\tsize_t, size, int, flags)\n{\n\treturn path_setxattr(pathname, name, value, size, flags, 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE5(lsetxattr, const char __user *, pathname,\n\t\tconst char __user *, name, const void __user *, value,\n\t\tsize_t, size, int, flags)\n{\n\treturn path_setxattr(pathname, name, value, size, flags, 0);\n}"
  },
  {
    "function_name": "fsetxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "494-510",
    "snippet": "SYSCALL_DEFINE5(fsetxattr, int, fd, const char __user *, name,\n\t\tconst void __user *,value, size_t, size, int, flags)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = mnt_want_write_file(f.file);\n\tif (!error) {\n\t\terror = setxattr(f.file->f_path.dentry, name, value, size, flags);\n\t\tmnt_drop_write_file(f.file);\n\t}\n\tfdput(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE5(fsetxattr, int, fd, const char __user *, name,\n\t\tconst void __user *,value, size_t, size, int, flags)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = mnt_want_write_file(f.file);\n\tif (!error) {\n\t\terror = setxattr(f.file->f_path.dentry, name, value, size, flags);\n\t\tmnt_drop_write_file(f.file);\n\t}\n\tfdput(f);\n\treturn error;\n}"
  },
  {
    "function_name": "getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "574-578",
    "snippet": "SYSCALL_DEFINE4(getxattr, const char __user *, pathname,\n\t\tconst char __user *, name, void __user *, value, size_t, size)\n{\n\treturn path_getxattr(pathname, name, value, size, LOOKUP_FOLLOW);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE4(getxattr, const char __user *, pathname,\n\t\tconst char __user *, name, void __user *, value, size_t, size)\n{\n\treturn path_getxattr(pathname, name, value, size, LOOKUP_FOLLOW);\n}"
  },
  {
    "function_name": "lgetxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "580-584",
    "snippet": "SYSCALL_DEFINE4(lgetxattr, const char __user *, pathname,\n\t\tconst char __user *, name, void __user *, value, size_t, size)\n{\n\treturn path_getxattr(pathname, name, value, size, 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE4(lgetxattr, const char __user *, pathname,\n\t\tconst char __user *, name, void __user *, value, size_t, size)\n{\n\treturn path_getxattr(pathname, name, value, size, 0);\n}"
  },
  {
    "function_name": "fgetxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "586-598",
    "snippet": "SYSCALL_DEFINE4(fgetxattr, int, fd, const char __user *, name,\n\t\tvoid __user *, value, size_t, size)\n{\n\tstruct fd f = fdget(fd);\n\tssize_t error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = getxattr(f.file->f_path.dentry, name, value, size);\n\tfdput(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE4(fgetxattr, int, fd, const char __user *, name,\n\t\tvoid __user *, value, size_t, size)\n{\n\tstruct fd f = fdget(fd);\n\tssize_t error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = getxattr(f.file->f_path.dentry, name, value, size);\n\tfdput(f);\n\treturn error;\n}"
  },
  {
    "function_name": "listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "650-654",
    "snippet": "SYSCALL_DEFINE3(listxattr, const char __user *, pathname, char __user *, list,\n\t\tsize_t, size)\n{\n\treturn path_listxattr(pathname, list, size, LOOKUP_FOLLOW);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE3(listxattr, const char __user *, pathname, char __user *, list,\n\t\tsize_t, size)\n{\n\treturn path_listxattr(pathname, list, size, LOOKUP_FOLLOW);\n}"
  },
  {
    "function_name": "llistxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "656-660",
    "snippet": "SYSCALL_DEFINE3(llistxattr, const char __user *, pathname, char __user *, list,\n\t\tsize_t, size)\n{\n\treturn path_listxattr(pathname, list, size, 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE3(llistxattr, const char __user *, pathname, char __user *, list,\n\t\tsize_t, size)\n{\n\treturn path_listxattr(pathname, list, size, 0);\n}"
  },
  {
    "function_name": "flistxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "662-673",
    "snippet": "SYSCALL_DEFINE3(flistxattr, int, fd, char __user *, list, size_t, size)\n{\n\tstruct fd f = fdget(fd);\n\tssize_t error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = listxattr(f.file->f_path.dentry, list, size);\n\tfdput(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE3(flistxattr, int, fd, char __user *, list, size_t, size)\n{\n\tstruct fd f = fdget(fd);\n\tssize_t error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = listxattr(f.file->f_path.dentry, list, size);\n\tfdput(f);\n\treturn error;\n}"
  },
  {
    "function_name": "removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "715-719",
    "snippet": "SYSCALL_DEFINE2(removexattr, const char __user *, pathname,\n\t\tconst char __user *, name)\n{\n\treturn path_removexattr(pathname, name, LOOKUP_FOLLOW);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE2(removexattr, const char __user *, pathname,\n\t\tconst char __user *, name)\n{\n\treturn path_removexattr(pathname, name, LOOKUP_FOLLOW);\n}"
  },
  {
    "function_name": "lremovexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "721-725",
    "snippet": "SYSCALL_DEFINE2(lremovexattr, const char __user *, pathname,\n\t\tconst char __user *, name)\n{\n\treturn path_removexattr(pathname, name, 0);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE2(lremovexattr, const char __user *, pathname,\n\t\tconst char __user *, name)\n{\n\treturn path_removexattr(pathname, name, 0);\n}"
  },
  {
    "function_name": "fremovexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
    "lines": "727-742",
    "snippet": "SYSCALL_DEFINE2(fremovexattr, int, fd, const char __user *, name)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = mnt_want_write_file(f.file);\n\tif (!error) {\n\t\terror = removexattr(f.file->f_path.dentry, name);\n\t\tmnt_drop_write_file(f.file);\n\t}\n\tfdput(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/posix_acl_xattr.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/audit.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/evm.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/xattr.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nSYSCALL_DEFINE2(fremovexattr, int, fd, const char __user *, name)\n{\n\tstruct fd f = fdget(fd);\n\tint error = -EBADF;\n\n\tif (!f.file)\n\t\treturn error;\n\taudit_file(f.file);\n\terror = mnt_want_write_file(f.file);\n\tif (!error) {\n\t\terror = removexattr(f.file->f_path.dentry, name);\n\t\tmnt_drop_write_file(f.file);\n\t}\n\tfdput(f);\n\treturn error;\n}"
  }
]