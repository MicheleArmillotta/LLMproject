[
  {
    "function_name": "vfs_caches_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "3107-3119",
    "snippet": "void __init vfs_caches_init(void)\n{\n\tnames_cachep = kmem_cache_create_usercopy(\"names_cache\", PATH_MAX, 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, 0, PATH_MAX, NULL);\n\n\tdcache_init();\n\tinode_init();\n\tfiles_init();\n\tfiles_maxfiles_init();\n\tmnt_init();\n\tbdev_cache_init();\n\tchrdev_init();\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *names_cachep"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chrdev_init",
          "args": [],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "chrdev_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/char_dev.c",
          "lines": "667-670",
          "snippet": "void __init chrdev_init(void)\n{\n\tcdev_map = kobj_map_init(base_probe, &chrdevs_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/tty.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cdev.h>",
            "#include <linux/kobj_map.h>",
            "#include <linux/kobject.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobj_map *cdev_map;",
            "static DEFINE_MUTEX(chrdevs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/tty.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/cdev.h>\n#include <linux/kobj_map.h>\n#include <linux/kobject.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/major.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic struct kobj_map *cdev_map;\nstatic DEFINE_MUTEX(chrdevs_lock);\n\nvoid __init chrdev_init(void)\n{\n\tcdev_map = kobj_map_init(base_probe, &chrdevs_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdev_cache_init",
          "args": [],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/internal.h",
          "lines": "30-32",
          "snippet": "static inline void bdev_cache_init(void)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void bdev_cache_init(void)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_init",
          "args": [],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "3212-3244",
          "snippet": "void __init mnt_init(void)\n{\n\tint err;\n\n\tmnt_cache = kmem_cache_create(\"mnt_cache\", sizeof(struct mount),\n\t\t\t0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\n\tmount_hashtable = alloc_large_system_hash(\"Mount-cache\",\n\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\tmhash_entries, 19,\n\t\t\t\tHASH_ZERO,\n\t\t\t\t&m_hash_shift, &m_hash_mask, 0, 0);\n\tmountpoint_hashtable = alloc_large_system_hash(\"Mountpoint-cache\",\n\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\tmphash_entries, 19,\n\t\t\t\tHASH_ZERO,\n\t\t\t\t&mp_hash_shift, &mp_hash_mask, 0, 0);\n\n\tif (!mount_hashtable || !mountpoint_hashtable)\n\t\tpanic(\"Failed to allocate mount hash table\\n\");\n\n\tkernfs_init();\n\n\terr = sysfs_init();\n\tif (err)\n\t\tprintk(KERN_WARNING \"%s: sysfs_init error: %d\\n\",\n\t\t\t__func__, err);\n\tfs_kobj = kobject_create_and_add(\"fs\", NULL);\n\tif (!fs_kobj)\n\t\tprintk(KERN_WARNING \"%s: kobj create error\\n\", __func__);\n\tinit_rootfs();\n\tinit_mount_tree();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int m_hash_mask",
            "static unsigned int m_hash_shift",
            "static unsigned int mp_hash_mask",
            "static unsigned int mp_hash_shift",
            "static __initdata unsigned long mhash_entries;",
            "static __initdata unsigned long mphash_entries;",
            "static struct hlist_head *mount_hashtable",
            "static struct hlist_head *mountpoint_hashtable",
            "struct kobject *fs_kobj;",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int m_hash_mask;\nstatic unsigned int m_hash_shift;\nstatic unsigned int mp_hash_mask;\nstatic unsigned int mp_hash_shift;\nstatic __initdata unsigned long mhash_entries;\nstatic __initdata unsigned long mphash_entries;\nstatic struct hlist_head *mount_hashtable;\nstatic struct hlist_head *mountpoint_hashtable;\nstruct kobject *fs_kobj;\n__latent_entropy\nstruct;\n\nvoid __init mnt_init(void)\n{\n\tint err;\n\n\tmnt_cache = kmem_cache_create(\"mnt_cache\", sizeof(struct mount),\n\t\t\t0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\n\tmount_hashtable = alloc_large_system_hash(\"Mount-cache\",\n\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\tmhash_entries, 19,\n\t\t\t\tHASH_ZERO,\n\t\t\t\t&m_hash_shift, &m_hash_mask, 0, 0);\n\tmountpoint_hashtable = alloc_large_system_hash(\"Mountpoint-cache\",\n\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\tmphash_entries, 19,\n\t\t\t\tHASH_ZERO,\n\t\t\t\t&mp_hash_shift, &mp_hash_mask, 0, 0);\n\n\tif (!mount_hashtable || !mountpoint_hashtable)\n\t\tpanic(\"Failed to allocate mount hash table\\n\");\n\n\tkernfs_init();\n\n\terr = sysfs_init();\n\tif (err)\n\t\tprintk(KERN_WARNING \"%s: sysfs_init error: %d\\n\",\n\t\t\t__func__, err);\n\tfs_kobj = kobject_create_and_add(\"fs\", NULL);\n\tif (!fs_kobj)\n\t\tprintk(KERN_WARNING \"%s: kobj create error\\n\", __func__);\n\tinit_rootfs();\n\tinit_mount_tree();\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_maxfiles_init",
          "args": [],
          "line": 3115
        },
        "resolved": true,
        "details": {
          "function_name": "files_maxfiles_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "380-389",
          "snippet": "void __init files_maxfiles_init(void)\n{\n\tunsigned long n;\n\tunsigned long memreserve = (totalram_pages - nr_free_pages()) * 3/2;\n\n\tmemreserve = min(memreserve, totalram_pages - 1);\n\tn = ((totalram_pages - memreserve) * (PAGE_SIZE / 1024)) / 10;\n\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct files_stat_struct files_stat = {\n\t.max_files = NR_FILE\n};\n\nvoid __init files_maxfiles_init(void)\n{\n\tunsigned long n;\n\tunsigned long memreserve = (totalram_pages - nr_free_pages()) * 3/2;\n\n\tmemreserve = min(memreserve, totalram_pages - 1);\n\tn = ((totalram_pages - memreserve) * (PAGE_SIZE / 1024)) / 10;\n\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init",
          "args": [],
          "line": 3113
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1954-1978",
          "snippet": "void __init inode_init(void)\n{\n\t/* inode slab cache */\n\tinode_cachep = kmem_cache_create(\"inode_cache\",\n\t\t\t\t\t sizeof(struct inode),\n\t\t\t\t\t 0,\n\t\t\t\t\t (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t init_once);\n\n\t/* Hash may have been set up in inode_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int i_hash_mask",
            "static unsigned int i_hash_shift",
            "static struct hlist_head *inode_hashtable",
            "static struct kmem_cache *inode_cachep",
            "static void __wait_on_freeing_inode(struct inode *inode);",
            "static __initdata unsigned long ihash_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic unsigned int i_hash_mask;\nstatic unsigned int i_hash_shift;\nstatic struct hlist_head *inode_hashtable;\nstatic struct kmem_cache *inode_cachep;\nstatic void __wait_on_freeing_inode(struct inode *inode);\nstatic __initdata unsigned long ihash_entries;\n\nvoid __init inode_init(void)\n{\n\t/* inode slab cache */\n\tinode_cachep = kmem_cache_create(\"inode_cache\",\n\t\t\t\t\t sizeof(struct inode),\n\t\t\t\t\t 0,\n\t\t\t\t\t (SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|\n\t\t\t\t\t SLAB_MEM_SPREAD|SLAB_ACCOUNT),\n\t\t\t\t\t init_once);\n\n\t/* Hash may have been set up in inode_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dcache_init",
          "args": [],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "dcache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "3064-3090",
          "snippet": "static void __init dcache_init(void)\n{\n\t/*\n\t * A constructor could be added for stable state like the lists,\n\t * but it is probably not worth it because of the cache nature\n\t * of the dcache.\n\t */\n\tdentry_cache = KMEM_CACHE_USERCOPY(dentry,\n\t\tSLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT,\n\t\td_iname);\n\n\t/* Hash may have been set up in dcache_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dentry_cache",
            "static unsigned int d_hash_shift",
            "static struct hlist_bl_head *dentry_hashtable",
            "static __initdata unsigned long dhash_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\nstatic __initdata unsigned long dhash_entries;\n\nstatic void __init dcache_init(void)\n{\n\t/*\n\t * A constructor could be added for stable state like the lists,\n\t * but it is probably not worth it because of the cache nature\n\t * of the dcache.\n\t */\n\tdentry_cache = KMEM_CACHE_USERCOPY(dentry,\n\t\tSLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT,\n\t\td_iname);\n\n\t/* Hash may have been set up in dcache_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create_usercopy",
          "args": [
            "\"names_cache\"",
            "PATH_MAX",
            "0",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC",
            "0",
            "PATH_MAX",
            "NULL"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct kmem_cache *names_cachep;\n\nvoid __init vfs_caches_init(void)\n{\n\tnames_cachep = kmem_cache_create_usercopy(\"names_cache\", PATH_MAX, 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC, 0, PATH_MAX, NULL);\n\n\tdcache_init();\n\tinode_init();\n\tfiles_init();\n\tfiles_maxfiles_init();\n\tmnt_init();\n\tbdev_cache_init();\n\tchrdev_init();\n}"
  },
  {
    "function_name": "vfs_caches_init_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "3096-3105",
    "snippet": "void __init vfs_caches_init_early(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(in_lookup_hashtable); i++)\n\t\tINIT_HLIST_BL_HEAD(&in_lookup_hashtable[i]);\n\n\tdcache_init_early();\n\tinode_init_early();\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_early",
          "args": [],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1934-1952",
          "snippet": "void __init inode_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int i_hash_mask",
            "static unsigned int i_hash_shift",
            "static struct hlist_head *inode_hashtable",
            "static __initdata unsigned long ihash_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic unsigned int i_hash_mask;\nstatic unsigned int i_hash_shift;\nstatic struct hlist_head *inode_hashtable;\nstatic __initdata unsigned long ihash_entries;\n\nvoid __init inode_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tinode_hashtable =\n\t\talloc_large_system_hash(\"Inode-cache\",\n\t\t\t\t\tsizeof(struct hlist_head),\n\t\t\t\t\tihash_entries,\n\t\t\t\t\t14,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&i_hash_shift,\n\t\t\t\t\t&i_hash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dcache_init_early",
          "args": [],
          "line": 3103
        },
        "resolved": true,
        "details": {
          "function_name": "dcache_init_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "3043-3062",
          "snippet": "static void __init dcache_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int d_hash_shift",
            "static struct hlist_bl_head *dentry_hashtable",
            "static __initdata unsigned long dhash_entries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\nstatic __initdata unsigned long dhash_entries;\n\nstatic void __init dcache_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_BL_HEAD",
          "args": [
            "&in_lookup_hashtable[i]"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "in_lookup_hashtable"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];\n\nvoid __init vfs_caches_init_early(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(in_lookup_hashtable); i++)\n\t\tINIT_HLIST_BL_HEAD(&in_lookup_hashtable[i]);\n\n\tdcache_init_early();\n\tinode_init_early();\n}"
  },
  {
    "function_name": "dcache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "3064-3090",
    "snippet": "static void __init dcache_init(void)\n{\n\t/*\n\t * A constructor could be added for stable state like the lists,\n\t * but it is probably not worth it because of the cache nature\n\t * of the dcache.\n\t */\n\tdentry_cache = KMEM_CACHE_USERCOPY(dentry,\n\t\tSLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT,\n\t\td_iname);\n\n\t/* Hash may have been set up in dcache_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dentry_cache",
      "static unsigned int d_hash_shift",
      "static struct hlist_bl_head *dentry_hashtable",
      "static __initdata unsigned long dhash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"Dentry cache\"",
            "sizeof(struct hlist_bl_head)",
            "dhash_entries",
            "13",
            "HASH_ZERO",
            "&d_hash_shift",
            "NULL",
            "0",
            "0"
          ],
          "line": 3080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE_USERCOPY",
          "args": [
            "dentry",
            "SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT",
            "d_iname"
          ],
          "line": 3071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\nstatic __initdata unsigned long dhash_entries;\n\nstatic void __init dcache_init(void)\n{\n\t/*\n\t * A constructor could be added for stable state like the lists,\n\t * but it is probably not worth it because of the cache nature\n\t * of the dcache.\n\t */\n\tdentry_cache = KMEM_CACHE_USERCOPY(dentry,\n\t\tSLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT,\n\t\td_iname);\n\n\t/* Hash may have been set up in dcache_init_early */\n\tif (!hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}"
  },
  {
    "function_name": "dcache_init_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "3043-3062",
    "snippet": "static void __init dcache_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int d_hash_shift",
      "static struct hlist_bl_head *dentry_hashtable",
      "static __initdata unsigned long dhash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_large_system_hash",
          "args": [
            "\"Dentry cache\"",
            "sizeof(struct hlist_bl_head)",
            "dhash_entries",
            "13",
            "HASH_EARLY | HASH_ZERO",
            "&d_hash_shift",
            "NULL",
            "0",
            "0"
          ],
          "line": 3052
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\nstatic __initdata unsigned long dhash_entries;\n\nstatic void __init dcache_init_early(void)\n{\n\t/* If hashes are distributed across NUMA nodes, defer\n\t * hash allocation until vmalloc space is available.\n\t */\n\tif (hashdist)\n\t\treturn;\n\n\tdentry_hashtable =\n\t\talloc_large_system_hash(\"Dentry cache\",\n\t\t\t\t\tsizeof(struct hlist_bl_head),\n\t\t\t\t\tdhash_entries,\n\t\t\t\t\t13,\n\t\t\t\t\tHASH_EARLY | HASH_ZERO,\n\t\t\t\t\t&d_hash_shift,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t0);\n\td_hash_shift = 32 - d_hash_shift;\n}"
  },
  {
    "function_name": "set_dhash_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "3034-3040",
    "snippet": "static int __init set_dhash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tdhash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __initdata unsigned long dhash_entries;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "str",
            "&str",
            "0"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic __initdata unsigned long dhash_entries;\n\nstatic int __init set_dhash_entries(char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\tdhash_entries = simple_strtoul(str, &str, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "d_tmpfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "3017-3030",
    "snippet": "void d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1937-1940",
          "snippet": "struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_parent->d_lock"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "dentry->d_iname",
            "\"#%llu\"",
            "(unsigned long long)inode->i_ino"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&dentry->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_parent->d_lock"
          ],
          "line": 3023
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry)"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unlinked",
          "args": [
            "dentry"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&dentry->d_u.d_alias"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dec_link_count",
          "args": [
            "inode"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_tmpfile(struct dentry *dentry, struct inode *inode)\n{\n\tinode_dec_link_count(inode);\n\tBUG_ON(dentry->d_name.name != dentry->d_iname ||\n\t\t!hlist_unhashed(&dentry->d_u.d_alias) ||\n\t\t!d_unlinked(dentry));\n\tspin_lock(&dentry->d_parent->d_lock);\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tdentry->d_name.len = sprintf(dentry->d_iname, \"#%llu\",\n\t\t\t\t(unsigned long long)inode->i_ino);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&dentry->d_parent->d_lock);\n\td_instantiate(dentry, inode);\n}"
  },
  {
    "function_name": "d_genocide",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "3010-3013",
    "snippet": "void d_genocide(struct dentry *parent)\n{\n\td_walk(parent, parent, d_genocide_kill);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_walk",
          "args": [
            "parent",
            "parent",
            "d_genocide_kill"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "d_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1227-1331",
          "snippet": "static void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstatic void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_genocide(struct dentry *parent)\n{\n\td_walk(parent, parent, d_genocide_kill);\n}"
  },
  {
    "function_name": "d_genocide_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2995-3008",
    "snippet": "static enum d_walk_ret d_genocide_kill(void *data, struct dentry *dentry)\n{\n\tstruct dentry *root = data;\n\tif (dentry != root) {\n\t\tif (d_unhashed(dentry) || !dentry->d_inode)\n\t\t\treturn D_WALK_SKIP;\n\n\t\tif (!(dentry->d_flags & DCACHE_GENOCIDE)) {\n\t\t\tdentry->d_flags |= DCACHE_GENOCIDE;\n\t\t\tdentry->d_lockref.count--;\n\t\t}\n\t}\n\treturn D_WALK_CONTINUE;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic enum d_walk_ret d_genocide_kill(void *data, struct dentry *dentry)\n{\n\tstruct dentry *root = data;\n\tif (dentry != root) {\n\t\tif (d_unhashed(dentry) || !dentry->d_inode)\n\t\t\treturn D_WALK_SKIP;\n\n\t\tif (!(dentry->d_flags & DCACHE_GENOCIDE)) {\n\t\t\tdentry->d_flags |= DCACHE_GENOCIDE;\n\t\t\tdentry->d_lockref.count--;\n\t\t}\n\t}\n\treturn D_WALK_CONTINUE;\n}"
  },
  {
    "function_name": "is_subdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2968-2992",
    "snippet": "bool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tbool result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn true;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ancestor",
          "args": [
            "old_dentry",
            "new_dentry"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "d_ancestor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2829-2838",
          "snippet": "struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nbool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tbool result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn true;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}"
  },
  {
    "function_name": "d_splice_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2901-2949",
    "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode)\n\t\tgoto out;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\t/* The reference to new ensures it remains an alias */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tstruct dentry *old_parent = dget(new->d_parent);\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t\tdput(old_parent);\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\nout:\n\t__d_add(dentry, inode);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "__d_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2541-2565",
          "snippet": "static inline void __d_add(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(d_in_lookup(dentry))) {\n\t\tdir = dentry->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(dentry);\n\t}\n\tif (inode) {\n\t\tunsigned add_flags = d_flags_for_inode(inode);\n\t\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\t\traw_write_seqcount_begin(&dentry->d_seq);\n\t\t__d_set_inode_and_type(dentry, inode, add_flags);\n\t\traw_write_seqcount_end(&dentry->d_seq);\n\t\tfsnotify_update_flags(dentry);\n\t}\n\t__d_rehash(dentry);\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\tspin_unlock(&dentry->d_lock);\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_add(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(d_in_lookup(dentry))) {\n\t\tdir = dentry->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(dentry);\n\t}\n\tif (inode) {\n\t\tunsigned add_flags = d_flags_for_inode(inode);\n\t\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\t\traw_write_seqcount_begin(&dentry->d_seq);\n\t\t__d_set_inode_and_type(dentry, inode, add_flags);\n\t\traw_write_seqcount_end(&dentry->d_seq);\n\t\tfsnotify_update_flags(dentry);\n\t}\n\t__d_rehash(dentry);\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\tspin_unlock(&dentry->d_lock);\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&rename_lock"
          ],
          "line": 2940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_move",
          "args": [
            "new",
            "dentry",
            "false"
          ],
          "line": 2939
        },
        "resolved": true,
        "details": {
          "function_name": "__d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2704-2783",
          "snippet": "static void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "old_parent"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&rename_lock"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_unalias",
          "args": [
            "inode",
            "dentry",
            "new"
          ],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "__d_unalias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2849-2876",
          "snippet": "static int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL;\n\tstruct rw_semaphore *m2 = NULL;\n\tint ret = -ESTALE;\n\n\t/* If alias and dentry share a parent, then no extra locks required */\n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\n\t/* See lock_rename() */\n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!inode_trylock_shared(alias->d_parent->d_inode))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_rwsem;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tif (m2)\n\t\tup_read(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL;\n\tstruct rw_semaphore *m2 = NULL;\n\tint ret = -ESTALE;\n\n\t/* If alias and dentry share a parent, then no extra locks required */\n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\n\t/* See lock_rename() */\n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!inode_trylock_shared(alias->d_parent->d_inode))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_rwsem;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tif (m2)\n\t\tup_read(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "new->d_parent"
          ],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "new"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\"",
            "dentry->d_name.name",
            "inode->i_sb->s_type->name",
            "inode->i_sb->s_id"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ELOOP"
          ],
          "line": 2922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&rename_lock"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "d_ancestor(new, dentry)"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ancestor",
          "args": [
            "new",
            "dentry"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "d_ancestor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2829-2838",
          "snippet": "struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&rename_lock"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_find_any_alias",
          "args": [
            "inode"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "__d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "889-898",
          "snippet": "static struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2912
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!d_unhashed(dentry)"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 2904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode)\n\t\tgoto out;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\t/* The reference to new ensures it remains an alias */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tstruct dentry *old_parent = dget(new->d_parent);\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t\tdput(old_parent);\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\nout:\n\t__d_add(dentry, inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "__d_unalias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2849-2876",
    "snippet": "static int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL;\n\tstruct rw_semaphore *m2 = NULL;\n\tint ret = -ESTALE;\n\n\t/* If alias and dentry share a parent, then no extra locks required */\n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\n\t/* See lock_rename() */\n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!inode_trylock_shared(alias->d_parent->d_inode))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_rwsem;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tif (m2)\n\t\tup_read(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "m1"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "m2"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_move",
          "args": [
            "alias",
            "dentry",
            "false"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "__d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2704-2783",
          "snippet": "static void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_trylock_shared",
          "args": [
            "alias->d_parent->d_inode"
          ],
          "line": 2864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&dentry->d_sb->s_vfs_rename_mutex"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL;\n\tstruct rw_semaphore *m2 = NULL;\n\tint ret = -ESTALE;\n\n\t/* If alias and dentry share a parent, then no extra locks required */\n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\n\t/* See lock_rename() */\n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!inode_trylock_shared(alias->d_parent->d_inode))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_rwsem;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tif (m2)\n\t\tup_read(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}"
  },
  {
    "function_name": "d_ancestor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2829-2838",
    "snippet": "struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "p"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "d_exchange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2807-2819",
    "snippet": "void d_exchange(struct dentry *dentry1, struct dentry *dentry2)\n{\n\twrite_seqlock(&rename_lock);\n\n\tWARN_ON(!dentry1->d_inode);\n\tWARN_ON(!dentry2->d_inode);\n\tWARN_ON(IS_ROOT(dentry1));\n\tWARN_ON(IS_ROOT(dentry2));\n\n\t__d_move(dentry1, dentry2, true);\n\n\twrite_sequnlock(&rename_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&rename_lock"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_move",
          "args": [
            "dentry1",
            "dentry2",
            "true"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "__d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2704-2783",
          "snippet": "static void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "IS_ROOT(dentry2)"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry2"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "IS_ROOT(dentry1)"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry1"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dentry2->d_inode"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dentry1->d_inode"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&rename_lock"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_exchange(struct dentry *dentry1, struct dentry *dentry2)\n{\n\twrite_seqlock(&rename_lock);\n\n\tWARN_ON(!dentry1->d_inode);\n\tWARN_ON(!dentry2->d_inode);\n\tWARN_ON(IS_ROOT(dentry1));\n\tWARN_ON(IS_ROOT(dentry2));\n\n\t__d_move(dentry1, dentry2, true);\n\n\twrite_sequnlock(&rename_lock);\n}"
  },
  {
    "function_name": "d_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2794-2799",
    "snippet": "void d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&rename_lock"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_move",
          "args": [
            "dentry",
            "target",
            "false"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "__d_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2704-2783",
          "snippet": "static void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&rename_lock"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nvoid d_move(struct dentry *dentry, struct dentry *target)\n{\n\twrite_seqlock(&rename_lock);\n\t__d_move(dentry, target, false);\n\twrite_sequnlock(&rename_lock);\n}"
  },
  {
    "function_name": "__d_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2704-2783",
    "snippet": "static void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2782
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_dir_add",
          "args": [
            "dir",
            "n"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "end_dir_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2395-2398",
          "snippet": "static inline void end_dir_add(struct inode *dir, unsigned n)\n{\n\tsmp_store_release(&dir->i_dir_seq, n + 2);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void end_dir_add(struct inode *dir, unsigned n)\n{\n\tsmp_store_release(&dir->i_dir_seq, n + 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_end",
          "args": [
            "&target->d_seq"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_update_flags",
          "args": [
            "dentry"
          ],
          "line": 2769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_rehash",
          "args": [
            "dentry"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "__d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2360-2367",
          "snippet": "static void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&dentry->d_child",
            "&dentry->d_parent->d_subdirs"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_update_flags",
          "args": [
            "target"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&target->d_child",
            "&target->d_parent->d_subdirs"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap_names",
          "args": [
            "dentry",
            "target"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2632-2673",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!--old_parent->d_lockref.count"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_name",
          "args": [
            "dentry",
            "target"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "copy_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2675-2691",
          "snippet": "static void copy_name(struct dentry *dentry, struct dentry *target)\n{\n\tstruct external_name *old_name = NULL;\n\tif (unlikely(dname_external(dentry)))\n\t\told_name = external_name(dentry);\n\tif (unlikely(dname_external(target))) {\n\t\tatomic_inc(&external_name(target)->u.count);\n\t\tdentry->d_name = target->d_name;\n\t} else {\n\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\ttarget->d_name.len + 1);\n\t\tdentry->d_name.name = dentry->d_iname;\n\t\tdentry->d_name.hash_len = target->d_name.hash_len;\n\t}\n\tif (old_name && likely(atomic_dec_and_test(&old_name->u.count)))\n\t\tkfree_rcu(old_name, u.head);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void copy_name(struct dentry *dentry, struct dentry *target)\n{\n\tstruct external_name *old_name = NULL;\n\tif (unlikely(dname_external(dentry)))\n\t\told_name = external_name(dentry);\n\tif (unlikely(dname_external(target))) {\n\t\tatomic_inc(&external_name(target)->u.count);\n\t\tdentry->d_name = target->d_name;\n\t} else {\n\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\ttarget->d_name.len + 1);\n\t\tdentry->d_name.name = dentry->d_iname;\n\t\tdentry->d_name.hash_len = target->d_name.hash_len;\n\t}\n\tif (old_name && likely(atomic_dec_and_test(&old_name->u.count)))\n\t\tkfree_rcu(old_name, u.head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "___d_drop",
          "args": [
            "target"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "___d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "449-465",
          "snippet": "static void ___d_drop(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b;\n\t/*\n\t * Hashed dentries are normally on the dentry hashtable,\n\t * with the exception of those newly allocated by\n\t * d_obtain_root, which are always IS_ROOT:\n\t */\n\tif (unlikely(IS_ROOT(dentry)))\n\t\tb = &dentry->d_sb->s_roots;\n\telse\n\t\tb = d_hash(dentry->d_name.hash);\n\n\thlist_bl_lock(b);\n\t__hlist_bl_del(&dentry->d_hash);\n\thlist_bl_unlock(b);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void ___d_drop(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b;\n\t/*\n\t * Hashed dentries are normally on the dentry hashtable,\n\t * with the exception of those newly allocated by\n\t * d_obtain_root, which are always IS_ROOT:\n\t */\n\tif (unlikely(IS_ROOT(dentry)))\n\t\tb = &dentry->d_sb->s_roots;\n\telse\n\t\tb = d_hash(dentry->d_name.hash);\n\n\thlist_bl_lock(b);\n\t__hlist_bl_del(&dentry->d_hash);\n\thlist_bl_unlock(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "target"
          ],
          "line": 2747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin_nested",
          "args": [
            "&target->d_seq",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqcount_begin",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_lookup_done",
          "args": [
            "target"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "__d_lookup_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2524-2536",
          "snippet": "void __d_lookup_done(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b = in_lookup_hash(dentry->d_parent,\n\t\t\t\t\t\t dentry->d_name.hash);\n\thlist_bl_lock(b);\n\tdentry->d_flags &= ~DCACHE_PAR_LOOKUP;\n\t__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);\n\twake_up_all(dentry->d_wait);\n\tdentry->d_wait = NULL;\n\thlist_bl_unlock(b);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid __d_lookup_done(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b = in_lookup_hash(dentry->d_parent,\n\t\t\t\t\t\t dentry->d_name.hash);\n\thlist_bl_lock(b);\n\tdentry->d_flags &= ~DCACHE_PAR_LOOKUP;\n\t__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);\n\twake_up_all(dentry->d_wait);\n\tdentry->d_wait = NULL;\n\thlist_bl_unlock(b);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_dir_add",
          "args": [
            "dir"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "start_dir_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2384-2393",
          "snippet": "static inline unsigned start_dir_add(struct inode *dir)\n{\n\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline unsigned start_dir_add(struct inode *dir)\n{\n\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "d_in_lookup(target)"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_in_lookup",
          "args": [
            "target"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&target->d_lock",
            "3"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&dentry->d_lock",
            "2"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&target->d_parent->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&old_parent->d_lock"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p == dentry"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&old_parent->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ancestor",
          "args": [
            "old_parent",
            "target"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "d_ancestor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2829-2838",
          "snippet": "struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)\n{\n\tstruct dentry *p;\n\n\tfor (p = p2; !IS_ROOT(p); p = p->d_parent) {\n\t\tif (p->d_parent == p1)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "d_ancestor(target, dentry)"
          ],
          "line": 2715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dentry == target"
          ],
          "line": 2712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dentry->d_inode"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_move(struct dentry *dentry, struct dentry *target,\n\t\t     bool exchange)\n{\n\tstruct dentry *old_parent, *p;\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\n\tWARN_ON(!dentry->d_inode);\n\tif (WARN_ON(dentry == target))\n\t\treturn;\n\n\tBUG_ON(d_ancestor(target, dentry));\n\told_parent = dentry->d_parent;\n\tp = d_ancestor(old_parent, target);\n\tif (IS_ROOT(dentry)) {\n\t\tBUG_ON(p);\n\t\tspin_lock(&target->d_parent->d_lock);\n\t} else if (!p) {\n\t\t/* target is not a descendent of dentry->d_parent */\n\t\tspin_lock(&target->d_parent->d_lock);\n\t\tspin_lock_nested(&old_parent->d_lock, DENTRY_D_LOCK_NESTED);\n\t} else {\n\t\tBUG_ON(p == dentry);\n\t\tspin_lock(&old_parent->d_lock);\n\t\tif (p != target)\n\t\t\tspin_lock_nested(&target->d_parent->d_lock,\n\t\t\t\t\tDENTRY_D_LOCK_NESTED);\n\t}\n\tspin_lock_nested(&dentry->d_lock, 2);\n\tspin_lock_nested(&target->d_lock, 3);\n\n\tif (unlikely(d_in_lookup(target))) {\n\t\tdir = target->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(target);\n\t}\n\n\twrite_seqcount_begin(&dentry->d_seq);\n\twrite_seqcount_begin_nested(&target->d_seq, DENTRY_D_LOCK_NESTED);\n\n\t/* unhash both */\n\tif (!d_unhashed(dentry))\n\t\t___d_drop(dentry);\n\tif (!d_unhashed(target))\n\t\t___d_drop(target);\n\n\t/* ... and switch them in the tree */\n\tdentry->d_parent = target->d_parent;\n\tif (!exchange) {\n\t\tcopy_name(dentry, target);\n\t\ttarget->d_hash.pprev = NULL;\n\t\tdentry->d_parent->d_lockref.count++;\n\t\tif (dentry == old_parent)\n\t\t\tdentry->d_flags |= DCACHE_RCUACCESS;\n\t\telse\n\t\t\tWARN_ON(!--old_parent->d_lockref.count);\n\t} else {\n\t\ttarget->d_parent = old_parent;\n\t\tswap_names(dentry, target);\n\t\tlist_move(&target->d_child, &target->d_parent->d_subdirs);\n\t\t__d_rehash(target);\n\t\tfsnotify_update_flags(target);\n\t}\n\tlist_move(&dentry->d_child, &dentry->d_parent->d_subdirs);\n\t__d_rehash(dentry);\n\tfsnotify_update_flags(dentry);\n\n\twrite_seqcount_end(&target->d_seq);\n\twrite_seqcount_end(&dentry->d_seq);\n\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\n\tif (dentry->d_parent != old_parent)\n\t\tspin_unlock(&dentry->d_parent->d_lock);\n\tif (dentry != old_parent)\n\t\tspin_unlock(&old_parent->d_lock);\n\tspin_unlock(&target->d_lock);\n\tspin_unlock(&dentry->d_lock);\n}"
  },
  {
    "function_name": "copy_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2675-2691",
    "snippet": "static void copy_name(struct dentry *dentry, struct dentry *target)\n{\n\tstruct external_name *old_name = NULL;\n\tif (unlikely(dname_external(dentry)))\n\t\told_name = external_name(dentry);\n\tif (unlikely(dname_external(target))) {\n\t\tatomic_inc(&external_name(target)->u.count);\n\t\tdentry->d_name = target->d_name;\n\t} else {\n\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\ttarget->d_name.len + 1);\n\t\tdentry->d_name.name = dentry->d_iname;\n\t\tdentry->d_name.hash_len = target->d_name.hash_len;\n\t}\n\tif (old_name && likely(atomic_dec_and_test(&old_name->u.count)))\n\t\tkfree_rcu(old_name, u.head);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "old_name",
            "u.head"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "atomic_dec_and_test(&old_name->u.count)"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&old_name->u.count"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dentry->d_iname",
            "target->d_name.name",
            "target->d_name.len + 1"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&external_name(target)->u.count"
          ],
          "line": 2681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "external_name",
          "args": [
            "target"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "external_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "248-251",
          "snippet": "static inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dname_external(target)"
          ],
          "line": 2680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname_external",
          "args": [
            "target"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "dname_external",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "267-270",
          "snippet": "static inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dname_external(dentry)"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void copy_name(struct dentry *dentry, struct dentry *target)\n{\n\tstruct external_name *old_name = NULL;\n\tif (unlikely(dname_external(dentry)))\n\t\told_name = external_name(dentry);\n\tif (unlikely(dname_external(target))) {\n\t\tatomic_inc(&external_name(target)->u.count);\n\t\tdentry->d_name = target->d_name;\n\t} else {\n\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\ttarget->d_name.len + 1);\n\t\tdentry->d_name.name = dentry->d_iname;\n\t\tdentry->d_name.hash_len = target->d_name.hash_len;\n\t}\n\tif (old_name && likely(atomic_dec_and_test(&old_name->u.count)))\n\t\tkfree_rcu(old_name, u.head);\n}"
  },
  {
    "function_name": "swap_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2632-2673",
    "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "dentry->d_name.hash_len",
            "target->d_name.hash_len"
          ],
          "line": 2672
        },
        "resolved": true,
        "details": {
          "function_name": "swap_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2632-2673",
          "snippet": "static void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long))"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "DNAME_INLINE_LEN",
            "sizeof(long)"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dentry->d_iname",
            "target->d_name.name",
            "target->d_name.len + 1"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dname_external(dentry)"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname_external",
          "args": [
            "dentry"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "dname_external",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "267-270",
          "snippet": "static inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "target->d_iname",
            "dentry->d_name.name",
            "dentry->d_name.len + 1"
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dname_external(dentry)"
          ],
          "line": 2635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dname_external(target)"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void swap_names(struct dentry *dentry, struct dentry *target)\n{\n\tif (unlikely(dname_external(target))) {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * Both external: swap the pointers\n\t\t\t */\n\t\t\tswap(target->d_name.name, dentry->d_name.name);\n\t\t} else {\n\t\t\t/*\n\t\t\t * dentry:internal, target:external.  Steal target's\n\t\t\t * storage and make target internal.\n\t\t\t */\n\t\t\tmemcpy(target->d_iname, dentry->d_name.name,\n\t\t\t\t\tdentry->d_name.len + 1);\n\t\t\tdentry->d_name.name = target->d_name.name;\n\t\t\ttarget->d_name.name = target->d_iname;\n\t\t}\n\t} else {\n\t\tif (unlikely(dname_external(dentry))) {\n\t\t\t/*\n\t\t\t * dentry:external, target:internal.  Give dentry's\n\t\t\t * storage to target and make dentry internal\n\t\t\t */\n\t\t\tmemcpy(dentry->d_iname, target->d_name.name,\n\t\t\t\t\ttarget->d_name.len + 1);\n\t\t\ttarget->d_name.name = dentry->d_name.name;\n\t\t\tdentry->d_name.name = dentry->d_iname;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Both are internal.\n\t\t\t */\n\t\t\tunsigned int i;\n\t\t\tBUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long)));\n\t\t\tfor (i = 0; i < DNAME_INLINE_LEN / sizeof(long); i++) {\n\t\t\t\tswap(((long *) &dentry->d_iname)[i],\n\t\t\t\t     ((long *) &target->d_iname)[i]);\n\t\t\t}\n\t\t}\n\t}\n\tswap(dentry->d_name.hash_len, target->d_name.hash_len);\n}"
  },
  {
    "function_name": "d_exact_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2597-2629",
    "snippet": "struct dentry *d_exact_alias(struct dentry *entry, struct inode *inode)\n{\n\tstruct dentry *alias;\n\tunsigned int hash = entry->d_name.hash;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\t/*\n\t\t * Don't need alias->d_lock here, because aliases with\n\t\t * d_parent == entry->d_parent are not subject to name or\n\t\t * parent changes, because the parent inode i_mutex is held.\n\t\t */\n\t\tif (alias->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (alias->d_parent != entry->d_parent)\n\t\t\tcontinue;\n\t\tif (!d_same_name(alias, entry->d_parent, &entry->d_name))\n\t\t\tcontinue;\n\t\tspin_lock(&alias->d_lock);\n\t\tif (!d_unhashed(alias)) {\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t\talias = NULL;\n\t\t} else {\n\t\t\t__dget_dlock(alias);\n\t\t\t__d_rehash(alias);\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn alias;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_rehash",
          "args": [
            "alias"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "__d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2360-2367",
          "snippet": "static void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dget_dlock",
          "args": [
            "alias"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "839-842",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "alias"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&alias->d_lock"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_same_name",
          "args": [
            "alias",
            "entry->d_parent",
            "&entry->d_name"
          ],
          "line": 2613
        },
        "resolved": true,
        "details": {
          "function_name": "d_same_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2069-2081",
          "snippet": "static inline bool d_same_name(const struct dentry *dentry,\n\t\t\t\tconst struct dentry *parent,\n\t\t\t\tconst struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool d_same_name(const struct dentry *dentry,\n\t\t\t\tconst struct dentry *parent,\n\t\t\t\tconst struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "alias",
            "&inode->i_dentry",
            "d_u.d_alias"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_exact_alias(struct dentry *entry, struct inode *inode)\n{\n\tstruct dentry *alias;\n\tunsigned int hash = entry->d_name.hash;\n\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\t/*\n\t\t * Don't need alias->d_lock here, because aliases with\n\t\t * d_parent == entry->d_parent are not subject to name or\n\t\t * parent changes, because the parent inode i_mutex is held.\n\t\t */\n\t\tif (alias->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (alias->d_parent != entry->d_parent)\n\t\t\tcontinue;\n\t\tif (!d_same_name(alias, entry->d_parent, &entry->d_name))\n\t\t\tcontinue;\n\t\tspin_lock(&alias->d_lock);\n\t\tif (!d_unhashed(alias)) {\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t\talias = NULL;\n\t\t} else {\n\t\t\t__dget_dlock(alias);\n\t\t\t__d_rehash(alias);\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t}\n\t\tspin_unlock(&inode->i_lock);\n\t\treturn alias;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "d_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2576-2583",
    "snippet": "void d_add(struct dentry *entry, struct inode *inode)\n{\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t}\n\t__d_add(entry, inode);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__d_add",
          "args": [
            "entry",
            "inode"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "__d_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2541-2565",
          "snippet": "static inline void __d_add(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(d_in_lookup(dentry))) {\n\t\tdir = dentry->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(dentry);\n\t}\n\tif (inode) {\n\t\tunsigned add_flags = d_flags_for_inode(inode);\n\t\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\t\traw_write_seqcount_begin(&dentry->d_seq);\n\t\t__d_set_inode_and_type(dentry, inode, add_flags);\n\t\traw_write_seqcount_end(&dentry->d_seq);\n\t\tfsnotify_update_flags(dentry);\n\t}\n\t__d_rehash(dentry);\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\tspin_unlock(&dentry->d_lock);\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_add(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(d_in_lookup(dentry))) {\n\t\tdir = dentry->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(dentry);\n\t}\n\tif (inode) {\n\t\tunsigned add_flags = d_flags_for_inode(inode);\n\t\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\t\traw_write_seqcount_begin(&dentry->d_seq);\n\t\t__d_set_inode_and_type(dentry, inode, add_flags);\n\t\traw_write_seqcount_end(&dentry->d_seq);\n\t\tfsnotify_update_flags(dentry);\n\t}\n\t__d_rehash(dentry);\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\tspin_unlock(&dentry->d_lock);\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_d_instantiate",
          "args": [
            "entry",
            "inode"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_add(struct dentry *entry, struct inode *inode)\n{\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t}\n\t__d_add(entry, inode);\n}"
  },
  {
    "function_name": "__d_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2541-2565",
    "snippet": "static inline void __d_add(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(d_in_lookup(dentry))) {\n\t\tdir = dentry->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(dentry);\n\t}\n\tif (inode) {\n\t\tunsigned add_flags = d_flags_for_inode(inode);\n\t\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\t\traw_write_seqcount_begin(&dentry->d_seq);\n\t\t__d_set_inode_and_type(dentry, inode, add_flags);\n\t\traw_write_seqcount_end(&dentry->d_seq);\n\t\tfsnotify_update_flags(dentry);\n\t}\n\t__d_rehash(dentry);\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\tspin_unlock(&dentry->d_lock);\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_dir_add",
          "args": [
            "dir",
            "n"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "end_dir_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2395-2398",
          "snippet": "static inline void end_dir_add(struct inode *dir, unsigned n)\n{\n\tsmp_store_release(&dir->i_dir_seq, n + 2);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void end_dir_add(struct inode *dir, unsigned n)\n{\n\tsmp_store_release(&dir->i_dir_seq, n + 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_rehash",
          "args": [
            "dentry"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "__d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2360-2367",
          "snippet": "static void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_update_flags",
          "args": [
            "dentry"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_end",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_set_inode_and_type",
          "args": [
            "dentry",
            "inode",
            "add_flags"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "__d_set_inode_and_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "300-311",
          "snippet": "static inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_begin",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&dentry->d_u.d_alias",
            "&inode->i_dentry"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_flags_for_inode",
          "args": [
            "inode"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "d_flags_for_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1782-1815",
          "snippet": "static unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_lookup_done",
          "args": [
            "dentry"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "__d_lookup_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2524-2536",
          "snippet": "void __d_lookup_done(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b = in_lookup_hash(dentry->d_parent,\n\t\t\t\t\t\t dentry->d_name.hash);\n\thlist_bl_lock(b);\n\tdentry->d_flags &= ~DCACHE_PAR_LOOKUP;\n\t__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);\n\twake_up_all(dentry->d_wait);\n\tdentry->d_wait = NULL;\n\thlist_bl_unlock(b);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid __d_lookup_done(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b = in_lookup_hash(dentry->d_parent,\n\t\t\t\t\t\t dentry->d_name.hash);\n\thlist_bl_lock(b);\n\tdentry->d_flags &= ~DCACHE_PAR_LOOKUP;\n\t__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);\n\twake_up_all(dentry->d_wait);\n\tdentry->d_wait = NULL;\n\thlist_bl_unlock(b);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_dir_add",
          "args": [
            "dir"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "start_dir_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2384-2393",
          "snippet": "static inline unsigned start_dir_add(struct inode *dir)\n{\n\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline unsigned start_dir_add(struct inode *dir)\n{\n\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "d_in_lookup(dentry)"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_in_lookup",
          "args": [
            "dentry"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_add(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = NULL;\n\tunsigned n;\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(d_in_lookup(dentry))) {\n\t\tdir = dentry->d_parent->d_inode;\n\t\tn = start_dir_add(dir);\n\t\t__d_lookup_done(dentry);\n\t}\n\tif (inode) {\n\t\tunsigned add_flags = d_flags_for_inode(inode);\n\t\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\t\traw_write_seqcount_begin(&dentry->d_seq);\n\t\t__d_set_inode_and_type(dentry, inode, add_flags);\n\t\traw_write_seqcount_end(&dentry->d_seq);\n\t\tfsnotify_update_flags(dentry);\n\t}\n\t__d_rehash(dentry);\n\tif (dir)\n\t\tend_dir_add(dir, n);\n\tspin_unlock(&dentry->d_lock);\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "__d_lookup_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2524-2536",
    "snippet": "void __d_lookup_done(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b = in_lookup_hash(dentry->d_parent,\n\t\t\t\t\t\t dentry->d_name.hash);\n\thlist_bl_lock(b);\n\tdentry->d_flags &= ~DCACHE_PAR_LOOKUP;\n\t__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);\n\twake_up_all(dentry->d_wait);\n\tdentry->d_wait = NULL;\n\thlist_bl_unlock(b);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dentry->d_lru"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&dentry->d_u.d_alias"
          ],
          "line": 2534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_unlock",
          "args": [
            "b"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "dentry->d_wait"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hlist_bl_del",
          "args": [
            "&dentry->d_u.d_in_lookup_hash"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_lock",
          "args": [
            "b"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lookup_hash",
          "args": [
            "dentry->d_parent",
            "dentry->d_name.hash"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "in_lookup_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "107-112",
          "snippet": "static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent,\n\t\t\t\t\tunsigned int hash)\n{\n\thash += (unsigned long) parent / L1_CACHE_BYTES;\n\treturn in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [
            "#define IN_LOOKUP_SHIFT 10"
          ],
          "globals_used": [
            "static struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n#define IN_LOOKUP_SHIFT 10\n\nstatic struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];\n\nstatic inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent,\n\t\t\t\t\tunsigned int hash)\n{\n\thash += (unsigned long) parent / L1_CACHE_BYTES;\n\treturn in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid __d_lookup_done(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b = in_lookup_hash(dentry->d_parent,\n\t\t\t\t\t\t dentry->d_name.hash);\n\thlist_bl_lock(b);\n\tdentry->d_flags &= ~DCACHE_PAR_LOOKUP;\n\t__hlist_bl_del(&dentry->d_u.d_in_lookup_hash);\n\twake_up_all(dentry->d_wait);\n\tdentry->d_wait = NULL;\n\thlist_bl_unlock(b);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n}"
  },
  {
    "function_name": "d_alloc_parallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2414-2521",
    "snippet": "struct dentry *d_alloc_parallel(struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\twait_queue_head_t *wq)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = in_lookup_hash(parent, hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *new = d_alloc(parent, name);\n\tstruct dentry *dentry;\n\tunsigned seq, r_seq, d_seq;\n\n\tif (unlikely(!new))\n\t\treturn ERR_PTR(-ENOMEM);\n\nretry:\n\trcu_read_lock();\n\tseq = smp_load_acquire(&parent->d_inode->i_dir_seq);\n\tr_seq = read_seqbegin(&rename_lock);\n\tdentry = __d_lookup_rcu(parent, name, &d_seq);\n\tif (unlikely(dentry)) {\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (read_seqcount_retry(&dentry->d_seq, d_seq)) {\n\t\t\trcu_read_unlock();\n\t\t\tdput(dentry);\n\t\t\tgoto retry;\n\t\t}\n\t\trcu_read_unlock();\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, r_seq))) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\tif (unlikely(seq & 1)) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\thlist_bl_lock(b);\n\tif (unlikely(READ_ONCE(parent->d_inode->i_dir_seq) != seq)) {\n\t\thlist_bl_unlock(b);\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\t/*\n\t * No changes for the parent since the beginning of d_lookup().\n\t * Since all removals from the chain happen with hlist_bl_lock(),\n\t * any potential in-lookup matches are going to stay here until\n\t * we unlock the chain.  All fields are stable in everything\n\t * we encounter.\n\t */\n\thlist_bl_for_each_entry(dentry, node, b, d_u.d_in_lookup_hash) {\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tcontinue;\n\t\thlist_bl_unlock(b);\n\t\t/* now we can try to grab a reference */\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\n\t\trcu_read_unlock();\n\t\t/*\n\t\t * somebody is likely to be still doing lookup for it;\n\t\t * wait for them to finish\n\t\t */\n\t\tspin_lock(&dentry->d_lock);\n\t\td_wait_lookup(dentry);\n\t\t/*\n\t\t * it's not in-lookup anymore; in principle we should repeat\n\t\t * everything from dcache lookup, but it's likely to be what\n\t\t * d_lookup() would've found anyway.  If it is, just return it;\n\t\t * otherwise we really have to repeat the whole thing.\n\t\t */\n\t\tif (unlikely(dentry->d_name.hash != hash))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(dentry->d_parent != parent))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(d_unhashed(dentry)))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(!d_same_name(dentry, parent, name)))\n\t\t\tgoto mismatch;\n\t\t/* OK, it *is* a hashed match; return it */\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\trcu_read_unlock();\n\t/* we can't take ->d_lock here; it's OK, though. */\n\tnew->d_flags |= DCACHE_PAR_LOOKUP;\n\tnew->d_wait = wq;\n\thlist_bl_add_head_rcu(&new->d_u.d_in_lookup_hash, b);\n\thlist_bl_unlock(b);\n\treturn new;\nmismatch:\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\tgoto retry;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_bl_unlock",
          "args": [
            "b"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_add_head_rcu",
          "args": [
            "&new->d_u.d_in_lookup_hash",
            "b"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!d_same_name(dentry, parent, name)"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_same_name",
          "args": [
            "dentry",
            "parent",
            "name"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "d_same_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2069-2081",
          "snippet": "static inline bool d_same_name(const struct dentry *dentry,\n\t\t\t\tconst struct dentry *parent,\n\t\t\t\tconst struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool d_same_name(const struct dentry *dentry,\n\t\t\t\tconst struct dentry *parent,\n\t\t\t\tconst struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "d_unhashed(dentry)"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_parent != parent"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_name.hash != hash"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_wait_lookup",
          "args": [
            "dentry"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "d_wait_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2400-2412",
          "snippet": "static void d_wait_lookup(struct dentry *dentry)\n{\n\tif (d_in_lookup(dentry)) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\t\tadd_wait_queue(dentry->d_wait, &wait);\n\t\tdo {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t} while (d_in_lookup(dentry));\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void d_wait_lookup(struct dentry *dentry)\n{\n\tif (d_in_lookup(dentry)) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\t\tadd_wait_queue(dentry->d_wait, &wait);\n\t\tdo {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t} while (d_in_lookup(dentry));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_get_not_dead",
          "args": [
            "&dentry->d_lockref"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_unlock",
          "args": [
            "b"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_for_each_entry",
          "args": [
            "dentry",
            "node",
            "b",
            "d_u.d_in_lookup_hash"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_unlock",
          "args": [
            "b"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "READ_ONCE(parent->d_inode->i_dir_seq) != seq"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "parent->d_inode->i_dir_seq"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_lock",
          "args": [
            "b"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "seq & 1"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_seqretry(&rename_lock, r_seq)"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "r_seq"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&dentry->d_seq",
            "d_seq"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_get_not_dead",
          "args": [
            "&dentry->d_lockref"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_lookup_rcu",
          "args": [
            "parent",
            "name",
            "&d_seq"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "__d_lookup_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2112-2194",
          "snippet": "struct dentry *__d_lookup_rcu(const struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\tunsigned *seqp)\n{\n\tu64 hashlen = name->hash_len;\n\tconst unsigned char *str = name->name;\n\tstruct hlist_bl_head *b = d_hash(hashlen_hash(hashlen));\n\tstruct hlist_bl_node *node;\n\tstruct dentry *dentry;\n\n\t/*\n\t * Note: There is significant duplication with __d_lookup_rcu which is\n\t * required to prevent single threaded performance regressions\n\t * especially on architectures where smp_rmb (in seqcounts) are costly.\n\t * Keep the two functions in sync.\n\t */\n\n\t/*\n\t * The hash list is protected using RCU.\n\t *\n\t * Carefully use d_seq when comparing a candidate dentry, to avoid\n\t * races with d_move().\n\t *\n\t * It is possible that concurrent renames can mess up our list\n\t * walk here and result in missing our dentry, resulting in the\n\t * false-negative result. d_lookup() protects against concurrent\n\t * renames using rename_lock seqlock.\n\t *\n\t * See Documentation/filesystems/path-lookup.txt for more details.\n\t */\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\t\tunsigned seq;\n\nseqretry:\n\t\t/*\n\t\t * The dentry sequence count protects us from concurrent\n\t\t * renames, and thus protects parent and name fields.\n\t\t *\n\t\t * The caller must perform a seqcount check in order\n\t\t * to do anything useful with the returned dentry.\n\t\t *\n\t\t * NOTE! We do a \"raw\" seqcount_begin here. That means that\n\t\t * we don't wait for the sequence count to stabilize if it\n\t\t * is in the middle of a sequence change. If we do the slow\n\t\t * dentry compare, we will do seqretries until it is stable,\n\t\t * and if we end up with a successful lookup, we actually\n\t\t * want to exit RCU lookup anyway.\n\t\t *\n\t\t * Note that raw_seqcount_begin still *does* smp_rmb(), so\n\t\t * we are still guaranteed NUL-termination of ->d_name.name.\n\t\t */\n\t\tseq = raw_seqcount_begin(&dentry->d_seq);\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (d_unhashed(dentry))\n\t\t\tcontinue;\n\n\t\tif (unlikely(parent->d_flags & DCACHE_OP_COMPARE)) {\n\t\t\tint tlen;\n\t\t\tconst char *tname;\n\t\t\tif (dentry->d_name.hash != hashlen_hash(hashlen))\n\t\t\t\tcontinue;\n\t\t\ttlen = dentry->d_name.len;\n\t\t\ttname = dentry->d_name.name;\n\t\t\t/* we want a consistent (name,len) pair */\n\t\t\tif (read_seqcount_retry(&dentry->d_seq, seq)) {\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto seqretry;\n\t\t\t}\n\t\t\tif (parent->d_op->d_compare(dentry,\n\t\t\t\t\t\t    tlen, tname, name) != 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (dentry->d_name.hash_len != hashlen)\n\t\t\t\tcontinue;\n\t\t\tif (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\t*seqp = seq;\n\t\treturn dentry;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *__d_lookup_rcu(const struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\tunsigned *seqp)\n{\n\tu64 hashlen = name->hash_len;\n\tconst unsigned char *str = name->name;\n\tstruct hlist_bl_head *b = d_hash(hashlen_hash(hashlen));\n\tstruct hlist_bl_node *node;\n\tstruct dentry *dentry;\n\n\t/*\n\t * Note: There is significant duplication with __d_lookup_rcu which is\n\t * required to prevent single threaded performance regressions\n\t * especially on architectures where smp_rmb (in seqcounts) are costly.\n\t * Keep the two functions in sync.\n\t */\n\n\t/*\n\t * The hash list is protected using RCU.\n\t *\n\t * Carefully use d_seq when comparing a candidate dentry, to avoid\n\t * races with d_move().\n\t *\n\t * It is possible that concurrent renames can mess up our list\n\t * walk here and result in missing our dentry, resulting in the\n\t * false-negative result. d_lookup() protects against concurrent\n\t * renames using rename_lock seqlock.\n\t *\n\t * See Documentation/filesystems/path-lookup.txt for more details.\n\t */\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\t\tunsigned seq;\n\nseqretry:\n\t\t/*\n\t\t * The dentry sequence count protects us from concurrent\n\t\t * renames, and thus protects parent and name fields.\n\t\t *\n\t\t * The caller must perform a seqcount check in order\n\t\t * to do anything useful with the returned dentry.\n\t\t *\n\t\t * NOTE! We do a \"raw\" seqcount_begin here. That means that\n\t\t * we don't wait for the sequence count to stabilize if it\n\t\t * is in the middle of a sequence change. If we do the slow\n\t\t * dentry compare, we will do seqretries until it is stable,\n\t\t * and if we end up with a successful lookup, we actually\n\t\t * want to exit RCU lookup anyway.\n\t\t *\n\t\t * Note that raw_seqcount_begin still *does* smp_rmb(), so\n\t\t * we are still guaranteed NUL-termination of ->d_name.name.\n\t\t */\n\t\tseq = raw_seqcount_begin(&dentry->d_seq);\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (d_unhashed(dentry))\n\t\t\tcontinue;\n\n\t\tif (unlikely(parent->d_flags & DCACHE_OP_COMPARE)) {\n\t\t\tint tlen;\n\t\t\tconst char *tname;\n\t\t\tif (dentry->d_name.hash != hashlen_hash(hashlen))\n\t\t\t\tcontinue;\n\t\t\ttlen = dentry->d_name.len;\n\t\t\ttname = dentry->d_name.name;\n\t\t\t/* we want a consistent (name,len) pair */\n\t\t\tif (read_seqcount_retry(&dentry->d_seq, seq)) {\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto seqretry;\n\t\t\t}\n\t\t\tif (parent->d_op->d_compare(dentry,\n\t\t\t\t\t\t    tlen, tname, name) != 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (dentry->d_name.hash_len != hashlen)\n\t\t\t\tcontinue;\n\t\t\tif (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\t*seqp = seq;\n\t\treturn dentry;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&parent->d_inode->i_dir_seq"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!new"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "parent",
            "name"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1726-1733",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_lookup_hash",
          "args": [
            "parent",
            "hash"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "in_lookup_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "107-112",
          "snippet": "static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent,\n\t\t\t\t\tunsigned int hash)\n{\n\thash += (unsigned long) parent / L1_CACHE_BYTES;\n\treturn in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [
            "#define IN_LOOKUP_SHIFT 10"
          ],
          "globals_used": [
            "static struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n#define IN_LOOKUP_SHIFT 10\n\nstatic struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];\n\nstatic inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent,\n\t\t\t\t\tunsigned int hash)\n{\n\thash += (unsigned long) parent / L1_CACHE_BYTES;\n\treturn in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_alloc_parallel(struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\twait_queue_head_t *wq)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = in_lookup_hash(parent, hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *new = d_alloc(parent, name);\n\tstruct dentry *dentry;\n\tunsigned seq, r_seq, d_seq;\n\n\tif (unlikely(!new))\n\t\treturn ERR_PTR(-ENOMEM);\n\nretry:\n\trcu_read_lock();\n\tseq = smp_load_acquire(&parent->d_inode->i_dir_seq);\n\tr_seq = read_seqbegin(&rename_lock);\n\tdentry = __d_lookup_rcu(parent, name, &d_seq);\n\tif (unlikely(dentry)) {\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (read_seqcount_retry(&dentry->d_seq, d_seq)) {\n\t\t\trcu_read_unlock();\n\t\t\tdput(dentry);\n\t\t\tgoto retry;\n\t\t}\n\t\trcu_read_unlock();\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, r_seq))) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\tif (unlikely(seq & 1)) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\thlist_bl_lock(b);\n\tif (unlikely(READ_ONCE(parent->d_inode->i_dir_seq) != seq)) {\n\t\thlist_bl_unlock(b);\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\t/*\n\t * No changes for the parent since the beginning of d_lookup().\n\t * Since all removals from the chain happen with hlist_bl_lock(),\n\t * any potential in-lookup matches are going to stay here until\n\t * we unlock the chain.  All fields are stable in everything\n\t * we encounter.\n\t */\n\thlist_bl_for_each_entry(dentry, node, b, d_u.d_in_lookup_hash) {\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tcontinue;\n\t\thlist_bl_unlock(b);\n\t\t/* now we can try to grab a reference */\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\n\t\trcu_read_unlock();\n\t\t/*\n\t\t * somebody is likely to be still doing lookup for it;\n\t\t * wait for them to finish\n\t\t */\n\t\tspin_lock(&dentry->d_lock);\n\t\td_wait_lookup(dentry);\n\t\t/*\n\t\t * it's not in-lookup anymore; in principle we should repeat\n\t\t * everything from dcache lookup, but it's likely to be what\n\t\t * d_lookup() would've found anyway.  If it is, just return it;\n\t\t * otherwise we really have to repeat the whole thing.\n\t\t */\n\t\tif (unlikely(dentry->d_name.hash != hash))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(dentry->d_parent != parent))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(d_unhashed(dentry)))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(!d_same_name(dentry, parent, name)))\n\t\t\tgoto mismatch;\n\t\t/* OK, it *is* a hashed match; return it */\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\trcu_read_unlock();\n\t/* we can't take ->d_lock here; it's OK, though. */\n\tnew->d_flags |= DCACHE_PAR_LOOKUP;\n\tnew->d_wait = wq;\n\thlist_bl_add_head_rcu(&new->d_u.d_in_lookup_hash, b);\n\thlist_bl_unlock(b);\n\treturn new;\nmismatch:\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\tgoto retry;\n}"
  },
  {
    "function_name": "d_wait_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2400-2412",
    "snippet": "static void d_wait_lookup(struct dentry *dentry)\n{\n\tif (d_in_lookup(dentry)) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\t\tadd_wait_queue(dentry->d_wait, &wait);\n\t\tdo {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t} while (d_in_lookup(dentry));\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_in_lookup",
          "args": [
            "dentry"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "dentry->d_wait",
            "&wait"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "wait",
            "current"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_in_lookup",
          "args": [
            "dentry"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void d_wait_lookup(struct dentry *dentry)\n{\n\tif (d_in_lookup(dentry)) {\n\t\tDECLARE_WAITQUEUE(wait, current);\n\t\tadd_wait_queue(dentry->d_wait, &wait);\n\t\tdo {\n\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tschedule();\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t} while (d_in_lookup(dentry));\n\t}\n}"
  },
  {
    "function_name": "end_dir_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2395-2398",
    "snippet": "static inline void end_dir_add(struct inode *dir, unsigned n)\n{\n\tsmp_store_release(&dir->i_dir_seq, n + 2);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&dir->i_dir_seq",
            "n + 2"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void end_dir_add(struct inode *dir, unsigned n)\n{\n\tsmp_store_release(&dir->i_dir_seq, n + 2);\n}"
  },
  {
    "function_name": "start_dir_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2384-2393",
    "snippet": "static inline unsigned start_dir_add(struct inode *dir)\n{\n\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&dir->i_dir_seq",
            "n",
            "n + 1"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline unsigned start_dir_add(struct inode *dir)\n{\n\n\tfor (;;) {\n\t\tunsigned n = dir->i_dir_seq;\n\t\tif (!(n & 1) && cmpxchg(&dir->i_dir_seq, n, n + 1) == n)\n\t\t\treturn n;\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "d_rehash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2376-2381",
    "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t__d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&entry->d_lock"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_rehash",
          "args": [
            "entry"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "__d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2360-2367",
          "snippet": "static void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&entry->d_lock"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t__d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
  },
  {
    "function_name": "__d_rehash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2360-2367",
    "snippet": "static void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_bl_unlock",
          "args": [
            "b"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_add_head_rcu",
          "args": [
            "&entry->d_hash",
            "b"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_lock",
          "args": [
            "b"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_hash",
          "args": [
            "entry->d_name.hash"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "99-102",
          "snippet": "static inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int d_hash_shift",
            "static struct hlist_bl_head *dentry_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\n\nstatic inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_rehash(struct dentry *entry)\n{\n\tstruct hlist_bl_head *b = d_hash(entry->d_name.hash);\n\n\thlist_bl_lock(b);\n\thlist_bl_add_head_rcu(&entry->d_hash, b);\n\thlist_bl_unlock(b);\n}"
  },
  {
    "function_name": "d_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2338-2357",
    "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint isdir = d_is_dir(dentry);\n\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\t/*\n\t * Are we the only user?\n\t */\n\tif (dentry->d_lockref.count == 1) {\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t} else {\n\t\t__d_drop(dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tfsnotify_nameremove(dentry, isdir);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_nameremove",
          "args": [
            "dentry",
            "isdir"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_drop",
          "args": [
            "dentry"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "__d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "467-474",
          "snippet": "void __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_unlink_inode",
          "args": [
            "dentry"
          ],
          "line": 2350
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_unlink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "343-361",
          "snippet": "static void dentry_unlink_inode(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_clear_type_and_inode(dentry);\n\thlist_del_init(&dentry->d_u.d_alias);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tif (!inode->i_nlink)\n\t\tfsnotify_inoderemove(inode);\n\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\tdentry->d_op->d_iput(dentry, inode);\n\telse\n\t\tiput(inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void dentry_unlink_inode(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_clear_type_and_inode(dentry);\n\thlist_del_init(&dentry->d_u.d_alias);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tif (!inode->i_nlink)\n\t\tfsnotify_inoderemove(inode);\n\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\tdentry->d_op->d_iput(dentry, inode);\n\telse\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint isdir = d_is_dir(dentry);\n\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\t/*\n\t * Are we the only user?\n\t */\n\tif (dentry->d_lockref.count == 1) {\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t} else {\n\t\t__d_drop(dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tfsnotify_nameremove(dentry, isdir);\n}"
  },
  {
    "function_name": "d_hash_and_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2300-2314",
    "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(dir, name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_lookup",
          "args": [
            "dir",
            "name"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2300-2314",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(dir, name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir->d_op->d_hash",
          "args": [
            "dir",
            "name"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "dir",
            "name->name",
            "name->len"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "2015-2021",
          "snippet": "unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash(salt);\n\twhile (len--)\n\t\thash = partial_name_hash((unsigned char)*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const void *salt, const char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash(salt);\n\twhile (len--)\n\t\thash = partial_name_hash((unsigned char)*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(dir, name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
  },
  {
    "function_name": "__d_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2237-2291",
    "snippet": "struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = d_hash(hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *found = NULL;\n\tstruct dentry *dentry;\n\n\t/*\n\t * Note: There is significant duplication with __d_lookup_rcu which is\n\t * required to prevent single threaded performance regressions\n\t * especially on architectures where smp_rmb (in seqcounts) are costly.\n\t * Keep the two functions in sync.\n\t */\n\n\t/*\n\t * The hash list is protected using RCU.\n\t *\n\t * Take d_lock when comparing a candidate dentry, to avoid races\n\t * with d_move().\n\t *\n\t * It is possible that concurrent renames can mess up our list\n\t * walk here and result in missing our dentry, resulting in the\n\t * false-negative result. d_lookup() protects against concurrent\n\t * renames using rename_lock seqlock.\n\t *\n\t * See Documentation/filesystems/path-lookup.txt for more details.\n\t */\n\trcu_read_lock();\n\t\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_parent != parent)\n\t\t\tgoto next;\n\t\tif (d_unhashed(dentry))\n\t\t\tgoto next;\n\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tgoto next;\n\n\t\tdentry->d_lockref.count++;\n\t\tfound = dentry;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tbreak;\nnext:\n\t\tspin_unlock(&dentry->d_lock);\n \t}\n \trcu_read_unlock();\n\n \treturn found;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_same_name",
          "args": [
            "dentry",
            "parent",
            "name"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "d_same_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2069-2081",
          "snippet": "static inline bool d_same_name(const struct dentry *dentry,\n\t\t\t\tconst struct dentry *parent,\n\t\t\t\tconst struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool d_same_name(const struct dentry *dentry,\n\t\t\t\tconst struct dentry *parent,\n\t\t\t\tconst struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_bl_for_each_entry_rcu",
          "args": [
            "dentry",
            "node",
            "b",
            "d_hash"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_hash",
          "args": [
            "hash"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "99-102",
          "snippet": "static inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int d_hash_shift",
            "static struct hlist_bl_head *dentry_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\n\nstatic inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = d_hash(hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *found = NULL;\n\tstruct dentry *dentry;\n\n\t/*\n\t * Note: There is significant duplication with __d_lookup_rcu which is\n\t * required to prevent single threaded performance regressions\n\t * especially on architectures where smp_rmb (in seqcounts) are costly.\n\t * Keep the two functions in sync.\n\t */\n\n\t/*\n\t * The hash list is protected using RCU.\n\t *\n\t * Take d_lock when comparing a candidate dentry, to avoid races\n\t * with d_move().\n\t *\n\t * It is possible that concurrent renames can mess up our list\n\t * walk here and result in missing our dentry, resulting in the\n\t * false-negative result. d_lookup() protects against concurrent\n\t * renames using rename_lock seqlock.\n\t *\n\t * See Documentation/filesystems/path-lookup.txt for more details.\n\t */\n\trcu_read_lock();\n\t\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_parent != parent)\n\t\t\tgoto next;\n\t\tif (d_unhashed(dentry))\n\t\t\tgoto next;\n\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tgoto next;\n\n\t\tdentry->d_lockref.count++;\n\t\tfound = dentry;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tbreak;\nnext:\n\t\tspin_unlock(&dentry->d_lock);\n \t}\n \trcu_read_unlock();\n\n \treturn found;\n}"
  },
  {
    "function_name": "d_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2207-2219",
    "snippet": "struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&rename_lock);\n\t\tdentry = __d_lookup(parent, name);\n\t\tif (dentry)\n\t\t\tbreak;\n\t} while (read_seqretry(&rename_lock, seq));\n\treturn dentry;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_lookup",
          "args": [
            "parent",
            "name"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "__d_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2237-2291",
          "snippet": "struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = d_hash(hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *found = NULL;\n\tstruct dentry *dentry;\n\n\t/*\n\t * Note: There is significant duplication with __d_lookup_rcu which is\n\t * required to prevent single threaded performance regressions\n\t * especially on architectures where smp_rmb (in seqcounts) are costly.\n\t * Keep the two functions in sync.\n\t */\n\n\t/*\n\t * The hash list is protected using RCU.\n\t *\n\t * Take d_lock when comparing a candidate dentry, to avoid races\n\t * with d_move().\n\t *\n\t * It is possible that concurrent renames can mess up our list\n\t * walk here and result in missing our dentry, resulting in the\n\t * false-negative result. d_lookup() protects against concurrent\n\t * renames using rename_lock seqlock.\n\t *\n\t * See Documentation/filesystems/path-lookup.txt for more details.\n\t */\n\trcu_read_lock();\n\t\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_parent != parent)\n\t\t\tgoto next;\n\t\tif (d_unhashed(dentry))\n\t\t\tgoto next;\n\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tgoto next;\n\n\t\tdentry->d_lockref.count++;\n\t\tfound = dentry;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tbreak;\nnext:\n\t\tspin_unlock(&dentry->d_lock);\n \t}\n \trcu_read_unlock();\n\n \treturn found;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = d_hash(hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *found = NULL;\n\tstruct dentry *dentry;\n\n\t/*\n\t * Note: There is significant duplication with __d_lookup_rcu which is\n\t * required to prevent single threaded performance regressions\n\t * especially on architectures where smp_rmb (in seqcounts) are costly.\n\t * Keep the two functions in sync.\n\t */\n\n\t/*\n\t * The hash list is protected using RCU.\n\t *\n\t * Take d_lock when comparing a candidate dentry, to avoid races\n\t * with d_move().\n\t *\n\t * It is possible that concurrent renames can mess up our list\n\t * walk here and result in missing our dentry, resulting in the\n\t * false-negative result. d_lookup() protects against concurrent\n\t * renames using rename_lock seqlock.\n\t *\n\t * See Documentation/filesystems/path-lookup.txt for more details.\n\t */\n\trcu_read_lock();\n\t\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_parent != parent)\n\t\t\tgoto next;\n\t\tif (d_unhashed(dentry))\n\t\t\tgoto next;\n\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tgoto next;\n\n\t\tdentry->d_lockref.count++;\n\t\tfound = dentry;\n\t\tspin_unlock(&dentry->d_lock);\n\t\tbreak;\nnext:\n\t\tspin_unlock(&dentry->d_lock);\n \t}\n \trcu_read_unlock();\n\n \treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqbegin(&rename_lock);\n\t\tdentry = __d_lookup(parent, name);\n\t\tif (dentry)\n\t\t\tbreak;\n\t} while (read_seqretry(&rename_lock, seq));\n\treturn dentry;\n}"
  },
  {
    "function_name": "__d_lookup_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2112-2194",
    "snippet": "struct dentry *__d_lookup_rcu(const struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\tunsigned *seqp)\n{\n\tu64 hashlen = name->hash_len;\n\tconst unsigned char *str = name->name;\n\tstruct hlist_bl_head *b = d_hash(hashlen_hash(hashlen));\n\tstruct hlist_bl_node *node;\n\tstruct dentry *dentry;\n\n\t/*\n\t * Note: There is significant duplication with __d_lookup_rcu which is\n\t * required to prevent single threaded performance regressions\n\t * especially on architectures where smp_rmb (in seqcounts) are costly.\n\t * Keep the two functions in sync.\n\t */\n\n\t/*\n\t * The hash list is protected using RCU.\n\t *\n\t * Carefully use d_seq when comparing a candidate dentry, to avoid\n\t * races with d_move().\n\t *\n\t * It is possible that concurrent renames can mess up our list\n\t * walk here and result in missing our dentry, resulting in the\n\t * false-negative result. d_lookup() protects against concurrent\n\t * renames using rename_lock seqlock.\n\t *\n\t * See Documentation/filesystems/path-lookup.txt for more details.\n\t */\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\t\tunsigned seq;\n\nseqretry:\n\t\t/*\n\t\t * The dentry sequence count protects us from concurrent\n\t\t * renames, and thus protects parent and name fields.\n\t\t *\n\t\t * The caller must perform a seqcount check in order\n\t\t * to do anything useful with the returned dentry.\n\t\t *\n\t\t * NOTE! We do a \"raw\" seqcount_begin here. That means that\n\t\t * we don't wait for the sequence count to stabilize if it\n\t\t * is in the middle of a sequence change. If we do the slow\n\t\t * dentry compare, we will do seqretries until it is stable,\n\t\t * and if we end up with a successful lookup, we actually\n\t\t * want to exit RCU lookup anyway.\n\t\t *\n\t\t * Note that raw_seqcount_begin still *does* smp_rmb(), so\n\t\t * we are still guaranteed NUL-termination of ->d_name.name.\n\t\t */\n\t\tseq = raw_seqcount_begin(&dentry->d_seq);\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (d_unhashed(dentry))\n\t\t\tcontinue;\n\n\t\tif (unlikely(parent->d_flags & DCACHE_OP_COMPARE)) {\n\t\t\tint tlen;\n\t\t\tconst char *tname;\n\t\t\tif (dentry->d_name.hash != hashlen_hash(hashlen))\n\t\t\t\tcontinue;\n\t\t\ttlen = dentry->d_name.len;\n\t\t\ttname = dentry->d_name.name;\n\t\t\t/* we want a consistent (name,len) pair */\n\t\t\tif (read_seqcount_retry(&dentry->d_seq, seq)) {\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto seqretry;\n\t\t\t}\n\t\t\tif (parent->d_op->d_compare(dentry,\n\t\t\t\t\t\t    tlen, tname, name) != 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (dentry->d_name.hash_len != hashlen)\n\t\t\t\tcontinue;\n\t\t\tif (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\t*seqp = seq;\n\t\treturn dentry;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dentry_cmp",
          "args": [
            "dentry",
            "str",
            "hashlen_len(hashlen)"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "217-238",
          "snippet": "static inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)\n{\n\t/*\n\t * Be careful about RCU walk racing with rename:\n\t * use 'READ_ONCE' to fetch the name pointer.\n\t *\n\t * NOTE! Even if a rename will mean that the length\n\t * was not loaded atomically, we don't care. The\n\t * RCU walk will check the sequence count eventually,\n\t * and catch it. And we won't overrun the buffer,\n\t * because we're reading the name pointer atomically,\n\t * and a dentry name is guaranteed to be properly\n\t * terminated with a NUL byte.\n\t *\n\t * End result: even if 'len' is wrong, we'll exit\n\t * early because the data cannot match (there can\n\t * be no NUL in the ct/tcount data)\n\t */\n\tconst unsigned char *cs = READ_ONCE(dentry->d_name.name);\n\n\treturn dentry_string_cmp(cs, ct, tcount);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)\n{\n\t/*\n\t * Be careful about RCU walk racing with rename:\n\t * use 'READ_ONCE' to fetch the name pointer.\n\t *\n\t * NOTE! Even if a rename will mean that the length\n\t * was not loaded atomically, we don't care. The\n\t * RCU walk will check the sequence count eventually,\n\t * and catch it. And we won't overrun the buffer,\n\t * because we're reading the name pointer atomically,\n\t * and a dentry name is guaranteed to be properly\n\t * terminated with a NUL byte.\n\t *\n\t * End result: even if 'len' is wrong, we'll exit\n\t * early because the data cannot match (there can\n\t * be no NUL in the ct/tcount data)\n\t */\n\tconst unsigned char *cs = READ_ONCE(dentry->d_name.name);\n\n\treturn dentry_string_cmp(cs, ct, tcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashlen_len",
          "args": [
            "hashlen"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parent->d_op->d_compare",
          "args": [
            "dentry",
            "tlen",
            "tname",
            "name"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqcount_retry",
          "args": [
            "&dentry->d_seq",
            "seq"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashlen_hash",
          "args": [
            "hashlen"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "parent->d_flags & DCACHE_OP_COMPARE"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_seqcount_begin",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_for_each_entry_rcu",
          "args": [
            "dentry",
            "node",
            "b",
            "d_hash"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_hash",
          "args": [
            "hashlen_hash(hashlen)"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "99-102",
          "snippet": "static inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int d_hash_shift",
            "static struct hlist_bl_head *dentry_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\n\nstatic inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashlen_hash",
          "args": [
            "hashlen"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *__d_lookup_rcu(const struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\tunsigned *seqp)\n{\n\tu64 hashlen = name->hash_len;\n\tconst unsigned char *str = name->name;\n\tstruct hlist_bl_head *b = d_hash(hashlen_hash(hashlen));\n\tstruct hlist_bl_node *node;\n\tstruct dentry *dentry;\n\n\t/*\n\t * Note: There is significant duplication with __d_lookup_rcu which is\n\t * required to prevent single threaded performance regressions\n\t * especially on architectures where smp_rmb (in seqcounts) are costly.\n\t * Keep the two functions in sync.\n\t */\n\n\t/*\n\t * The hash list is protected using RCU.\n\t *\n\t * Carefully use d_seq when comparing a candidate dentry, to avoid\n\t * races with d_move().\n\t *\n\t * It is possible that concurrent renames can mess up our list\n\t * walk here and result in missing our dentry, resulting in the\n\t * false-negative result. d_lookup() protects against concurrent\n\t * renames using rename_lock seqlock.\n\t *\n\t * See Documentation/filesystems/path-lookup.txt for more details.\n\t */\n\thlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) {\n\t\tunsigned seq;\n\nseqretry:\n\t\t/*\n\t\t * The dentry sequence count protects us from concurrent\n\t\t * renames, and thus protects parent and name fields.\n\t\t *\n\t\t * The caller must perform a seqcount check in order\n\t\t * to do anything useful with the returned dentry.\n\t\t *\n\t\t * NOTE! We do a \"raw\" seqcount_begin here. That means that\n\t\t * we don't wait for the sequence count to stabilize if it\n\t\t * is in the middle of a sequence change. If we do the slow\n\t\t * dentry compare, we will do seqretries until it is stable,\n\t\t * and if we end up with a successful lookup, we actually\n\t\t * want to exit RCU lookup anyway.\n\t\t *\n\t\t * Note that raw_seqcount_begin still *does* smp_rmb(), so\n\t\t * we are still guaranteed NUL-termination of ->d_name.name.\n\t\t */\n\t\tseq = raw_seqcount_begin(&dentry->d_seq);\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (d_unhashed(dentry))\n\t\t\tcontinue;\n\n\t\tif (unlikely(parent->d_flags & DCACHE_OP_COMPARE)) {\n\t\t\tint tlen;\n\t\t\tconst char *tname;\n\t\t\tif (dentry->d_name.hash != hashlen_hash(hashlen))\n\t\t\t\tcontinue;\n\t\t\ttlen = dentry->d_name.len;\n\t\t\ttname = dentry->d_name.name;\n\t\t\t/* we want a consistent (name,len) pair */\n\t\t\tif (read_seqcount_retry(&dentry->d_seq, seq)) {\n\t\t\t\tcpu_relax();\n\t\t\t\tgoto seqretry;\n\t\t\t}\n\t\t\tif (parent->d_op->d_compare(dentry,\n\t\t\t\t\t\t    tlen, tname, name) != 0)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (dentry->d_name.hash_len != hashlen)\n\t\t\t\tcontinue;\n\t\t\tif (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0)\n\t\t\t\tcontinue;\n\t\t}\n\t\t*seqp = seq;\n\t\treturn dentry;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "d_same_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2069-2081",
    "snippet": "static inline bool d_same_name(const struct dentry *dentry,\n\t\t\t\tconst struct dentry *parent,\n\t\t\t\tconst struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parent->d_op->d_compare",
          "args": [
            "dentry",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "name"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_cmp",
          "args": [
            "dentry",
            "name->name",
            "name->len"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "217-238",
          "snippet": "static inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)\n{\n\t/*\n\t * Be careful about RCU walk racing with rename:\n\t * use 'READ_ONCE' to fetch the name pointer.\n\t *\n\t * NOTE! Even if a rename will mean that the length\n\t * was not loaded atomically, we don't care. The\n\t * RCU walk will check the sequence count eventually,\n\t * and catch it. And we won't overrun the buffer,\n\t * because we're reading the name pointer atomically,\n\t * and a dentry name is guaranteed to be properly\n\t * terminated with a NUL byte.\n\t *\n\t * End result: even if 'len' is wrong, we'll exit\n\t * early because the data cannot match (there can\n\t * be no NUL in the ct/tcount data)\n\t */\n\tconst unsigned char *cs = READ_ONCE(dentry->d_name.name);\n\n\treturn dentry_string_cmp(cs, ct, tcount);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)\n{\n\t/*\n\t * Be careful about RCU walk racing with rename:\n\t * use 'READ_ONCE' to fetch the name pointer.\n\t *\n\t * NOTE! Even if a rename will mean that the length\n\t * was not loaded atomically, we don't care. The\n\t * RCU walk will check the sequence count eventually,\n\t * and catch it. And we won't overrun the buffer,\n\t * because we're reading the name pointer atomically,\n\t * and a dentry name is guaranteed to be properly\n\t * terminated with a NUL byte.\n\t *\n\t * End result: even if 'len' is wrong, we'll exit\n\t * early because the data cannot match (there can\n\t * be no NUL in the ct/tcount data)\n\t */\n\tconst unsigned char *cs = READ_ONCE(dentry->d_name.name);\n\n\treturn dentry_string_cmp(cs, ct, tcount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(parent->d_flags & DCACHE_OP_COMPARE)"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool d_same_name(const struct dentry *dentry,\n\t\t\t\tconst struct dentry *parent,\n\t\t\t\tconst struct qstr *name)\n{\n\tif (likely(!(parent->d_flags & DCACHE_OP_COMPARE))) {\n\t\tif (dentry->d_name.len != name->len)\n\t\t\treturn false;\n\t\treturn dentry_cmp(dentry, name->name, name->len) == 0;\n\t}\n\treturn parent->d_op->d_compare(dentry,\n\t\t\t\t       dentry->d_name.len, dentry->d_name.name,\n\t\t\t\t       name) == 0;\n}"
  },
  {
    "function_name": "d_add_ci",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2031-2065",
    "snippet": "struct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,\n\t\t\tstruct qstr *name)\n{\n\tstruct dentry *found, *res;\n\n\t/*\n\t * First check if a dentry matching the name already exists,\n\t * if not go ahead and create it now.\n\t */\n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (found) {\n\t\tiput(inode);\n\t\treturn found;\n\t}\n\tif (d_in_lookup(dentry)) {\n\t\tfound = d_alloc_parallel(dentry->d_parent, name,\n\t\t\t\t\tdentry->d_wait);\n\t\tif (IS_ERR(found) || !d_in_lookup(found)) {\n\t\t\tiput(inode);\n\t\t\treturn found;\n\t\t}\n\t} else {\n\t\tfound = d_alloc(dentry->d_parent, name);\n\t\tif (!found) {\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t} \n\t}\n\tres = d_splice_alias(inode, found);\n\tif (res) {\n\t\tdput(found);\n\t\treturn res;\n\t}\n\treturn found;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "found"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "found"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2901-2949",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode)\n\t\tgoto out;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\t/* The reference to new ensures it remains an alias */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tstruct dentry *old_parent = dget(new->d_parent);\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t\tdput(old_parent);\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\nout:\n\t__d_add(dentry, inode);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode)\n\t\tgoto out;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\t/* The reference to new ensures it remains an alias */\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tstruct dentry *old_parent = dget(new->d_parent);\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t\tdput(old_parent);\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\nout:\n\t__d_add(dentry, inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "dentry->d_parent",
            "name"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1726-1733",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_in_lookup",
          "args": [
            "found"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "found"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc_parallel",
          "args": [
            "dentry->d_parent",
            "name",
            "dentry->d_wait"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_parallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2414-2521",
          "snippet": "struct dentry *d_alloc_parallel(struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\twait_queue_head_t *wq)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = in_lookup_hash(parent, hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *new = d_alloc(parent, name);\n\tstruct dentry *dentry;\n\tunsigned seq, r_seq, d_seq;\n\n\tif (unlikely(!new))\n\t\treturn ERR_PTR(-ENOMEM);\n\nretry:\n\trcu_read_lock();\n\tseq = smp_load_acquire(&parent->d_inode->i_dir_seq);\n\tr_seq = read_seqbegin(&rename_lock);\n\tdentry = __d_lookup_rcu(parent, name, &d_seq);\n\tif (unlikely(dentry)) {\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (read_seqcount_retry(&dentry->d_seq, d_seq)) {\n\t\t\trcu_read_unlock();\n\t\t\tdput(dentry);\n\t\t\tgoto retry;\n\t\t}\n\t\trcu_read_unlock();\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, r_seq))) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\tif (unlikely(seq & 1)) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\thlist_bl_lock(b);\n\tif (unlikely(READ_ONCE(parent->d_inode->i_dir_seq) != seq)) {\n\t\thlist_bl_unlock(b);\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\t/*\n\t * No changes for the parent since the beginning of d_lookup().\n\t * Since all removals from the chain happen with hlist_bl_lock(),\n\t * any potential in-lookup matches are going to stay here until\n\t * we unlock the chain.  All fields are stable in everything\n\t * we encounter.\n\t */\n\thlist_bl_for_each_entry(dentry, node, b, d_u.d_in_lookup_hash) {\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tcontinue;\n\t\thlist_bl_unlock(b);\n\t\t/* now we can try to grab a reference */\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\n\t\trcu_read_unlock();\n\t\t/*\n\t\t * somebody is likely to be still doing lookup for it;\n\t\t * wait for them to finish\n\t\t */\n\t\tspin_lock(&dentry->d_lock);\n\t\td_wait_lookup(dentry);\n\t\t/*\n\t\t * it's not in-lookup anymore; in principle we should repeat\n\t\t * everything from dcache lookup, but it's likely to be what\n\t\t * d_lookup() would've found anyway.  If it is, just return it;\n\t\t * otherwise we really have to repeat the whole thing.\n\t\t */\n\t\tif (unlikely(dentry->d_name.hash != hash))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(dentry->d_parent != parent))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(d_unhashed(dentry)))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(!d_same_name(dentry, parent, name)))\n\t\t\tgoto mismatch;\n\t\t/* OK, it *is* a hashed match; return it */\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\trcu_read_unlock();\n\t/* we can't take ->d_lock here; it's OK, though. */\n\tnew->d_flags |= DCACHE_PAR_LOOKUP;\n\tnew->d_wait = wq;\n\thlist_bl_add_head_rcu(&new->d_u.d_in_lookup_hash, b);\n\thlist_bl_unlock(b);\n\treturn new;\nmismatch:\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\tgoto retry;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_alloc_parallel(struct dentry *parent,\n\t\t\t\tconst struct qstr *name,\n\t\t\t\twait_queue_head_t *wq)\n{\n\tunsigned int hash = name->hash;\n\tstruct hlist_bl_head *b = in_lookup_hash(parent, hash);\n\tstruct hlist_bl_node *node;\n\tstruct dentry *new = d_alloc(parent, name);\n\tstruct dentry *dentry;\n\tunsigned seq, r_seq, d_seq;\n\n\tif (unlikely(!new))\n\t\treturn ERR_PTR(-ENOMEM);\n\nretry:\n\trcu_read_lock();\n\tseq = smp_load_acquire(&parent->d_inode->i_dir_seq);\n\tr_seq = read_seqbegin(&rename_lock);\n\tdentry = __d_lookup_rcu(parent, name, &d_seq);\n\tif (unlikely(dentry)) {\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (read_seqcount_retry(&dentry->d_seq, d_seq)) {\n\t\t\trcu_read_unlock();\n\t\t\tdput(dentry);\n\t\t\tgoto retry;\n\t\t}\n\t\trcu_read_unlock();\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, r_seq))) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\tif (unlikely(seq & 1)) {\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\n\thlist_bl_lock(b);\n\tif (unlikely(READ_ONCE(parent->d_inode->i_dir_seq) != seq)) {\n\t\thlist_bl_unlock(b);\n\t\trcu_read_unlock();\n\t\tgoto retry;\n\t}\n\t/*\n\t * No changes for the parent since the beginning of d_lookup().\n\t * Since all removals from the chain happen with hlist_bl_lock(),\n\t * any potential in-lookup matches are going to stay here until\n\t * we unlock the chain.  All fields are stable in everything\n\t * we encounter.\n\t */\n\thlist_bl_for_each_entry(dentry, node, b, d_u.d_in_lookup_hash) {\n\t\tif (dentry->d_name.hash != hash)\n\t\t\tcontinue;\n\t\tif (dentry->d_parent != parent)\n\t\t\tcontinue;\n\t\tif (!d_same_name(dentry, parent, name))\n\t\t\tcontinue;\n\t\thlist_bl_unlock(b);\n\t\t/* now we can try to grab a reference */\n\t\tif (!lockref_get_not_dead(&dentry->d_lockref)) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto retry;\n\t\t}\n\n\t\trcu_read_unlock();\n\t\t/*\n\t\t * somebody is likely to be still doing lookup for it;\n\t\t * wait for them to finish\n\t\t */\n\t\tspin_lock(&dentry->d_lock);\n\t\td_wait_lookup(dentry);\n\t\t/*\n\t\t * it's not in-lookup anymore; in principle we should repeat\n\t\t * everything from dcache lookup, but it's likely to be what\n\t\t * d_lookup() would've found anyway.  If it is, just return it;\n\t\t * otherwise we really have to repeat the whole thing.\n\t\t */\n\t\tif (unlikely(dentry->d_name.hash != hash))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(dentry->d_parent != parent))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(d_unhashed(dentry)))\n\t\t\tgoto mismatch;\n\t\tif (unlikely(!d_same_name(dentry, parent, name)))\n\t\t\tgoto mismatch;\n\t\t/* OK, it *is* a hashed match; return it */\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdput(new);\n\t\treturn dentry;\n\t}\n\trcu_read_unlock();\n\t/* we can't take ->d_lock here; it's OK, though. */\n\tnew->d_flags |= DCACHE_PAR_LOOKUP;\n\tnew->d_wait = wq;\n\thlist_bl_add_head_rcu(&new->d_u.d_in_lookup_hash, b);\n\thlist_bl_unlock(b);\n\treturn new;\nmismatch:\n\tspin_unlock(&dentry->d_lock);\n\tdput(dentry);\n\tgoto retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_in_lookup",
          "args": [
            "dentry"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_hash_and_lookup",
          "args": [
            "dentry->d_parent",
            "name"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2300-2314",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(dir, name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(dir, name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,\n\t\t\tstruct qstr *name)\n{\n\tstruct dentry *found, *res;\n\n\t/*\n\t * First check if a dentry matching the name already exists,\n\t * if not go ahead and create it now.\n\t */\n\tfound = d_hash_and_lookup(dentry->d_parent, name);\n\tif (found) {\n\t\tiput(inode);\n\t\treturn found;\n\t}\n\tif (d_in_lookup(dentry)) {\n\t\tfound = d_alloc_parallel(dentry->d_parent, name,\n\t\t\t\t\tdentry->d_wait);\n\t\tif (IS_ERR(found) || !d_in_lookup(found)) {\n\t\t\tiput(inode);\n\t\t\treturn found;\n\t\t}\n\t} else {\n\t\tfound = d_alloc(dentry->d_parent, name);\n\t\tif (!found) {\n\t\t\tiput(inode);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t} \n\t}\n\tres = d_splice_alias(inode, found);\n\tif (res) {\n\t\tdput(found);\n\t\treturn res;\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "d_obtain_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "2009-2012",
    "snippet": "struct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, false);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__d_obtain_alias",
          "args": [
            "inode",
            "false"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "__d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1943-1968",
          "snippet": "static struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)\n{\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\n\ttmp = d_alloc_anon(inode->i_sb);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\n\treturn __d_instantiate_anon(tmp, inode, disconnected);\n\nout_iput:\n\tiput(inode);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)\n{\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\n\ttmp = d_alloc_anon(inode->i_sb);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\n\treturn __d_instantiate_anon(tmp, inode, disconnected);\n\nout_iput:\n\tiput(inode);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, false);\n}"
  },
  {
    "function_name": "d_obtain_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1988-1991",
    "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, true);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__d_obtain_alias",
          "args": [
            "inode",
            "true"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "__d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1943-1968",
          "snippet": "static struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)\n{\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\n\ttmp = d_alloc_anon(inode->i_sb);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\n\treturn __d_instantiate_anon(tmp, inode, disconnected);\n\nout_iput:\n\tiput(inode);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)\n{\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\n\ttmp = d_alloc_anon(inode->i_sb);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\n\treturn __d_instantiate_anon(tmp, inode, disconnected);\n\nout_iput:\n\tiput(inode);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, true);\n}"
  },
  {
    "function_name": "__d_obtain_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1943-1968",
    "snippet": "static struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)\n{\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\n\ttmp = d_alloc_anon(inode->i_sb);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\n\treturn __d_instantiate_anon(tmp, inode, disconnected);\n\nout_iput:\n\tiput(inode);\n\treturn res;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_instantiate_anon",
          "args": [
            "tmp",
            "inode",
            "disconnected"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "__d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1897-1935",
          "snippet": "static struct dentry *__d_instantiate_anon(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   bool disconnected)\n{\n\tstruct dentry *res;\n\tunsigned add_flags;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(dentry);\n\t\tgoto out_iput;\n\t}\n\n\t/* attach a disconnected dentry */\n\tadd_flags = d_flags_for_inode(inode);\n\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\n\tspin_lock(&dentry->d_lock);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\tif (!disconnected) {\n\t\thlist_bl_lock(&dentry->d_sb->s_roots);\n\t\thlist_bl_add_head(&dentry->d_hash, &dentry->d_sb->s_roots);\n\t\thlist_bl_unlock(&dentry->d_sb->s_roots);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\n\treturn dentry;\n\n out_iput:\n\tiput(inode);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__d_instantiate_anon(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   bool disconnected)\n{\n\tstruct dentry *res;\n\tunsigned add_flags;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(dentry);\n\t\tgoto out_iput;\n\t}\n\n\t/* attach a disconnected dentry */\n\tadd_flags = d_flags_for_inode(inode);\n\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\n\tspin_lock(&dentry->d_lock);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\tif (!disconnected) {\n\t\thlist_bl_lock(&dentry->d_sb->s_roots);\n\t\thlist_bl_add_head(&dentry->d_hash, &dentry->d_sb->s_roots);\n\t\thlist_bl_unlock(&dentry->d_sb->s_roots);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\n\treturn dentry;\n\n out_iput:\n\tiput(inode);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_alloc_anon",
          "args": [
            "inode->i_sb"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1696-1699",
          "snippet": "struct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_find_any_alias",
          "args": [
            "inode"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "907-915",
          "snippet": "struct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)\n{\n\tstruct dentry *tmp;\n\tstruct dentry *res;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ESTALE);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tres = d_find_any_alias(inode);\n\tif (res)\n\t\tgoto out_iput;\n\n\ttmp = d_alloc_anon(inode->i_sb);\n\tif (!tmp) {\n\t\tres = ERR_PTR(-ENOMEM);\n\t\tgoto out_iput;\n\t}\n\n\treturn __d_instantiate_anon(tmp, inode, disconnected);\n\nout_iput:\n\tiput(inode);\n\treturn res;\n}"
  },
  {
    "function_name": "d_instantiate_anon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1937-1940",
    "snippet": "struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__d_instantiate_anon",
          "args": [
            "dentry",
            "inode",
            "true"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "__d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1897-1935",
          "snippet": "static struct dentry *__d_instantiate_anon(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   bool disconnected)\n{\n\tstruct dentry *res;\n\tunsigned add_flags;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(dentry);\n\t\tgoto out_iput;\n\t}\n\n\t/* attach a disconnected dentry */\n\tadd_flags = d_flags_for_inode(inode);\n\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\n\tspin_lock(&dentry->d_lock);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\tif (!disconnected) {\n\t\thlist_bl_lock(&dentry->d_sb->s_roots);\n\t\thlist_bl_add_head(&dentry->d_hash, &dentry->d_sb->s_roots);\n\t\thlist_bl_unlock(&dentry->d_sb->s_roots);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\n\treturn dentry;\n\n out_iput:\n\tiput(inode);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__d_instantiate_anon(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   bool disconnected)\n{\n\tstruct dentry *res;\n\tunsigned add_flags;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(dentry);\n\t\tgoto out_iput;\n\t}\n\n\t/* attach a disconnected dentry */\n\tadd_flags = d_flags_for_inode(inode);\n\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\n\tspin_lock(&dentry->d_lock);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\tif (!disconnected) {\n\t\thlist_bl_lock(&dentry->d_sb->s_roots);\n\t\thlist_bl_add_head(&dentry->d_hash, &dentry->d_sb->s_roots);\n\t\thlist_bl_unlock(&dentry->d_sb->s_roots);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\n\treturn dentry;\n\n out_iput:\n\tiput(inode);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}"
  },
  {
    "function_name": "__d_instantiate_anon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1897-1935",
    "snippet": "static struct dentry *__d_instantiate_anon(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   bool disconnected)\n{\n\tstruct dentry *res;\n\tunsigned add_flags;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(dentry);\n\t\tgoto out_iput;\n\t}\n\n\t/* attach a disconnected dentry */\n\tadd_flags = d_flags_for_inode(inode);\n\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\n\tspin_lock(&dentry->d_lock);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\tif (!disconnected) {\n\t\thlist_bl_lock(&dentry->d_sb->s_roots);\n\t\thlist_bl_add_head(&dentry->d_hash, &dentry->d_sb->s_roots);\n\t\thlist_bl_unlock(&dentry->d_sb->s_roots);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\n\treturn dentry;\n\n out_iput:\n\tiput(inode);\n\treturn res;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_bl_unlock",
          "args": [
            "&dentry->d_sb->s_roots"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_add_head",
          "args": [
            "&dentry->d_hash",
            "&dentry->d_sb->s_roots"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_lock",
          "args": [
            "&dentry->d_sb->s_roots"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&dentry->d_u.d_alias",
            "&inode->i_dentry"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_set_inode_and_type",
          "args": [
            "dentry",
            "inode",
            "add_flags"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "__d_set_inode_and_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "300-311",
          "snippet": "static inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_flags_for_inode",
          "args": [
            "inode"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "d_flags_for_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1782-1815",
          "snippet": "static unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_find_any_alias",
          "args": [
            "inode"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "__d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "889-898",
          "snippet": "static struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__d_instantiate_anon(struct dentry *dentry,\n\t\t\t\t\t   struct inode *inode,\n\t\t\t\t\t   bool disconnected)\n{\n\tstruct dentry *res;\n\tunsigned add_flags;\n\n\tsecurity_d_instantiate(dentry, inode);\n\tspin_lock(&inode->i_lock);\n\tres = __d_find_any_alias(inode);\n\tif (res) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tdput(dentry);\n\t\tgoto out_iput;\n\t}\n\n\t/* attach a disconnected dentry */\n\tadd_flags = d_flags_for_inode(inode);\n\n\tif (disconnected)\n\t\tadd_flags |= DCACHE_DISCONNECTED;\n\n\tspin_lock(&dentry->d_lock);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\tif (!disconnected) {\n\t\thlist_bl_lock(&dentry->d_sb->s_roots);\n\t\thlist_bl_add_head(&dentry->d_hash, &dentry->d_sb->s_roots);\n\t\thlist_bl_unlock(&dentry->d_sb->s_roots);\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\n\treturn dentry;\n\n out_iput:\n\tiput(inode);\n\treturn res;\n}"
  },
  {
    "function_name": "d_make_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1880-1894",
    "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tres = d_alloc_anon(root_inode->i_sb);\n\t\tif (res) {\n\t\t\tres->d_flags |= DCACHE_RCUACCESS;\n\t\t\td_instantiate(res, root_inode);\n\t\t} else {\n\t\t\tiput(root_inode);\n\t\t}\n\t}\n\treturn res;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "root_inode"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "res",
            "root_inode"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1937-1940",
          "snippet": "struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)\n{\n\treturn __d_instantiate_anon(dentry, inode, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_anon",
          "args": [
            "root_inode->i_sb"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1696-1699",
          "snippet": "struct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tres = d_alloc_anon(root_inode->i_sb);\n\t\tif (res) {\n\t\t\tres->d_flags |= DCACHE_RCUACCESS;\n\t\t\td_instantiate(res, root_inode);\n\t\t} else {\n\t\t\tiput(root_inode);\n\t\t}\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "d_instantiate_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1864-1877",
    "snippet": "void d_instantiate_new(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\tBUG_ON(!inode);\n\tlockdep_annotate_inode_mutex_key(inode);\n\tsecurity_d_instantiate(entry, inode);\n\tspin_lock(&inode->i_lock);\n\t__d_instantiate(entry, inode);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW & ~I_CREATING;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&inode->i_state",
            "__I_NEW"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(inode->i_state & I_NEW)"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_instantiate",
          "args": [
            "entry",
            "inode"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "__d_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1817-1829",
          "snippet": "static void __d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tunsigned add_flags = d_flags_for_inode(inode);\n\tWARN_ON(d_in_lookup(dentry));\n\n\tspin_lock(&dentry->d_lock);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tfsnotify_update_flags(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tunsigned add_flags = d_flags_for_inode(inode);\n\tWARN_ON(d_in_lookup(dentry));\n\n\tspin_lock(&dentry->d_lock);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tfsnotify_update_flags(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_d_instantiate",
          "args": [
            "entry",
            "inode"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_annotate_inode_mutex_key",
          "args": [
            "inode"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_annotate_inode_mutex_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "943-959",
          "snippet": "void lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid lockdep_annotate_inode_mutex_key(struct inode *inode)\n{\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct file_system_type *type = inode->i_sb->s_type;\n\n\t\t/* Set new key only if filesystem hasn't already changed it */\n\t\tif (lockdep_match_class(&inode->i_rwsem, &type->i_mutex_key)) {\n\t\t\t/*\n\t\t\t * ensure nobody is actually holding i_mutex\n\t\t\t */\n\t\t\t// mutex_destroy(&inode->i_mutex);\n\t\t\tinit_rwsem(&inode->i_rwsem);\n\t\t\tlockdep_set_class(&inode->i_rwsem,\n\t\t\t\t\t  &type->i_mutex_dir_key);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!inode"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_unhashed(&entry->d_u.d_alias)"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&entry->d_u.d_alias"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_instantiate_new(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\tBUG_ON(!inode);\n\tlockdep_annotate_inode_mutex_key(inode);\n\tsecurity_d_instantiate(entry, inode);\n\tspin_lock(&inode->i_lock);\n\t__d_instantiate(entry, inode);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW & ~I_CREATING;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "d_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1846-1855",
    "snippet": "void d_instantiate(struct dentry *entry, struct inode * inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t\t__d_instantiate(entry, inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_instantiate",
          "args": [
            "entry",
            "inode"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "__d_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1817-1829",
          "snippet": "static void __d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tunsigned add_flags = d_flags_for_inode(inode);\n\tWARN_ON(d_in_lookup(dentry));\n\n\tspin_lock(&dentry->d_lock);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tfsnotify_update_flags(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tunsigned add_flags = d_flags_for_inode(inode);\n\tWARN_ON(d_in_lookup(dentry));\n\n\tspin_lock(&dentry->d_lock);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tfsnotify_update_flags(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_d_instantiate",
          "args": [
            "entry",
            "inode"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!hlist_unhashed(&entry->d_u.d_alias)"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&entry->d_u.d_alias"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_instantiate(struct dentry *entry, struct inode * inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t\t__d_instantiate(entry, inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}"
  },
  {
    "function_name": "__d_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1817-1829",
    "snippet": "static void __d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tunsigned add_flags = d_flags_for_inode(inode);\n\tWARN_ON(d_in_lookup(dentry));\n\n\tspin_lock(&dentry->d_lock);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tfsnotify_update_flags(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_update_flags",
          "args": [
            "dentry"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_end",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_set_inode_and_type",
          "args": [
            "dentry",
            "inode",
            "add_flags"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "__d_set_inode_and_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "300-311",
          "snippet": "static inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_begin",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&dentry->d_u.d_alias",
            "&inode->i_dentry"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "d_in_lookup(dentry)"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_in_lookup",
          "args": [
            "dentry"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_flags_for_inode",
          "args": [
            "inode"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "d_flags_for_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1782-1815",
          "snippet": "static unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void __d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tunsigned add_flags = d_flags_for_inode(inode);\n\tWARN_ON(d_in_lookup(dentry));\n\n\tspin_lock(&dentry->d_lock);\n\thlist_add_head(&dentry->d_u.d_alias, &inode->i_dentry);\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_set_inode_and_type(dentry, inode, add_flags);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tfsnotify_update_flags(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
  },
  {
    "function_name": "d_flags_for_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1782-1815",
    "snippet": "static unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_AUTOMOUNT(inode)"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_AUTOMOUNT",
          "args": [
            "inode"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!S_ISREG(inode->i_mode)"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_op->get_link"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(inode->i_opflags & IOP_NOFOLLOW)"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!inode->i_op->lookup"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(inode->i_opflags & IOP_LOOKUP)"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned d_flags_for_inode(struct inode *inode)\n{\n\tunsigned add_flags = DCACHE_REGULAR_TYPE;\n\n\tif (!inode)\n\t\treturn DCACHE_MISS_TYPE;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tadd_flags = DCACHE_DIRECTORY_TYPE;\n\t\tif (unlikely(!(inode->i_opflags & IOP_LOOKUP))) {\n\t\t\tif (unlikely(!inode->i_op->lookup))\n\t\t\t\tadd_flags = DCACHE_AUTODIR_TYPE;\n\t\t\telse\n\t\t\t\tinode->i_opflags |= IOP_LOOKUP;\n\t\t}\n\t\tgoto type_determined;\n\t}\n\n\tif (unlikely(!(inode->i_opflags & IOP_NOFOLLOW))) {\n\t\tif (unlikely(inode->i_op->get_link)) {\n\t\t\tadd_flags = DCACHE_SYMLINK_TYPE;\n\t\t\tgoto type_determined;\n\t\t}\n\t\tinode->i_opflags |= IOP_NOFOLLOW;\n\t}\n\n\tif (unlikely(!S_ISREG(inode->i_mode)))\n\t\tadd_flags = DCACHE_SPECIAL_TYPE;\n\ntype_determined:\n\tif (unlikely(IS_AUTOMOUNT(inode)))\n\t\tadd_flags |= DCACHE_NEED_AUTOMOUNT;\n\treturn add_flags;\n}"
  },
  {
    "function_name": "d_set_fallthru",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1774-1779",
    "snippet": "void d_set_fallthru(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_FALLTHRU;\n\tspin_unlock(&dentry->d_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_set_fallthru(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_FALLTHRU;\n\tspin_unlock(&dentry->d_lock);\n}"
  },
  {
    "function_name": "d_set_d_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1736-1763",
    "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL)"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "dentry->d_op"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}"
  },
  {
    "function_name": "d_alloc_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1726-1733",
    "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "parent",
            "&q"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1726-1733",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "hashlen_string",
          "args": [
            "parent",
            "name"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "hashlen_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "2025-2037",
          "snippet": "u64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\twhile (c) {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t}\n\treturn hashlen_create(end_name_hash(hash), len);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nu64 hashlen_string(const void *salt, const char *name)\n{\n\tunsigned long hash = init_name_hash(salt);\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\twhile (c) {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t}\n\treturn hashlen_create(end_name_hash(hash), len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.hash_len = hashlen_string(parent, name);\n\treturn d_alloc(parent, &q);\n}"
  },
  {
    "function_name": "d_alloc_pseudo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1720-1723",
    "snippet": "struct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__d_alloc",
          "args": [
            "sb",
            "name"
          ],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "__d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1593-1665",
          "snippet": "struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dentry_cache",
            "const struct qstr slash_name = QSTR_INIT(\"/\", 1);",
            "static DEFINE_PER_CPU(long, nr_dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\nconst struct qstr slash_name = QSTR_INIT(\"/\", 1);\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstruct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_pseudo(struct super_block *sb, const struct qstr *name)\n{\n\treturn __d_alloc(sb, name);\n}"
  },
  {
    "function_name": "d_alloc_cursor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1702-1710",
    "snippet": "struct dentry *d_alloc_cursor(struct dentry * parent)\n{\n\tstruct dentry *dentry = d_alloc_anon(parent->d_sb);\n\tif (dentry) {\n\t\tdentry->d_flags |= DCACHE_RCUACCESS | DCACHE_DENTRY_CURSOR;\n\t\tdentry->d_parent = dget(parent);\n\t}\n\treturn dentry;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "parent"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_anon",
          "args": [
            "parent->d_sb"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_anon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1696-1699",
          "snippet": "struct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_cursor(struct dentry * parent)\n{\n\tstruct dentry *dentry = d_alloc_anon(parent->d_sb);\n\tif (dentry) {\n\t\tdentry->d_flags |= DCACHE_RCUACCESS | DCACHE_DENTRY_CURSOR;\n\t\tdentry->d_parent = dget(parent);\n\t}\n\treturn dentry;\n}"
  },
  {
    "function_name": "d_alloc_anon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1696-1699",
    "snippet": "struct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__d_alloc",
          "args": [
            "sb",
            "NULL"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "__d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1593-1665",
          "snippet": "struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dentry_cache",
            "const struct qstr slash_name = QSTR_INIT(\"/\", 1);",
            "static DEFINE_PER_CPU(long, nr_dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\nconst struct qstr slash_name = QSTR_INIT(\"/\", 1);\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstruct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc_anon(struct super_block *sb)\n{\n\treturn __d_alloc(sb, NULL);\n}"
  },
  {
    "function_name": "d_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1676-1693",
    "snippet": "struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)\n{\n\tstruct dentry *dentry = __d_alloc(parent->d_sb, name);\n\tif (!dentry)\n\t\treturn NULL;\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * don't need child lock because it is not subject\n\t * to concurrency here\n\t */\n\t__dget_dlock(parent);\n\tdentry->d_parent = parent;\n\tlist_add(&dentry->d_child, &parent->d_subdirs);\n\tspin_unlock(&parent->d_lock);\n\n\treturn dentry;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dentry->d_child",
            "&parent->d_subdirs"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dget_dlock",
          "args": [
            "parent"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "839-842",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_alloc",
          "args": [
            "parent->d_sb",
            "name"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "__d_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1593-1665",
          "snippet": "struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dentry_cache",
            "const struct qstr slash_name = QSTR_INIT(\"/\", 1);",
            "static DEFINE_PER_CPU(long, nr_dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\nconst struct qstr slash_name = QSTR_INIT(\"/\", 1);\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstruct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_alloc(struct dentry * parent, const struct qstr *name)\n{\n\tstruct dentry *dentry = __d_alloc(parent->d_sb, name);\n\tif (!dentry)\n\t\treturn NULL;\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * don't need child lock because it is not subject\n\t * to concurrency here\n\t */\n\t__dget_dlock(parent);\n\tdentry->d_parent = parent;\n\tlist_add(&dentry->d_child, &parent->d_subdirs);\n\tspin_unlock(&parent->d_lock);\n\n\treturn dentry;\n}"
  },
  {
    "function_name": "__d_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1593-1665",
    "snippet": "struct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dentry_cache",
      "const struct qstr slash_name = QSTR_INIT(\"/\", 1);",
      "static DEFINE_PER_CPU(long, nr_dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "nr_dentry"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dentry_cache",
            "dentry"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "external_name(dentry)"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "external_name",
          "args": [
            "dentry"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "external_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "248-251",
          "snippet": "static inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dname_external",
          "args": [
            "dentry"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "dname_external",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "267-270",
          "snippet": "static inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry->d_op->d_init",
          "args": [
            "dentry"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "dentry->d_sb->s_d_op"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1736-1763",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE\t|\n\t\t\t\tDCACHE_OP_REAL));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\tif (op->d_real)\n\t\tdentry->d_flags |= DCACHE_OP_REAL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dentry->d_child"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&dentry->d_u.d_alias"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dentry->d_subdirs"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&dentry->d_lru"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_BL_NODE",
          "args": [
            "&dentry->d_hash"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seqcount_init",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&dentry->d_name.name",
            "dname"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dname",
            "name->name",
            "name->len"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&p->u.count",
            "1"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dentry_cache",
            "dentry"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size + name->len",
            "GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!name"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "dentry_cache",
            "GFP_KERNEL"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\nconst struct qstr slash_name = QSTR_INIT(\"/\", 1);\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstruct dentry *__d_alloc(struct super_block *sb, const struct qstr *name)\n{\n\tstruct dentry *dentry;\n\tchar *dname;\n\tint err;\n\n\tdentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);\n\tif (!dentry)\n\t\treturn NULL;\n\n\t/*\n\t * We guarantee that the inline name is always NUL-terminated.\n\t * This way the memcpy() done by the name switching in rename\n\t * will still always have a NUL at the end, even if we might\n\t * be overwriting an internal NUL character\n\t */\n\tdentry->d_iname[DNAME_INLINE_LEN-1] = 0;\n\tif (unlikely(!name)) {\n\t\tname = &slash_name;\n\t\tdname = dentry->d_iname;\n\t} else if (name->len > DNAME_INLINE_LEN-1) {\n\t\tsize_t size = offsetof(struct external_name, name[1]);\n\t\tstruct external_name *p = kmalloc(size + name->len,\n\t\t\t\t\t\t  GFP_KERNEL_ACCOUNT |\n\t\t\t\t\t\t  __GFP_RECLAIMABLE);\n\t\tif (!p) {\n\t\t\tkmem_cache_free(dentry_cache, dentry); \n\t\t\treturn NULL;\n\t\t}\n\t\tatomic_set(&p->u.count, 1);\n\t\tdname = p->name;\n\t} else  {\n\t\tdname = dentry->d_iname;\n\t}\t\n\n\tdentry->d_name.len = name->len;\n\tdentry->d_name.hash = name->hash;\n\tmemcpy(dname, name->name, name->len);\n\tdname[name->len] = 0;\n\n\t/* Make sure we always see the terminating NUL character */\n\tsmp_store_release(&dentry->d_name.name, dname); /* ^^^ */\n\n\tdentry->d_lockref.count = 1;\n\tdentry->d_flags = 0;\n\tspin_lock_init(&dentry->d_lock);\n\tseqcount_init(&dentry->d_seq);\n\tdentry->d_inode = NULL;\n\tdentry->d_parent = dentry;\n\tdentry->d_sb = sb;\n\tdentry->d_op = NULL;\n\tdentry->d_fsdata = NULL;\n\tINIT_HLIST_BL_NODE(&dentry->d_hash);\n\tINIT_LIST_HEAD(&dentry->d_lru);\n\tINIT_LIST_HEAD(&dentry->d_subdirs);\n\tINIT_HLIST_NODE(&dentry->d_u.d_alias);\n\tINIT_LIST_HEAD(&dentry->d_child);\n\td_set_d_op(dentry, dentry->d_sb->s_d_op);\n\n\tif (dentry->d_op && dentry->d_op->d_init) {\n\t\terr = dentry->d_op->d_init(dentry);\n\t\tif (err) {\n\t\t\tif (dname_external(dentry))\n\t\t\t\tkfree(external_name(dentry));\n\t\t\tkmem_cache_free(dentry_cache, dentry);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tthis_cpu_inc(nr_dentry);\n\n\treturn dentry;\n}"
  },
  {
    "function_name": "d_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1552-1580",
    "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\tbool had_submounts = false;\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode)\n\t\treturn;\n\n\tshrink_dcache_parent(dentry);\n\tfor (;;) {\n\t\tstruct dentry *victim = NULL;\n\t\td_walk(dentry, &victim, find_submount);\n\t\tif (!victim) {\n\t\t\tif (had_submounts)\n\t\t\t\tshrink_dcache_parent(dentry);\n\t\t\treturn;\n\t\t}\n\t\thad_submounts = true;\n\t\tdetach_mounts(victim);\n\t\tdput(victim);\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "victim"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_mounts",
          "args": [
            "victim"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "detach_mounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "106-111",
          "snippet": "static inline void detach_mounts(struct dentry *dentry)\n{\n\tif (!d_mountpoint(dentry))\n\t\treturn;\n\t__detach_mounts(dentry);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct mount *__lookup_mnt(struct vfsmount *, struct dentry *);",
            "extern void __detach_mounts(struct dentry *dentry);",
            "extern bool __is_local_mountpoint(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern struct mount *__lookup_mnt(struct vfsmount *, struct dentry *);\nextern void __detach_mounts(struct dentry *dentry);\nextern bool __is_local_mountpoint(struct dentry *dentry);\n\nstatic inline void detach_mounts(struct dentry *dentry)\n{\n\tif (!d_mountpoint(dentry))\n\t\treturn;\n\t__detach_mounts(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "dentry"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1464-1484",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_walk",
          "args": [
            "dentry",
            "&victim",
            "find_submount"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "d_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1227-1331",
          "snippet": "static void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstatic void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_drop",
          "args": [
            "dentry"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "__d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "467-474",
          "snippet": "void __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\tbool had_submounts = false;\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode)\n\t\treturn;\n\n\tshrink_dcache_parent(dentry);\n\tfor (;;) {\n\t\tstruct dentry *victim = NULL;\n\t\td_walk(dentry, &victim, find_submount);\n\t\tif (!victim) {\n\t\t\tif (had_submounts)\n\t\t\t\tshrink_dcache_parent(dentry);\n\t\t\treturn;\n\t\t}\n\t\thad_submounts = true;\n\t\tdetach_mounts(victim);\n\t\tdput(victim);\n\t}\n}"
  },
  {
    "function_name": "find_submount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1537-1546",
    "snippet": "static enum d_walk_ret find_submount(void *_data, struct dentry *dentry)\n{\n\tstruct dentry **victim = _data;\n\tif (d_mountpoint(dentry)) {\n\t\t__dget_dlock(dentry);\n\t\t*victim = dentry;\n\t\treturn D_WALK_QUIT;\n\t}\n\treturn D_WALK_CONTINUE;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dget_dlock",
          "args": [
            "dentry"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "839-842",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic enum d_walk_ret find_submount(void *_data, struct dentry *dentry)\n{\n\tstruct dentry **victim = _data;\n\tif (d_mountpoint(dentry)) {\n\t\t__dget_dlock(dentry);\n\t\t*victim = dentry;\n\t\treturn D_WALK_QUIT;\n\t}\n\treturn D_WALK_CONTINUE;\n}"
  },
  {
    "function_name": "shrink_dcache_for_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1521-1535",
    "snippet": "void shrink_dcache_for_umount(struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\n\tWARN(down_read_trylock(&sb->s_umount), \"s_umount should've been locked\");\n\n\tdentry = sb->s_root;\n\tsb->s_root = NULL;\n\tdo_one_tree(dentry);\n\n\twhile (!hlist_bl_empty(&sb->s_roots)) {\n\t\tdentry = dget(hlist_bl_entry(hlist_bl_first(&sb->s_roots), struct dentry, d_hash));\n\t\tdo_one_tree(dentry);\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_one_tree",
          "args": [
            "dentry"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "do_one_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1510-1516",
          "snippet": "static void do_one_tree(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\td_walk(dentry, dentry, umount_check);\n\td_drop(dentry);\n\tdput(dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void do_one_tree(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\td_walk(dentry, dentry, umount_check);\n\td_drop(dentry);\n\tdput(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "hlist_bl_entry(hlist_bl_first(&sb->s_roots), struct dentry, d_hash)"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_bl_entry",
          "args": [
            "hlist_bl_first(&sb->s_roots)",
            "structdentry",
            "d_hash"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_first",
          "args": [
            "&sb->s_roots"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_empty",
          "args": [
            "&sb->s_roots"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "down_read_trylock(&sb->s_umount)",
            "\"s_umount should've been locked\""
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid shrink_dcache_for_umount(struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\n\tWARN(down_read_trylock(&sb->s_umount), \"s_umount should've been locked\");\n\n\tdentry = sb->s_root;\n\tsb->s_root = NULL;\n\tdo_one_tree(dentry);\n\n\twhile (!hlist_bl_empty(&sb->s_roots)) {\n\t\tdentry = dget(hlist_bl_entry(hlist_bl_first(&sb->s_roots), struct dentry, d_hash));\n\t\tdo_one_tree(dentry);\n\t}\n}"
  },
  {
    "function_name": "do_one_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1510-1516",
    "snippet": "static void do_one_tree(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\td_walk(dentry, dentry, umount_check);\n\td_drop(dentry);\n\tdput(dentry);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "477-482",
          "snippet": "void d_drop(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_drop(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_walk",
          "args": [
            "dentry",
            "dentry",
            "umount_check"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "d_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1227-1331",
          "snippet": "static void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstatic void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "dentry"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1464-1484",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void do_one_tree(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\td_walk(dentry, dentry, umount_check);\n\td_drop(dentry);\n\tdput(dentry);\n}"
  },
  {
    "function_name": "umount_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1487-1508",
    "snippet": "static enum d_walk_ret umount_check(void *_data, struct dentry *dentry)\n{\n\t/* it has busy descendents; complain about those instead */\n\tif (!list_empty(&dentry->d_subdirs))\n\t\treturn D_WALK_CONTINUE;\n\n\t/* root with refcount 1 is fine */\n\tif (dentry == _data && dentry->d_lockref.count == 1)\n\t\treturn D_WALK_CONTINUE;\n\n\tprintk(KERN_ERR \"BUG: Dentry %p{i=%lx,n=%pd} \"\n\t\t\t\" still in use (%d) [unmount of %s %s]\\n\",\n\t\t       dentry,\n\t\t       dentry->d_inode ?\n\t\t       dentry->d_inode->i_ino : 0UL,\n\t\t       dentry,\n\t\t       dentry->d_lockref.count,\n\t\t       dentry->d_sb->s_type->name,\n\t\t       dentry->d_sb->s_id);\n\tWARN_ON(1);\n\treturn D_WALK_CONTINUE;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BUG: Dentry %p{i=%lx,n=%pd} \"\n\t\t\t\" still in use (%d) [unmount of %s %s]\\n\"",
            "dentry",
            "dentry->d_inode ?\n\t\t       dentry->d_inode->i_ino : 0UL",
            "dentry",
            "dentry->d_lockref.count",
            "dentry->d_sb->s_type->name",
            "dentry->d_sb->s_id"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dentry->d_subdirs"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic enum d_walk_ret umount_check(void *_data, struct dentry *dentry)\n{\n\t/* it has busy descendents; complain about those instead */\n\tif (!list_empty(&dentry->d_subdirs))\n\t\treturn D_WALK_CONTINUE;\n\n\t/* root with refcount 1 is fine */\n\tif (dentry == _data && dentry->d_lockref.count == 1)\n\t\treturn D_WALK_CONTINUE;\n\n\tprintk(KERN_ERR \"BUG: Dentry %p{i=%lx,n=%pd} \"\n\t\t\t\" still in use (%d) [unmount of %s %s]\\n\",\n\t\t       dentry,\n\t\t       dentry->d_inode ?\n\t\t       dentry->d_inode->i_ino : 0UL,\n\t\t       dentry,\n\t\t       dentry->d_lockref.count,\n\t\t       dentry->d_sb->s_type->name,\n\t\t       dentry->d_sb->s_id);\n\tWARN_ON(1);\n\treturn D_WALK_CONTINUE;\n}"
  },
  {
    "function_name": "shrink_dcache_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1464-1484",
    "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_dentry_list",
          "args": [
            "&data.dispose"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dentry_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1043-1078",
          "snippet": "static void shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\t__dentry_kill(dentry);\n\t\tif (parent == dentry)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref))\n\t\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\t__dentry_kill(dentry);\n\t\tif (parent == dentry)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref))\n\t\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&data.dispose"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_walk",
          "args": [
            "parent",
            "&data",
            "select_collect"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "d_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1227-1331",
          "snippet": "static void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstatic void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&data.dispose"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect);\n\n\t\tif (!list_empty(&data.dispose)) {\n\t\t\tshrink_dentry_list(&data.dispose);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcond_resched();\n\t\tif (!data.found)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "select_collect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1429-1456",
    "snippet": "static enum d_walk_ret select_collect(void *_data, struct dentry *dentry)\n{\n\tstruct select_data *data = _data;\n\tenum d_walk_ret ret = D_WALK_CONTINUE;\n\n\tif (data->start == dentry)\n\t\tgoto out;\n\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdata->found++;\n\t} else {\n\t\tif (dentry->d_flags & DCACHE_LRU_LIST)\n\t\t\td_lru_del(dentry);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\td_shrink_add(dentry, &data->dispose);\n\t\t\tdata->found++;\n\t\t}\n\t}\n\t/*\n\t * We can return to the caller if we have found some (this\n\t * ensures forward progress). We'll be coming back to find\n\t * the rest.\n\t */\n\tif (!list_empty(&data->dispose))\n\t\tret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&data->dispose"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_shrink_add",
          "args": [
            "dentry",
            "&data->dispose"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "d_shrink_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "402-408",
          "snippet": "static void d_shrink_add(struct dentry *dentry, struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tlist_add(&dentry->d_lru, list);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_shrink_add(struct dentry *dentry, struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tlist_add(&dentry->d_lru, list);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lru_del",
          "args": [
            "dentry"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "d_lru_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "386-392",
          "snippet": "static void d_lru_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_lru_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic enum d_walk_ret select_collect(void *_data, struct dentry *dentry)\n{\n\tstruct select_data *data = _data;\n\tenum d_walk_ret ret = D_WALK_CONTINUE;\n\n\tif (data->start == dentry)\n\t\tgoto out;\n\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdata->found++;\n\t} else {\n\t\tif (dentry->d_flags & DCACHE_LRU_LIST)\n\t\t\td_lru_del(dentry);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\td_shrink_add(dentry, &data->dispose);\n\t\t\tdata->found++;\n\t\t}\n\t}\n\t/*\n\t * We can return to the caller if we have found some (this\n\t * ensures forward progress). We'll be coming back to find\n\t * the rest.\n\t */\n\tif (!list_empty(&data->dispose))\n\t\tret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "d_set_mounted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1380-1406",
    "snippet": "int d_set_mounted(struct dentry *dentry)\n{\n\tstruct dentry *p;\n\tint ret = -ENOENT;\n\twrite_seqlock(&rename_lock);\n\tfor (p = dentry->d_parent; !IS_ROOT(p); p = p->d_parent) {\n\t\t/* Need exclusion wrt. d_invalidate() */\n\t\tspin_lock(&p->d_lock);\n\t\tif (unlikely(d_unhashed(p))) {\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&p->d_lock);\n\t}\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unlinked(dentry)) {\n\t\tret = -EBUSY;\n\t\tif (!d_mountpoint(dentry)) {\n\t\t\tdentry->d_flags |= DCACHE_MOUNTED;\n\t\t\tret = 0;\n\t\t}\n\t}\n \tspin_unlock(&dentry->d_lock);\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_sequnlock",
          "args": [
            "&rename_lock"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unlinked",
          "args": [
            "dentry"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "d_unhashed(p)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "p"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "p"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_seqlock",
          "args": [
            "&rename_lock"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nint d_set_mounted(struct dentry *dentry)\n{\n\tstruct dentry *p;\n\tint ret = -ENOENT;\n\twrite_seqlock(&rename_lock);\n\tfor (p = dentry->d_parent; !IS_ROOT(p); p = p->d_parent) {\n\t\t/* Need exclusion wrt. d_invalidate() */\n\t\tspin_lock(&p->d_lock);\n\t\tif (unlikely(d_unhashed(p))) {\n\t\t\tspin_unlock(&p->d_lock);\n\t\t\tgoto out;\n\t\t}\n\t\tspin_unlock(&p->d_lock);\n\t}\n\tspin_lock(&dentry->d_lock);\n\tif (!d_unlinked(dentry)) {\n\t\tret = -EBUSY;\n\t\tif (!d_mountpoint(dentry)) {\n\t\t\tdentry->d_flags |= DCACHE_MOUNTED;\n\t\t\tret = 0;\n\t\t}\n\t}\n \tspin_unlock(&dentry->d_lock);\nout:\n\twrite_sequnlock(&rename_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "path_has_submounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1360-1369",
    "snippet": "int path_has_submounts(const struct path *parent)\n{\n\tstruct check_mount data = { .mnt = parent->mnt, .mounted = 0 };\n\n\tread_seqlock_excl(&mount_lock);\n\td_walk(parent->dentry, &data, path_check_mount);\n\tread_sequnlock_excl(&mount_lock);\n\n\treturn data.mounted;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_sequnlock_excl",
          "args": [
            "&mount_lock"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_walk",
          "args": [
            "parent->dentry",
            "&data",
            "path_check_mount"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "d_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1227-1331",
          "snippet": "static void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstatic void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_seqlock_excl",
          "args": [
            "&mount_lock"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nint path_has_submounts(const struct path *parent)\n{\n\tstruct check_mount data = { .mnt = parent->mnt, .mounted = 0 };\n\n\tread_seqlock_excl(&mount_lock);\n\td_walk(parent->dentry, &data, path_check_mount);\n\tread_sequnlock_excl(&mount_lock);\n\n\treturn data.mounted;\n}"
  },
  {
    "function_name": "path_check_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1338-1350",
    "snippet": "static enum d_walk_ret path_check_mount(void *data, struct dentry *dentry)\n{\n\tstruct check_mount *info = data;\n\tstruct path path = { .mnt = info->mnt, .dentry = dentry };\n\n\tif (likely(!d_mountpoint(dentry)))\n\t\treturn D_WALK_CONTINUE;\n\tif (__path_is_mountpoint(&path)) {\n\t\tinfo->mounted = 1;\n\t\treturn D_WALK_QUIT;\n\t}\n\treturn D_WALK_CONTINUE;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__path_is_mountpoint",
          "args": [
            "&path"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "__path_is_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/mount.h",
          "lines": "98-102",
          "snippet": "static inline bool __path_is_mountpoint(const struct path *path)\n{\n\tstruct mount *m = __lookup_mnt(path->mnt, path->dentry);\n\treturn m && likely(!(m->mnt.mnt_flags & MNT_SYNC_UMOUNT));\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct mount *__lookup_mnt(struct vfsmount *, struct dentry *);",
            "extern void __detach_mounts(struct dentry *dentry);",
            "extern bool __is_local_mountpoint(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern struct mount *__lookup_mnt(struct vfsmount *, struct dentry *);\nextern void __detach_mounts(struct dentry *dentry);\nextern bool __is_local_mountpoint(struct dentry *dentry);\n\nstatic inline bool __path_is_mountpoint(const struct path *path)\n{\n\tstruct mount *m = __lookup_mnt(path->mnt, path->dentry);\n\treturn m && likely(!(m->mnt.mnt_flags & MNT_SYNC_UMOUNT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!d_mountpoint(dentry)"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_mountpoint",
          "args": [
            "dentry"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic enum d_walk_ret path_check_mount(void *data, struct dentry *dentry)\n{\n\tstruct check_mount *info = data;\n\tstruct path path = { .mnt = info->mnt, .dentry = dentry };\n\n\tif (likely(!d_mountpoint(dentry)))\n\t\treturn D_WALK_CONTINUE;\n\tif (__path_is_mountpoint(&path)) {\n\t\tinfo->mounted = 1;\n\t\treturn D_WALK_QUIT;\n\t}\n\treturn D_WALK_CONTINUE;\n}"
  },
  {
    "function_name": "d_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1227-1331",
    "snippet": "static void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "seq & 1"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&this_parent->d_lock"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "done_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "child->d_flags & DCACHE_DENTRY_KILLED"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structdentry",
            "d_child"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&this_parent->d_lock"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_acquire",
          "args": [
            "&this_parent->d_lock.dep_map",
            "0",
            "1",
            "_RET_IP_"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_release",
          "args": [
            "&dentry->d_lock.dep_map",
            "1",
            "_RET_IP_"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dentry->d_subdirs"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter",
          "args": [
            "data",
            "dentry"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coda/cache.c",
          "lines": "31-43",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&dentry->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_flags & DCACHE_DENTRY_CURSOR"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tmp",
            "structdentry",
            "d_child"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin_or_lock",
          "args": [
            "&rename_lock",
            "&seq"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstatic void d_walk(struct dentry *parent, void *data,\n\t\t   enum d_walk_ret (*enter)(void *, struct dentry *))\n{\n\tstruct dentry *this_parent;\n\tstruct list_head *next;\n\tunsigned seq = 0;\n\tenum d_walk_ret ret;\n\tbool retry = true;\n\nagain:\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\tthis_parent = parent;\n\tspin_lock(&this_parent->d_lock);\n\n\tret = enter(data, this_parent);\n\tswitch (ret) {\n\tcase D_WALK_CONTINUE:\n\t\tbreak;\n\tcase D_WALK_QUIT:\n\tcase D_WALK_SKIP:\n\t\tgoto out_unlock;\n\tcase D_WALK_NORETRY:\n\t\tretry = false;\n\t\tbreak;\n\t}\nrepeat:\n\tnext = this_parent->d_subdirs.next;\nresume:\n\twhile (next != &this_parent->d_subdirs) {\n\t\tstruct list_head *tmp = next;\n\t\tstruct dentry *dentry = list_entry(tmp, struct dentry, d_child);\n\t\tnext = tmp->next;\n\n\t\tif (unlikely(dentry->d_flags & DCACHE_DENTRY_CURSOR))\n\t\t\tcontinue;\n\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\n\t\tret = enter(data, dentry);\n\t\tswitch (ret) {\n\t\tcase D_WALK_CONTINUE:\n\t\t\tbreak;\n\t\tcase D_WALK_QUIT:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tgoto out_unlock;\n\t\tcase D_WALK_NORETRY:\n\t\t\tretry = false;\n\t\t\tbreak;\n\t\tcase D_WALK_SKIP:\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!list_empty(&dentry->d_subdirs)) {\n\t\t\tspin_unlock(&this_parent->d_lock);\n\t\t\tspin_release(&dentry->d_lock.dep_map, 1, _RET_IP_);\n\t\t\tthis_parent = dentry;\n\t\t\tspin_acquire(&this_parent->d_lock.dep_map, 0, 1, _RET_IP_);\n\t\t\tgoto repeat;\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\t/*\n\t * All done at this level ... ascend and resume the search.\n\t */\n\trcu_read_lock();\nascend:\n\tif (this_parent != parent) {\n\t\tstruct dentry *child = this_parent;\n\t\tthis_parent = child->d_parent;\n\n\t\tspin_unlock(&child->d_lock);\n\t\tspin_lock(&this_parent->d_lock);\n\n\t\t/* might go back up the wrong parent if we have had a rename. */\n\t\tif (need_seqretry(&rename_lock, seq))\n\t\t\tgoto rename_retry;\n\t\t/* go into the first sibling still alive */\n\t\tdo {\n\t\t\tnext = child->d_child.next;\n\t\t\tif (next == &this_parent->d_subdirs)\n\t\t\t\tgoto ascend;\n\t\t\tchild = list_entry(next, struct dentry, d_child);\n\t\t} while (unlikely(child->d_flags & DCACHE_DENTRY_KILLED));\n\t\trcu_read_unlock();\n\t\tgoto resume;\n\t}\n\tif (need_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\n\trcu_read_unlock();\n\nout_unlock:\n\tspin_unlock(&this_parent->d_lock);\n\tdone_seqretry(&rename_lock, seq);\n\treturn;\n\nrename_retry:\n\tspin_unlock(&this_parent->d_lock);\n\trcu_read_unlock();\n\tBUG_ON(seq & 1);\n\tif (!retry)\n\t\treturn;\n\tseq = 1;\n\tgoto again;\n}"
  },
  {
    "function_name": "shrink_dcache_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1189-1202",
    "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, 1024);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (list_lru_count(&sb->s_dentry_lru) > 0);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry_unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_count",
          "args": [
            "&sb->s_dentry_lru"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_dentry_list",
          "args": [
            "&dispose"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dentry_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1043-1078",
          "snippet": "static void shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\t__dentry_kill(dentry);\n\t\tif (parent == dentry)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref))\n\t\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\t__dentry_kill(dentry);\n\t\tif (parent == dentry)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref))\n\t\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_sub",
          "args": [
            "nr_dentry_unused",
            "freed"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_walk",
          "args": [
            "&sb->s_dentry_lru",
            "dentry_lru_isolate_shrink",
            "&dispose",
            "1024"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, 1024);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (list_lru_count(&sb->s_dentry_lru) > 0);\n}"
  },
  {
    "function_name": "dentry_lru_isolate_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1161-1179",
    "snippet": "static enum lru_status dentry_lru_isolate_shrink(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct dentry\t*dentry = container_of(item, struct dentry, d_lru);\n\n\t/*\n\t * we are inverting the lru lock/dentry->d_lock here,\n\t * so use a trylock. If we fail to get the lock, just skip\n\t * it\n\t */\n\tif (!spin_trylock(&dentry->d_lock))\n\t\treturn LRU_SKIP;\n\n\td_lru_shrink_move(lru, dentry, freeable);\n\tspin_unlock(&dentry->d_lock);\n\n\treturn LRU_REMOVED;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lru_shrink_move",
          "args": [
            "lru",
            "dentry",
            "freeable"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "d_lru_shrink_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "424-430",
          "snippet": "static void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry,\n\t\t\t      struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST;\n\tlist_lru_isolate_move(lru, &dentry->d_lru, list);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry,\n\t\t\t      struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST;\n\tlist_lru_isolate_move(lru, &dentry->d_lru, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structdentry",
            "d_lru"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic enum lru_status dentry_lru_isolate_shrink(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct dentry\t*dentry = container_of(item, struct dentry, d_lru);\n\n\t/*\n\t * we are inverting the lru lock/dentry->d_lock here,\n\t * so use a trylock. If we fail to get the lock, just skip\n\t * it\n\t */\n\tif (!spin_trylock(&dentry->d_lock))\n\t\treturn LRU_SKIP;\n\n\td_lru_shrink_move(lru, dentry, freeable);\n\tspin_unlock(&dentry->d_lock);\n\n\treturn LRU_REMOVED;\n}"
  },
  {
    "function_name": "prune_dcache_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1150-1159",
    "snippet": "long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_dentry_lru, sc,\n\t\t\t\t     dentry_lru_isolate, &dispose);\n\tshrink_dentry_list(&dispose);\n\treturn freed;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_dentry_list",
          "args": [
            "&dispose"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dentry_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1043-1078",
          "snippet": "static void shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\t__dentry_kill(dentry);\n\t\tif (parent == dentry)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref))\n\t\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\t__dentry_kill(dentry);\n\t\tif (parent == dentry)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref))\n\t\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_walk",
          "args": [
            "&sb->s_dentry_lru",
            "sc",
            "dentry_lru_isolate",
            "&dispose"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "dispose"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nlong prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_dentry_lru, sc,\n\t\t\t\t     dentry_lru_isolate, &dispose);\n\tshrink_dentry_list(&dispose);\n\treturn freed;\n}"
  },
  {
    "function_name": "dentry_lru_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1080-1136",
    "snippet": "static enum lru_status dentry_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct dentry\t*dentry = container_of(item, struct dentry, d_lru);\n\n\n\t/*\n\t * we are inverting the lru lock/dentry->d_lock here,\n\t * so use a trylock. If we fail to get the lock, just skip\n\t * it\n\t */\n\tif (!spin_trylock(&dentry->d_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * Referenced dentries are still in use. If they have active\n\t * counts, just remove them from the LRU. Otherwise give them\n\t * another pass through the LRU.\n\t */\n\tif (dentry->d_lockref.count) {\n\t\td_lru_isolate(lru, dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn LRU_REMOVED;\n\t}\n\n\tif (dentry->d_flags & DCACHE_REFERENCED) {\n\t\tdentry->d_flags &= ~DCACHE_REFERENCED;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\t/*\n\t\t * The list move itself will be made by the common LRU code. At\n\t\t * this point, we've dropped the dentry->d_lock but keep the\n\t\t * lru lock. This is safe to do, since every list movement is\n\t\t * protected by the lru lock even if both locks are held.\n\t\t *\n\t\t * This is guaranteed by the fact that all LRU management\n\t\t * functions are intermediated by the LRU API calls like\n\t\t * list_lru_add and list_lru_del. List movement in this file\n\t\t * only ever occur through this functions or through callbacks\n\t\t * like this one, that are called from the LRU API.\n\t\t *\n\t\t * The only exceptions to this are functions like\n\t\t * shrink_dentry_list, and code that first checks for the\n\t\t * DCACHE_SHRINK_LIST flag.  Those are guaranteed to be\n\t\t * operating only with stack provided lists after they are\n\t\t * properly isolated from the main list.  It is thus, always a\n\t\t * local access.\n\t\t */\n\t\treturn LRU_ROTATE;\n\t}\n\n\td_lru_shrink_move(lru, dentry, freeable);\n\tspin_unlock(&dentry->d_lock);\n\n\treturn LRU_REMOVED;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lru_shrink_move",
          "args": [
            "lru",
            "dentry",
            "freeable"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "d_lru_shrink_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "424-430",
          "snippet": "static void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry,\n\t\t\t      struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST;\n\tlist_lru_isolate_move(lru, &dentry->d_lru, list);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry,\n\t\t\t      struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST;\n\tlist_lru_isolate_move(lru, &dentry->d_lru, list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lru_isolate",
          "args": [
            "lru",
            "dentry"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "d_lru_isolate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "416-422",
          "snippet": "static void d_lru_isolate(struct list_lru_one *lru, struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tlist_lru_isolate(lru, &dentry->d_lru);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_lru_isolate(struct list_lru_one *lru, struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tlist_lru_isolate(lru, &dentry->d_lru);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structdentry",
            "d_lru"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic enum lru_status dentry_lru_isolate(struct list_head *item,\n\t\tstruct list_lru_one *lru, spinlock_t *lru_lock, void *arg)\n{\n\tstruct list_head *freeable = arg;\n\tstruct dentry\t*dentry = container_of(item, struct dentry, d_lru);\n\n\n\t/*\n\t * we are inverting the lru lock/dentry->d_lock here,\n\t * so use a trylock. If we fail to get the lock, just skip\n\t * it\n\t */\n\tif (!spin_trylock(&dentry->d_lock))\n\t\treturn LRU_SKIP;\n\n\t/*\n\t * Referenced dentries are still in use. If they have active\n\t * counts, just remove them from the LRU. Otherwise give them\n\t * another pass through the LRU.\n\t */\n\tif (dentry->d_lockref.count) {\n\t\td_lru_isolate(lru, dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn LRU_REMOVED;\n\t}\n\n\tif (dentry->d_flags & DCACHE_REFERENCED) {\n\t\tdentry->d_flags &= ~DCACHE_REFERENCED;\n\t\tspin_unlock(&dentry->d_lock);\n\n\t\t/*\n\t\t * The list move itself will be made by the common LRU code. At\n\t\t * this point, we've dropped the dentry->d_lock but keep the\n\t\t * lru lock. This is safe to do, since every list movement is\n\t\t * protected by the lru lock even if both locks are held.\n\t\t *\n\t\t * This is guaranteed by the fact that all LRU management\n\t\t * functions are intermediated by the LRU API calls like\n\t\t * list_lru_add and list_lru_del. List movement in this file\n\t\t * only ever occur through this functions or through callbacks\n\t\t * like this one, that are called from the LRU API.\n\t\t *\n\t\t * The only exceptions to this are functions like\n\t\t * shrink_dentry_list, and code that first checks for the\n\t\t * DCACHE_SHRINK_LIST flag.  Those are guaranteed to be\n\t\t * operating only with stack provided lists after they are\n\t\t * properly isolated from the main list.  It is thus, always a\n\t\t * local access.\n\t\t */\n\t\treturn LRU_ROTATE;\n\t}\n\n\td_lru_shrink_move(lru, dentry, freeable);\n\tspin_unlock(&dentry->d_lock);\n\n\treturn LRU_REMOVED;\n}"
  },
  {
    "function_name": "shrink_dentry_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1043-1078",
    "snippet": "static void shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\t__dentry_kill(dentry);\n\t\tif (parent == dentry)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref))\n\t\t\tdentry = dentry_kill(dentry);\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dentry_kill",
          "args": [
            "dentry"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "637-681",
          "snippet": "static struct dentry *dentry_kill(struct dentry *dentry)\n\t__releases(dentry->d_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *parent = NULL;\n\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock)))\n\t\tgoto slow_positive;\n\n\tif (!IS_ROOT(dentry)) {\n\t\tparent = dentry->d_parent;\n\t\tif (unlikely(!spin_trylock(&parent->d_lock))) {\n\t\t\tparent = __lock_parent(dentry);\n\t\t\tif (likely(inode || !dentry->d_inode))\n\t\t\t\tgoto got_locks;\n\t\t\t/* negative that became positive */\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tinode = dentry->d_inode;\n\t\t\tgoto slow_positive;\n\t\t}\n\t}\n\t__dentry_kill(dentry);\n\treturn parent;\n\nslow_positive:\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\tparent = lock_parent(dentry);\ngot_locks:\n\tif (unlikely(dentry->d_lockref.count != 1)) {\n\t\tdentry->d_lockref.count--;\n\t} else if (likely(!retain_dentry(dentry))) {\n\t\t__dentry_kill(dentry);\n\t\treturn parent;\n\t}\n\t/* we are keeping it, after all */\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tspin_unlock(&dentry->d_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *dentry_kill(struct dentry *dentry)\n\t__releases(dentry->d_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *parent = NULL;\n\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock)))\n\t\tgoto slow_positive;\n\n\tif (!IS_ROOT(dentry)) {\n\t\tparent = dentry->d_parent;\n\t\tif (unlikely(!spin_trylock(&parent->d_lock))) {\n\t\t\tparent = __lock_parent(dentry);\n\t\t\tif (likely(inode || !dentry->d_inode))\n\t\t\t\tgoto got_locks;\n\t\t\t/* negative that became positive */\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tinode = dentry->d_inode;\n\t\t\tgoto slow_positive;\n\t\t}\n\t}\n\t__dentry_kill(dentry);\n\treturn parent;\n\nslow_positive:\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\tparent = lock_parent(dentry);\ngot_locks:\n\tif (unlikely(dentry->d_lockref.count != 1)) {\n\t\tdentry->d_lockref.count--;\n\t} else if (likely(!retain_dentry(dentry))) {\n\t\t__dentry_kill(dentry);\n\t\treturn parent;\n\t}\n\t/* we are keeping it, after all */\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tspin_unlock(&dentry->d_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockref_put_or_lock",
          "args": [
            "&dentry->d_lockref"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dentry_kill",
          "args": [
            "dentry"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "__dentry_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "523-568",
          "snippet": "static void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstatic void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_shrink_del",
          "args": [
            "dentry"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "d_shrink_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "394-400",
          "snippet": "static void d_shrink_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tlist_del_init(&dentry->d_lru);\n\tdentry->d_flags &= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tthis_cpu_dec(nr_dentry_unused);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_shrink_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tlist_del_init(&dentry->d_lru);\n\tdentry->d_flags &= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tthis_cpu_dec(nr_dentry_unused);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_free",
          "args": [
            "dentry"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "322-337",
          "snippet": "static void dentry_free(struct dentry *dentry)\n{\n\tWARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tif (likely(atomic_dec_and_test(&p->u.count))) {\n\t\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free_external);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* if dentry was never visible to RCU, immediate free is OK */\n\tif (!(dentry->d_flags & DCACHE_RCUACCESS))\n\t\t__d_free(&dentry->d_u.d_rcu);\n\telse\n\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void dentry_free(struct dentry *dentry)\n{\n\tWARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tif (likely(atomic_dec_and_test(&p->u.count))) {\n\t\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free_external);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* if dentry was never visible to RCU, immediate free is OK */\n\tif (!(dentry->d_flags & DCACHE_RCUACCESS))\n\t\t__d_free(&dentry->d_u.d_rcu);\n\telse\n\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_lock_dentry",
          "args": [
            "dentry"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_lock_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1002-1041",
          "snippet": "static bool shrink_lock_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\n\tif (dentry->d_lockref.count)\n\t\treturn false;\n\n\tinode = dentry->d_inode;\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock))) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (unlikely(dentry->d_lockref.count))\n\t\t\tgoto out;\n\t\t/* changed inode means that somebody had grabbed it */\n\t\tif (unlikely(inode != dentry->d_inode))\n\t\t\tgoto out;\n\t}\n\n\tparent = dentry->d_parent;\n\tif (IS_ROOT(dentry) || likely(spin_trylock(&parent->d_lock)))\n\t\treturn true;\n\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&parent->d_lock);\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tgoto out;\n\t}\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tif (likely(!dentry->d_lockref.count))\n\t\treturn true;\n\tspin_unlock(&parent->d_lock);\nout:\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\treturn false;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic bool shrink_lock_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\n\tif (dentry->d_lockref.count)\n\t\treturn false;\n\n\tinode = dentry->d_inode;\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock))) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (unlikely(dentry->d_lockref.count))\n\t\t\tgoto out;\n\t\t/* changed inode means that somebody had grabbed it */\n\t\tif (unlikely(inode != dentry->d_inode))\n\t\t\tgoto out;\n\t}\n\n\tparent = dentry->d_parent;\n\tif (IS_ROOT(dentry) || likely(spin_trylock(&parent->d_lock)))\n\t\treturn true;\n\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&parent->d_lock);\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tgoto out;\n\t}\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tif (likely(!dentry->d_lockref.count))\n\t\treturn true;\n\tspin_unlock(&parent->d_lock);\nout:\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list->prev",
            "structdentry",
            "d_lru"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void shrink_dentry_list(struct list_head *list)\n{\n\twhile (!list_empty(list)) {\n\t\tstruct dentry *dentry, *parent;\n\n\t\tdentry = list_entry(list->prev, struct dentry, d_lru);\n\t\tspin_lock(&dentry->d_lock);\n\t\trcu_read_lock();\n\t\tif (!shrink_lock_dentry(dentry)) {\n\t\t\tbool can_free = false;\n\t\t\trcu_read_unlock();\n\t\t\td_shrink_del(dentry);\n\t\t\tif (dentry->d_lockref.count < 0)\n\t\t\t\tcan_free = dentry->d_flags & DCACHE_MAY_FREE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (can_free)\n\t\t\t\tdentry_free(dentry);\n\t\t\tcontinue;\n\t\t}\n\t\trcu_read_unlock();\n\t\td_shrink_del(dentry);\n\t\tparent = dentry->d_parent;\n\t\t__dentry_kill(dentry);\n\t\tif (parent == dentry)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We need to prune ancestors too. This is necessary to prevent\n\t\t * quadratic behavior of shrink_dcache_parent(), but is also\n\t\t * expected to be beneficial in reducing dentry cache\n\t\t * fragmentation.\n\t\t */\n\t\tdentry = parent;\n\t\twhile (dentry && !lockref_put_or_lock(&dentry->d_lockref))\n\t\t\tdentry = dentry_kill(dentry);\n\t}\n}"
  },
  {
    "function_name": "shrink_lock_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "1002-1041",
    "snippet": "static bool shrink_lock_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\n\tif (dentry->d_lockref.count)\n\t\treturn false;\n\n\tinode = dentry->d_inode;\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock))) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (unlikely(dentry->d_lockref.count))\n\t\t\tgoto out;\n\t\t/* changed inode means that somebody had grabbed it */\n\t\tif (unlikely(inode != dentry->d_inode))\n\t\t\tgoto out;\n\t}\n\n\tparent = dentry->d_parent;\n\tif (IS_ROOT(dentry) || likely(spin_trylock(&parent->d_lock)))\n\t\treturn true;\n\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&parent->d_lock);\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tgoto out;\n\t}\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tif (likely(!dentry->d_lockref.count))\n\t\treturn true;\n\tspin_unlock(&parent->d_lock);\nout:\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\treturn false;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!dentry->d_lockref.count"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&dentry->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "parent != dentry->d_parent"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "spin_trylock(&parent->d_lock)"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode != dentry->d_inode"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_lockref.count"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!spin_trylock(&inode->i_lock)"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic bool shrink_lock_dentry(struct dentry *dentry)\n{\n\tstruct inode *inode;\n\tstruct dentry *parent;\n\n\tif (dentry->d_lockref.count)\n\t\treturn false;\n\n\tinode = dentry->d_inode;\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock))) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_lock(&inode->i_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (unlikely(dentry->d_lockref.count))\n\t\t\tgoto out;\n\t\t/* changed inode means that somebody had grabbed it */\n\t\tif (unlikely(inode != dentry->d_inode))\n\t\t\tgoto out;\n\t}\n\n\tparent = dentry->d_parent;\n\tif (IS_ROOT(dentry) || likely(spin_trylock(&parent->d_lock)))\n\t\treturn true;\n\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&parent->d_lock);\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tspin_lock(&dentry->d_lock);\n\t\tgoto out;\n\t}\n\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\tif (likely(!dentry->d_lockref.count))\n\t\treturn true;\n\tspin_unlock(&parent->d_lock);\nout:\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\treturn false;\n}"
  },
  {
    "function_name": "d_prune_aliases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "968-988",
    "snippet": "void d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dentry_kill",
          "args": [
            "dentry"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "__dentry_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "523-568",
          "snippet": "static void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstatic void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!dentry->d_lockref.count"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "dentry"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "598-606",
          "snippet": "static inline struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent = dentry->d_parent;\n\tif (IS_ROOT(dentry))\n\t\treturn NULL;\n\tif (likely(spin_trylock(&parent->d_lock)))\n\t\treturn parent;\n\treturn __lock_parent(dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent = dentry->d_parent;\n\tif (IS_ROOT(dentry))\n\t\treturn NULL;\n\tif (likely(spin_trylock(&parent->d_lock)))\n\t\treturn parent;\n\treturn __lock_parent(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "dentry",
            "&inode->i_dentry",
            "d_u.d_alias"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_prune_aliases(struct inode *inode)\n{\n\tstruct dentry *dentry;\nrestart:\n\tspin_lock(&inode->i_lock);\n\thlist_for_each_entry(dentry, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (!dentry->d_lockref.count) {\n\t\t\tstruct dentry *parent = lock_parent(dentry);\n\t\t\tif (likely(!dentry->d_lockref.count)) {\n\t\t\t\t__dentry_kill(dentry);\n\t\t\t\tdput(parent);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t}\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
  },
  {
    "function_name": "d_find_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "951-961",
    "snippet": "struct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_find_alias",
          "args": [
            "inode"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "__d_find_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "932-949",
          "snippet": "static struct dentry *__d_find_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn __d_find_any_alias(inode);\n\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&alias->d_lock);\n \t\tif (!d_unhashed(alias)) {\n\t\t\t__dget_dlock(alias);\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t\treturn alias;\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__d_find_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn __d_find_any_alias(inode);\n\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&alias->d_lock);\n \t\tif (!d_unhashed(alias)) {\n\t\t\t__dget_dlock(alias);\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t\treturn alias;\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&inode->i_dentry"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_find_alias(struct inode *inode)\n{\n\tstruct dentry *de = NULL;\n\n\tif (!hlist_empty(&inode->i_dentry)) {\n\t\tspin_lock(&inode->i_lock);\n\t\tde = __d_find_alias(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\treturn de;\n}"
  },
  {
    "function_name": "__d_find_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "932-949",
    "snippet": "static struct dentry *__d_find_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn __d_find_any_alias(inode);\n\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&alias->d_lock);\n \t\tif (!d_unhashed(alias)) {\n\t\t\t__dget_dlock(alias);\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t\treturn alias;\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&alias->d_lock"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dget_dlock",
          "args": [
            "alias"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "__dget_dlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "839-842",
          "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "alias"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&alias->d_lock"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "alias",
            "&inode->i_dentry",
            "d_u.d_alias"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_find_any_alias",
          "args": [
            "inode"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "__d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "889-898",
          "snippet": "static struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__d_find_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn __d_find_any_alias(inode);\n\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tspin_lock(&alias->d_lock);\n \t\tif (!d_unhashed(alias)) {\n\t\t\t__dget_dlock(alias);\n\t\t\tspin_unlock(&alias->d_lock);\n\t\t\treturn alias;\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "d_find_any_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "907-915",
    "snippet": "struct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_find_any_alias",
          "args": [
            "inode"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "__d_find_any_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "889-898",
          "snippet": "static struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *de;\n\n\tspin_lock(&inode->i_lock);\n\tde = __d_find_any_alias(inode);\n\tspin_unlock(&inode->i_lock);\n\treturn de;\n}"
  },
  {
    "function_name": "__d_find_any_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "889-898",
    "snippet": "static struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dget",
          "args": [
            "alias"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "__dget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "844-847",
          "snippet": "static inline void __dget(struct dentry *dentry)\n{\n\tlockref_get(&dentry->d_lockref);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __dget(struct dentry *dentry)\n{\n\tlockref_get(&dentry->d_lockref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "inode->i_dentry.first",
            "structdentry",
            "d_u.d_alias"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&inode->i_dentry"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry * __d_find_any_alias(struct inode *inode)\n{\n\tstruct dentry *alias;\n\n\tif (hlist_empty(&inode->i_dentry))\n\t\treturn NULL;\n\talias = hlist_entry(inode->i_dentry.first, struct dentry, d_u.d_alias);\n\t__dget(alias);\n\treturn alias;\n}"
  },
  {
    "function_name": "dget_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "849-886",
    "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ret->d_lock"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ret->d_lockref.count"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret != dentry->d_parent"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ret->d_lock"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "ret"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ret == READ_ONCE(dentry->d_parent)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dentry->d_parent"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "gotref"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_get_not_zero",
          "args": [
            "&ret->d_lockref"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dentry->d_parent"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__dget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "844-847",
    "snippet": "static inline void __dget(struct dentry *dentry)\n{\n\tlockref_get(&dentry->d_lockref);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockref_get",
          "args": [
            "&dentry->d_lockref"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __dget(struct dentry *dentry)\n{\n\tlockref_get(&dentry->d_lockref);\n}"
  },
  {
    "function_name": "__dget_dlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "839-842",
    "snippet": "static inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __dget_dlock(struct dentry *dentry)\n{\n\tdentry->d_lockref.count++;\n}"
  },
  {
    "function_name": "dput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "813-834",
    "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dentry_kill",
          "args": [
            "dentry"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "637-681",
          "snippet": "static struct dentry *dentry_kill(struct dentry *dentry)\n\t__releases(dentry->d_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *parent = NULL;\n\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock)))\n\t\tgoto slow_positive;\n\n\tif (!IS_ROOT(dentry)) {\n\t\tparent = dentry->d_parent;\n\t\tif (unlikely(!spin_trylock(&parent->d_lock))) {\n\t\t\tparent = __lock_parent(dentry);\n\t\t\tif (likely(inode || !dentry->d_inode))\n\t\t\t\tgoto got_locks;\n\t\t\t/* negative that became positive */\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tinode = dentry->d_inode;\n\t\t\tgoto slow_positive;\n\t\t}\n\t}\n\t__dentry_kill(dentry);\n\treturn parent;\n\nslow_positive:\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\tparent = lock_parent(dentry);\ngot_locks:\n\tif (unlikely(dentry->d_lockref.count != 1)) {\n\t\tdentry->d_lockref.count--;\n\t} else if (likely(!retain_dentry(dentry))) {\n\t\t__dentry_kill(dentry);\n\t\treturn parent;\n\t}\n\t/* we are keeping it, after all */\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tspin_unlock(&dentry->d_lock);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *dentry_kill(struct dentry *dentry)\n\t__releases(dentry->d_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *parent = NULL;\n\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock)))\n\t\tgoto slow_positive;\n\n\tif (!IS_ROOT(dentry)) {\n\t\tparent = dentry->d_parent;\n\t\tif (unlikely(!spin_trylock(&parent->d_lock))) {\n\t\t\tparent = __lock_parent(dentry);\n\t\t\tif (likely(inode || !dentry->d_inode))\n\t\t\t\tgoto got_locks;\n\t\t\t/* negative that became positive */\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tinode = dentry->d_inode;\n\t\t\tgoto slow_positive;\n\t\t}\n\t}\n\t__dentry_kill(dentry);\n\treturn parent;\n\nslow_positive:\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\tparent = lock_parent(dentry);\ngot_locks:\n\tif (unlikely(dentry->d_lockref.count != 1)) {\n\t\tdentry->d_lockref.count--;\n\t} else if (likely(!retain_dentry(dentry))) {\n\t\t__dentry_kill(dentry);\n\t\treturn parent;\n\t}\n\t/* we are keeping it, after all */\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tspin_unlock(&dentry->d_lock);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "retain_dentry(dentry)"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retain_dentry",
          "args": [
            "dentry"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "retain_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "608-630",
          "snippet": "static inline bool retain_dentry(struct dentry *dentry)\n{\n\tWARN_ON(d_in_lookup(dentry));\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\treturn false;\n\t}\n\t/* retain; LRU fodder */\n\tdentry->d_lockref.count--;\n\tif (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))\n\t\td_lru_add(dentry);\n\telse if (unlikely(!(dentry->d_flags & DCACHE_REFERENCED)))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\treturn true;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool retain_dentry(struct dentry *dentry)\n{\n\tWARN_ON(d_in_lookup(dentry));\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\treturn false;\n\t}\n\t/* retain; LRU fodder */\n\tdentry->d_lockref.count--;\n\tif (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))\n\t\td_lru_add(dentry);\n\telse if (unlikely(!(dentry->d_flags & DCACHE_REFERENCED)))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "fast_dput(dentry)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fast_dput",
          "args": [
            "dentry"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "fast_dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "691-784",
          "snippet": "static inline bool fast_dput(struct dentry *dentry)\n{\n\tint ret;\n\tunsigned int d_flags;\n\n\t/*\n\t * If we have a d_op->d_delete() operation, we sould not\n\t * let the dentry count go to zero, so use \"put_or_lock\".\n\t */\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE))\n\t\treturn lockref_put_or_lock(&dentry->d_lockref);\n\n\t/*\n\t * .. otherwise, we can try to just decrement the\n\t * lockref optimistically.\n\t */\n\tret = lockref_put_return(&dentry->d_lockref);\n\n\t/*\n\t * If the lockref_put_return() failed due to the lock being held\n\t * by somebody else, the fast path has failed. We will need to\n\t * get the lock, and then check the count again.\n\t */\n\tif (unlikely(ret < 0)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_lockref.count > 1) {\n\t\t\tdentry->d_lockref.count--;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we weren't the last ref, we're done.\n\t */\n\tif (ret)\n\t\treturn true;\n\n\t/*\n\t * Careful, careful. The reference count went down\n\t * to zero, but we don't hold the dentry lock, so\n\t * somebody else could get it again, and do another\n\t * dput(), and we need to not race with that.\n\t *\n\t * However, there is a very special and common case\n\t * where we don't care, because there is nothing to\n\t * do: the dentry is still hashed, it does not have\n\t * a 'delete' op, and it's referenced and already on\n\t * the LRU list.\n\t *\n\t * NOTE! Since we aren't locked, these values are\n\t * not \"stable\". However, it is sufficient that at\n\t * some point after we dropped the reference the\n\t * dentry was hashed and the flags had the proper\n\t * value. Other dentry users may have re-gotten\n\t * a reference to the dentry and change that, but\n\t * our work is done - we can leave the dentry\n\t * around with a zero refcount.\n\t */\n\tsmp_rmb();\n\td_flags = READ_ONCE(dentry->d_flags);\n\td_flags &= DCACHE_REFERENCED | DCACHE_LRU_LIST | DCACHE_DISCONNECTED;\n\n\t/* Nothing to do? Dropping the reference was all we needed? */\n\tif (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) && !d_unhashed(dentry))\n\t\treturn true;\n\n\t/*\n\t * Not the fast normal case? Get the lock. We've already decremented\n\t * the refcount, but we'll need to re-check the situation after\n\t * getting the lock.\n\t */\n\tspin_lock(&dentry->d_lock);\n\n\t/*\n\t * Did somebody else grab a reference to it in the meantime, and\n\t * we're no longer the last user after all? Alternatively, somebody\n\t * else could have killed it and marked it dead. Either way, we\n\t * don't need to do anything else.\n\t */\n\tif (dentry->d_lockref.count) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn true;\n\t}\n\n\t/*\n\t * Re-get the reference we optimistically dropped. We hold the\n\t * lock, and we just tested that it was zero, so we can just\n\t * set it to 1.\n\t */\n\tdentry->d_lockref.count = 1;\n\treturn false;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool fast_dput(struct dentry *dentry)\n{\n\tint ret;\n\tunsigned int d_flags;\n\n\t/*\n\t * If we have a d_op->d_delete() operation, we sould not\n\t * let the dentry count go to zero, so use \"put_or_lock\".\n\t */\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE))\n\t\treturn lockref_put_or_lock(&dentry->d_lockref);\n\n\t/*\n\t * .. otherwise, we can try to just decrement the\n\t * lockref optimistically.\n\t */\n\tret = lockref_put_return(&dentry->d_lockref);\n\n\t/*\n\t * If the lockref_put_return() failed due to the lock being held\n\t * by somebody else, the fast path has failed. We will need to\n\t * get the lock, and then check the count again.\n\t */\n\tif (unlikely(ret < 0)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_lockref.count > 1) {\n\t\t\tdentry->d_lockref.count--;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we weren't the last ref, we're done.\n\t */\n\tif (ret)\n\t\treturn true;\n\n\t/*\n\t * Careful, careful. The reference count went down\n\t * to zero, but we don't hold the dentry lock, so\n\t * somebody else could get it again, and do another\n\t * dput(), and we need to not race with that.\n\t *\n\t * However, there is a very special and common case\n\t * where we don't care, because there is nothing to\n\t * do: the dentry is still hashed, it does not have\n\t * a 'delete' op, and it's referenced and already on\n\t * the LRU list.\n\t *\n\t * NOTE! Since we aren't locked, these values are\n\t * not \"stable\". However, it is sufficient that at\n\t * some point after we dropped the reference the\n\t * dentry was hashed and the flags had the proper\n\t * value. Other dentry users may have re-gotten\n\t * a reference to the dentry and change that, but\n\t * our work is done - we can leave the dentry\n\t * around with a zero refcount.\n\t */\n\tsmp_rmb();\n\td_flags = READ_ONCE(dentry->d_flags);\n\td_flags &= DCACHE_REFERENCED | DCACHE_LRU_LIST | DCACHE_DISCONNECTED;\n\n\t/* Nothing to do? Dropping the reference was all we needed? */\n\tif (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) && !d_unhashed(dentry))\n\t\treturn true;\n\n\t/*\n\t * Not the fast normal case? Get the lock. We've already decremented\n\t * the refcount, but we'll need to re-check the situation after\n\t * getting the lock.\n\t */\n\tspin_lock(&dentry->d_lock);\n\n\t/*\n\t * Did somebody else grab a reference to it in the meantime, and\n\t * we're no longer the last user after all? Alternatively, somebody\n\t * else could have killed it and marked it dead. Either way, we\n\t * don't need to do anything else.\n\t */\n\tif (dentry->d_lockref.count) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn true;\n\t}\n\n\t/*\n\t * Re-get the reference we optimistically dropped. We hold the\n\t * lock, and we just tested that it was zero, so we can just\n\t * set it to 1.\n\t */\n\tdentry->d_lockref.count = 1;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
  },
  {
    "function_name": "fast_dput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "691-784",
    "snippet": "static inline bool fast_dput(struct dentry *dentry)\n{\n\tint ret;\n\tunsigned int d_flags;\n\n\t/*\n\t * If we have a d_op->d_delete() operation, we sould not\n\t * let the dentry count go to zero, so use \"put_or_lock\".\n\t */\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE))\n\t\treturn lockref_put_or_lock(&dentry->d_lockref);\n\n\t/*\n\t * .. otherwise, we can try to just decrement the\n\t * lockref optimistically.\n\t */\n\tret = lockref_put_return(&dentry->d_lockref);\n\n\t/*\n\t * If the lockref_put_return() failed due to the lock being held\n\t * by somebody else, the fast path has failed. We will need to\n\t * get the lock, and then check the count again.\n\t */\n\tif (unlikely(ret < 0)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_lockref.count > 1) {\n\t\t\tdentry->d_lockref.count--;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we weren't the last ref, we're done.\n\t */\n\tif (ret)\n\t\treturn true;\n\n\t/*\n\t * Careful, careful. The reference count went down\n\t * to zero, but we don't hold the dentry lock, so\n\t * somebody else could get it again, and do another\n\t * dput(), and we need to not race with that.\n\t *\n\t * However, there is a very special and common case\n\t * where we don't care, because there is nothing to\n\t * do: the dentry is still hashed, it does not have\n\t * a 'delete' op, and it's referenced and already on\n\t * the LRU list.\n\t *\n\t * NOTE! Since we aren't locked, these values are\n\t * not \"stable\". However, it is sufficient that at\n\t * some point after we dropped the reference the\n\t * dentry was hashed and the flags had the proper\n\t * value. Other dentry users may have re-gotten\n\t * a reference to the dentry and change that, but\n\t * our work is done - we can leave the dentry\n\t * around with a zero refcount.\n\t */\n\tsmp_rmb();\n\td_flags = READ_ONCE(dentry->d_flags);\n\td_flags &= DCACHE_REFERENCED | DCACHE_LRU_LIST | DCACHE_DISCONNECTED;\n\n\t/* Nothing to do? Dropping the reference was all we needed? */\n\tif (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) && !d_unhashed(dentry))\n\t\treturn true;\n\n\t/*\n\t * Not the fast normal case? Get the lock. We've already decremented\n\t * the refcount, but we'll need to re-check the situation after\n\t * getting the lock.\n\t */\n\tspin_lock(&dentry->d_lock);\n\n\t/*\n\t * Did somebody else grab a reference to it in the meantime, and\n\t * we're no longer the last user after all? Alternatively, somebody\n\t * else could have killed it and marked it dead. Either way, we\n\t * don't need to do anything else.\n\t */\n\tif (dentry->d_lockref.count) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn true;\n\t}\n\n\t/*\n\t * Re-get the reference we optimistically dropped. We hold the\n\t * lock, and we just tested that it was zero, so we can just\n\t * set it to 1.\n\t */\n\tdentry->d_lockref.count = 1;\n\treturn false;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dentry->d_flags"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_put_return",
          "args": [
            "&dentry->d_lockref"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_put_or_lock",
          "args": [
            "&dentry->d_lockref"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_flags & DCACHE_OP_DELETE"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool fast_dput(struct dentry *dentry)\n{\n\tint ret;\n\tunsigned int d_flags;\n\n\t/*\n\t * If we have a d_op->d_delete() operation, we sould not\n\t * let the dentry count go to zero, so use \"put_or_lock\".\n\t */\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE))\n\t\treturn lockref_put_or_lock(&dentry->d_lockref);\n\n\t/*\n\t * .. otherwise, we can try to just decrement the\n\t * lockref optimistically.\n\t */\n\tret = lockref_put_return(&dentry->d_lockref);\n\n\t/*\n\t * If the lockref_put_return() failed due to the lock being held\n\t * by somebody else, the fast path has failed. We will need to\n\t * get the lock, and then check the count again.\n\t */\n\tif (unlikely(ret < 0)) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (dentry->d_lockref.count > 1) {\n\t\t\tdentry->d_lockref.count--;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*\n\t * If we weren't the last ref, we're done.\n\t */\n\tif (ret)\n\t\treturn true;\n\n\t/*\n\t * Careful, careful. The reference count went down\n\t * to zero, but we don't hold the dentry lock, so\n\t * somebody else could get it again, and do another\n\t * dput(), and we need to not race with that.\n\t *\n\t * However, there is a very special and common case\n\t * where we don't care, because there is nothing to\n\t * do: the dentry is still hashed, it does not have\n\t * a 'delete' op, and it's referenced and already on\n\t * the LRU list.\n\t *\n\t * NOTE! Since we aren't locked, these values are\n\t * not \"stable\". However, it is sufficient that at\n\t * some point after we dropped the reference the\n\t * dentry was hashed and the flags had the proper\n\t * value. Other dentry users may have re-gotten\n\t * a reference to the dentry and change that, but\n\t * our work is done - we can leave the dentry\n\t * around with a zero refcount.\n\t */\n\tsmp_rmb();\n\td_flags = READ_ONCE(dentry->d_flags);\n\td_flags &= DCACHE_REFERENCED | DCACHE_LRU_LIST | DCACHE_DISCONNECTED;\n\n\t/* Nothing to do? Dropping the reference was all we needed? */\n\tif (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) && !d_unhashed(dentry))\n\t\treturn true;\n\n\t/*\n\t * Not the fast normal case? Get the lock. We've already decremented\n\t * the refcount, but we'll need to re-check the situation after\n\t * getting the lock.\n\t */\n\tspin_lock(&dentry->d_lock);\n\n\t/*\n\t * Did somebody else grab a reference to it in the meantime, and\n\t * we're no longer the last user after all? Alternatively, somebody\n\t * else could have killed it and marked it dead. Either way, we\n\t * don't need to do anything else.\n\t */\n\tif (dentry->d_lockref.count) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn true;\n\t}\n\n\t/*\n\t * Re-get the reference we optimistically dropped. We hold the\n\t * lock, and we just tested that it was zero, so we can just\n\t * set it to 1.\n\t */\n\tdentry->d_lockref.count = 1;\n\treturn false;\n}"
  },
  {
    "function_name": "dentry_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "637-681",
    "snippet": "static struct dentry *dentry_kill(struct dentry *dentry)\n\t__releases(dentry->d_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *parent = NULL;\n\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock)))\n\t\tgoto slow_positive;\n\n\tif (!IS_ROOT(dentry)) {\n\t\tparent = dentry->d_parent;\n\t\tif (unlikely(!spin_trylock(&parent->d_lock))) {\n\t\t\tparent = __lock_parent(dentry);\n\t\t\tif (likely(inode || !dentry->d_inode))\n\t\t\t\tgoto got_locks;\n\t\t\t/* negative that became positive */\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tinode = dentry->d_inode;\n\t\t\tgoto slow_positive;\n\t\t}\n\t}\n\t__dentry_kill(dentry);\n\treturn parent;\n\nslow_positive:\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\tparent = lock_parent(dentry);\ngot_locks:\n\tif (unlikely(dentry->d_lockref.count != 1)) {\n\t\tdentry->d_lockref.count--;\n\t} else if (likely(!retain_dentry(dentry))) {\n\t\t__dentry_kill(dentry);\n\t\treturn parent;\n\t}\n\t/* we are keeping it, after all */\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tspin_unlock(&dentry->d_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dentry_kill",
          "args": [
            "dentry"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "__dentry_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "523-568",
          "snippet": "static void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstatic void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!retain_dentry(dentry)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retain_dentry",
          "args": [
            "dentry"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "retain_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "608-630",
          "snippet": "static inline bool retain_dentry(struct dentry *dentry)\n{\n\tWARN_ON(d_in_lookup(dentry));\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\treturn false;\n\t}\n\t/* retain; LRU fodder */\n\tdentry->d_lockref.count--;\n\tif (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))\n\t\td_lru_add(dentry);\n\telse if (unlikely(!(dentry->d_flags & DCACHE_REFERENCED)))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\treturn true;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool retain_dentry(struct dentry *dentry)\n{\n\tWARN_ON(d_in_lookup(dentry));\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\treturn false;\n\t}\n\t/* retain; LRU fodder */\n\tdentry->d_lockref.count--;\n\tif (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))\n\t\td_lru_add(dentry);\n\telse if (unlikely(!(dentry->d_flags & DCACHE_REFERENCED)))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_lockref.count != 1"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_parent",
          "args": [
            "dentry"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "598-606",
          "snippet": "static inline struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent = dentry->d_parent;\n\tif (IS_ROOT(dentry))\n\t\treturn NULL;\n\tif (likely(spin_trylock(&parent->d_lock)))\n\t\treturn parent;\n\treturn __lock_parent(dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent = dentry->d_parent;\n\tif (IS_ROOT(dentry))\n\t\treturn NULL;\n\tif (likely(spin_trylock(&parent->d_lock)))\n\t\treturn parent;\n\treturn __lock_parent(dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "inode || !dentry->d_inode"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__lock_parent",
          "args": [
            "dentry"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "570-596",
          "snippet": "static struct dentry *__lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\trcu_read_lock();\n\tspin_unlock(&dentry->d_lock);\nagain:\n\tparent = READ_ONCE(dentry->d_parent);\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * We can't blindly lock dentry until we are sure\n\t * that we won't violate the locking order.\n\t * Any changes of dentry->d_parent must have\n\t * been done with parent->d_lock held, so\n\t * spin_lock() above is enough of a barrier\n\t * for checking if it's still our child.\n\t */\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tif (parent != dentry)\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\telse\n\t\tparent = NULL;\n\treturn parent;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\trcu_read_lock();\n\tspin_unlock(&dentry->d_lock);\nagain:\n\tparent = READ_ONCE(dentry->d_parent);\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * We can't blindly lock dentry until we are sure\n\t * that we won't violate the locking order.\n\t * Any changes of dentry->d_parent must have\n\t * been done with parent->d_lock held, so\n\t * spin_lock() above is enough of a barrier\n\t * for checking if it's still our child.\n\t */\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tif (parent != dentry)\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\telse\n\t\tparent = NULL;\n\treturn parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!spin_trylock(&parent->d_lock)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!spin_trylock(&inode->i_lock)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "dentry->d_lock"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *dentry_kill(struct dentry *dentry)\n\t__releases(dentry->d_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *parent = NULL;\n\n\tif (inode && unlikely(!spin_trylock(&inode->i_lock)))\n\t\tgoto slow_positive;\n\n\tif (!IS_ROOT(dentry)) {\n\t\tparent = dentry->d_parent;\n\t\tif (unlikely(!spin_trylock(&parent->d_lock))) {\n\t\t\tparent = __lock_parent(dentry);\n\t\t\tif (likely(inode || !dentry->d_inode))\n\t\t\t\tgoto got_locks;\n\t\t\t/* negative that became positive */\n\t\t\tif (parent)\n\t\t\t\tspin_unlock(&parent->d_lock);\n\t\t\tinode = dentry->d_inode;\n\t\t\tgoto slow_positive;\n\t\t}\n\t}\n\t__dentry_kill(dentry);\n\treturn parent;\n\nslow_positive:\n\tspin_unlock(&dentry->d_lock);\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\tparent = lock_parent(dentry);\ngot_locks:\n\tif (unlikely(dentry->d_lockref.count != 1)) {\n\t\tdentry->d_lockref.count--;\n\t} else if (likely(!retain_dentry(dentry))) {\n\t\t__dentry_kill(dentry);\n\t\treturn parent;\n\t}\n\t/* we are keeping it, after all */\n\tif (inode)\n\t\tspin_unlock(&inode->i_lock);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tspin_unlock(&dentry->d_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "retain_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "608-630",
    "snippet": "static inline bool retain_dentry(struct dentry *dentry)\n{\n\tWARN_ON(d_in_lookup(dentry));\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\treturn false;\n\t}\n\t/* retain; LRU fodder */\n\tdentry->d_lockref.count--;\n\tif (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))\n\t\td_lru_add(dentry);\n\telse if (unlikely(!(dentry->d_flags & DCACHE_REFERENCED)))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\treturn true;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(dentry->d_flags & DCACHE_REFERENCED)"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_lru_add",
          "args": [
            "dentry"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "d_lru_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "378-384",
          "snippet": "static void d_lru_add(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tdentry->d_flags |= DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_add(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_lru_add(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tdentry->d_flags |= DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_add(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(dentry->d_flags & DCACHE_LRU_LIST)"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry->d_op->d_delete",
          "args": [
            "dentry"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "d_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2338-2357",
          "snippet": "void d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint isdir = d_is_dir(dentry);\n\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\t/*\n\t * Are we the only user?\n\t */\n\tif (dentry->d_lockref.count == 1) {\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t} else {\n\t\t__d_drop(dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tfsnotify_nameremove(dentry, isdir);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_delete(struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint isdir = d_is_dir(dentry);\n\n\tspin_lock(&inode->i_lock);\n\tspin_lock(&dentry->d_lock);\n\t/*\n\t * Are we the only user?\n\t */\n\tif (dentry->d_lockref.count == 1) {\n\t\tdentry->d_flags &= ~DCACHE_CANT_MOUNT;\n\t\tdentry_unlink_inode(dentry);\n\t} else {\n\t\t__d_drop(dentry);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n\tfsnotify_nameremove(dentry, isdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_flags & DCACHE_OP_DELETE"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dentry->d_flags & DCACHE_DISCONNECTED"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "d_unhashed(dentry)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "d_in_lookup(dentry)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_in_lookup",
          "args": [
            "dentry"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline bool retain_dentry(struct dentry *dentry)\n{\n\tWARN_ON(d_in_lookup(dentry));\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_DISCONNECTED))\n\t\treturn false;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\treturn false;\n\t}\n\t/* retain; LRU fodder */\n\tdentry->d_lockref.count--;\n\tif (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))\n\t\td_lru_add(dentry);\n\telse if (unlikely(!(dentry->d_flags & DCACHE_REFERENCED)))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\treturn true;\n}"
  },
  {
    "function_name": "lock_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "598-606",
    "snippet": "static inline struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent = dentry->d_parent;\n\tif (IS_ROOT(dentry))\n\t\treturn NULL;\n\tif (likely(spin_trylock(&parent->d_lock)))\n\t\treturn parent;\n\treturn __lock_parent(dentry);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lock_parent",
          "args": [
            "dentry"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "570-596",
          "snippet": "static struct dentry *__lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\trcu_read_lock();\n\tspin_unlock(&dentry->d_lock);\nagain:\n\tparent = READ_ONCE(dentry->d_parent);\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * We can't blindly lock dentry until we are sure\n\t * that we won't violate the locking order.\n\t * Any changes of dentry->d_parent must have\n\t * been done with parent->d_lock held, so\n\t * spin_lock() above is enough of a barrier\n\t * for checking if it's still our child.\n\t */\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tif (parent != dentry)\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\telse\n\t\tparent = NULL;\n\treturn parent;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\trcu_read_lock();\n\tspin_unlock(&dentry->d_lock);\nagain:\n\tparent = READ_ONCE(dentry->d_parent);\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * We can't blindly lock dentry until we are sure\n\t * that we won't violate the locking order.\n\t * Any changes of dentry->d_parent must have\n\t * been done with parent->d_lock held, so\n\t * spin_lock() above is enough of a barrier\n\t * for checking if it's still our child.\n\t */\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tif (parent != dentry)\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\telse\n\t\tparent = NULL;\n\treturn parent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "spin_trylock(&parent->d_lock)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct dentry *lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent = dentry->d_parent;\n\tif (IS_ROOT(dentry))\n\t\treturn NULL;\n\tif (likely(spin_trylock(&parent->d_lock)))\n\t\treturn parent;\n\treturn __lock_parent(dentry);\n}"
  },
  {
    "function_name": "__lock_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "570-596",
    "snippet": "static struct dentry *__lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\trcu_read_lock();\n\tspin_unlock(&dentry->d_lock);\nagain:\n\tparent = READ_ONCE(dentry->d_parent);\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * We can't blindly lock dentry until we are sure\n\t * that we won't violate the locking order.\n\t * Any changes of dentry->d_parent must have\n\t * been done with parent->d_lock held, so\n\t * spin_lock() above is enough of a barrier\n\t * for checking if it's still our child.\n\t */\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tif (parent != dentry)\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\telse\n\t\tparent = NULL;\n\treturn parent;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_nested",
          "args": [
            "&dentry->d_lock",
            "DENTRY_D_LOCK_NESTED"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "parent != dentry->d_parent"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dentry->d_parent"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct dentry *__lock_parent(struct dentry *dentry)\n{\n\tstruct dentry *parent;\n\trcu_read_lock();\n\tspin_unlock(&dentry->d_lock);\nagain:\n\tparent = READ_ONCE(dentry->d_parent);\n\tspin_lock(&parent->d_lock);\n\t/*\n\t * We can't blindly lock dentry until we are sure\n\t * that we won't violate the locking order.\n\t * Any changes of dentry->d_parent must have\n\t * been done with parent->d_lock held, so\n\t * spin_lock() above is enough of a barrier\n\t * for checking if it's still our child.\n\t */\n\tif (unlikely(parent != dentry->d_parent)) {\n\t\tspin_unlock(&parent->d_lock);\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tif (parent != dentry)\n\t\tspin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);\n\telse\n\t\tparent = NULL;\n\treturn parent;\n}"
  },
  {
    "function_name": "__dentry_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "523-568",
    "snippet": "static void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_free",
          "args": [
            "dentry"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "322-337",
          "snippet": "static void dentry_free(struct dentry *dentry)\n{\n\tWARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tif (likely(atomic_dec_and_test(&p->u.count))) {\n\t\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free_external);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* if dentry was never visible to RCU, immediate free is OK */\n\tif (!(dentry->d_flags & DCACHE_RCUACCESS))\n\t\t__d_free(&dentry->d_u.d_rcu);\n\telse\n\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void dentry_free(struct dentry *dentry)\n{\n\tWARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tif (likely(atomic_dec_and_test(&p->u.count))) {\n\t\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free_external);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* if dentry was never visible to RCU, immediate free is OK */\n\tif (!(dentry->d_flags & DCACHE_RCUACCESS))\n\t\t__d_free(&dentry->d_u.d_rcu);\n\telse\n\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "can_free"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry->d_op->d_release",
          "args": [
            "dentry"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_dentry"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_unlink_inode",
          "args": [
            "dentry"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_unlink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "343-361",
          "snippet": "static void dentry_unlink_inode(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_clear_type_and_inode(dentry);\n\thlist_del_init(&dentry->d_u.d_alias);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tif (!inode->i_nlink)\n\t\tfsnotify_inoderemove(inode);\n\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\tdentry->d_op->d_iput(dentry, inode);\n\telse\n\t\tiput(inode);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void dentry_unlink_inode(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_clear_type_and_inode(dentry);\n\thlist_del_init(&dentry->d_u.d_alias);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tif (!inode->i_nlink)\n\t\tfsnotify_inoderemove(inode);\n\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\tdentry->d_op->d_iput(dentry, inode);\n\telse\n\t\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_unlist",
          "args": [
            "dentry",
            "parent"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_unlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "485-521",
          "snippet": "static inline void dentry_unlist(struct dentry *dentry, struct dentry *parent)\n{\n\tstruct dentry *next;\n\t/*\n\t * Inform d_walk() and shrink_dentry_list() that we are no longer\n\t * attached to the dentry tree\n\t */\n\tdentry->d_flags |= DCACHE_DENTRY_KILLED;\n\tif (unlikely(list_empty(&dentry->d_child)))\n\t\treturn;\n\t__list_del_entry(&dentry->d_child);\n\t/*\n\t * Cursors can move around the list of children.  While we'd been\n\t * a normal list member, it didn't matter - ->d_child.next would've\n\t * been updated.  However, from now on it won't be and for the\n\t * things like d_walk() it might end up with a nasty surprise.\n\t * Normally d_walk() doesn't care about cursors moving around -\n\t * ->d_lock on parent prevents that and since a cursor has no children\n\t * of its own, we get through it without ever unlocking the parent.\n\t * There is one exception, though - if we ascend from a child that\n\t * gets killed as soon as we unlock it, the next sibling is found\n\t * using the value left in its ->d_child.next.  And if _that_\n\t * pointed to a cursor, and cursor got moved (e.g. by lseek())\n\t * before d_walk() regains parent->d_lock, we'll end up skipping\n\t * everything the cursor had been moved past.\n\t *\n\t * Solution: make sure that the pointer left behind in ->d_child.next\n\t * points to something that won't be moving around.  I.e. skip the\n\t * cursors.\n\t */\n\twhile (dentry->d_child.next != &parent->d_subdirs) {\n\t\tnext = list_entry(dentry->d_child.next, struct dentry, d_child);\n\t\tif (likely(!(next->d_flags & DCACHE_DENTRY_CURSOR)))\n\t\t\tbreak;\n\t\tdentry->d_child.next = next->d_child.next;\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void dentry_unlist(struct dentry *dentry, struct dentry *parent)\n{\n\tstruct dentry *next;\n\t/*\n\t * Inform d_walk() and shrink_dentry_list() that we are no longer\n\t * attached to the dentry tree\n\t */\n\tdentry->d_flags |= DCACHE_DENTRY_KILLED;\n\tif (unlikely(list_empty(&dentry->d_child)))\n\t\treturn;\n\t__list_del_entry(&dentry->d_child);\n\t/*\n\t * Cursors can move around the list of children.  While we'd been\n\t * a normal list member, it didn't matter - ->d_child.next would've\n\t * been updated.  However, from now on it won't be and for the\n\t * things like d_walk() it might end up with a nasty surprise.\n\t * Normally d_walk() doesn't care about cursors moving around -\n\t * ->d_lock on parent prevents that and since a cursor has no children\n\t * of its own, we get through it without ever unlocking the parent.\n\t * There is one exception, though - if we ascend from a child that\n\t * gets killed as soon as we unlock it, the next sibling is found\n\t * using the value left in its ->d_child.next.  And if _that_\n\t * pointed to a cursor, and cursor got moved (e.g. by lseek())\n\t * before d_walk() regains parent->d_lock, we'll end up skipping\n\t * everything the cursor had been moved past.\n\t *\n\t * Solution: make sure that the pointer left behind in ->d_child.next\n\t * points to something that won't be moving around.  I.e. skip the\n\t * cursors.\n\t */\n\twhile (dentry->d_child.next != &parent->d_subdirs) {\n\t\tnext = list_entry(dentry->d_child.next, struct dentry, d_child);\n\t\tif (likely(!(next->d_flags & DCACHE_DENTRY_CURSOR)))\n\t\t\tbreak;\n\t\tdentry->d_child.next = next->d_child.next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_drop",
          "args": [
            "dentry"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "__d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "467-474",
          "snippet": "void __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_lru_del",
          "args": [
            "dentry"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "d_lru_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "386-392",
          "snippet": "static void d_lru_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_lru_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry->d_op->d_prune",
          "args": [
            "dentry"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_mark_dead",
          "args": [
            "&dentry->d_lockref"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstatic void __dentry_kill(struct dentry *dentry)\n{\n\tstruct dentry *parent = NULL;\n\tbool can_free = true;\n\tif (!IS_ROOT(dentry))\n\t\tparent = dentry->d_parent;\n\n\t/*\n\t * The dentry is now unrecoverably dead to the world.\n\t */\n\tlockref_mark_dead(&dentry->d_lockref);\n\n\t/*\n\t * inform the fs via d_prune that this dentry is about to be\n\t * unhashed and destroyed.\n\t */\n\tif (dentry->d_flags & DCACHE_OP_PRUNE)\n\t\tdentry->d_op->d_prune(dentry);\n\n\tif (dentry->d_flags & DCACHE_LRU_LIST) {\n\t\tif (!(dentry->d_flags & DCACHE_SHRINK_LIST))\n\t\t\td_lru_del(dentry);\n\t}\n\t/* if it was on the hash then remove it */\n\t__d_drop(dentry);\n\tdentry_unlist(dentry, parent);\n\tif (parent)\n\t\tspin_unlock(&parent->d_lock);\n\tif (dentry->d_inode)\n\t\tdentry_unlink_inode(dentry);\n\telse\n\t\tspin_unlock(&dentry->d_lock);\n\tthis_cpu_dec(nr_dentry);\n\tif (dentry->d_op && dentry->d_op->d_release)\n\t\tdentry->d_op->d_release(dentry);\n\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_flags & DCACHE_SHRINK_LIST) {\n\t\tdentry->d_flags |= DCACHE_MAY_FREE;\n\t\tcan_free = false;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\tif (likely(can_free))\n\t\tdentry_free(dentry);\n\tcond_resched();\n}"
  },
  {
    "function_name": "dentry_unlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "485-521",
    "snippet": "static inline void dentry_unlist(struct dentry *dentry, struct dentry *parent)\n{\n\tstruct dentry *next;\n\t/*\n\t * Inform d_walk() and shrink_dentry_list() that we are no longer\n\t * attached to the dentry tree\n\t */\n\tdentry->d_flags |= DCACHE_DENTRY_KILLED;\n\tif (unlikely(list_empty(&dentry->d_child)))\n\t\treturn;\n\t__list_del_entry(&dentry->d_child);\n\t/*\n\t * Cursors can move around the list of children.  While we'd been\n\t * a normal list member, it didn't matter - ->d_child.next would've\n\t * been updated.  However, from now on it won't be and for the\n\t * things like d_walk() it might end up with a nasty surprise.\n\t * Normally d_walk() doesn't care about cursors moving around -\n\t * ->d_lock on parent prevents that and since a cursor has no children\n\t * of its own, we get through it without ever unlocking the parent.\n\t * There is one exception, though - if we ascend from a child that\n\t * gets killed as soon as we unlock it, the next sibling is found\n\t * using the value left in its ->d_child.next.  And if _that_\n\t * pointed to a cursor, and cursor got moved (e.g. by lseek())\n\t * before d_walk() regains parent->d_lock, we'll end up skipping\n\t * everything the cursor had been moved past.\n\t *\n\t * Solution: make sure that the pointer left behind in ->d_child.next\n\t * points to something that won't be moving around.  I.e. skip the\n\t * cursors.\n\t */\n\twhile (dentry->d_child.next != &parent->d_subdirs) {\n\t\tnext = list_entry(dentry->d_child.next, struct dentry, d_child);\n\t\tif (likely(!(next->d_flags & DCACHE_DENTRY_CURSOR)))\n\t\t\tbreak;\n\t\tdentry->d_child.next = next->d_child.next;\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(next->d_flags & DCACHE_DENTRY_CURSOR)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "dentry->d_child.next",
            "structdentry",
            "d_child"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__list_del_entry",
          "args": [
            "&dentry->d_child"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "list_empty(&dentry->d_child)"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&dentry->d_child"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void dentry_unlist(struct dentry *dentry, struct dentry *parent)\n{\n\tstruct dentry *next;\n\t/*\n\t * Inform d_walk() and shrink_dentry_list() that we are no longer\n\t * attached to the dentry tree\n\t */\n\tdentry->d_flags |= DCACHE_DENTRY_KILLED;\n\tif (unlikely(list_empty(&dentry->d_child)))\n\t\treturn;\n\t__list_del_entry(&dentry->d_child);\n\t/*\n\t * Cursors can move around the list of children.  While we'd been\n\t * a normal list member, it didn't matter - ->d_child.next would've\n\t * been updated.  However, from now on it won't be and for the\n\t * things like d_walk() it might end up with a nasty surprise.\n\t * Normally d_walk() doesn't care about cursors moving around -\n\t * ->d_lock on parent prevents that and since a cursor has no children\n\t * of its own, we get through it without ever unlocking the parent.\n\t * There is one exception, though - if we ascend from a child that\n\t * gets killed as soon as we unlock it, the next sibling is found\n\t * using the value left in its ->d_child.next.  And if _that_\n\t * pointed to a cursor, and cursor got moved (e.g. by lseek())\n\t * before d_walk() regains parent->d_lock, we'll end up skipping\n\t * everything the cursor had been moved past.\n\t *\n\t * Solution: make sure that the pointer left behind in ->d_child.next\n\t * points to something that won't be moving around.  I.e. skip the\n\t * cursors.\n\t */\n\twhile (dentry->d_child.next != &parent->d_subdirs) {\n\t\tnext = list_entry(dentry->d_child.next, struct dentry, d_child);\n\t\tif (likely(!(next->d_flags & DCACHE_DENTRY_CURSOR)))\n\t\t\tbreak;\n\t\tdentry->d_child.next = next->d_child.next;\n\t}\n}"
  },
  {
    "function_name": "d_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "477-482",
    "snippet": "void d_drop(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__d_drop",
          "args": [
            "dentry"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "__d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "467-474",
          "snippet": "void __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_drop(struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
  },
  {
    "function_name": "__d_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "467-474",
    "snippet": "void __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_seqcount_invalidate",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "___d_drop",
          "args": [
            "dentry"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "___d_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "449-465",
          "snippet": "static void ___d_drop(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b;\n\t/*\n\t * Hashed dentries are normally on the dentry hashtable,\n\t * with the exception of those newly allocated by\n\t * d_obtain_root, which are always IS_ROOT:\n\t */\n\tif (unlikely(IS_ROOT(dentry)))\n\t\tb = &dentry->d_sb->s_roots;\n\telse\n\t\tb = d_hash(dentry->d_name.hash);\n\n\thlist_bl_lock(b);\n\t__hlist_bl_del(&dentry->d_hash);\n\thlist_bl_unlock(b);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void ___d_drop(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b;\n\t/*\n\t * Hashed dentries are normally on the dentry hashtable,\n\t * with the exception of those newly allocated by\n\t * d_obtain_root, which are always IS_ROOT:\n\t */\n\tif (unlikely(IS_ROOT(dentry)))\n\t\tb = &dentry->d_sb->s_roots;\n\telse\n\t\tb = d_hash(dentry->d_name.hash);\n\n\thlist_bl_lock(b);\n\t__hlist_bl_del(&dentry->d_hash);\n\thlist_bl_unlock(b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid __d_drop(struct dentry *dentry)\n{\n\tif (!d_unhashed(dentry)) {\n\t\t___d_drop(dentry);\n\t\tdentry->d_hash.pprev = NULL;\n\t\twrite_seqcount_invalidate(&dentry->d_seq);\n\t}\n}"
  },
  {
    "function_name": "___d_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "449-465",
    "snippet": "static void ___d_drop(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b;\n\t/*\n\t * Hashed dentries are normally on the dentry hashtable,\n\t * with the exception of those newly allocated by\n\t * d_obtain_root, which are always IS_ROOT:\n\t */\n\tif (unlikely(IS_ROOT(dentry)))\n\t\tb = &dentry->d_sb->s_roots;\n\telse\n\t\tb = d_hash(dentry->d_name.hash);\n\n\thlist_bl_lock(b);\n\t__hlist_bl_del(&dentry->d_hash);\n\thlist_bl_unlock(b);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_bl_unlock",
          "args": [
            "b"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__hlist_bl_del",
          "args": [
            "&dentry->d_hash"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_bl_lock",
          "args": [
            "b"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_hash",
          "args": [
            "dentry->d_name.hash"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "99-102",
          "snippet": "static inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int d_hash_shift",
            "static struct hlist_bl_head *dentry_hashtable"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\n\nstatic inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ROOT(dentry)"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ROOT",
          "args": [
            "dentry"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void ___d_drop(struct dentry *dentry)\n{\n\tstruct hlist_bl_head *b;\n\t/*\n\t * Hashed dentries are normally on the dentry hashtable,\n\t * with the exception of those newly allocated by\n\t * d_obtain_root, which are always IS_ROOT:\n\t */\n\tif (unlikely(IS_ROOT(dentry)))\n\t\tb = &dentry->d_sb->s_roots;\n\telse\n\t\tb = d_hash(dentry->d_name.hash);\n\n\thlist_bl_lock(b);\n\t__hlist_bl_del(&dentry->d_hash);\n\thlist_bl_unlock(b);\n}"
  },
  {
    "function_name": "d_lru_shrink_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "424-430",
    "snippet": "static void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry,\n\t\t\t      struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST;\n\tlist_lru_isolate_move(lru, &dentry->d_lru, list);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_isolate_move",
          "args": [
            "lru",
            "&dentry->d_lru",
            "list"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_FLAG_VERIFY",
          "args": [
            "dentry",
            "DCACHE_LRU_LIST"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry,\n\t\t\t      struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST;\n\tlist_lru_isolate_move(lru, &dentry->d_lru, list);\n}"
  },
  {
    "function_name": "d_lru_isolate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "416-422",
    "snippet": "static void d_lru_isolate(struct list_lru_one *lru, struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tlist_lru_isolate(lru, &dentry->d_lru);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry_unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_lru_isolate",
          "args": [
            "lru",
            "&dentry->d_lru"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_dentry_unused"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_FLAG_VERIFY",
          "args": [
            "dentry",
            "DCACHE_LRU_LIST"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_lru_isolate(struct list_lru_one *lru, struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tlist_lru_isolate(lru, &dentry->d_lru);\n}"
  },
  {
    "function_name": "d_shrink_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "402-408",
    "snippet": "static void d_shrink_add(struct dentry *dentry, struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tlist_add(&dentry->d_lru, list);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry_unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "nr_dentry_unused"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&dentry->d_lru",
            "list"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "D_FLAG_VERIFY",
          "args": [
            "dentry",
            "0"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_shrink_add(struct dentry *dentry, struct list_head *list)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tlist_add(&dentry->d_lru, list);\n\tdentry->d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n}"
  },
  {
    "function_name": "d_shrink_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "394-400",
    "snippet": "static void d_shrink_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tlist_del_init(&dentry->d_lru);\n\tdentry->d_flags &= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tthis_cpu_dec(nr_dentry_unused);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry_unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_dentry_unused"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&dentry->d_lru"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_FLAG_VERIFY",
          "args": [
            "dentry",
            "DCACHE_SHRINK_LIST | DCACHE_LRU_LIST"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_shrink_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tlist_del_init(&dentry->d_lru);\n\tdentry->d_flags &= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);\n\tthis_cpu_dec(nr_dentry_unused);\n}"
  },
  {
    "function_name": "d_lru_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "386-392",
    "snippet": "static void d_lru_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry_unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru)"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_del",
          "args": [
            "&dentry->d_sb->s_dentry_lru",
            "&dentry->d_lru"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_dec",
          "args": [
            "nr_dentry_unused"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_FLAG_VERIFY",
          "args": [
            "dentry",
            "DCACHE_LRU_LIST"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_lru_del(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);\n\tdentry->d_flags &= ~DCACHE_LRU_LIST;\n\tthis_cpu_dec(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}"
  },
  {
    "function_name": "d_lru_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "378-384",
    "snippet": "static void d_lru_add(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tdentry->d_flags |= DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_add(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry_unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!list_lru_add(&dentry->d_sb->s_dentry_lru, &dentry->d_lru)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_add",
          "args": [
            "&dentry->d_sb->s_dentry_lru",
            "&dentry->d_lru"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc",
          "args": [
            "nr_dentry_unused"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "D_FLAG_VERIFY",
          "args": [
            "dentry",
            "0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic void d_lru_add(struct dentry *dentry)\n{\n\tD_FLAG_VERIFY(dentry, 0);\n\tdentry->d_flags |= DCACHE_LRU_LIST;\n\tthis_cpu_inc(nr_dentry_unused);\n\tWARN_ON_ONCE(!list_lru_add(&dentry->d_sb->s_dentry_lru, &dentry->d_lru));\n}"
  },
  {
    "function_name": "dentry_unlink_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "343-361",
    "snippet": "static void dentry_unlink_inode(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_clear_type_and_inode(dentry);\n\thlist_del_init(&dentry->d_u.d_alias);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tif (!inode->i_nlink)\n\t\tfsnotify_inoderemove(inode);\n\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\tdentry->d_op->d_iput(dentry, inode);\n\telse\n\t\tiput(inode);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "1562-1578",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry->d_op->d_iput",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_inoderemove",
          "args": [
            "inode"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_end",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&dentry->d_u.d_alias"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_clear_type_and_inode",
          "args": [
            "dentry"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "__d_clear_type_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "313-320",
          "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_write_seqcount_begin",
          "args": [
            "&dentry->d_seq"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "dentry->d_inode->i_lock"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "dentry->d_lock"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void dentry_unlink_inode(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\traw_write_seqcount_begin(&dentry->d_seq);\n\t__d_clear_type_and_inode(dentry);\n\thlist_del_init(&dentry->d_u.d_alias);\n\traw_write_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n\tspin_unlock(&inode->i_lock);\n\tif (!inode->i_nlink)\n\t\tfsnotify_inoderemove(inode);\n\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\tdentry->d_op->d_iput(dentry, inode);\n\telse\n\t\tiput(inode);\n}"
  },
  {
    "function_name": "dentry_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "322-337",
    "snippet": "static void dentry_free(struct dentry *dentry)\n{\n\tWARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tif (likely(atomic_dec_and_test(&p->u.count))) {\n\t\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free_external);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* if dentry was never visible to RCU, immediate free is OK */\n\tif (!(dentry->d_flags & DCACHE_RCUACCESS))\n\t\t__d_free(&dentry->d_u.d_rcu);\n\telse\n\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&dentry->d_u.d_rcu",
            "__d_free"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__d_free",
          "args": [
            "&dentry->d_u.d_rcu"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "__d_free_external",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "260-265",
          "snippet": "static void __d_free_external(struct rcu_head *head)\n{\n\tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n\tkfree(external_name(dentry));\n\tkmem_cache_free(dentry_cache, dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *dentry_cache"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\n\nstatic void __d_free_external(struct rcu_head *head)\n{\n\tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n\tkfree(external_name(dentry));\n\tkmem_cache_free(dentry_cache, dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&dentry->d_u.d_rcu",
            "__d_free_external"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "atomic_dec_and_test(&p->u.count)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&p->u.count"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "external_name",
          "args": [
            "dentry"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "external_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "248-251",
          "snippet": "static inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dname_external(dentry)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname_external",
          "args": [
            "dentry"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "dname_external",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "267-270",
          "snippet": "static inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!hlist_unhashed(&dentry->d_u.d_alias)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&dentry->d_u.d_alias"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic void dentry_free(struct dentry *dentry)\n{\n\tWARN_ON(!hlist_unhashed(&dentry->d_u.d_alias));\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tif (likely(atomic_dec_and_test(&p->u.count))) {\n\t\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free_external);\n\t\t\treturn;\n\t\t}\n\t}\n\t/* if dentry was never visible to RCU, immediate free is OK */\n\tif (!(dentry->d_flags & DCACHE_RCUACCESS))\n\t\t__d_free(&dentry->d_u.d_rcu);\n\telse\n\t\tcall_rcu(&dentry->d_u.d_rcu, __d_free);\n}"
  },
  {
    "function_name": "__d_clear_type_and_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "313-320",
    "snippet": "static inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "dentry->d_flags",
            "flags"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dentry->d_flags"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_clear_type_and_inode(struct dentry *dentry)\n{\n\tunsigned flags = READ_ONCE(dentry->d_flags);\n\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tWRITE_ONCE(dentry->d_flags, flags);\n\tdentry->d_inode = NULL;\n}"
  },
  {
    "function_name": "__d_set_inode_and_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "300-311",
    "snippet": "static inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "dentry->d_flags",
            "flags"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dentry->d_flags"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline void __d_set_inode_and_type(struct dentry *dentry,\n\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t  unsigned type_flags)\n{\n\tunsigned flags;\n\n\tdentry->d_inode = inode;\n\tflags = READ_ONCE(dentry->d_flags);\n\tflags &= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);\n\tflags |= type_flags;\n\tWRITE_ONCE(dentry->d_flags, flags);\n}"
  },
  {
    "function_name": "release_dentry_name_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "289-297",
    "snippet": "void release_dentry_name_snapshot(struct name_snapshot *name)\n{\n\tif (unlikely(name->name != name->inline_name)) {\n\t\tstruct external_name *p;\n\t\tp = container_of(name->name, struct external_name, name[0]);\n\t\tif (unlikely(atomic_dec_and_test(&p->u.count)))\n\t\t\tkfree_rcu(p, u.head);\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "p",
            "u.head"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_dec_and_test(&p->u.count)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&p->u.count"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "name->name",
            "structexternal_name",
            "name[0]"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "name->name != name->inline_name"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid release_dentry_name_snapshot(struct name_snapshot *name)\n{\n\tif (unlikely(name->name != name->inline_name)) {\n\t\tstruct external_name *p;\n\t\tp = container_of(name->name, struct external_name, name[0]);\n\t\tif (unlikely(atomic_dec_and_test(&p->u.count)))\n\t\t\tkfree_rcu(p, u.head);\n\t}\n}"
  },
  {
    "function_name": "take_dentry_name_snapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "272-286",
    "snippet": "void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tatomic_inc(&p->u.count);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = p->name;\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname,\n\t\t       dentry->d_name.len + 1);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = name->inline_name;\n\t}\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "name->inline_name",
            "dentry->d_iname",
            "dentry->d_name.len + 1"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&p->u.count"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "external_name",
          "args": [
            "dentry"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "external_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "248-251",
          "snippet": "static inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dname_external(dentry)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname_external",
          "args": [
            "dentry"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "dname_external",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "267-270",
          "snippet": "static inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tatomic_inc(&p->u.count);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = p->name;\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname,\n\t\t       dentry->d_name.len + 1);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = name->inline_name;\n\t}\n}"
  },
  {
    "function_name": "dname_external",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "267-270",
    "snippet": "static inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dname_external(const struct dentry *dentry)\n{\n\treturn dentry->d_name.name != dentry->d_iname;\n}"
  },
  {
    "function_name": "__d_free_external",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "260-265",
    "snippet": "static void __d_free_external(struct rcu_head *head)\n{\n\tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n\tkfree(external_name(dentry));\n\tkmem_cache_free(dentry_cache, dentry);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dentry_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dentry_cache",
            "dentry"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "external_name(dentry)"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "external_name",
          "args": [
            "dentry"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "external_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "248-251",
          "snippet": "static inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structdentry",
            "d_u.d_rcu"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\n\nstatic void __d_free_external(struct rcu_head *head)\n{\n\tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n\tkfree(external_name(dentry));\n\tkmem_cache_free(dentry_cache, dentry);\n}"
  },
  {
    "function_name": "__d_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "253-258",
    "snippet": "static void __d_free(struct rcu_head *head)\n{\n\tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n\n\tkmem_cache_free(dentry_cache, dentry); \n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *dentry_cache"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "dentry_cache",
            "dentry"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structdentry",
            "d_u.d_rcu"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic struct kmem_cache *dentry_cache;\n\nstatic void __d_free(struct rcu_head *head)\n{\n\tstruct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);\n\n\tkmem_cache_free(dentry_cache, dentry); \n}"
  },
  {
    "function_name": "external_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "248-251",
    "snippet": "static inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dentry->d_name.name",
            "structexternal_name",
            "name[0]"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline struct external_name *external_name(struct dentry *dentry)\n{\n\treturn container_of(dentry->d_name.name, struct external_name, name[0]);\n}"
  },
  {
    "function_name": "dentry_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "217-238",
    "snippet": "static inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)\n{\n\t/*\n\t * Be careful about RCU walk racing with rename:\n\t * use 'READ_ONCE' to fetch the name pointer.\n\t *\n\t * NOTE! Even if a rename will mean that the length\n\t * was not loaded atomically, we don't care. The\n\t * RCU walk will check the sequence count eventually,\n\t * and catch it. And we won't overrun the buffer,\n\t * because we're reading the name pointer atomically,\n\t * and a dentry name is guaranteed to be properly\n\t * terminated with a NUL byte.\n\t *\n\t * End result: even if 'len' is wrong, we'll exit\n\t * early because the data cannot match (there can\n\t * be no NUL in the ct/tcount data)\n\t */\n\tconst unsigned char *cs = READ_ONCE(dentry->d_name.name);\n\n\treturn dentry_string_cmp(cs, ct, tcount);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dentry_string_cmp",
          "args": [
            "cs",
            "ct",
            "tcount"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_string_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "203-213",
          "snippet": "static inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)\n{\n\tdo {\n\t\tif (*cs != *ct)\n\t\t\treturn 1;\n\t\tcs++;\n\t\tct++;\n\t\ttcount--;\n\t} while (tcount);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)\n{\n\tdo {\n\t\tif (*cs != *ct)\n\t\t\treturn 1;\n\t\tcs++;\n\t\tct++;\n\t\ttcount--;\n\t} while (tcount);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "dentry->d_name.name"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)\n{\n\t/*\n\t * Be careful about RCU walk racing with rename:\n\t * use 'READ_ONCE' to fetch the name pointer.\n\t *\n\t * NOTE! Even if a rename will mean that the length\n\t * was not loaded atomically, we don't care. The\n\t * RCU walk will check the sequence count eventually,\n\t * and catch it. And we won't overrun the buffer,\n\t * because we're reading the name pointer atomically,\n\t * and a dentry name is guaranteed to be properly\n\t * terminated with a NUL byte.\n\t *\n\t * End result: even if 'len' is wrong, we'll exit\n\t * early because the data cannot match (there can\n\t * be no NUL in the ct/tcount data)\n\t */\n\tconst unsigned char *cs = READ_ONCE(dentry->d_name.name);\n\n\treturn dentry_string_cmp(cs, ct, tcount);\n}"
  },
  {
    "function_name": "dentry_string_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "203-213",
    "snippet": "static inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)\n{\n\tdo {\n\t\tif (*cs != *ct)\n\t\t\treturn 1;\n\t\tcs++;\n\t\tct++;\n\t\ttcount--;\n\t} while (tcount);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)\n{\n\tdo {\n\t\tif (*cs != *ct)\n\t\t\treturn 1;\n\t\tcs++;\n\t\tct++;\n\t\ttcount--;\n\t} while (tcount);\n\treturn 0;\n}"
  },
  {
    "function_name": "dentry_string_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "180-199",
    "snippet": "static inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)\n{\n\tunsigned long a,b,mask;\n\n\tfor (;;) {\n\t\ta = read_word_at_a_time(cs);\n\t\tb = load_unaligned_zeropad(ct);\n\t\tif (tcount < sizeof(unsigned long))\n\t\t\tbreak;\n\t\tif (unlikely(a != b))\n\t\t\treturn 1;\n\t\tcs += sizeof(unsigned long);\n\t\tct += sizeof(unsigned long);\n\t\ttcount -= sizeof(unsigned long);\n\t\tif (!tcount)\n\t\t\treturn 0;\n\t}\n\tmask = bytemask_from_count(tcount);\n\treturn unlikely(!!((a ^ b) & mask));\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!!((a ^ b) & mask)"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytemask_from_count",
          "args": [
            "tcount"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "a != b"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_unaligned_zeropad",
          "args": [
            "ct"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_word_at_a_time",
          "args": [
            "cs"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)\n{\n\tunsigned long a,b,mask;\n\n\tfor (;;) {\n\t\ta = read_word_at_a_time(cs);\n\t\tb = load_unaligned_zeropad(ct);\n\t\tif (tcount < sizeof(unsigned long))\n\t\t\tbreak;\n\t\tif (unlikely(a != b))\n\t\t\treturn 1;\n\t\tcs += sizeof(unsigned long);\n\t\tct += sizeof(unsigned long);\n\t\ttcount -= sizeof(unsigned long);\n\t\tif (!tcount)\n\t\t\treturn 0;\n\t}\n\tmask = bytemask_from_count(tcount);\n\treturn unlikely(!!((a ^ b) & mask));\n}"
  },
  {
    "function_name": "proc_nr_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "155-161",
    "snippet": "int proc_nr_dentry(struct ctl_table *table, int write, void __user *buffer,\n\t\t   size_t *lenp, loff_t *ppos)\n{\n\tdentry_stat.nr_dentry = get_nr_dentry();\n\tdentry_stat.nr_unused = get_nr_dentry_unused();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct dentry_stat_t dentry_stat = {\n\t.age_limit = 45,\n};",
      "static DEFINE_PER_CPU(long, nr_dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_doulongvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_dentry_unused",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "get_nr_dentry_unused",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "146-153",
          "snippet": "static long get_nr_dentry_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic long get_nr_dentry_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry_stat_t dentry_stat = {\n\t.age_limit = 45,\n};\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nint proc_nr_dentry(struct ctl_table *table, int write, void __user *buffer,\n\t\t   size_t *lenp, loff_t *ppos)\n{\n\tdentry_stat.nr_dentry = get_nr_dentry();\n\tdentry_stat.nr_unused = get_nr_dentry_unused();\n\treturn proc_doulongvec_minmax(table, write, buffer, lenp, ppos);\n}"
  },
  {
    "function_name": "get_nr_dentry_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "146-153",
    "snippet": "static long get_nr_dentry_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry_unused);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nstatic long get_nr_dentry_unused(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry_unused, i);\n\treturn sum < 0 ? 0 : sum;\n}"
  },
  {
    "function_name": "get_nr_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "137-144",
    "snippet": "static long get_nr_dentry(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry, i);\n\treturn sum < 0 ? 0 : sum;\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(long, nr_dentry);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry);\n\nstatic long get_nr_dentry(void)\n{\n\tint i;\n\tlong sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += per_cpu(nr_dentry, i);\n\treturn sum < 0 ? 0 : sum;\n}"
  },
  {
    "function_name": "in_lookup_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "107-112",
    "snippet": "static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent,\n\t\t\t\t\tunsigned int hash)\n{\n\thash += (unsigned long) parent / L1_CACHE_BYTES;\n\treturn in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [
      "#define IN_LOOKUP_SHIFT 10"
    ],
    "globals_used": [
      "static struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_32",
          "args": [
            "hash",
            "IN_LOOKUP_SHIFT"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n#define IN_LOOKUP_SHIFT 10\n\nstatic struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];\n\nstatic inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent,\n\t\t\t\t\tunsigned int hash)\n{\n\thash += (unsigned long) parent / L1_CACHE_BYTES;\n\treturn in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);\n}"
  },
  {
    "function_name": "d_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
    "lines": "99-102",
    "snippet": "static inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}",
    "includes": [
      "#include <asm/word-at-a-time.h>",
      "#include \"mount.h\"",
      "#include \"internal.h\"",
      "#include <linux/list_lru.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/memblock.h>",
      "#include <linux/seqlock.h>",
      "#include <linux/security.h>",
      "#include <linux/export.h>",
      "#include <linux/cache.h>",
      "#include <linux/hash.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/fs.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int d_hash_shift",
      "static struct hlist_bl_head *dentry_hashtable"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic unsigned int d_hash_shift;\nstatic struct hlist_bl_head *dentry_hashtable;\n\nstatic inline struct hlist_bl_head *d_hash(unsigned int hash)\n{\n\treturn dentry_hashtable + (hash >> d_hash_shift);\n}"
  }
]