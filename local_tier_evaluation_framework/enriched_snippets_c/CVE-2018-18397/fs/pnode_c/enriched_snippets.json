[
  {
    "function_name": "propagate_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "542-609",
    "snippet": "int propagate_umount(struct list_head *list)\n{\n\tstruct mount *mnt;\n\tLIST_HEAD(to_restore);\n\tLIST_HEAD(to_umount);\n\tLIST_HEAD(visited);\n\n\t/* Find candidates for unmounting */\n\tlist_for_each_entry_reverse(mnt, list, mnt_list) {\n\t\tstruct mount *parent = mnt->mnt_parent;\n\t\tstruct mount *m;\n\n\t\t/*\n\t\t * If this mount has already been visited it is known that it's\n\t\t * entire peer group and all of their slaves in the propagation\n\t\t * tree for the mountpoint has already been visited and there is\n\t\t * no need to visit them again.\n\t\t */\n\t\tif (!list_empty(&mnt->mnt_umounting))\n\t\t\tcontinue;\n\n\t\tlist_add_tail(&mnt->mnt_umounting, &visited);\n\t\tfor (m = propagation_next(parent, parent); m;\n\t\t     m = propagation_next(m, parent)) {\n\t\t\tstruct mount *child = __lookup_mnt(&m->mnt,\n\t\t\t\t\t\t\t   mnt->mnt_mountpoint);\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&child->mnt_umounting)) {\n\t\t\t\t/*\n\t\t\t\t * If the child has already been visited it is\n\t\t\t\t * know that it's entire peer group and all of\n\t\t\t\t * their slaves in the propgation tree for the\n\t\t\t\t * mountpoint has already been visited and there\n\t\t\t\t * is no need to visit this subtree again.\n\t\t\t\t */\n\t\t\t\tm = skip_propagation_subtree(m, parent);\n\t\t\t\tcontinue;\n\t\t\t} else if (child->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\t\t/*\n\t\t\t\t * We have come accross an partially unmounted\n\t\t\t\t * mount in list that has not been visited yet.\n\t\t\t\t * Remember it has been visited and continue\n\t\t\t\t * about our merry way.\n\t\t\t\t */\n\t\t\t\tlist_add_tail(&child->mnt_umounting, &visited);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check the child and parents while progress is made */\n\t\t\twhile (__propagate_umount(child,\n\t\t\t\t\t\t  &to_umount, &to_restore)) {\n\t\t\t\t/* Is the parent a umount candidate? */\n\t\t\t\tchild = child->mnt_parent;\n\t\t\t\tif (list_empty(&child->mnt_umounting))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tumount_list(&to_umount, &to_restore);\n\trestore_mounts(&to_restore);\n\tcleanup_umount_visitations(&visited);\n\tlist_splice_tail(&to_umount, list);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_splice_tail",
          "args": [
            "&to_umount",
            "list"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cleanup_umount_visitations",
          "args": [
            "&visited"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_umount_visitations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "526-533",
          "snippet": "static void cleanup_umount_visitations(struct list_head *visited)\n{\n\twhile (!list_empty(visited)) {\n\t\tstruct mount *mnt =\n\t\t\tlist_first_entry(visited, struct mount, mnt_umounting);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic void cleanup_umount_visitations(struct list_head *visited)\n{\n\twhile (!list_empty(visited)) {\n\t\tstruct mount *mnt =\n\t\t\tlist_first_entry(visited, struct mount, mnt_umounting);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_mounts",
          "args": [
            "&to_restore"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "restore_mounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "503-524",
          "snippet": "static void restore_mounts(struct list_head *to_restore)\n{\n\t/* Restore mounts to a clean working state */\n\twhile (!list_empty(to_restore)) {\n\t\tstruct mount *mnt, *parent;\n\t\tstruct mountpoint *mp;\n\n\t\tmnt = list_first_entry(to_restore, struct mount, mnt_umounting);\n\t\tCLEAR_MNT_MARK(mnt);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\n\t\t/* Should this mount be reparented? */\n\t\tmp = mnt->mnt_mp;\n\t\tparent = mnt->mnt_parent;\n\t\twhile (parent->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tmp = parent->mnt_mp;\n\t\t\tparent = parent->mnt_parent;\n\t\t}\n\t\tif (parent != mnt->mnt_parent)\n\t\t\tmnt_change_mountpoint(parent, mp, mnt);\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mountpoint *mp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mountpoint *mp;\n\nstatic void restore_mounts(struct list_head *to_restore)\n{\n\t/* Restore mounts to a clean working state */\n\twhile (!list_empty(to_restore)) {\n\t\tstruct mount *mnt, *parent;\n\t\tstruct mountpoint *mp;\n\n\t\tmnt = list_first_entry(to_restore, struct mount, mnt_umounting);\n\t\tCLEAR_MNT_MARK(mnt);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\n\t\t/* Should this mount be reparented? */\n\t\tmp = mnt->mnt_mp;\n\t\tparent = mnt->mnt_parent;\n\t\twhile (parent->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tmp = parent->mnt_mp;\n\t\t\tparent = parent->mnt_parent;\n\t\t}\n\t\tif (parent != mnt->mnt_parent)\n\t\t\tmnt_change_mountpoint(parent, mp, mnt);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount_list",
          "args": [
            "&to_umount",
            "&to_restore"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "umount_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "488-501",
          "snippet": "static void umount_list(struct list_head *to_umount,\n\t\t\tstruct list_head *to_restore)\n{\n\tstruct mount *mnt, *child, *tmp;\n\tlist_for_each_entry(mnt, to_umount, mnt_list) {\n\t\tlist_for_each_entry_safe(child, tmp, &mnt->mnt_mounts, mnt_child) {\n\t\t\t/* topper? */\n\t\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\t\tlist_move_tail(&child->mnt_umounting, to_restore);\n\t\t\telse\n\t\t\t\tumount_one(child, to_umount);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic void umount_list(struct list_head *to_umount,\n\t\t\tstruct list_head *to_restore)\n{\n\tstruct mount *mnt, *child, *tmp;\n\tlist_for_each_entry(mnt, to_umount, mnt_list) {\n\t\tlist_for_each_entry_safe(child, tmp, &mnt->mnt_mounts, mnt_child) {\n\t\t\t/* topper? */\n\t\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\t\tlist_move_tail(&child->mnt_umounting, to_restore);\n\t\t\telse\n\t\t\t\tumount_one(child, to_umount);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child->mnt_umounting"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__propagate_umount",
          "args": [
            "child",
            "&to_umount",
            "&to_restore"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__propagate_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "447-486",
          "snippet": "static bool __propagate_umount(struct mount *mnt,\n\t\t\t       struct list_head *to_umount,\n\t\t\t       struct list_head *to_restore)\n{\n\tbool progress = false;\n\tstruct mount *child;\n\n\t/*\n\t * The state of the parent won't change if this mount is\n\t * already unmounted or marked as without children.\n\t */\n\tif (mnt->mnt.mnt_flags & (MNT_UMOUNT | MNT_MARKED))\n\t\tgoto out;\n\n\t/* Verify topper is the only grandchild that has not been\n\t * speculatively unmounted.\n\t */\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\tcontinue;\n\t\tif (!list_empty(&child->mnt_umounting) && IS_MNT_MARKED(child))\n\t\t\tcontinue;\n\t\t/* Found a mounted child */\n\t\tgoto children;\n\t}\n\n\t/* Mark mounts that can be unmounted if not locked */\n\tSET_MNT_MARK(mnt);\n\tprogress = true;\n\n\t/* If a mount is without children and not locked umount it. */\n\tif (!IS_MNT_LOCKED(mnt)) {\n\t\tumount_one(mnt, to_umount);\n\t} else {\nchildren:\n\t\tlist_move_tail(&mnt->mnt_umounting, to_restore);\n\t}\nout:\n\treturn progress;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic bool __propagate_umount(struct mount *mnt,\n\t\t\t       struct list_head *to_umount,\n\t\t\t       struct list_head *to_restore)\n{\n\tbool progress = false;\n\tstruct mount *child;\n\n\t/*\n\t * The state of the parent won't change if this mount is\n\t * already unmounted or marked as without children.\n\t */\n\tif (mnt->mnt.mnt_flags & (MNT_UMOUNT | MNT_MARKED))\n\t\tgoto out;\n\n\t/* Verify topper is the only grandchild that has not been\n\t * speculatively unmounted.\n\t */\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\tcontinue;\n\t\tif (!list_empty(&child->mnt_umounting) && IS_MNT_MARKED(child))\n\t\t\tcontinue;\n\t\t/* Found a mounted child */\n\t\tgoto children;\n\t}\n\n\t/* Mark mounts that can be unmounted if not locked */\n\tSET_MNT_MARK(mnt);\n\tprogress = true;\n\n\t/* If a mount is without children and not locked umount it. */\n\tif (!IS_MNT_LOCKED(mnt)) {\n\t\tumount_one(mnt, to_umount);\n\t} else {\nchildren:\n\t\tlist_move_tail(&mnt->mnt_umounting, to_restore);\n\t}\nout:\n\treturn progress;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&child->mnt_umounting",
            "&visited"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_propagation_subtree",
          "args": [
            "m",
            "parent"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "skip_propagation_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "170-181",
          "snippet": "static struct mount *skip_propagation_subtree(struct mount *m,\n\t\t\t\t\t\tstruct mount *origin)\n{\n\t/*\n\t * Advance m such that propagation_next will not return\n\t * the slaves of m.\n\t */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\tm = last_slave(m);\n\n\treturn m;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *skip_propagation_subtree(struct mount *m,\n\t\t\t\t\t\tstruct mount *origin)\n{\n\t/*\n\t * Advance m such that propagation_next will not return\n\t * the slaves of m.\n\t */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\tm = last_slave(m);\n\n\treturn m;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_mnt",
          "args": [
            "&m->mnt",
            "mnt->mnt_mountpoint"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "613-622",
          "snippet": "struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct hlist_head *head = m_hash(mnt, dentry);\n\tstruct mount *p;\n\n\thlist_for_each_entry_rcu(p, head, mnt_hash)\n\t\tif (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)\n\t\t\treturn p;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct hlist_head *head = m_hash(mnt, dentry);\n\tstruct mount *p;\n\n\thlist_for_each_entry_rcu(p, head, mnt_hash)\n\t\tif (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)\n\t\t\treturn p;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagation_next",
          "args": [
            "m",
            "parent"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "propagation_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "149-168",
          "snippet": "static struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&mnt->mnt_umounting",
            "&visited"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "mnt",
            "list",
            "mnt_list"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "visited"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "to_umount"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "to_restore"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct hlist_head *list;\n\nint propagate_umount(struct list_head *list)\n{\n\tstruct mount *mnt;\n\tLIST_HEAD(to_restore);\n\tLIST_HEAD(to_umount);\n\tLIST_HEAD(visited);\n\n\t/* Find candidates for unmounting */\n\tlist_for_each_entry_reverse(mnt, list, mnt_list) {\n\t\tstruct mount *parent = mnt->mnt_parent;\n\t\tstruct mount *m;\n\n\t\t/*\n\t\t * If this mount has already been visited it is known that it's\n\t\t * entire peer group and all of their slaves in the propagation\n\t\t * tree for the mountpoint has already been visited and there is\n\t\t * no need to visit them again.\n\t\t */\n\t\tif (!list_empty(&mnt->mnt_umounting))\n\t\t\tcontinue;\n\n\t\tlist_add_tail(&mnt->mnt_umounting, &visited);\n\t\tfor (m = propagation_next(parent, parent); m;\n\t\t     m = propagation_next(m, parent)) {\n\t\t\tstruct mount *child = __lookup_mnt(&m->mnt,\n\t\t\t\t\t\t\t   mnt->mnt_mountpoint);\n\t\t\tif (!child)\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&child->mnt_umounting)) {\n\t\t\t\t/*\n\t\t\t\t * If the child has already been visited it is\n\t\t\t\t * know that it's entire peer group and all of\n\t\t\t\t * their slaves in the propgation tree for the\n\t\t\t\t * mountpoint has already been visited and there\n\t\t\t\t * is no need to visit this subtree again.\n\t\t\t\t */\n\t\t\t\tm = skip_propagation_subtree(m, parent);\n\t\t\t\tcontinue;\n\t\t\t} else if (child->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\t\t/*\n\t\t\t\t * We have come accross an partially unmounted\n\t\t\t\t * mount in list that has not been visited yet.\n\t\t\t\t * Remember it has been visited and continue\n\t\t\t\t * about our merry way.\n\t\t\t\t */\n\t\t\t\tlist_add_tail(&child->mnt_umounting, &visited);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check the child and parents while progress is made */\n\t\t\twhile (__propagate_umount(child,\n\t\t\t\t\t\t  &to_umount, &to_restore)) {\n\t\t\t\t/* Is the parent a umount candidate? */\n\t\t\t\tchild = child->mnt_parent;\n\t\t\t\tif (list_empty(&child->mnt_umounting))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tumount_list(&to_umount, &to_restore);\n\trestore_mounts(&to_restore);\n\tcleanup_umount_visitations(&visited);\n\tlist_splice_tail(&to_umount, list);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cleanup_umount_visitations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "526-533",
    "snippet": "static void cleanup_umount_visitations(struct list_head *visited)\n{\n\twhile (!list_empty(visited)) {\n\t\tstruct mount *mnt =\n\t\t\tlist_first_entry(visited, struct mount, mnt_umounting);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\t}\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mnt->mnt_umounting"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "visited",
            "structmount",
            "mnt_umounting"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "visited"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic void cleanup_umount_visitations(struct list_head *visited)\n{\n\twhile (!list_empty(visited)) {\n\t\tstruct mount *mnt =\n\t\t\tlist_first_entry(visited, struct mount, mnt_umounting);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\t}\n}"
  },
  {
    "function_name": "restore_mounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "503-524",
    "snippet": "static void restore_mounts(struct list_head *to_restore)\n{\n\t/* Restore mounts to a clean working state */\n\twhile (!list_empty(to_restore)) {\n\t\tstruct mount *mnt, *parent;\n\t\tstruct mountpoint *mp;\n\n\t\tmnt = list_first_entry(to_restore, struct mount, mnt_umounting);\n\t\tCLEAR_MNT_MARK(mnt);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\n\t\t/* Should this mount be reparented? */\n\t\tmp = mnt->mnt_mp;\n\t\tparent = mnt->mnt_parent;\n\t\twhile (parent->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tmp = parent->mnt_mp;\n\t\t\tparent = parent->mnt_parent;\n\t\t}\n\t\tif (parent != mnt->mnt_parent)\n\t\t\tmnt_change_mountpoint(parent, mp, mnt);\n\t}\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mountpoint *mp;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_change_mountpoint",
          "args": [
            "parent",
            "mp",
            "mnt"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_change_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "862-892",
          "snippet": "void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt)\n{\n\tstruct mountpoint *old_mp = mnt->mnt_mp;\n\tstruct dentry *old_mountpoint = mnt->mnt_mountpoint;\n\tstruct mount *old_parent = mnt->mnt_parent;\n\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init(&mnt->mnt_mp_list);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\n\tattach_mnt(mnt, parent, mp);\n\n\tput_mountpoint(old_mp);\n\n\t/*\n\t * Safely avoid even the suggestion this code might sleep or\n\t * lock the mount hash by taking advantage of the knowledge that\n\t * mnt_change_mountpoint will not release the final reference\n\t * to a mountpoint.\n\t *\n\t * During mounting, the mount passed in as the parent mount will\n\t * continue to use the old mountpoint and during unmounting, the\n\t * old mountpoint will continue to exist until namespace_unlock,\n\t * which happens well after mnt_change_mountpoint.\n\t */\n\tspin_lock(&old_mountpoint->d_lock);\n\told_mountpoint->d_lockref.count--;\n\tspin_unlock(&old_mountpoint->d_lock);\n\n\tmnt_add_count(old_parent, -1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt)\n{\n\tstruct mountpoint *old_mp = mnt->mnt_mp;\n\tstruct dentry *old_mountpoint = mnt->mnt_mountpoint;\n\tstruct mount *old_parent = mnt->mnt_parent;\n\n\tlist_del_init(&mnt->mnt_child);\n\thlist_del_init(&mnt->mnt_mp_list);\n\thlist_del_init_rcu(&mnt->mnt_hash);\n\n\tattach_mnt(mnt, parent, mp);\n\n\tput_mountpoint(old_mp);\n\n\t/*\n\t * Safely avoid even the suggestion this code might sleep or\n\t * lock the mount hash by taking advantage of the knowledge that\n\t * mnt_change_mountpoint will not release the final reference\n\t * to a mountpoint.\n\t *\n\t * During mounting, the mount passed in as the parent mount will\n\t * continue to use the old mountpoint and during unmounting, the\n\t * old mountpoint will continue to exist until namespace_unlock,\n\t * which happens well after mnt_change_mountpoint.\n\t */\n\tspin_lock(&old_mountpoint->d_lock);\n\told_mountpoint->d_lockref.count--;\n\tspin_unlock(&old_mountpoint->d_lock);\n\n\tmnt_add_count(old_parent, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mnt->mnt_umounting"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_MNT_MARK",
          "args": [
            "mnt"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "to_restore",
            "structmount",
            "mnt_umounting"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "to_restore"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mountpoint *mp;\n\nstatic void restore_mounts(struct list_head *to_restore)\n{\n\t/* Restore mounts to a clean working state */\n\twhile (!list_empty(to_restore)) {\n\t\tstruct mount *mnt, *parent;\n\t\tstruct mountpoint *mp;\n\n\t\tmnt = list_first_entry(to_restore, struct mount, mnt_umounting);\n\t\tCLEAR_MNT_MARK(mnt);\n\t\tlist_del_init(&mnt->mnt_umounting);\n\n\t\t/* Should this mount be reparented? */\n\t\tmp = mnt->mnt_mp;\n\t\tparent = mnt->mnt_parent;\n\t\twhile (parent->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tmp = parent->mnt_mp;\n\t\t\tparent = parent->mnt_parent;\n\t\t}\n\t\tif (parent != mnt->mnt_parent)\n\t\t\tmnt_change_mountpoint(parent, mp, mnt);\n\t}\n}"
  },
  {
    "function_name": "umount_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "488-501",
    "snippet": "static void umount_list(struct list_head *to_umount,\n\t\t\tstruct list_head *to_restore)\n{\n\tstruct mount *mnt, *child, *tmp;\n\tlist_for_each_entry(mnt, to_umount, mnt_list) {\n\t\tlist_for_each_entry_safe(child, tmp, &mnt->mnt_mounts, mnt_child) {\n\t\t\t/* topper? */\n\t\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\t\tlist_move_tail(&child->mnt_umounting, to_restore);\n\t\t\telse\n\t\t\t\tumount_one(child, to_umount);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umount_one",
          "args": [
            "child",
            "to_umount"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "umount_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "434-441",
          "snippet": "static void umount_one(struct mount *mnt, struct list_head *to_umount)\n{\n\tCLEAR_MNT_MARK(mnt);\n\tmnt->mnt.mnt_flags |= MNT_UMOUNT;\n\tlist_del_init(&mnt->mnt_child);\n\tlist_del_init(&mnt->mnt_umounting);\n\tlist_move_tail(&mnt->mnt_list, to_umount);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic void umount_one(struct mount *mnt, struct list_head *to_umount)\n{\n\tCLEAR_MNT_MARK(mnt);\n\tmnt->mnt.mnt_flags |= MNT_UMOUNT;\n\tlist_del_init(&mnt->mnt_child);\n\tlist_del_init(&mnt->mnt_umounting);\n\tlist_move_tail(&mnt->mnt_list, to_umount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&child->mnt_umounting",
            "to_restore"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "child",
            "tmp",
            "&mnt->mnt_mounts",
            "mnt_child"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mnt",
            "to_umount",
            "mnt_list"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic void umount_list(struct list_head *to_umount,\n\t\t\tstruct list_head *to_restore)\n{\n\tstruct mount *mnt, *child, *tmp;\n\tlist_for_each_entry(mnt, to_umount, mnt_list) {\n\t\tlist_for_each_entry_safe(child, tmp, &mnt->mnt_mounts, mnt_child) {\n\t\t\t/* topper? */\n\t\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\t\tlist_move_tail(&child->mnt_umounting, to_restore);\n\t\t\telse\n\t\t\t\tumount_one(child, to_umount);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "__propagate_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "447-486",
    "snippet": "static bool __propagate_umount(struct mount *mnt,\n\t\t\t       struct list_head *to_umount,\n\t\t\t       struct list_head *to_restore)\n{\n\tbool progress = false;\n\tstruct mount *child;\n\n\t/*\n\t * The state of the parent won't change if this mount is\n\t * already unmounted or marked as without children.\n\t */\n\tif (mnt->mnt.mnt_flags & (MNT_UMOUNT | MNT_MARKED))\n\t\tgoto out;\n\n\t/* Verify topper is the only grandchild that has not been\n\t * speculatively unmounted.\n\t */\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\tcontinue;\n\t\tif (!list_empty(&child->mnt_umounting) && IS_MNT_MARKED(child))\n\t\t\tcontinue;\n\t\t/* Found a mounted child */\n\t\tgoto children;\n\t}\n\n\t/* Mark mounts that can be unmounted if not locked */\n\tSET_MNT_MARK(mnt);\n\tprogress = true;\n\n\t/* If a mount is without children and not locked umount it. */\n\tif (!IS_MNT_LOCKED(mnt)) {\n\t\tumount_one(mnt, to_umount);\n\t} else {\nchildren:\n\t\tlist_move_tail(&mnt->mnt_umounting, to_restore);\n\t}\nout:\n\treturn progress;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&mnt->mnt_umounting",
            "to_restore"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount_one",
          "args": [
            "mnt",
            "to_umount"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "umount_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "434-441",
          "snippet": "static void umount_one(struct mount *mnt, struct list_head *to_umount)\n{\n\tCLEAR_MNT_MARK(mnt);\n\tmnt->mnt.mnt_flags |= MNT_UMOUNT;\n\tlist_del_init(&mnt->mnt_child);\n\tlist_del_init(&mnt->mnt_umounting);\n\tlist_move_tail(&mnt->mnt_list, to_umount);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic void umount_one(struct mount *mnt, struct list_head *to_umount)\n{\n\tCLEAR_MNT_MARK(mnt);\n\tmnt->mnt.mnt_flags |= MNT_UMOUNT;\n\tlist_del_init(&mnt->mnt_child);\n\tlist_del_init(&mnt->mnt_umounting);\n\tlist_move_tail(&mnt->mnt_list, to_umount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_LOCKED",
          "args": [
            "mnt"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_MNT_MARK",
          "args": [
            "mnt"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MNT_MARKED",
          "args": [
            "child"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child->mnt_umounting"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&mnt->mnt_mounts",
            "mnt_child"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic bool __propagate_umount(struct mount *mnt,\n\t\t\t       struct list_head *to_umount,\n\t\t\t       struct list_head *to_restore)\n{\n\tbool progress = false;\n\tstruct mount *child;\n\n\t/*\n\t * The state of the parent won't change if this mount is\n\t * already unmounted or marked as without children.\n\t */\n\tif (mnt->mnt.mnt_flags & (MNT_UMOUNT | MNT_MARKED))\n\t\tgoto out;\n\n\t/* Verify topper is the only grandchild that has not been\n\t * speculatively unmounted.\n\t */\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (child->mnt_mountpoint == mnt->mnt.mnt_root)\n\t\t\tcontinue;\n\t\tif (!list_empty(&child->mnt_umounting) && IS_MNT_MARKED(child))\n\t\t\tcontinue;\n\t\t/* Found a mounted child */\n\t\tgoto children;\n\t}\n\n\t/* Mark mounts that can be unmounted if not locked */\n\tSET_MNT_MARK(mnt);\n\tprogress = true;\n\n\t/* If a mount is without children and not locked umount it. */\n\tif (!IS_MNT_LOCKED(mnt)) {\n\t\tumount_one(mnt, to_umount);\n\t} else {\nchildren:\n\t\tlist_move_tail(&mnt->mnt_umounting, to_restore);\n\t}\nout:\n\treturn progress;\n}"
  },
  {
    "function_name": "umount_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "434-441",
    "snippet": "static void umount_one(struct mount *mnt, struct list_head *to_umount)\n{\n\tCLEAR_MNT_MARK(mnt);\n\tmnt->mnt.mnt_flags |= MNT_UMOUNT;\n\tlist_del_init(&mnt->mnt_child);\n\tlist_del_init(&mnt->mnt_umounting);\n\tlist_move_tail(&mnt->mnt_list, to_umount);\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&mnt->mnt_list",
            "to_umount"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mnt->mnt_umounting"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mnt->mnt_child"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_MNT_MARK",
          "args": [
            "mnt"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic void umount_one(struct mount *mnt, struct list_head *to_umount)\n{\n\tCLEAR_MNT_MARK(mnt);\n\tmnt->mnt.mnt_flags |= MNT_UMOUNT;\n\tlist_del_init(&mnt->mnt_child);\n\tlist_del_init(&mnt->mnt_umounting);\n\tlist_move_tail(&mnt->mnt_list, to_umount);\n}"
  },
  {
    "function_name": "propagate_mount_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "419-432",
    "snippet": "void propagate_mount_unlock(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m, *child;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child)\n\t\t\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\t}\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__lookup_mnt",
          "args": [
            "&m->mnt",
            "mnt->mnt_mountpoint"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "613-622",
          "snippet": "struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct hlist_head *head = m_hash(mnt, dentry);\n\tstruct mount *p;\n\n\thlist_for_each_entry_rcu(p, head, mnt_hash)\n\t\tif (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)\n\t\t\treturn p;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct hlist_head *head = m_hash(mnt, dentry);\n\tstruct mount *p;\n\n\thlist_for_each_entry_rcu(p, head, mnt_hash)\n\t\tif (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)\n\t\t\treturn p;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagation_next",
          "args": [
            "m",
            "parent"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "propagation_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "149-168",
          "snippet": "static struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "parent == mnt"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nvoid propagate_mount_unlock(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m, *child;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child)\n\t\t\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\t}\n}"
  },
  {
    "function_name": "propagate_mount_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "376-412",
    "snippet": "int propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child, *topper;\n\tstruct mount *parent = mnt->mnt_parent;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tint count = 1;\n\t\tchild = __lookup_mnt(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (!child)\n\t\t\tcontinue;\n\n\t\t/* Is there exactly one mount on the child that covers\n\t\t * it completely whose reference should be ignored?\n\t\t */\n\t\ttopper = find_topper(child);\n\t\tif (topper)\n\t\t\tcount += 1;\n\t\telse if (!list_empty(&child->mnt_mounts))\n\t\t\tcontinue;\n\n\t\tif (do_refcount_check(child, count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_refcount_check",
          "args": [
            "child",
            "count"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "do_refcount_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "361-364",
          "snippet": "static inline int do_refcount_check(struct mount *mnt, int count)\n{\n\treturn mnt_get_count(mnt) > count;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline int do_refcount_check(struct mount *mnt, int count)\n{\n\treturn mnt_get_count(mnt) > count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child->mnt_mounts"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_topper",
          "args": [
            "child"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "find_topper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "343-356",
          "snippet": "static struct mount *find_topper(struct mount *mnt)\n{\n\t/* If there is exactly one mount covering mnt completely return it. */\n\tstruct mount *child;\n\n\tif (!list_is_singular(&mnt->mnt_mounts))\n\t\treturn NULL;\n\n\tchild = list_first_entry(&mnt->mnt_mounts, struct mount, mnt_child);\n\tif (child->mnt_mountpoint != mnt->mnt.mnt_root)\n\t\treturn NULL;\n\n\treturn child;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *find_topper(struct mount *mnt)\n{\n\t/* If there is exactly one mount covering mnt completely return it. */\n\tstruct mount *child;\n\n\tif (!list_is_singular(&mnt->mnt_mounts))\n\t\treturn NULL;\n\n\tchild = list_first_entry(&mnt->mnt_mounts, struct mount, mnt_child);\n\tif (child->mnt_mountpoint != mnt->mnt.mnt_root)\n\t\treturn NULL;\n\n\treturn child;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__lookup_mnt",
          "args": [
            "&m->mnt",
            "mnt->mnt_mountpoint"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "__lookup_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "613-622",
          "snippet": "struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct hlist_head *head = m_hash(mnt, dentry);\n\tstruct mount *p;\n\n\thlist_for_each_entry_rcu(p, head, mnt_hash)\n\t\tif (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)\n\t\t\treturn p;\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)\n{\n\tstruct hlist_head *head = m_hash(mnt, dentry);\n\tstruct mount *p;\n\n\thlist_for_each_entry_rcu(p, head, mnt_hash)\n\t\tif (&p->mnt_parent->mnt == mnt && p->mnt_mountpoint == dentry)\n\t\t\treturn p;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagation_next",
          "args": [
            "m",
            "parent"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "propagation_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "149-168",
          "snippet": "static struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint propagate_mount_busy(struct mount *mnt, int refcnt)\n{\n\tstruct mount *m, *child, *topper;\n\tstruct mount *parent = mnt->mnt_parent;\n\n\tif (mnt == parent)\n\t\treturn do_refcount_check(mnt, refcnt);\n\n\t/*\n\t * quickly check if the current mount can be unmounted.\n\t * If not, we don't have to go checking for all other\n\t * mounts\n\t */\n\tif (!list_empty(&mnt->mnt_mounts) || do_refcount_check(mnt, refcnt))\n\t\treturn 1;\n\n\tfor (m = propagation_next(parent, parent); m;\n\t     \t\tm = propagation_next(m, parent)) {\n\t\tint count = 1;\n\t\tchild = __lookup_mnt(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (!child)\n\t\t\tcontinue;\n\n\t\t/* Is there exactly one mount on the child that covers\n\t\t * it completely whose reference should be ignored?\n\t\t */\n\t\ttopper = find_topper(child);\n\t\tif (topper)\n\t\t\tcount += 1;\n\t\telse if (!list_empty(&child->mnt_mounts))\n\t\t\tcontinue;\n\n\t\tif (do_refcount_check(child, count))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_refcount_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "361-364",
    "snippet": "static inline int do_refcount_check(struct mount *mnt, int count)\n{\n\treturn mnt_get_count(mnt) > count;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_get_count",
          "args": [
            "mnt"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_get_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "153-167",
          "snippet": "unsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nunsigned int mnt_get_count(struct mount *mnt)\n{\n#ifdef CONFIG_SMP\n\tunsigned int count = 0;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tcount += per_cpu_ptr(mnt->mnt_pcp, cpu)->mnt_count;\n\t}\n\n\treturn count;\n#else\n\treturn mnt->mnt_count;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline int do_refcount_check(struct mount *mnt, int count)\n{\n\treturn mnt_get_count(mnt) > count;\n}"
  },
  {
    "function_name": "find_topper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "343-356",
    "snippet": "static struct mount *find_topper(struct mount *mnt)\n{\n\t/* If there is exactly one mount covering mnt completely return it. */\n\tstruct mount *child;\n\n\tif (!list_is_singular(&mnt->mnt_mounts))\n\t\treturn NULL;\n\n\tchild = list_first_entry(&mnt->mnt_mounts, struct mount, mnt_child);\n\tif (child->mnt_mountpoint != mnt->mnt.mnt_root)\n\t\treturn NULL;\n\n\treturn child;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&mnt->mnt_mounts",
            "structmount",
            "mnt_child"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_singular",
          "args": [
            "&mnt->mnt_mounts"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *find_topper(struct mount *mnt)\n{\n\t/* If there is exactly one mount covering mnt completely return it. */\n\tstruct mount *child;\n\n\tif (!list_is_singular(&mnt->mnt_mounts))\n\t\treturn NULL;\n\n\tchild = list_first_entry(&mnt->mnt_mounts, struct mount, mnt_child);\n\tif (child->mnt_mountpoint != mnt->mnt.mnt_root)\n\t\treturn NULL;\n\n\treturn child;\n}"
  },
  {
    "function_name": "propagate_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "294-341",
    "snippet": "int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\n\t/*\n\t * we don't want to bother passing tons of arguments to\n\t * propagate_one(); everything is serialized by namespace_sem,\n\t * so globals will do just fine.\n\t */\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tfirst_source = source_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\n\t/* all peers of dest_mnt, except dest_mnt itself */\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* all slave groups */\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\t/* everything in that slave group */\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct user_namespace *user_ns;",
      "static struct mount *last_dest, *first_source, *last_source, *dest_master;",
      "static struct mountpoint *mp;",
      "static struct hlist_head *list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_sequnlock_excl",
          "args": [
            "&mount_lock"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_MNT_MARK",
          "args": [
            "m->mnt_master"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "n",
            "tree_list",
            "mnt_hash"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqlock_excl",
          "args": [
            "&mount_lock"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_peer",
          "args": [
            "n"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "next_peer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "17-20",
          "snippet": "static inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}"
        }
      },
      {
        "call_info": {
          "callee": "propagate_one",
          "args": [
            "n"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "propagate_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "226-279",
          "snippet": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\t/* skip ones added by this propagate_mnt() */\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\t/* skip if mountpoint isn't covered by it */\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\n\t\ttype = CL_SLAVE;\n\t\t/* beginning of peer group among the slaves? */\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\t\t\n\t/* Notice when we are propagating across user namespaces */\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn count_mounts(m->mnt_ns, child);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct user_namespace *user_ns;",
            "static struct mount *last_dest, *first_source, *last_source, *dest_master;",
            "static struct mountpoint *mp;",
            "static struct hlist_head *list;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct user_namespace *user_ns;\nstatic struct mount *last_dest, *first_source, *last_source, *dest_master;\nstatic struct mountpoint *mp;\nstatic struct hlist_head *list;\n\nstatic int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\t/* skip ones added by this propagate_mnt() */\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\t/* skip if mountpoint isn't covered by it */\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\n\t\ttype = CL_SLAVE;\n\t\t/* beginning of peer group among the slaves? */\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\t\t\n\t/* Notice when we are propagating across user namespaces */\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn count_mounts(m->mnt_ns, child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_group",
          "args": [
            "m",
            "dest_mnt"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "next_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "183-213",
          "snippet": "static struct mount *next_group(struct mount *m, struct mount *origin)\n{\n\twhile (1) {\n\t\twhile (1) {\n\t\t\tstruct mount *next;\n\t\t\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\t\t\treturn first_slave(m);\n\t\t\tnext = next_peer(m);\n\t\t\tif (m->mnt_group_id == origin->mnt_group_id) {\n\t\t\t\tif (next == origin)\n\t\t\t\t\treturn NULL;\n\t\t\t} else if (m->mnt_slave.next != &next->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = next;\n\t\t}\n\t\t/* m is the last peer */\n\t\twhile (1) {\n\t\t\tstruct mount *master = m->mnt_master;\n\t\t\tif (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\t\treturn next_slave(m);\n\t\t\tm = next_peer(master);\n\t\t\tif (master->mnt_group_id == origin->mnt_group_id)\n\t\t\t\tbreak;\n\t\t\tif (master->mnt_slave.next == &m->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = master;\n\t\t}\n\t\tif (m == origin)\n\t\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *next_group(struct mount *m, struct mount *origin)\n{\n\twhile (1) {\n\t\twhile (1) {\n\t\t\tstruct mount *next;\n\t\t\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\t\t\treturn first_slave(m);\n\t\t\tnext = next_peer(m);\n\t\t\tif (m->mnt_group_id == origin->mnt_group_id) {\n\t\t\t\tif (next == origin)\n\t\t\t\t\treturn NULL;\n\t\t\t} else if (m->mnt_slave.next != &next->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = next;\n\t\t}\n\t\t/* m is the last peer */\n\t\twhile (1) {\n\t\t\tstruct mount *master = m->mnt_master;\n\t\t\tif (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\t\treturn next_slave(m);\n\t\t\tm = next_peer(master);\n\t\t\tif (master->mnt_group_id == origin->mnt_group_id)\n\t\t\t\tbreak;\n\t\t\tif (master->mnt_slave.next == &m->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = master;\n\t\t}\n\t\tif (m == origin)\n\t\t\treturn NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct user_namespace *user_ns;\nstatic struct mount *last_dest, *first_source, *last_source, *dest_master;\nstatic struct mountpoint *mp;\nstatic struct hlist_head *list;\n\nint propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\n\t/*\n\t * we don't want to bother passing tons of arguments to\n\t * propagate_one(); everything is serialized by namespace_sem,\n\t * so globals will do just fine.\n\t */\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tfirst_source = source_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\n\t/* all peers of dest_mnt, except dest_mnt itself */\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t/* all slave groups */\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\t/* everything in that slave group */\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "propagate_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "226-279",
    "snippet": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\t/* skip ones added by this propagate_mnt() */\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\t/* skip if mountpoint isn't covered by it */\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\n\t\ttype = CL_SLAVE;\n\t\t/* beginning of peer group among the slaves? */\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\t\t\n\t/* Notice when we are propagating across user namespaces */\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn count_mounts(m->mnt_ns, child);\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct user_namespace *user_ns;",
      "static struct mount *last_dest, *first_source, *last_source, *dest_master;",
      "static struct mountpoint *mp;",
      "static struct hlist_head *list;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_mounts",
          "args": [
            "m->mnt_ns",
            "child"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "count_mounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1869-1889",
          "snippet": "int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n{\n\tunsigned int max = READ_ONCE(sysctl_mount_max);\n\tunsigned int mounts = 0, old, pending, sum;\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = next_mnt(p, mnt))\n\t\tmounts++;\n\n\told = ns->mounts;\n\tpending = ns->pending_mounts;\n\tsum = old + pending;\n\tif ((old > sum) ||\n\t    (pending > sum) ||\n\t    (max < sum) ||\n\t    (mounts > (max - sum)))\n\t\treturn -ENOSPC;\n\n\tns->pending_mounts = pending + mounts;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int sysctl_mount_max",
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_mount_max;\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nint count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n{\n\tunsigned int max = READ_ONCE(sysctl_mount_max);\n\tunsigned int mounts = 0, old, pending, sum;\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = next_mnt(p, mnt))\n\t\tmounts++;\n\n\told = ns->mounts;\n\tpending = ns->pending_mounts;\n\tsum = old + pending;\n\tif ((old > sum) ||\n\t    (pending > sum) ||\n\t    (max < sum) ||\n\t    (mounts > (max - sum)))\n\t\treturn -ENOSPC;\n\n\tns->pending_mounts = pending + mounts;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&child->mnt_hash",
            "list"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_sequnlock_excl",
          "args": [
            "&mount_lock"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_MNT_MARK",
          "args": [
            "m->mnt_master"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqlock_excl",
          "args": [
            "&mount_lock"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_set_mountpoint",
          "args": [
            "m",
            "mp",
            "child"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_set_mountpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "832-842",
          "snippet": "void mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid mnt_set_mountpoint(struct mount *mnt,\n\t\t\tstruct mountpoint *mp,\n\t\t\tstruct mount *child_mnt)\n{\n\tmp->m_count++;\n\tmnt_add_count(mnt, 1);\t/* essentially, that's mntget */\n\tchild_mnt->mnt_mountpoint = dget(mp->m_dentry);\n\tchild_mnt->mnt_parent = mnt;\n\tchild_mnt->mnt_mp = mp;\n\thlist_add_head(&child_mnt->mnt_mp_list, &mp->m_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "child"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "child"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_tree",
          "args": [
            "last_source",
            "last_source->mnt.mnt_root",
            "type"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "copy_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "1711-1774",
          "snippet": "struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\tif (s->mnt.mnt_flags & MNT_LOCKED) {\n\t\t\t\t\t/* Both unbindable and locked. */\n\t\t\t\t\tq = ERR_PTR(-EPERM);\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tattach_mnt(q, parent, p->mnt_mp);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nstruct mount *copy_tree(struct mount *mnt, struct dentry *dentry,\n\t\t\t\t\tint flag)\n{\n\tstruct mount *res, *p, *q, *r, *parent;\n\n\tif (!(flag & CL_COPY_UNBINDABLE) && IS_MNT_UNBINDABLE(mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!(flag & CL_COPY_MNT_NS_FILE) && is_mnt_ns_file(dentry))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tres = q = clone_mnt(mnt, dentry, flag);\n\tif (IS_ERR(q))\n\t\treturn q;\n\n\tq->mnt_mountpoint = mnt->mnt_mountpoint;\n\n\tp = mnt;\n\tlist_for_each_entry(r, &mnt->mnt_mounts, mnt_child) {\n\t\tstruct mount *s;\n\t\tif (!is_subdir(r->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tfor (s = r; s; s = next_mnt(s, r)) {\n\t\t\tif (!(flag & CL_COPY_UNBINDABLE) &&\n\t\t\t    IS_MNT_UNBINDABLE(s)) {\n\t\t\t\tif (s->mnt.mnt_flags & MNT_LOCKED) {\n\t\t\t\t\t/* Both unbindable and locked. */\n\t\t\t\t\tq = ERR_PTR(-EPERM);\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(flag & CL_COPY_MNT_NS_FILE) &&\n\t\t\t    is_mnt_ns_file(s->mnt.mnt_root)) {\n\t\t\t\ts = skip_mnt_tree(s);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (p != s->mnt_parent) {\n\t\t\t\tp = p->mnt_parent;\n\t\t\t\tq = q->mnt_parent;\n\t\t\t}\n\t\t\tp = s;\n\t\t\tparent = q;\n\t\t\tq = clone_mnt(p, p->mnt.mnt_root, flag);\n\t\t\tif (IS_ERR(q))\n\t\t\t\tgoto out;\n\t\t\tlock_mount_hash();\n\t\t\tlist_add_tail(&q->mnt_list, &res->mnt_list);\n\t\t\tattach_mnt(q, parent, p->mnt_mp);\n\t\t\tunlock_mount_hash();\n\t\t}\n\t}\n\treturn res;\nout:\n\tif (res) {\n\t\tlock_mount_hash();\n\t\tumount_tree(res, UMOUNT_SYNC);\n\t\tunlock_mount_hash();\n\t}\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "m"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "peers",
          "args": [
            "n",
            "parent"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "peers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "221-224",
          "snippet": "static inline bool peers(struct mount *m1, struct mount *m2)\n{\n\treturn m1->mnt_group_id == m2->mnt_group_id && m1->mnt_group_id;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline bool peers(struct mount *m1, struct mount *m2)\n{\n\treturn m1->mnt_group_id == m2->mnt_group_id && m1->mnt_group_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_MARKED",
          "args": [
            "p"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_subdir",
          "args": [
            "mp->m_dentry",
            "m->mnt.mnt_root"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "is_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "2968-2992",
          "snippet": "bool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tbool result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn true;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nbool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)\n{\n\tbool result;\n\tunsigned seq;\n\n\tif (new_dentry == old_dentry)\n\t\treturn true;\n\n\tdo {\n\t\t/* for restarting inner loop in case of seq retry */\n\t\tseq = read_seqbegin(&rename_lock);\n\t\t/*\n\t\t * Need rcu_readlock to protect against the d_parent trashing\n\t\t * due to d_move\n\t\t */\n\t\trcu_read_lock();\n\t\tif (d_ancestor(old_dentry, new_dentry))\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t\trcu_read_unlock();\n\t} while (read_seqretry(&rename_lock, seq));\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_NEW",
          "args": [
            "m"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct user_namespace *user_ns;\nstatic struct mount *last_dest, *first_source, *last_source, *dest_master;\nstatic struct mountpoint *mp;\nstatic struct hlist_head *list;\n\nstatic int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\t/* skip ones added by this propagate_mnt() */\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\t/* skip if mountpoint isn't covered by it */\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\n\t\ttype = CL_SLAVE;\n\t\t/* beginning of peer group among the slaves? */\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\t\t\n\t/* Notice when we are propagating across user namespaces */\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn count_mounts(m->mnt_ns, child);\n}"
  },
  {
    "function_name": "peers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "221-224",
    "snippet": "static inline bool peers(struct mount *m1, struct mount *m2)\n{\n\treturn m1->mnt_group_id == m2->mnt_group_id && m1->mnt_group_id;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline bool peers(struct mount *m1, struct mount *m2)\n{\n\treturn m1->mnt_group_id == m2->mnt_group_id && m1->mnt_group_id;\n}"
  },
  {
    "function_name": "next_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "183-213",
    "snippet": "static struct mount *next_group(struct mount *m, struct mount *origin)\n{\n\twhile (1) {\n\t\twhile (1) {\n\t\t\tstruct mount *next;\n\t\t\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\t\t\treturn first_slave(m);\n\t\t\tnext = next_peer(m);\n\t\t\tif (m->mnt_group_id == origin->mnt_group_id) {\n\t\t\t\tif (next == origin)\n\t\t\t\t\treturn NULL;\n\t\t\t} else if (m->mnt_slave.next != &next->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = next;\n\t\t}\n\t\t/* m is the last peer */\n\t\twhile (1) {\n\t\t\tstruct mount *master = m->mnt_master;\n\t\t\tif (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\t\treturn next_slave(m);\n\t\t\tm = next_peer(master);\n\t\t\tif (master->mnt_group_id == origin->mnt_group_id)\n\t\t\t\tbreak;\n\t\t\tif (master->mnt_slave.next == &m->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = master;\n\t\t}\n\t\tif (m == origin)\n\t\t\treturn NULL;\n\t}\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_peer",
          "args": [
            "master"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "next_peer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "17-20",
          "snippet": "static inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_slave",
          "args": [
            "m"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "next_slave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "32-35",
          "snippet": "static inline struct mount *next_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave.next, struct mount, mnt_slave);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave.next, struct mount, mnt_slave);\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_slave",
          "args": [
            "m"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "first_slave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "22-25",
          "snippet": "static inline struct mount *first_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.next, struct mount, mnt_slave);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *first_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.next, struct mount, mnt_slave);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&m->mnt_slave_list"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_NEW",
          "args": [
            "m"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *next_group(struct mount *m, struct mount *origin)\n{\n\twhile (1) {\n\t\twhile (1) {\n\t\t\tstruct mount *next;\n\t\t\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\t\t\treturn first_slave(m);\n\t\t\tnext = next_peer(m);\n\t\t\tif (m->mnt_group_id == origin->mnt_group_id) {\n\t\t\t\tif (next == origin)\n\t\t\t\t\treturn NULL;\n\t\t\t} else if (m->mnt_slave.next != &next->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = next;\n\t\t}\n\t\t/* m is the last peer */\n\t\twhile (1) {\n\t\t\tstruct mount *master = m->mnt_master;\n\t\t\tif (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\t\treturn next_slave(m);\n\t\t\tm = next_peer(master);\n\t\t\tif (master->mnt_group_id == origin->mnt_group_id)\n\t\t\t\tbreak;\n\t\t\tif (master->mnt_slave.next == &m->mnt_slave)\n\t\t\t\tbreak;\n\t\t\tm = master;\n\t\t}\n\t\tif (m == origin)\n\t\t\treturn NULL;\n\t}\n}"
  },
  {
    "function_name": "skip_propagation_subtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "170-181",
    "snippet": "static struct mount *skip_propagation_subtree(struct mount *m,\n\t\t\t\t\t\tstruct mount *origin)\n{\n\t/*\n\t * Advance m such that propagation_next will not return\n\t * the slaves of m.\n\t */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\tm = last_slave(m);\n\n\treturn m;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "last_slave",
          "args": [
            "m"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "last_slave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "27-30",
          "snippet": "static inline struct mount *last_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.prev, struct mount, mnt_slave);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *last_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.prev, struct mount, mnt_slave);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&m->mnt_slave_list"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_NEW",
          "args": [
            "m"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *skip_propagation_subtree(struct mount *m,\n\t\t\t\t\t\tstruct mount *origin)\n{\n\t/*\n\t * Advance m such that propagation_next will not return\n\t * the slaves of m.\n\t */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\tm = last_slave(m);\n\n\treturn m;\n}"
  },
  {
    "function_name": "propagation_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "149-168",
    "snippet": "static struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_slave",
          "args": [
            "m"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "next_slave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "32-35",
          "snippet": "static inline struct mount *next_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave.next, struct mount, mnt_slave);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave.next, struct mount, mnt_slave);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_peer",
          "args": [
            "m"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "next_peer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "17-20",
          "snippet": "static inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_slave",
          "args": [
            "m"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "first_slave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "22-25",
          "snippet": "static inline struct mount *first_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.next, struct mount, mnt_slave);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *first_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.next, struct mount, mnt_slave);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&m->mnt_slave_list"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_NEW",
          "args": [
            "m"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *propagation_next(struct mount *m,\n\t\t\t\t\t struct mount *origin)\n{\n\t/* are there any slaves of this mount? */\n\tif (!IS_MNT_NEW(m) && !list_empty(&m->mnt_slave_list))\n\t\treturn first_slave(m);\n\n\twhile (1) {\n\t\tstruct mount *master = m->mnt_master;\n\n\t\tif (master == origin->mnt_master) {\n\t\t\tstruct mount *next = next_peer(m);\n\t\t\treturn (next == origin) ? NULL : next;\n\t\t} else if (m->mnt_slave.next != &master->mnt_slave_list)\n\t\t\treturn next_slave(m);\n\n\t\t/* back at master */\n\t\tm = master;\n\t}\n}"
  },
  {
    "function_name": "change_mnt_propagation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "122-137",
    "snippet": "void change_mnt_propagation(struct mount *mnt, int type)\n{\n\tif (type == MS_SHARED) {\n\t\tset_mnt_shared(mnt);\n\t\treturn;\n\t}\n\tdo_make_slave(mnt);\n\tif (type != MS_SLAVE) {\n\t\tlist_del_init(&mnt->mnt_slave);\n\t\tmnt->mnt_master = NULL;\n\t\tif (type == MS_UNBINDABLE)\n\t\t\tmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\n\t\telse\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\n\t}\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mnt->mnt_slave"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_make_slave",
          "args": [
            "mnt"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "do_make_slave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "73-117",
          "snippet": "static int do_make_slave(struct mount *mnt)\n{\n\tstruct mount *master, *slave_mnt;\n\n\tif (list_empty(&mnt->mnt_share)) {\n\t\tif (IS_MNT_SHARED(mnt)) {\n\t\t\tmnt_release_group_id(mnt);\n\t\t\tCLEAR_MNT_SHARED(mnt);\n\t\t}\n\t\tmaster = mnt->mnt_master;\n\t\tif (!master) {\n\t\t\tstruct list_head *p = &mnt->mnt_slave_list;\n\t\t\twhile (!list_empty(p)) {\n\t\t\t\tslave_mnt = list_first_entry(p,\n\t\t\t\t\t\tstruct mount, mnt_slave);\n\t\t\t\tlist_del_init(&slave_mnt->mnt_slave);\n\t\t\t\tslave_mnt->mnt_master = NULL;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tstruct mount *m;\n\t\t/*\n\t\t * slave 'mnt' to a peer mount that has the\n\t\t * same root dentry. If none is available then\n\t\t * slave it to anything that is available.\n\t\t */\n\t\tfor (m = master = next_peer(mnt); m != mnt; m = next_peer(m)) {\n\t\t\tif (m->mnt.mnt_root == mnt->mnt.mnt_root) {\n\t\t\t\tmaster = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&mnt->mnt_share);\n\t\tmnt->mnt_group_id = 0;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t}\n\tlist_for_each_entry(slave_mnt, &mnt->mnt_slave_list, mnt_slave)\n\t\tslave_mnt->mnt_master = master;\n\tlist_move(&mnt->mnt_slave, &master->mnt_slave_list);\n\tlist_splice(&mnt->mnt_slave_list, master->mnt_slave_list.prev);\n\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\tmnt->mnt_master = master;\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic int do_make_slave(struct mount *mnt)\n{\n\tstruct mount *master, *slave_mnt;\n\n\tif (list_empty(&mnt->mnt_share)) {\n\t\tif (IS_MNT_SHARED(mnt)) {\n\t\t\tmnt_release_group_id(mnt);\n\t\t\tCLEAR_MNT_SHARED(mnt);\n\t\t}\n\t\tmaster = mnt->mnt_master;\n\t\tif (!master) {\n\t\t\tstruct list_head *p = &mnt->mnt_slave_list;\n\t\t\twhile (!list_empty(p)) {\n\t\t\t\tslave_mnt = list_first_entry(p,\n\t\t\t\t\t\tstruct mount, mnt_slave);\n\t\t\t\tlist_del_init(&slave_mnt->mnt_slave);\n\t\t\t\tslave_mnt->mnt_master = NULL;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tstruct mount *m;\n\t\t/*\n\t\t * slave 'mnt' to a peer mount that has the\n\t\t * same root dentry. If none is available then\n\t\t * slave it to anything that is available.\n\t\t */\n\t\tfor (m = master = next_peer(mnt); m != mnt; m = next_peer(m)) {\n\t\t\tif (m->mnt.mnt_root == mnt->mnt.mnt_root) {\n\t\t\t\tmaster = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&mnt->mnt_share);\n\t\tmnt->mnt_group_id = 0;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t}\n\tlist_for_each_entry(slave_mnt, &mnt->mnt_slave_list, mnt_slave)\n\t\tslave_mnt->mnt_master = master;\n\tlist_move(&mnt->mnt_slave, &master->mnt_slave_list);\n\tlist_splice(&mnt->mnt_slave_list, master->mnt_slave_list.prev);\n\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\tmnt->mnt_master = master;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_mnt_shared",
          "args": [
            "mnt"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "set_mnt_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.h",
          "lines": "35-39",
          "snippet": "static inline void set_mnt_shared(struct mount *mnt)\n{\n\tmnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;\n\tmnt->mnt.mnt_flags |= MNT_SHARED;\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/list.h>\n\nstatic inline void set_mnt_shared(struct mount *mnt)\n{\n\tmnt->mnt.mnt_flags &= ~MNT_SHARED_MASK;\n\tmnt->mnt.mnt_flags |= MNT_SHARED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nvoid change_mnt_propagation(struct mount *mnt, int type)\n{\n\tif (type == MS_SHARED) {\n\t\tset_mnt_shared(mnt);\n\t\treturn;\n\t}\n\tdo_make_slave(mnt);\n\tif (type != MS_SLAVE) {\n\t\tlist_del_init(&mnt->mnt_slave);\n\t\tmnt->mnt_master = NULL;\n\t\tif (type == MS_UNBINDABLE)\n\t\t\tmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\n\t\telse\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\n\t}\n}"
  },
  {
    "function_name": "do_make_slave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "73-117",
    "snippet": "static int do_make_slave(struct mount *mnt)\n{\n\tstruct mount *master, *slave_mnt;\n\n\tif (list_empty(&mnt->mnt_share)) {\n\t\tif (IS_MNT_SHARED(mnt)) {\n\t\t\tmnt_release_group_id(mnt);\n\t\t\tCLEAR_MNT_SHARED(mnt);\n\t\t}\n\t\tmaster = mnt->mnt_master;\n\t\tif (!master) {\n\t\t\tstruct list_head *p = &mnt->mnt_slave_list;\n\t\t\twhile (!list_empty(p)) {\n\t\t\t\tslave_mnt = list_first_entry(p,\n\t\t\t\t\t\tstruct mount, mnt_slave);\n\t\t\t\tlist_del_init(&slave_mnt->mnt_slave);\n\t\t\t\tslave_mnt->mnt_master = NULL;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tstruct mount *m;\n\t\t/*\n\t\t * slave 'mnt' to a peer mount that has the\n\t\t * same root dentry. If none is available then\n\t\t * slave it to anything that is available.\n\t\t */\n\t\tfor (m = master = next_peer(mnt); m != mnt; m = next_peer(m)) {\n\t\t\tif (m->mnt.mnt_root == mnt->mnt.mnt_root) {\n\t\t\t\tmaster = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&mnt->mnt_share);\n\t\tmnt->mnt_group_id = 0;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t}\n\tlist_for_each_entry(slave_mnt, &mnt->mnt_slave_list, mnt_slave)\n\t\tslave_mnt->mnt_master = master;\n\tlist_move(&mnt->mnt_slave, &master->mnt_slave_list);\n\tlist_splice(&mnt->mnt_slave_list, master->mnt_slave_list.prev);\n\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\tmnt->mnt_master = master;\n\treturn 0;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&mnt->mnt_slave_list"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&mnt->mnt_slave_list",
            "master->mnt_slave_list.prev"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&mnt->mnt_slave",
            "&master->mnt_slave_list"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "slave_mnt",
            "&mnt->mnt_slave_list",
            "mnt_slave"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLEAR_MNT_SHARED",
          "args": [
            "mnt"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&mnt->mnt_share"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_peer",
          "args": [
            "m"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "next_peer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "17-20",
          "snippet": "static inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&slave_mnt->mnt_slave"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "p",
            "structmount",
            "mnt_slave"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "p"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CLEAR_MNT_SHARED",
          "args": [
            "mnt"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_release_group_id",
          "args": [
            "mnt"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_release_group_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "130-134",
          "snippet": "void mnt_release_group_id(struct mount *mnt)\n{\n\tida_free(&mnt_group_ida, mnt->mnt_group_id);\n\tmnt->mnt_group_id = 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(mnt_group_ida);",
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic DEFINE_IDA(mnt_group_ida);\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nvoid mnt_release_group_id(struct mount *mnt)\n{\n\tida_free(&mnt_group_ida, mnt->mnt_group_id);\n\tmnt->mnt_group_id = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "mnt"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic int do_make_slave(struct mount *mnt)\n{\n\tstruct mount *master, *slave_mnt;\n\n\tif (list_empty(&mnt->mnt_share)) {\n\t\tif (IS_MNT_SHARED(mnt)) {\n\t\t\tmnt_release_group_id(mnt);\n\t\t\tCLEAR_MNT_SHARED(mnt);\n\t\t}\n\t\tmaster = mnt->mnt_master;\n\t\tif (!master) {\n\t\t\tstruct list_head *p = &mnt->mnt_slave_list;\n\t\t\twhile (!list_empty(p)) {\n\t\t\t\tslave_mnt = list_first_entry(p,\n\t\t\t\t\t\tstruct mount, mnt_slave);\n\t\t\t\tlist_del_init(&slave_mnt->mnt_slave);\n\t\t\t\tslave_mnt->mnt_master = NULL;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tstruct mount *m;\n\t\t/*\n\t\t * slave 'mnt' to a peer mount that has the\n\t\t * same root dentry. If none is available then\n\t\t * slave it to anything that is available.\n\t\t */\n\t\tfor (m = master = next_peer(mnt); m != mnt; m = next_peer(m)) {\n\t\t\tif (m->mnt.mnt_root == mnt->mnt.mnt_root) {\n\t\t\t\tmaster = m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlist_del_init(&mnt->mnt_share);\n\t\tmnt->mnt_group_id = 0;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t}\n\tlist_for_each_entry(slave_mnt, &mnt->mnt_slave_list, mnt_slave)\n\t\tslave_mnt->mnt_master = master;\n\tlist_move(&mnt->mnt_slave, &master->mnt_slave_list);\n\tlist_splice(&mnt->mnt_slave_list, master->mnt_slave_list.prev);\n\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\tmnt->mnt_master = master;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_dominating_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "60-71",
    "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_peer_under_root",
          "args": [
            "m",
            "mnt->mnt_ns",
            "root"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "get_peer_under_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "37-52",
          "snippet": "static struct mount *get_peer_under_root(struct mount *mnt,\n\t\t\t\t\t struct mnt_namespace *ns,\n\t\t\t\t\t const struct path *root)\n{\n\tstruct mount *m = mnt;\n\n\tdo {\n\t\t/* Check the namespace first for optimization */\n\t\tif (m->mnt_ns == ns && is_path_reachable(m, m->mnt.mnt_root, root))\n\t\t\treturn m;\n\n\t\tm = next_peer(m);\n\t} while (m != mnt);\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *get_peer_under_root(struct mount *mnt,\n\t\t\t\t\t struct mnt_namespace *ns,\n\t\t\t\t\t const struct path *root)\n{\n\tstruct mount *m = mnt;\n\n\tdo {\n\t\t/* Check the namespace first for optimization */\n\t\tif (m->mnt_ns == ns && is_path_reachable(m, m->mnt.mnt_root, root))\n\t\t\treturn m;\n\n\t\tm = next_peer(m);\n\t} while (m != mnt);\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_peer_under_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "37-52",
    "snippet": "static struct mount *get_peer_under_root(struct mount *mnt,\n\t\t\t\t\t struct mnt_namespace *ns,\n\t\t\t\t\t const struct path *root)\n{\n\tstruct mount *m = mnt;\n\n\tdo {\n\t\t/* Check the namespace first for optimization */\n\t\tif (m->mnt_ns == ns && is_path_reachable(m, m->mnt.mnt_root, root))\n\t\t\treturn m;\n\n\t\tm = next_peer(m);\n\t} while (m != mnt);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "next_peer",
          "args": [
            "m"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "next_peer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "17-20",
          "snippet": "static inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_path_reachable",
          "args": [
            "m",
            "m->mnt.mnt_root",
            "root"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "is_path_reachable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "3039-3047",
          "snippet": "bool is_path_reachable(struct mount *mnt, struct dentry *dentry,\n\t\t\t const struct path *root)\n{\n\twhile (&mnt->mnt != root->mnt && mnt_has_parent(mnt)) {\n\t\tdentry = mnt->mnt_mountpoint;\n\t\tmnt = mnt->mnt_parent;\n\t}\n\treturn &mnt->mnt == root->mnt && is_subdir(dentry, root->dentry);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nbool is_path_reachable(struct mount *mnt, struct dentry *dentry,\n\t\t\t const struct path *root)\n{\n\twhile (&mnt->mnt != root->mnt && mnt_has_parent(mnt)) {\n\t\tdentry = mnt->mnt_mountpoint;\n\t\tmnt = mnt->mnt_parent;\n\t}\n\treturn &mnt->mnt == root->mnt && is_subdir(dentry, root->dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic struct mount *get_peer_under_root(struct mount *mnt,\n\t\t\t\t\t struct mnt_namespace *ns,\n\t\t\t\t\t const struct path *root)\n{\n\tstruct mount *m = mnt;\n\n\tdo {\n\t\t/* Check the namespace first for optimization */\n\t\tif (m->mnt_ns == ns && is_path_reachable(m, m->mnt.mnt_root, root))\n\t\t\treturn m;\n\n\t\tm = next_peer(m);\n\t} while (m != mnt);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "next_slave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "32-35",
    "snippet": "static inline struct mount *next_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave.next, struct mount, mnt_slave);\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p->mnt_slave.next",
            "structmount",
            "mnt_slave"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave.next, struct mount, mnt_slave);\n}"
  },
  {
    "function_name": "last_slave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "27-30",
    "snippet": "static inline struct mount *last_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.prev, struct mount, mnt_slave);\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p->mnt_slave_list.prev",
            "structmount",
            "mnt_slave"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *last_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.prev, struct mount, mnt_slave);\n}"
  },
  {
    "function_name": "first_slave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "22-25",
    "snippet": "static inline struct mount *first_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.next, struct mount, mnt_slave);\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p->mnt_slave_list.next",
            "structmount",
            "mnt_slave"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *first_slave(struct mount *p)\n{\n\treturn list_entry(p->mnt_slave_list.next, struct mount, mnt_slave);\n}"
  },
  {
    "function_name": "next_peer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
    "lines": "17-20",
    "snippet": "static inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}",
    "includes": [
      "#include \"pnode.h\"",
      "#include \"internal.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/fs.h>",
      "#include <linux/mount.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p->mnt_share.next",
            "structmount",
            "mnt_share"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline struct mount *next_peer(struct mount *p)\n{\n\treturn list_entry(p->mnt_share.next, struct mount, mnt_share);\n}"
  }
]