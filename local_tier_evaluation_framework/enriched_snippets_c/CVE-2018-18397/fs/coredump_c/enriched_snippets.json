[
  {
    "function_name": "dump_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "840-850",
    "snippet": "void dump_truncate(struct coredump_params *cprm)\n{\n\tstruct file *file = cprm->file;\n\tloff_t offset;\n\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\toffset = file->f_op->llseek(file, 0, SEEK_CUR);\n\t\tif (i_size_read(file->f_mapping->host) < offset)\n\t\t\tdo_truncate(file->f_path.dentry, offset, 0, file);\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_truncate",
          "args": [
            "file->f_path.dentry",
            "offset",
            "0",
            "file"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "do_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "37-66",
          "snippet": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file->f_mapping->host"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file->f_op->llseek",
          "args": [
            "file",
            "0",
            "SEEK_CUR"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid dump_truncate(struct coredump_params *cprm)\n{\n\tstruct file *file = cprm->file;\n\tloff_t offset;\n\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\toffset = file->f_op->llseek(file, 0, SEEK_CUR);\n\t\tif (i_size_read(file->f_mapping->host) < offset)\n\t\t\tdo_truncate(file->f_path.dentry, offset, 0, file);\n\t}\n}"
  },
  {
    "function_name": "dump_align",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "826-832",
    "snippet": "int dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = cprm->pos & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\treturn mod ? dump_skip(cprm, align - mod) : 1;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_skip",
          "args": [
            "cprm",
            "align - mod"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "dump_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "805-823",
          "snippet": "int dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_align(struct coredump_params *cprm, int align)\n{\n\tunsigned mod = cprm->pos & (align - 1);\n\tif (align & (align - 1))\n\t\treturn 0;\n\treturn mod ? dump_skip(cprm, align - mod) : 1;\n}"
  },
  {
    "function_name": "dump_skip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "805-823",
    "snippet": "int dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_emit",
          "args": [
            "cprm",
            "zeroes",
            "nr"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "dump_emit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "783-802",
          "snippet": "int dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->f_op->llseek",
          "args": [
            "file",
            "nr",
            "SEEK_CUR"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_interrupted",
          "args": [],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "dump_interrupted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "476-485",
          "snippet": "static bool dump_interrupted(void)\n{\n\t/*\n\t * SIGKILL or freezing() interrupt the coredumping. Perhaps we\n\t * can do try_to_freeze() and check __fatal_signal_pending(),\n\t * but then we need to teach dump_write() to restart and clear\n\t * TIF_SIGPENDING.\n\t */\n\treturn signal_pending(current);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;\n\nstatic bool dump_interrupted(void)\n{\n\t/*\n\t * SIGKILL or freezing() interrupt the coredumping. Perhaps we\n\t * can do try_to_freeze() and check __fatal_signal_pending(),\n\t * but then we need to teach dump_write() to restart and clear\n\t * TIF_SIGPENDING.\n\t */\n\treturn signal_pending(current);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_skip(struct coredump_params *cprm, size_t nr)\n{\n\tstatic char zeroes[PAGE_SIZE];\n\tstruct file *file = cprm->file;\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (dump_interrupted() ||\n\t\t    file->f_op->llseek(file, nr, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t\tcprm->pos += nr;\n\t\treturn 1;\n\t} else {\n\t\twhile (nr > PAGE_SIZE) {\n\t\t\tif (!dump_emit(cprm, zeroes, PAGE_SIZE))\n\t\t\t\treturn 0;\n\t\t\tnr -= PAGE_SIZE;\n\t\t}\n\t\treturn dump_emit(cprm, zeroes, nr);\n\t}\n}"
  },
  {
    "function_name": "dump_emit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "783-802",
    "snippet": "int dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kernel_write",
          "args": [
            "file",
            "addr",
            "nr",
            "&pos"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "__kernel_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/read_write.c",
          "lines": "492-514",
          "snippet": "ssize_t __kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tret = __vfs_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include \"internal.h\"\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/sched/xacct.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __kernel_write(struct file *file, const void *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tret = __vfs_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_interrupted",
          "args": [],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "dump_interrupted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "476-485",
          "snippet": "static bool dump_interrupted(void)\n{\n\t/*\n\t * SIGKILL or freezing() interrupt the coredumping. Perhaps we\n\t * can do try_to_freeze() and check __fatal_signal_pending(),\n\t * but then we need to teach dump_write() to restart and clear\n\t * TIF_SIGPENDING.\n\t */\n\treturn signal_pending(current);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;\n\nstatic bool dump_interrupted(void)\n{\n\t/*\n\t * SIGKILL or freezing() interrupt the coredumping. Perhaps we\n\t * can do try_to_freeze() and check __fatal_signal_pending(),\n\t * but then we need to teach dump_write() to restart and clear\n\t * TIF_SIGPENDING.\n\t */\n\treturn signal_pending(current);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint dump_emit(struct coredump_params *cprm, const void *addr, int nr)\n{\n\tstruct file *file = cprm->file;\n\tloff_t pos = file->f_pos;\n\tssize_t n;\n\tif (cprm->written + nr > cprm->limit)\n\t\treturn 0;\n\twhile (nr) {\n\t\tif (dump_interrupted())\n\t\t\treturn 0;\n\t\tn = __kernel_write(file, addr, nr, &pos);\n\t\tif (n <= 0)\n\t\t\treturn 0;\n\t\tfile->f_pos = pos;\n\t\tcprm->written += n;\n\t\tcprm->pos += n;\n\t\tnr -= n;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "do_coredump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "539-776",
    "snippet": "void do_coredump(const kernel_siginfo_t *siginfo)\n{\n\tstruct core_state core_state;\n\tstruct core_name cn;\n\tstruct mm_struct *mm = current->mm;\n\tstruct linux_binfmt * binfmt;\n\tconst struct cred *old_cred;\n\tstruct cred *cred;\n\tint retval = 0;\n\tint ispipe;\n\tstruct files_struct *displaced;\n\t/* require nonrelative corefile path and be extra careful */\n\tbool need_suid_safe = false;\n\tbool core_dumped = false;\n\tstatic atomic_t core_dump_count = ATOMIC_INIT(0);\n\tstruct coredump_params cprm = {\n\t\t.siginfo = siginfo,\n\t\t.regs = signal_pt_regs(),\n\t\t.limit = rlimit(RLIMIT_CORE),\n\t\t/*\n\t\t * We must use the same mm->flags while dumping core to avoid\n\t\t * inconsistency of bit flags, since this flag is not protected\n\t\t * by any locks.\n\t\t */\n\t\t.mm_flags = mm->flags,\n\t};\n\n\taudit_core_dumps(siginfo->si_signo);\n\n\tbinfmt = mm->binfmt;\n\tif (!binfmt || !binfmt->core_dump)\n\t\tgoto fail;\n\tif (!__get_dumpable(cprm.mm_flags))\n\t\tgoto fail;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\tgoto fail;\n\t/*\n\t * We cannot trust fsuid as being the \"true\" uid of the process\n\t * nor do we know its entire history. We only know it was tainted\n\t * so we dump it as root in mode 2, and only into a controlled\n\t * environment (pipe handler or fully qualified path).\n\t */\n\tif (__get_dumpable(cprm.mm_flags) == SUID_DUMP_ROOT) {\n\t\t/* Setuid core dump mode */\n\t\tcred->fsuid = GLOBAL_ROOT_UID;\t/* Dump root private */\n\t\tneed_suid_safe = true;\n\t}\n\n\tretval = coredump_wait(siginfo->si_signo, &core_state);\n\tif (retval < 0)\n\t\tgoto fail_creds;\n\n\told_cred = override_creds(cred);\n\n\tispipe = format_corename(&cn, &cprm);\n\n\tif (ispipe) {\n\t\tint dump_count;\n\t\tchar **helper_argv;\n\t\tstruct subprocess_info *sub_info;\n\n\t\tif (ispipe < 0) {\n\t\t\tprintk(KERN_WARNING \"format_corename failed\\n\");\n\t\t\tprintk(KERN_WARNING \"Aborting core\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\tif (cprm.limit == 1) {\n\t\t\t/* See umh_pipe_setup() which sets RLIMIT_CORE = 1.\n\t\t\t *\n\t\t\t * Normally core limits are irrelevant to pipes, since\n\t\t\t * we're not writing to the file system, but we use\n\t\t\t * cprm.limit of 1 here as a special value, this is a\n\t\t\t * consistent way to catch recursive crashes.\n\t\t\t * We can still crash if the core_pattern binary sets\n\t\t\t * RLIM_CORE = !1, but it runs as root, and can do\n\t\t\t * lots of stupid things.\n\t\t\t *\n\t\t\t * Note that we use task_tgid_vnr here to grab the pid\n\t\t\t * of the process group leader.  That way we get the\n\t\t\t * right pid if a thread in a multi-threaded\n\t\t\t * core_pattern process dies.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"Process %d(%s) has RLIMIT_CORE set to 1\\n\",\n\t\t\t\ttask_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Aborting core\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\t\tcprm.limit = RLIM_INFINITY;\n\n\t\tdump_count = atomic_inc_return(&core_dump_count);\n\t\tif (core_pipe_limit && (core_pipe_limit < dump_count)) {\n\t\t\tprintk(KERN_WARNING \"Pid %d(%s) over core_pipe_limit\\n\",\n\t\t\t       task_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Skipping core dump\\n\");\n\t\t\tgoto fail_dropcount;\n\t\t}\n\n\t\thelper_argv = argv_split(GFP_KERNEL, cn.corename, NULL);\n\t\tif (!helper_argv) {\n\t\t\tprintk(KERN_WARNING \"%s failed to allocate memory\\n\",\n\t\t\t       __func__);\n\t\t\tgoto fail_dropcount;\n\t\t}\n\n\t\tretval = -ENOMEM;\n\t\tsub_info = call_usermodehelper_setup(helper_argv[0],\n\t\t\t\t\t\thelper_argv, NULL, GFP_KERNEL,\n\t\t\t\t\t\tumh_pipe_setup, NULL, &cprm);\n\t\tif (sub_info)\n\t\t\tretval = call_usermodehelper_exec(sub_info,\n\t\t\t\t\t\t\t  UMH_WAIT_EXEC);\n\n\t\targv_free(helper_argv);\n\t\tif (retval) {\n\t\t\tprintk(KERN_INFO \"Core dump to |%s pipe failed\\n\",\n\t\t\t       cn.corename);\n\t\t\tgoto close_fail;\n\t\t}\n\t} else {\n\t\tstruct inode *inode;\n\t\tint open_flags = O_CREAT | O_RDWR | O_NOFOLLOW |\n\t\t\t\t O_LARGEFILE | O_EXCL;\n\n\t\tif (cprm.limit < binfmt->min_coredump)\n\t\t\tgoto fail_unlock;\n\n\t\tif (need_suid_safe && cn.corename[0] != '/') {\n\t\t\tprintk(KERN_WARNING \"Pid %d(%s) can only dump core \"\\\n\t\t\t\t\"to fully qualified path!\\n\",\n\t\t\t\ttask_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Skipping core dump\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Unlink the file if it exists unless this is a SUID\n\t\t * binary - in that case, we're running around with root\n\t\t * privs and don't want to unlink another user's coredump.\n\t\t */\n\t\tif (!need_suid_safe) {\n\t\t\t/*\n\t\t\t * If it doesn't exist, that's fine. If there's some\n\t\t\t * other problem, we'll catch it at the filp_open().\n\t\t\t */\n\t\t\tdo_unlinkat(AT_FDCWD, getname_kernel(cn.corename));\n\t\t}\n\n\t\t/*\n\t\t * There is a race between unlinking and creating the\n\t\t * file, but if that causes an EEXIST here, that's\n\t\t * fine - another process raced with us while creating\n\t\t * the corefile, and the other process won. To userspace,\n\t\t * what matters is that at least one of the two processes\n\t\t * writes its coredump successfully, not which one.\n\t\t */\n\t\tif (need_suid_safe) {\n\t\t\t/*\n\t\t\t * Using user namespaces, normal user tasks can change\n\t\t\t * their current->fs->root to point to arbitrary\n\t\t\t * directories. Since the intention of the \"only dump\n\t\t\t * with a fully qualified path\" rule is to control where\n\t\t\t * coredumps may be placed using root privileges,\n\t\t\t * current->fs->root must not be used. Instead, use the\n\t\t\t * root directory of init_task.\n\t\t\t */\n\t\t\tstruct path root;\n\n\t\t\ttask_lock(&init_task);\n\t\t\tget_fs_root(init_task.fs, &root);\n\t\t\ttask_unlock(&init_task);\n\t\t\tcprm.file = file_open_root(root.dentry, root.mnt,\n\t\t\t\tcn.corename, open_flags, 0600);\n\t\t\tpath_put(&root);\n\t\t} else {\n\t\t\tcprm.file = filp_open(cn.corename, open_flags, 0600);\n\t\t}\n\t\tif (IS_ERR(cprm.file))\n\t\t\tgoto fail_unlock;\n\n\t\tinode = file_inode(cprm.file);\n\t\tif (inode->i_nlink > 1)\n\t\t\tgoto close_fail;\n\t\tif (d_unhashed(cprm.file->f_path.dentry))\n\t\t\tgoto close_fail;\n\t\t/*\n\t\t * AK: actually i see no reason to not allow this for named\n\t\t * pipes etc, but keep the previous behaviour for now.\n\t\t */\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\tgoto close_fail;\n\t\t/*\n\t\t * Don't dump core if the filesystem changed owner or mode\n\t\t * of the file during file creation. This is an issue when\n\t\t * a process dumps core while its cwd is e.g. on a vfat\n\t\t * filesystem.\n\t\t */\n\t\tif (!uid_eq(inode->i_uid, current_fsuid()))\n\t\t\tgoto close_fail;\n\t\tif ((inode->i_mode & 0677) != 0600)\n\t\t\tgoto close_fail;\n\t\tif (!(cprm.file->f_mode & FMODE_CAN_WRITE))\n\t\t\tgoto close_fail;\n\t\tif (do_truncate(cprm.file->f_path.dentry, 0, 0, cprm.file))\n\t\t\tgoto close_fail;\n\t}\n\n\t/* get us an unshared descriptor table; almost always a no-op */\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto close_fail;\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\tif (!dump_interrupted()) {\n\t\tfile_start_write(cprm.file);\n\t\tcore_dumped = binfmt->core_dump(&cprm);\n\t\tfile_end_write(cprm.file);\n\t}\n\tif (ispipe && core_pipe_limit)\n\t\twait_for_dump_helpers(cprm.file);\nclose_fail:\n\tif (cprm.file)\n\t\tfilp_close(cprm.file, NULL);\nfail_dropcount:\n\tif (ispipe)\n\t\tatomic_dec(&core_dump_count);\nfail_unlock:\n\tkfree(cn.corename);\n\tcoredump_finish(mm, core_dumped);\n\trevert_creds(old_cred);\nfail_creds:\n\tput_cred(cred);\nfail:\n\treturn;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int core_pipe_limit;",
      "char core_pattern[CORENAME_MAX_SIZE] = \"core\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cred"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "old_cred"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coredump_finish",
          "args": [
            "mm",
            "core_dumped"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "coredump_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "448-474",
          "snippet": "static void coredump_finish(struct mm_struct *mm, bool core_dumped)\n{\n\tstruct core_thread *curr, *next;\n\tstruct task_struct *task;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (core_dumped && !__fatal_signal_pending(current))\n\t\tcurrent->signal->group_exit_code |= 0x80;\n\tcurrent->signal->group_exit_task = NULL;\n\tcurrent->signal->flags = SIGNAL_GROUP_EXIT;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tnext = mm->core_state->dumper.next;\n\twhile ((curr = next) != NULL) {\n\t\tnext = curr->next;\n\t\ttask = curr->task;\n\t\t/*\n\t\t * see exit_mm(), curr->task must not see\n\t\t * ->task == NULL before we read ->next.\n\t\t */\n\t\tsmp_mb();\n\t\tcurr->task = NULL;\n\t\twake_up_process(task);\n\t}\n\n\tmm->core_state = NULL;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void coredump_finish(struct mm_struct *mm, bool core_dumped)\n{\n\tstruct core_thread *curr, *next;\n\tstruct task_struct *task;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (core_dumped && !__fatal_signal_pending(current))\n\t\tcurrent->signal->group_exit_code |= 0x80;\n\tcurrent->signal->group_exit_task = NULL;\n\tcurrent->signal->flags = SIGNAL_GROUP_EXIT;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tnext = mm->core_state->dumper.next;\n\twhile ((curr = next) != NULL) {\n\t\tnext = curr->next;\n\t\ttask = curr->task;\n\t\t/*\n\t\t * see exit_mm(), curr->task must not see\n\t\t * ->task == NULL before we read ->next.\n\t\t */\n\t\tsmp_mb();\n\t\tcurr->task = NULL;\n\t\twake_up_process(task);\n\t}\n\n\tmm->core_state = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cn.corename"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&core_dump_count"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "cprm.file",
            "NULL"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1130-1148",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_dump_helpers",
          "args": [
            "cprm.file"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_dump_helpers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "487-508",
          "snippet": "static void wait_for_dump_helpers(struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\tpipe_lock(pipe);\n\tpipe->readers++;\n\tpipe->writers--;\n\twake_up_interruptible_sync(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\tpipe_unlock(pipe);\n\n\t/*\n\t * We actually want wait_event_freezable() but then we need\n\t * to clear TIF_SIGPENDING and improve dump_interrupted().\n\t */\n\twait_event_interruptible(pipe->wait, pipe->readers == 1);\n\n\tpipe_lock(pipe);\n\tpipe->readers--;\n\tpipe->writers++;\n\tpipe_unlock(pipe);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;\n\nstatic void wait_for_dump_helpers(struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\tpipe_lock(pipe);\n\tpipe->readers++;\n\tpipe->writers--;\n\twake_up_interruptible_sync(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\tpipe_unlock(pipe);\n\n\t/*\n\t * We actually want wait_event_freezable() but then we need\n\t * to clear TIF_SIGPENDING and improve dump_interrupted().\n\t */\n\twait_event_interruptible(pipe->wait, pipe->readers == 1);\n\n\tpipe_lock(pipe);\n\tpipe->readers--;\n\tpipe->writers++;\n\tpipe_unlock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "cprm.file"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "binfmt->core_dump",
          "args": [
            "&cprm"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "cprm.file"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_interrupted",
          "args": [],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "dump_interrupted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "476-485",
          "snippet": "static bool dump_interrupted(void)\n{\n\t/*\n\t * SIGKILL or freezing() interrupt the coredumping. Perhaps we\n\t * can do try_to_freeze() and check __fatal_signal_pending(),\n\t * but then we need to teach dump_write() to restart and clear\n\t * TIF_SIGPENDING.\n\t */\n\treturn signal_pending(current);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;\n\nstatic bool dump_interrupted(void)\n{\n\t/*\n\t * SIGKILL or freezing() interrupt the coredumping. Perhaps we\n\t * can do try_to_freeze() and check __fatal_signal_pending(),\n\t * but then we need to teach dump_write() to restart and clear\n\t * TIF_SIGPENDING.\n\t */\n\treturn signal_pending(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "displaced"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "413-423",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unshare_files",
          "args": [
            "&displaced"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_truncate",
          "args": [
            "cprm.file->f_path.dentry",
            "0",
            "0",
            "cprm.file"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "do_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "37-66",
          "snippet": "int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,\n\tstruct file *filp)\n{\n\tint ret;\n\tstruct iattr newattrs;\n\n\t/* Not pretty: \"inode->i_size\" shouldn't really be signed. But it is. */\n\tif (length < 0)\n\t\treturn -EINVAL;\n\n\tnewattrs.ia_size = length;\n\tnewattrs.ia_valid = ATTR_SIZE | time_attrs;\n\tif (filp) {\n\t\tnewattrs.ia_file = filp;\n\t\tnewattrs.ia_valid |= ATTR_FILE;\n\t}\n\n\t/* Remove suid, sgid, and file capabilities on truncate too */\n\tret = dentry_needs_remove_privs(dentry);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret)\n\t\tnewattrs.ia_valid |= ret | ATTR_FORCE;\n\n\tinode_lock(dentry->d_inode);\n\t/* Note any delegations or leases have already been broken: */\n\tret = notify_change(dentry, &newattrs, NULL);\n\tinode_unlock(dentry->d_inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "inode->i_uid",
            "current_fsuid()"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "cprm.file->f_path.dentry"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "cprm.file"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cprm.file"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_open",
          "args": [
            "cn.corename",
            "open_flags",
            "0600"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1024-1034",
          "snippet": "struct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&root"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "482-486",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_open_root",
          "args": [
            "root.dentry",
            "root.mnt",
            "cn.corename",
            "open_flags",
            "0600"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "file_open_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1037-1045",
          "snippet": "struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags, umode_t mode)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, mode, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "&init_task"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_root",
          "args": [
            "init_task.fs",
            "&root"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "get_fs_root_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/d_path.c",
          "lines": "230-238",
          "snippet": "static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include <linux/prefetch.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include <linux/prefetch.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/fs_struct.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "&init_task"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_unlinkat",
          "args": [
            "AT_FDCWD",
            "getname_kernel(cn.corename)"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "do_unlinkat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "4026-4095",
          "snippet": "long do_unlinkat(int dfd, struct filename *name)\n{\n\tint error;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tstruct inode *inode = NULL;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\terror = -EISDIR;\n\tif (type != LAST_NORM)\n\t\tgoto exit1;\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit1;\nretry_deleg:\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (last.name[last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (d_is_negative(dentry))\n\t\t\tgoto slashes;\n\t\tihold(inode);\n\t\terror = security_path_unlink(&path, dentry);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = vfs_unlink(path.dentry->d_inode, dentry, &delegated_inode);\nexit2:\n\t\tdput(dentry);\n\t}\n\tinode_unlock(path.dentry->d_inode);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\n\tinode = NULL;\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path.mnt);\nexit1:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tinode = NULL;\n\t\tgoto retry;\n\t}\n\tputname(name);\n\treturn error;\n\nslashes:\n\tif (d_is_negative(dentry))\n\t\terror = -ENOENT;\n\telse if (d_is_dir(dentry))\n\t\terror = -EISDIR;\n\telse\n\t\terror = -ENOTDIR;\n\tgoto exit2;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nlong do_unlinkat(int dfd, struct filename *name)\n{\n\tint error;\n\tstruct dentry *dentry;\n\tstruct path path;\n\tstruct qstr last;\n\tint type;\n\tstruct inode *inode = NULL;\n\tstruct inode *delegated_inode = NULL;\n\tunsigned int lookup_flags = 0;\nretry:\n\tname = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\n\terror = -EISDIR;\n\tif (type != LAST_NORM)\n\t\tgoto exit1;\n\n\terror = mnt_want_write(path.mnt);\n\tif (error)\n\t\tgoto exit1;\nretry_deleg:\n\tinode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);\n\tdentry = __lookup_hash(&last, path.dentry, lookup_flags);\n\terror = PTR_ERR(dentry);\n\tif (!IS_ERR(dentry)) {\n\t\t/* Why not before? Because we want correct error value */\n\t\tif (last.name[last.len])\n\t\t\tgoto slashes;\n\t\tinode = dentry->d_inode;\n\t\tif (d_is_negative(dentry))\n\t\t\tgoto slashes;\n\t\tihold(inode);\n\t\terror = security_path_unlink(&path, dentry);\n\t\tif (error)\n\t\t\tgoto exit2;\n\t\terror = vfs_unlink(path.dentry->d_inode, dentry, &delegated_inode);\nexit2:\n\t\tdput(dentry);\n\t}\n\tinode_unlock(path.dentry->d_inode);\n\tif (inode)\n\t\tiput(inode);\t/* truncate the inode here */\n\tinode = NULL;\n\tif (delegated_inode) {\n\t\terror = break_deleg_wait(&delegated_inode);\n\t\tif (!error)\n\t\t\tgoto retry_deleg;\n\t}\n\tmnt_drop_write(path.mnt);\nexit1:\n\tpath_put(&path);\n\tif (retry_estale(error, lookup_flags)) {\n\t\tlookup_flags |= LOOKUP_REVAL;\n\t\tinode = NULL;\n\t\tgoto retry;\n\t}\n\tputname(name);\n\treturn error;\n\nslashes:\n\tif (d_is_negative(dentry))\n\t\terror = -ENOENT;\n\telse if (d_is_dir(dentry))\n\t\terror = -EISDIR;\n\telse\n\t\terror = -ENOTDIR;\n\tgoto exit2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getname_kernel",
          "args": [
            "cn.corename"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "getname_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namei.c",
          "lines": "214-248",
          "snippet": "struct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/build_bug.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/init_task.h>",
            "#include <linux/bitops.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/build_bug.h>\n#include <linux/uaccess.h>\n#include <linux/init_task.h>\n#include <linux/bitops.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - offsetof(struct filename, iname))\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)result->iname;\n\t} else if (len <= PATH_MAX) {\n\t\tconst size_t size = offsetof(struct filename, iname[1]);\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(size, GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Skipping core dump\\n\""
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "current"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Core dump to |%s pipe failed\\n\"",
            "cn.corename"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "argv_free",
          "args": [
            "helper_argv"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_exec",
          "args": [
            "sub_info",
            "UMH_WAIT_EXEC"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_setup",
          "args": [
            "helper_argv[0]",
            "helper_argv",
            "NULL",
            "GFP_KERNEL",
            "umh_pipe_setup",
            "NULL",
            "&cprm"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "argv_split",
          "args": [
            "GFP_KERNEL",
            "cn.corename",
            "NULL"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "current"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&core_dump_count"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "current"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_corename",
          "args": [
            "&cn",
            "&cprm"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "format_corename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "190-310",
          "snippet": "static int format_corename(struct core_name *cn, struct coredump_params *cprm)\n{\n\tconst struct cred *cred = current_cred();\n\tconst char *pat_ptr = core_pattern;\n\tint ispipe = (*pat_ptr == '|');\n\tint pid_in_pattern = 0;\n\tint err = 0;\n\n\tcn->used = 0;\n\tcn->corename = NULL;\n\tif (expand_corename(cn, core_name_size))\n\t\treturn -ENOMEM;\n\tcn->corename[0] = '\\0';\n\n\tif (ispipe)\n\t\t++pat_ptr;\n\n\t/* Repeat as long as we have more pattern to process and more output\n\t   space */\n\twhile (*pat_ptr) {\n\t\tif (*pat_ptr != '%') {\n\t\t\terr = cn_printf(cn, \"%c\", *pat_ptr++);\n\t\t} else {\n\t\t\tswitch (*++pat_ptr) {\n\t\t\t/* single % at the end, drop that */\n\t\t\tcase 0:\n\t\t\t\tgoto out;\n\t\t\t/* Double percent, output one percent */\n\t\t\tcase '%':\n\t\t\t\terr = cn_printf(cn, \"%c\", '%');\n\t\t\t\tbreak;\n\t\t\t/* pid */\n\t\t\tcase 'p':\n\t\t\t\tpid_in_pattern = 1;\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_vnr(current));\n\t\t\t\tbreak;\n\t\t\t/* global pid */\n\t\t\tcase 'P':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_nr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_vnr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_nr(current));\n\t\t\t\tbreak;\n\t\t\t/* uid */\n\t\t\tcase 'u':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->uid));\n\t\t\t\tbreak;\n\t\t\t/* gid */\n\t\t\tcase 'g':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->gid));\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t__get_dumpable(cprm->mm_flags));\n\t\t\t\tbreak;\n\t\t\t/* signal that caused the coredump */\n\t\t\tcase 's':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t\tcprm->siginfo->si_signo);\n\t\t\t\tbreak;\n\t\t\t/* UNIX time of coredump */\n\t\t\tcase 't': {\n\t\t\t\ttime64_t time;\n\n\t\t\t\ttime = ktime_get_real_seconds();\n\t\t\t\terr = cn_printf(cn, \"%lld\", time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* hostname */\n\t\t\tcase 'h':\n\t\t\t\tdown_read(&uts_sem);\n\t\t\t\terr = cn_esc_printf(cn, \"%s\",\n\t\t\t\t\t      utsname()->nodename);\n\t\t\t\tup_read(&uts_sem);\n\t\t\t\tbreak;\n\t\t\t/* executable */\n\t\t\tcase 'e':\n\t\t\t\terr = cn_esc_printf(cn, \"%s\", current->comm);\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\terr = cn_print_exe_file(cn);\n\t\t\t\tbreak;\n\t\t\t/* core limit size */\n\t\t\tcase 'c':\n\t\t\t\terr = cn_printf(cn, \"%lu\",\n\t\t\t\t\t      rlimit(RLIMIT_CORE));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pat_ptr;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nout:\n\t/* Backward compatibility with core_uses_pid:\n\t *\n\t * If core_pattern does not include a %p (as is the default)\n\t * and core_uses_pid is set, then .%pid will be appended to\n\t * the filename. Do not do this for piped commands. */\n\tif (!ispipe && !pid_in_pattern && core_uses_pid) {\n\t\terr = cn_printf(cn, \".%d\", task_tgid_vnr(current));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn ispipe;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int core_uses_pid;",
            "char core_pattern[CORENAME_MAX_SIZE] = \"core\";",
            "static int core_name_size = CORENAME_MAX_SIZE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint core_uses_pid;\nchar core_pattern[CORENAME_MAX_SIZE] = \"core\";\nstatic int core_name_size = CORENAME_MAX_SIZE;\n\nstatic int format_corename(struct core_name *cn, struct coredump_params *cprm)\n{\n\tconst struct cred *cred = current_cred();\n\tconst char *pat_ptr = core_pattern;\n\tint ispipe = (*pat_ptr == '|');\n\tint pid_in_pattern = 0;\n\tint err = 0;\n\n\tcn->used = 0;\n\tcn->corename = NULL;\n\tif (expand_corename(cn, core_name_size))\n\t\treturn -ENOMEM;\n\tcn->corename[0] = '\\0';\n\n\tif (ispipe)\n\t\t++pat_ptr;\n\n\t/* Repeat as long as we have more pattern to process and more output\n\t   space */\n\twhile (*pat_ptr) {\n\t\tif (*pat_ptr != '%') {\n\t\t\terr = cn_printf(cn, \"%c\", *pat_ptr++);\n\t\t} else {\n\t\t\tswitch (*++pat_ptr) {\n\t\t\t/* single % at the end, drop that */\n\t\t\tcase 0:\n\t\t\t\tgoto out;\n\t\t\t/* Double percent, output one percent */\n\t\t\tcase '%':\n\t\t\t\terr = cn_printf(cn, \"%c\", '%');\n\t\t\t\tbreak;\n\t\t\t/* pid */\n\t\t\tcase 'p':\n\t\t\t\tpid_in_pattern = 1;\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_vnr(current));\n\t\t\t\tbreak;\n\t\t\t/* global pid */\n\t\t\tcase 'P':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_nr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_vnr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_nr(current));\n\t\t\t\tbreak;\n\t\t\t/* uid */\n\t\t\tcase 'u':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->uid));\n\t\t\t\tbreak;\n\t\t\t/* gid */\n\t\t\tcase 'g':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->gid));\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t__get_dumpable(cprm->mm_flags));\n\t\t\t\tbreak;\n\t\t\t/* signal that caused the coredump */\n\t\t\tcase 's':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t\tcprm->siginfo->si_signo);\n\t\t\t\tbreak;\n\t\t\t/* UNIX time of coredump */\n\t\t\tcase 't': {\n\t\t\t\ttime64_t time;\n\n\t\t\t\ttime = ktime_get_real_seconds();\n\t\t\t\terr = cn_printf(cn, \"%lld\", time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* hostname */\n\t\t\tcase 'h':\n\t\t\t\tdown_read(&uts_sem);\n\t\t\t\terr = cn_esc_printf(cn, \"%s\",\n\t\t\t\t\t      utsname()->nodename);\n\t\t\t\tup_read(&uts_sem);\n\t\t\t\tbreak;\n\t\t\t/* executable */\n\t\t\tcase 'e':\n\t\t\t\terr = cn_esc_printf(cn, \"%s\", current->comm);\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\terr = cn_print_exe_file(cn);\n\t\t\t\tbreak;\n\t\t\t/* core limit size */\n\t\t\tcase 'c':\n\t\t\t\terr = cn_printf(cn, \"%lu\",\n\t\t\t\t\t      rlimit(RLIMIT_CORE));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pat_ptr;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nout:\n\t/* Backward compatibility with core_uses_pid:\n\t *\n\t * If core_pattern does not include a %p (as is the default)\n\t * and core_uses_pid is set, then .%pid will be appended to\n\t * the filename. Do not do this for piped commands. */\n\tif (!ispipe && !pid_in_pattern && core_uses_pid) {\n\t\terr = cn_printf(cn, \".%d\", task_tgid_vnr(current));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn ispipe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "cred"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ovl_override_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/overlayfs/util.c",
          "lines": "39-44",
          "snippet": "const struct cred *ovl_override_creds(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\n\treturn override_creds(ofs->creator_cred);\n}",
          "includes": [
            "#include \"overlayfs.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/namei.h>",
            "#include <linux/uuid.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/xattr.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"overlayfs.h\"\n#include <linux/ratelimit.h>\n#include <linux/namei.h>\n#include <linux/uuid.h>\n#include <linux/exportfs.h>\n#include <linux/xattr.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nconst struct cred *ovl_override_creds(struct super_block *sb)\n{\n\tstruct ovl_fs *ofs = sb->s_fs_info;\n\n\treturn override_creds(ofs->creator_cred);\n}"
        }
      },
      {
        "call_info": {
          "callee": "coredump_wait",
          "args": [
            "siginfo->si_signo",
            "&core_state"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "coredump_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "410-446",
          "snippet": "static int coredump_wait(int exit_code, struct core_state *core_state)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->mm;\n\tint core_waiters = -EBUSY;\n\n\tinit_completion(&core_state->startup);\n\tcore_state->dumper.task = tsk;\n\tcore_state->dumper.next = NULL;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (!mm->core_state)\n\t\tcore_waiters = zap_threads(tsk, mm, core_state, exit_code);\n\tup_write(&mm->mmap_sem);\n\n\tif (core_waiters > 0) {\n\t\tstruct core_thread *ptr;\n\n\t\tfreezer_do_not_count();\n\t\twait_for_completion(&core_state->startup);\n\t\tfreezer_count();\n\t\t/*\n\t\t * Wait for all the threads to become inactive, so that\n\t\t * all the thread context (extended register state, like\n\t\t * fpu etc) gets copied to the memory.\n\t\t */\n\t\tptr = core_state->dumper.next;\n\t\twhile (ptr != NULL) {\n\t\t\twait_task_inactive(ptr->task, 0);\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\treturn core_waiters;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int coredump_wait(int exit_code, struct core_state *core_state)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->mm;\n\tint core_waiters = -EBUSY;\n\n\tinit_completion(&core_state->startup);\n\tcore_state->dumper.task = tsk;\n\tcore_state->dumper.next = NULL;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (!mm->core_state)\n\t\tcore_waiters = zap_threads(tsk, mm, core_state, exit_code);\n\tup_write(&mm->mmap_sem);\n\n\tif (core_waiters > 0) {\n\t\tstruct core_thread *ptr;\n\n\t\tfreezer_do_not_count();\n\t\twait_for_completion(&core_state->startup);\n\t\tfreezer_count();\n\t\t/*\n\t\t * Wait for all the threads to become inactive, so that\n\t\t * all the thread context (extended register state, like\n\t\t * fpu etc) gets copied to the memory.\n\t\t */\n\t\tptr = core_state->dumper.next;\n\t\twhile (ptr != NULL) {\n\t\t\twait_task_inactive(ptr->task, 0);\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\treturn core_waiters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_dumpable",
          "args": [
            "cprm.mm_flags"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_dumpable",
          "args": [
            "cprm.mm_flags"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_core_dumps",
          "args": [
            "siginfo->si_signo"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_CORE"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pt_regs",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "0"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nunsigned int core_pipe_limit;\nchar core_pattern[CORENAME_MAX_SIZE] = \"core\";\n\nvoid do_coredump(const kernel_siginfo_t *siginfo)\n{\n\tstruct core_state core_state;\n\tstruct core_name cn;\n\tstruct mm_struct *mm = current->mm;\n\tstruct linux_binfmt * binfmt;\n\tconst struct cred *old_cred;\n\tstruct cred *cred;\n\tint retval = 0;\n\tint ispipe;\n\tstruct files_struct *displaced;\n\t/* require nonrelative corefile path and be extra careful */\n\tbool need_suid_safe = false;\n\tbool core_dumped = false;\n\tstatic atomic_t core_dump_count = ATOMIC_INIT(0);\n\tstruct coredump_params cprm = {\n\t\t.siginfo = siginfo,\n\t\t.regs = signal_pt_regs(),\n\t\t.limit = rlimit(RLIMIT_CORE),\n\t\t/*\n\t\t * We must use the same mm->flags while dumping core to avoid\n\t\t * inconsistency of bit flags, since this flag is not protected\n\t\t * by any locks.\n\t\t */\n\t\t.mm_flags = mm->flags,\n\t};\n\n\taudit_core_dumps(siginfo->si_signo);\n\n\tbinfmt = mm->binfmt;\n\tif (!binfmt || !binfmt->core_dump)\n\t\tgoto fail;\n\tif (!__get_dumpable(cprm.mm_flags))\n\t\tgoto fail;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\tgoto fail;\n\t/*\n\t * We cannot trust fsuid as being the \"true\" uid of the process\n\t * nor do we know its entire history. We only know it was tainted\n\t * so we dump it as root in mode 2, and only into a controlled\n\t * environment (pipe handler or fully qualified path).\n\t */\n\tif (__get_dumpable(cprm.mm_flags) == SUID_DUMP_ROOT) {\n\t\t/* Setuid core dump mode */\n\t\tcred->fsuid = GLOBAL_ROOT_UID;\t/* Dump root private */\n\t\tneed_suid_safe = true;\n\t}\n\n\tretval = coredump_wait(siginfo->si_signo, &core_state);\n\tif (retval < 0)\n\t\tgoto fail_creds;\n\n\told_cred = override_creds(cred);\n\n\tispipe = format_corename(&cn, &cprm);\n\n\tif (ispipe) {\n\t\tint dump_count;\n\t\tchar **helper_argv;\n\t\tstruct subprocess_info *sub_info;\n\n\t\tif (ispipe < 0) {\n\t\t\tprintk(KERN_WARNING \"format_corename failed\\n\");\n\t\t\tprintk(KERN_WARNING \"Aborting core\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\tif (cprm.limit == 1) {\n\t\t\t/* See umh_pipe_setup() which sets RLIMIT_CORE = 1.\n\t\t\t *\n\t\t\t * Normally core limits are irrelevant to pipes, since\n\t\t\t * we're not writing to the file system, but we use\n\t\t\t * cprm.limit of 1 here as a special value, this is a\n\t\t\t * consistent way to catch recursive crashes.\n\t\t\t * We can still crash if the core_pattern binary sets\n\t\t\t * RLIM_CORE = !1, but it runs as root, and can do\n\t\t\t * lots of stupid things.\n\t\t\t *\n\t\t\t * Note that we use task_tgid_vnr here to grab the pid\n\t\t\t * of the process group leader.  That way we get the\n\t\t\t * right pid if a thread in a multi-threaded\n\t\t\t * core_pattern process dies.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"Process %d(%s) has RLIMIT_CORE set to 1\\n\",\n\t\t\t\ttask_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Aborting core\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\t\tcprm.limit = RLIM_INFINITY;\n\n\t\tdump_count = atomic_inc_return(&core_dump_count);\n\t\tif (core_pipe_limit && (core_pipe_limit < dump_count)) {\n\t\t\tprintk(KERN_WARNING \"Pid %d(%s) over core_pipe_limit\\n\",\n\t\t\t       task_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Skipping core dump\\n\");\n\t\t\tgoto fail_dropcount;\n\t\t}\n\n\t\thelper_argv = argv_split(GFP_KERNEL, cn.corename, NULL);\n\t\tif (!helper_argv) {\n\t\t\tprintk(KERN_WARNING \"%s failed to allocate memory\\n\",\n\t\t\t       __func__);\n\t\t\tgoto fail_dropcount;\n\t\t}\n\n\t\tretval = -ENOMEM;\n\t\tsub_info = call_usermodehelper_setup(helper_argv[0],\n\t\t\t\t\t\thelper_argv, NULL, GFP_KERNEL,\n\t\t\t\t\t\tumh_pipe_setup, NULL, &cprm);\n\t\tif (sub_info)\n\t\t\tretval = call_usermodehelper_exec(sub_info,\n\t\t\t\t\t\t\t  UMH_WAIT_EXEC);\n\n\t\targv_free(helper_argv);\n\t\tif (retval) {\n\t\t\tprintk(KERN_INFO \"Core dump to |%s pipe failed\\n\",\n\t\t\t       cn.corename);\n\t\t\tgoto close_fail;\n\t\t}\n\t} else {\n\t\tstruct inode *inode;\n\t\tint open_flags = O_CREAT | O_RDWR | O_NOFOLLOW |\n\t\t\t\t O_LARGEFILE | O_EXCL;\n\n\t\tif (cprm.limit < binfmt->min_coredump)\n\t\t\tgoto fail_unlock;\n\n\t\tif (need_suid_safe && cn.corename[0] != '/') {\n\t\t\tprintk(KERN_WARNING \"Pid %d(%s) can only dump core \"\\\n\t\t\t\t\"to fully qualified path!\\n\",\n\t\t\t\ttask_tgid_vnr(current), current->comm);\n\t\t\tprintk(KERN_WARNING \"Skipping core dump\\n\");\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Unlink the file if it exists unless this is a SUID\n\t\t * binary - in that case, we're running around with root\n\t\t * privs and don't want to unlink another user's coredump.\n\t\t */\n\t\tif (!need_suid_safe) {\n\t\t\t/*\n\t\t\t * If it doesn't exist, that's fine. If there's some\n\t\t\t * other problem, we'll catch it at the filp_open().\n\t\t\t */\n\t\t\tdo_unlinkat(AT_FDCWD, getname_kernel(cn.corename));\n\t\t}\n\n\t\t/*\n\t\t * There is a race between unlinking and creating the\n\t\t * file, but if that causes an EEXIST here, that's\n\t\t * fine - another process raced with us while creating\n\t\t * the corefile, and the other process won. To userspace,\n\t\t * what matters is that at least one of the two processes\n\t\t * writes its coredump successfully, not which one.\n\t\t */\n\t\tif (need_suid_safe) {\n\t\t\t/*\n\t\t\t * Using user namespaces, normal user tasks can change\n\t\t\t * their current->fs->root to point to arbitrary\n\t\t\t * directories. Since the intention of the \"only dump\n\t\t\t * with a fully qualified path\" rule is to control where\n\t\t\t * coredumps may be placed using root privileges,\n\t\t\t * current->fs->root must not be used. Instead, use the\n\t\t\t * root directory of init_task.\n\t\t\t */\n\t\t\tstruct path root;\n\n\t\t\ttask_lock(&init_task);\n\t\t\tget_fs_root(init_task.fs, &root);\n\t\t\ttask_unlock(&init_task);\n\t\t\tcprm.file = file_open_root(root.dentry, root.mnt,\n\t\t\t\tcn.corename, open_flags, 0600);\n\t\t\tpath_put(&root);\n\t\t} else {\n\t\t\tcprm.file = filp_open(cn.corename, open_flags, 0600);\n\t\t}\n\t\tif (IS_ERR(cprm.file))\n\t\t\tgoto fail_unlock;\n\n\t\tinode = file_inode(cprm.file);\n\t\tif (inode->i_nlink > 1)\n\t\t\tgoto close_fail;\n\t\tif (d_unhashed(cprm.file->f_path.dentry))\n\t\t\tgoto close_fail;\n\t\t/*\n\t\t * AK: actually i see no reason to not allow this for named\n\t\t * pipes etc, but keep the previous behaviour for now.\n\t\t */\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\tgoto close_fail;\n\t\t/*\n\t\t * Don't dump core if the filesystem changed owner or mode\n\t\t * of the file during file creation. This is an issue when\n\t\t * a process dumps core while its cwd is e.g. on a vfat\n\t\t * filesystem.\n\t\t */\n\t\tif (!uid_eq(inode->i_uid, current_fsuid()))\n\t\t\tgoto close_fail;\n\t\tif ((inode->i_mode & 0677) != 0600)\n\t\t\tgoto close_fail;\n\t\tif (!(cprm.file->f_mode & FMODE_CAN_WRITE))\n\t\t\tgoto close_fail;\n\t\tif (do_truncate(cprm.file->f_path.dentry, 0, 0, cprm.file))\n\t\t\tgoto close_fail;\n\t}\n\n\t/* get us an unshared descriptor table; almost always a no-op */\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto close_fail;\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\tif (!dump_interrupted()) {\n\t\tfile_start_write(cprm.file);\n\t\tcore_dumped = binfmt->core_dump(&cprm);\n\t\tfile_end_write(cprm.file);\n\t}\n\tif (ispipe && core_pipe_limit)\n\t\twait_for_dump_helpers(cprm.file);\nclose_fail:\n\tif (cprm.file)\n\t\tfilp_close(cprm.file, NULL);\nfail_dropcount:\n\tif (ispipe)\n\t\tatomic_dec(&core_dump_count);\nfail_unlock:\n\tkfree(cn.corename);\n\tcoredump_finish(mm, core_dumped);\n\trevert_creds(old_cred);\nfail_creds:\n\tput_cred(cred);\nfail:\n\treturn;\n}"
  },
  {
    "function_name": "umh_pipe_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "521-537",
    "snippet": "static int umh_pipe_setup(struct subprocess_info *info, struct cred *new)\n{\n\tstruct file *files[2];\n\tstruct coredump_params *cp = (struct coredump_params *)info->data;\n\tint err = create_pipe_files(files, 0);\n\tif (err)\n\t\treturn err;\n\n\tcp->file = files[1];\n\n\terr = replace_fd(0, files[0], 0);\n\tfput(files[0]);\n\t/* and disallow core files too */\n\tcurrent->signal->rlim[RLIMIT_CORE] = (struct rlimit){1, 1};\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "files[0]"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "0",
            "files[0]",
            "0"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "replace_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "852-872",
          "snippet": "int replace_fd(unsigned fd, struct file *file, unsigned flags)\n{\n\tint err;\n\tstruct files_struct *files = current->files;\n\n\tif (!file)\n\t\treturn __close_fd(files, fd);\n\n\tif (fd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, fd);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\treturn do_dup2(files, file, fd, flags);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint replace_fd(unsigned fd, struct file *file, unsigned flags)\n{\n\tint err;\n\tstruct files_struct *files = current->files;\n\n\tif (!file)\n\t\treturn __close_fd(files, fd);\n\n\tif (fd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, fd);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\treturn do_dup2(files, file, fd, flags);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_pipe_files",
          "args": [
            "files",
            "0"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "create_pipe_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "742-771",
          "snippet": "int create_pipe_files(struct file **res, int flags)\n{\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\tf = alloc_file_pseudo(inode, pipe_mnt, \"\",\n\t\t\t\tO_WRONLY | (flags & (O_NONBLOCK | O_DIRECT)),\n\t\t\t\t&pipefifo_fops);\n\tif (IS_ERR(f)) {\n\t\tfree_pipe_info(inode->i_pipe);\n\t\tiput(inode);\n\t\treturn PTR_ERR(f);\n\t}\n\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file_clone(f, O_RDONLY | (flags & O_NONBLOCK),\n\t\t\t\t  &pipefifo_fops);\n\tif (IS_ERR(res[0])) {\n\t\tput_pipe_info(inode, inode->i_pipe);\n\t\tfput(f);\n\t\treturn PTR_ERR(res[0]);\n\t}\n\tres[0]->private_data = inode->i_pipe;\n\tres[1] = f;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read_iter\t= pipe_read,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nint create_pipe_files(struct file **res, int flags)\n{\n\tstruct inode *inode = get_pipe_inode();\n\tstruct file *f;\n\n\tif (!inode)\n\t\treturn -ENFILE;\n\n\tf = alloc_file_pseudo(inode, pipe_mnt, \"\",\n\t\t\t\tO_WRONLY | (flags & (O_NONBLOCK | O_DIRECT)),\n\t\t\t\t&pipefifo_fops);\n\tif (IS_ERR(f)) {\n\t\tfree_pipe_info(inode->i_pipe);\n\t\tiput(inode);\n\t\treturn PTR_ERR(f);\n\t}\n\n\tf->private_data = inode->i_pipe;\n\n\tres[0] = alloc_file_clone(f, O_RDONLY | (flags & O_NONBLOCK),\n\t\t\t\t  &pipefifo_fops);\n\tif (IS_ERR(res[0])) {\n\t\tput_pipe_info(inode, inode->i_pipe);\n\t\tfput(f);\n\t\treturn PTR_ERR(res[0]);\n\t}\n\tres[0]->private_data = inode->i_pipe;\n\tres[1] = f;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int umh_pipe_setup(struct subprocess_info *info, struct cred *new)\n{\n\tstruct file *files[2];\n\tstruct coredump_params *cp = (struct coredump_params *)info->data;\n\tint err = create_pipe_files(files, 0);\n\tif (err)\n\t\treturn err;\n\n\tcp->file = files[1];\n\n\terr = replace_fd(0, files[0], 0);\n\tfput(files[0]);\n\t/* and disallow core files too */\n\tcurrent->signal->rlim[RLIMIT_CORE] = (struct rlimit){1, 1};\n\n\treturn err;\n}"
  },
  {
    "function_name": "wait_for_dump_helpers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "487-508",
    "snippet": "static void wait_for_dump_helpers(struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\tpipe_lock(pipe);\n\tpipe->readers++;\n\tpipe->writers--;\n\twake_up_interruptible_sync(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\tpipe_unlock(pipe);\n\n\t/*\n\t * We actually want wait_event_freezable() but then we need\n\t * to clear TIF_SIGPENDING and improve dump_interrupted().\n\t */\n\twait_event_interruptible(pipe->wait, pipe->readers == 1);\n\n\tpipe_lock(pipe);\n\tpipe->readers--;\n\tpipe->writers++;\n\tpipe_unlock(pipe);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "86-89",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pipe.c",
          "lines": "81-84",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <linux/uaccess.h>\n#include <linux/memcontrol.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event_interruptible",
          "args": [
            "pipe->wait",
            "pipe->readers == 1"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_readers",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "1014-1024",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync",
          "args": [
            "&pipe->wait"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;\n\nstatic void wait_for_dump_helpers(struct file *file)\n{\n\tstruct pipe_inode_info *pipe = file->private_data;\n\n\tpipe_lock(pipe);\n\tpipe->readers++;\n\tpipe->writers--;\n\twake_up_interruptible_sync(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\tpipe_unlock(pipe);\n\n\t/*\n\t * We actually want wait_event_freezable() but then we need\n\t * to clear TIF_SIGPENDING and improve dump_interrupted().\n\t */\n\twait_event_interruptible(pipe->wait, pipe->readers == 1);\n\n\tpipe_lock(pipe);\n\tpipe->readers--;\n\tpipe->writers++;\n\tpipe_unlock(pipe);\n}"
  },
  {
    "function_name": "dump_interrupted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "476-485",
    "snippet": "static bool dump_interrupted(void)\n{\n\t/*\n\t * SIGKILL or freezing() interrupt the coredumping. Perhaps we\n\t * can do try_to_freeze() and check __fatal_signal_pending(),\n\t * but then we need to teach dump_write() to restart and clear\n\t * TIF_SIGPENDING.\n\t */\n\treturn signal_pending(current);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic __printf(2, 0) int cn_vprintf(struct core_name *cn, const char *fmt,\n\t\t\t\t     va_list arg)\n{\n\tint free, need;\n\nstatic bool dump_interrupted(void)\n{\n\t/*\n\t * SIGKILL or freezing() interrupt the coredumping. Perhaps we\n\t * can do try_to_freeze() and check __fatal_signal_pending(),\n\t * but then we need to teach dump_write() to restart and clear\n\t * TIF_SIGPENDING.\n\t */\n\treturn signal_pending(current);\n}"
  },
  {
    "function_name": "coredump_finish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "448-474",
    "snippet": "static void coredump_finish(struct mm_struct *mm, bool core_dumped)\n{\n\tstruct core_thread *curr, *next;\n\tstruct task_struct *task;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (core_dumped && !__fatal_signal_pending(current))\n\t\tcurrent->signal->group_exit_code |= 0x80;\n\tcurrent->signal->group_exit_task = NULL;\n\tcurrent->signal->flags = SIGNAL_GROUP_EXIT;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tnext = mm->core_state->dumper.next;\n\twhile ((curr = next) != NULL) {\n\t\tnext = curr->next;\n\t\ttask = curr->task;\n\t\t/*\n\t\t * see exit_mm(), curr->task must not see\n\t\t * ->task == NULL before we read ->next.\n\t\t */\n\t\tsmp_mb();\n\t\tcurr->task = NULL;\n\t\twake_up_process(task);\n\t}\n\n\tmm->core_state = NULL;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "task"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void coredump_finish(struct mm_struct *mm, bool core_dumped)\n{\n\tstruct core_thread *curr, *next;\n\tstruct task_struct *task;\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tif (core_dumped && !__fatal_signal_pending(current))\n\t\tcurrent->signal->group_exit_code |= 0x80;\n\tcurrent->signal->group_exit_task = NULL;\n\tcurrent->signal->flags = SIGNAL_GROUP_EXIT;\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\tnext = mm->core_state->dumper.next;\n\twhile ((curr = next) != NULL) {\n\t\tnext = curr->next;\n\t\ttask = curr->task;\n\t\t/*\n\t\t * see exit_mm(), curr->task must not see\n\t\t * ->task == NULL before we read ->next.\n\t\t */\n\t\tsmp_mb();\n\t\tcurr->task = NULL;\n\t\twake_up_process(task);\n\t}\n\n\tmm->core_state = NULL;\n}"
  },
  {
    "function_name": "coredump_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "410-446",
    "snippet": "static int coredump_wait(int exit_code, struct core_state *core_state)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->mm;\n\tint core_waiters = -EBUSY;\n\n\tinit_completion(&core_state->startup);\n\tcore_state->dumper.task = tsk;\n\tcore_state->dumper.next = NULL;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (!mm->core_state)\n\t\tcore_waiters = zap_threads(tsk, mm, core_state, exit_code);\n\tup_write(&mm->mmap_sem);\n\n\tif (core_waiters > 0) {\n\t\tstruct core_thread *ptr;\n\n\t\tfreezer_do_not_count();\n\t\twait_for_completion(&core_state->startup);\n\t\tfreezer_count();\n\t\t/*\n\t\t * Wait for all the threads to become inactive, so that\n\t\t * all the thread context (extended register state, like\n\t\t * fpu etc) gets copied to the memory.\n\t\t */\n\t\tptr = core_state->dumper.next;\n\t\twhile (ptr != NULL) {\n\t\t\twait_task_inactive(ptr->task, 0);\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\treturn core_waiters;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_task_inactive",
          "args": [
            "ptr->task",
            "0"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezer_count",
          "args": [],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&core_state->startup"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezer_do_not_count",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_threads",
          "args": [
            "tsk",
            "mm",
            "core_state",
            "exit_code"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "zap_threads",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "334-408",
          "snippet": "static int zap_threads(struct task_struct *tsk, struct mm_struct *mm,\n\t\t\tstruct core_state *core_state, int exit_code)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long flags;\n\tint nr = -EAGAIN;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!signal_group_exit(tsk->signal)) {\n\t\tmm->core_state = core_state;\n\t\ttsk->signal->group_exit_task = tsk;\n\t\tnr = zap_process(tsk, exit_code, 0);\n\t\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (unlikely(nr < 0))\n\t\treturn nr;\n\n\ttsk->flags |= PF_DUMPCORE;\n\tif (atomic_read(&mm->mm_users) == nr + 1)\n\t\tgoto done;\n\t/*\n\t * We should find and kill all tasks which use this mm, and we should\n\t * count them correctly into ->nr_threads. We don't take tasklist\n\t * lock, but this is safe wrt:\n\t *\n\t * fork:\n\t *\tNone of sub-threads can fork after zap_process(leader). All\n\t *\tprocesses which were created before this point should be\n\t *\tvisible to zap_threads() because copy_process() adds the new\n\t *\tprocess to the tail of init_task.tasks list, and lock/unlock\n\t *\tof ->siglock provides a memory barrier.\n\t *\n\t * do_exit:\n\t *\tThe caller holds mm->mmap_sem. This means that the task which\n\t *\tuses this mm can't pass exit_mm(), so it can't exit or clear\n\t *\tits ->mm.\n\t *\n\t * de_thread:\n\t *\tIt does list_replace_rcu(&leader->tasks, &current->tasks),\n\t *\twe must see either old or new leader, this does not matter.\n\t *\tHowever, it can change p->sighand, so lock_task_sighand(p)\n\t *\tmust be used. Since p->mm != NULL and we hold ->mmap_sem\n\t *\tit can't fail.\n\t *\n\t *\tNote also that \"g\" can be the old leader with ->mm == NULL\n\t *\tand already unhashed and thus removed from ->thread_group.\n\t *\tThis is OK, __unhash_process()->list_del_rcu() does not\n\t *\tclear the ->next pointer, we will find the new leader via\n\t *\tnext_thread().\n\t */\n\trcu_read_lock();\n\tfor_each_process(g) {\n\t\tif (g == tsk->group_leader)\n\t\t\tcontinue;\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\tfor_each_thread(g, p) {\n\t\t\tif (unlikely(!p->mm))\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(p->mm == mm)) {\n\t\t\t\tlock_task_sighand(p, &flags);\n\t\t\t\tnr += zap_process(p, exit_code,\n\t\t\t\t\t\t\tSIGNAL_GROUP_EXIT);\n\t\t\t\tunlock_task_sighand(p, &flags);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\ndone:\n\tatomic_set(&core_state->nr_threads, nr);\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int zap_threads(struct task_struct *tsk, struct mm_struct *mm,\n\t\t\tstruct core_state *core_state, int exit_code)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long flags;\n\tint nr = -EAGAIN;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!signal_group_exit(tsk->signal)) {\n\t\tmm->core_state = core_state;\n\t\ttsk->signal->group_exit_task = tsk;\n\t\tnr = zap_process(tsk, exit_code, 0);\n\t\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (unlikely(nr < 0))\n\t\treturn nr;\n\n\ttsk->flags |= PF_DUMPCORE;\n\tif (atomic_read(&mm->mm_users) == nr + 1)\n\t\tgoto done;\n\t/*\n\t * We should find and kill all tasks which use this mm, and we should\n\t * count them correctly into ->nr_threads. We don't take tasklist\n\t * lock, but this is safe wrt:\n\t *\n\t * fork:\n\t *\tNone of sub-threads can fork after zap_process(leader). All\n\t *\tprocesses which were created before this point should be\n\t *\tvisible to zap_threads() because copy_process() adds the new\n\t *\tprocess to the tail of init_task.tasks list, and lock/unlock\n\t *\tof ->siglock provides a memory barrier.\n\t *\n\t * do_exit:\n\t *\tThe caller holds mm->mmap_sem. This means that the task which\n\t *\tuses this mm can't pass exit_mm(), so it can't exit or clear\n\t *\tits ->mm.\n\t *\n\t * de_thread:\n\t *\tIt does list_replace_rcu(&leader->tasks, &current->tasks),\n\t *\twe must see either old or new leader, this does not matter.\n\t *\tHowever, it can change p->sighand, so lock_task_sighand(p)\n\t *\tmust be used. Since p->mm != NULL and we hold ->mmap_sem\n\t *\tit can't fail.\n\t *\n\t *\tNote also that \"g\" can be the old leader with ->mm == NULL\n\t *\tand already unhashed and thus removed from ->thread_group.\n\t *\tThis is OK, __unhash_process()->list_del_rcu() does not\n\t *\tclear the ->next pointer, we will find the new leader via\n\t *\tnext_thread().\n\t */\n\trcu_read_lock();\n\tfor_each_process(g) {\n\t\tif (g == tsk->group_leader)\n\t\t\tcontinue;\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\tfor_each_thread(g, p) {\n\t\t\tif (unlikely(!p->mm))\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(p->mm == mm)) {\n\t\t\t\tlock_task_sighand(p, &flags);\n\t\t\t\tnr += zap_process(p, exit_code,\n\t\t\t\t\t\t\tSIGNAL_GROUP_EXIT);\n\t\t\t\tunlock_task_sighand(p, &flags);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\ndone:\n\tatomic_set(&core_state->nr_threads, nr);\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write_killable",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&core_state->startup"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int coredump_wait(int exit_code, struct core_state *core_state)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->mm;\n\tint core_waiters = -EBUSY;\n\n\tinit_completion(&core_state->startup);\n\tcore_state->dumper.task = tsk;\n\tcore_state->dumper.next = NULL;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tif (!mm->core_state)\n\t\tcore_waiters = zap_threads(tsk, mm, core_state, exit_code);\n\tup_write(&mm->mmap_sem);\n\n\tif (core_waiters > 0) {\n\t\tstruct core_thread *ptr;\n\n\t\tfreezer_do_not_count();\n\t\twait_for_completion(&core_state->startup);\n\t\tfreezer_count();\n\t\t/*\n\t\t * Wait for all the threads to become inactive, so that\n\t\t * all the thread context (extended register state, like\n\t\t * fpu etc) gets copied to the memory.\n\t\t */\n\t\tptr = core_state->dumper.next;\n\t\twhile (ptr != NULL) {\n\t\t\twait_task_inactive(ptr->task, 0);\n\t\t\tptr = ptr->next;\n\t\t}\n\t}\n\n\treturn core_waiters;\n}"
  },
  {
    "function_name": "zap_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "334-408",
    "snippet": "static int zap_threads(struct task_struct *tsk, struct mm_struct *mm,\n\t\t\tstruct core_state *core_state, int exit_code)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long flags;\n\tint nr = -EAGAIN;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!signal_group_exit(tsk->signal)) {\n\t\tmm->core_state = core_state;\n\t\ttsk->signal->group_exit_task = tsk;\n\t\tnr = zap_process(tsk, exit_code, 0);\n\t\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (unlikely(nr < 0))\n\t\treturn nr;\n\n\ttsk->flags |= PF_DUMPCORE;\n\tif (atomic_read(&mm->mm_users) == nr + 1)\n\t\tgoto done;\n\t/*\n\t * We should find and kill all tasks which use this mm, and we should\n\t * count them correctly into ->nr_threads. We don't take tasklist\n\t * lock, but this is safe wrt:\n\t *\n\t * fork:\n\t *\tNone of sub-threads can fork after zap_process(leader). All\n\t *\tprocesses which were created before this point should be\n\t *\tvisible to zap_threads() because copy_process() adds the new\n\t *\tprocess to the tail of init_task.tasks list, and lock/unlock\n\t *\tof ->siglock provides a memory barrier.\n\t *\n\t * do_exit:\n\t *\tThe caller holds mm->mmap_sem. This means that the task which\n\t *\tuses this mm can't pass exit_mm(), so it can't exit or clear\n\t *\tits ->mm.\n\t *\n\t * de_thread:\n\t *\tIt does list_replace_rcu(&leader->tasks, &current->tasks),\n\t *\twe must see either old or new leader, this does not matter.\n\t *\tHowever, it can change p->sighand, so lock_task_sighand(p)\n\t *\tmust be used. Since p->mm != NULL and we hold ->mmap_sem\n\t *\tit can't fail.\n\t *\n\t *\tNote also that \"g\" can be the old leader with ->mm == NULL\n\t *\tand already unhashed and thus removed from ->thread_group.\n\t *\tThis is OK, __unhash_process()->list_del_rcu() does not\n\t *\tclear the ->next pointer, we will find the new leader via\n\t *\tnext_thread().\n\t */\n\trcu_read_lock();\n\tfor_each_process(g) {\n\t\tif (g == tsk->group_leader)\n\t\t\tcontinue;\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\tfor_each_thread(g, p) {\n\t\t\tif (unlikely(!p->mm))\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(p->mm == mm)) {\n\t\t\t\tlock_task_sighand(p, &flags);\n\t\t\t\tnr += zap_process(p, exit_code,\n\t\t\t\t\t\t\tSIGNAL_GROUP_EXIT);\n\t\t\t\tunlock_task_sighand(p, &flags);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\ndone:\n\tatomic_set(&core_state->nr_threads, nr);\n\treturn nr;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&core_state->nr_threads",
            "nr"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_process",
          "args": [
            "p",
            "exit_code",
            "SIGNAL_GROUP_EXIT"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "zap_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "312-332",
          "snippet": "static int zap_process(struct task_struct *start, int exit_code, int flags)\n{\n\tstruct task_struct *t;\n\tint nr = 0;\n\n\t/* ignore all signals except SIGKILL, see prepare_signal() */\n\tstart->signal->flags = SIGNAL_GROUP_COREDUMP | flags;\n\tstart->signal->group_exit_code = exit_code;\n\tstart->signal->group_stop_count = 0;\n\n\tfor_each_thread(start, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tif (t != current && t->mm) {\n\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\tsignal_wake_up(t, 1);\n\t\t\tnr++;\n\t\t}\n\t}\n\n\treturn nr;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int zap_process(struct task_struct *start, int exit_code, int flags)\n{\n\tstruct task_struct *t;\n\tint nr = 0;\n\n\t/* ignore all signals except SIGKILL, see prepare_signal() */\n\tstart->signal->flags = SIGNAL_GROUP_COREDUMP | flags;\n\tstart->signal->group_exit_code = exit_code;\n\tstart->signal->group_stop_count = 0;\n\n\tfor_each_thread(start, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tif (t != current && t->mm) {\n\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\tsignal_wake_up(t, 1);\n\t\t\tnr++;\n\t\t}\n\t}\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->mm == mm"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!p->mm"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&mm->mm_users"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr < 0"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "tsk",
            "TIF_SIGPENDING"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_group_exit",
          "args": [
            "tsk->signal"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int zap_threads(struct task_struct *tsk, struct mm_struct *mm,\n\t\t\tstruct core_state *core_state, int exit_code)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long flags;\n\tint nr = -EAGAIN;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!signal_group_exit(tsk->signal)) {\n\t\tmm->core_state = core_state;\n\t\ttsk->signal->group_exit_task = tsk;\n\t\tnr = zap_process(tsk, exit_code, 0);\n\t\tclear_tsk_thread_flag(tsk, TIF_SIGPENDING);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\tif (unlikely(nr < 0))\n\t\treturn nr;\n\n\ttsk->flags |= PF_DUMPCORE;\n\tif (atomic_read(&mm->mm_users) == nr + 1)\n\t\tgoto done;\n\t/*\n\t * We should find and kill all tasks which use this mm, and we should\n\t * count them correctly into ->nr_threads. We don't take tasklist\n\t * lock, but this is safe wrt:\n\t *\n\t * fork:\n\t *\tNone of sub-threads can fork after zap_process(leader). All\n\t *\tprocesses which were created before this point should be\n\t *\tvisible to zap_threads() because copy_process() adds the new\n\t *\tprocess to the tail of init_task.tasks list, and lock/unlock\n\t *\tof ->siglock provides a memory barrier.\n\t *\n\t * do_exit:\n\t *\tThe caller holds mm->mmap_sem. This means that the task which\n\t *\tuses this mm can't pass exit_mm(), so it can't exit or clear\n\t *\tits ->mm.\n\t *\n\t * de_thread:\n\t *\tIt does list_replace_rcu(&leader->tasks, &current->tasks),\n\t *\twe must see either old or new leader, this does not matter.\n\t *\tHowever, it can change p->sighand, so lock_task_sighand(p)\n\t *\tmust be used. Since p->mm != NULL and we hold ->mmap_sem\n\t *\tit can't fail.\n\t *\n\t *\tNote also that \"g\" can be the old leader with ->mm == NULL\n\t *\tand already unhashed and thus removed from ->thread_group.\n\t *\tThis is OK, __unhash_process()->list_del_rcu() does not\n\t *\tclear the ->next pointer, we will find the new leader via\n\t *\tnext_thread().\n\t */\n\trcu_read_lock();\n\tfor_each_process(g) {\n\t\tif (g == tsk->group_leader)\n\t\t\tcontinue;\n\t\tif (g->flags & PF_KTHREAD)\n\t\t\tcontinue;\n\n\t\tfor_each_thread(g, p) {\n\t\t\tif (unlikely(!p->mm))\n\t\t\t\tcontinue;\n\t\t\tif (unlikely(p->mm == mm)) {\n\t\t\t\tlock_task_sighand(p, &flags);\n\t\t\t\tnr += zap_process(p, exit_code,\n\t\t\t\t\t\t\tSIGNAL_GROUP_EXIT);\n\t\t\t\tunlock_task_sighand(p, &flags);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\ndone:\n\tatomic_set(&core_state->nr_threads, nr);\n\treturn nr;\n}"
  },
  {
    "function_name": "zap_process",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "312-332",
    "snippet": "static int zap_process(struct task_struct *start, int exit_code, int flags)\n{\n\tstruct task_struct *t;\n\tint nr = 0;\n\n\t/* ignore all signals except SIGKILL, see prepare_signal() */\n\tstart->signal->flags = SIGNAL_GROUP_COREDUMP | flags;\n\tstart->signal->group_exit_code = exit_code;\n\tstart->signal->group_stop_count = 0;\n\n\tfor_each_thread(start, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tif (t != current && t->mm) {\n\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\tsignal_wake_up(t, 1);\n\t\t\tnr++;\n\t\t}\n\t}\n\n\treturn nr;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "1"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&t->pending.signal",
            "SIGKILL"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_PENDING_MASK"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "start",
            "t"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int zap_process(struct task_struct *start, int exit_code, int flags)\n{\n\tstruct task_struct *t;\n\tint nr = 0;\n\n\t/* ignore all signals except SIGKILL, see prepare_signal() */\n\tstart->signal->flags = SIGNAL_GROUP_COREDUMP | flags;\n\tstart->signal->group_exit_code = exit_code;\n\tstart->signal->group_stop_count = 0;\n\n\tfor_each_thread(start, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tif (t != current && t->mm) {\n\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\tsignal_wake_up(t, 1);\n\t\t\tnr++;\n\t\t}\n\t}\n\n\treturn nr;\n}"
  },
  {
    "function_name": "format_corename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "190-310",
    "snippet": "static int format_corename(struct core_name *cn, struct coredump_params *cprm)\n{\n\tconst struct cred *cred = current_cred();\n\tconst char *pat_ptr = core_pattern;\n\tint ispipe = (*pat_ptr == '|');\n\tint pid_in_pattern = 0;\n\tint err = 0;\n\n\tcn->used = 0;\n\tcn->corename = NULL;\n\tif (expand_corename(cn, core_name_size))\n\t\treturn -ENOMEM;\n\tcn->corename[0] = '\\0';\n\n\tif (ispipe)\n\t\t++pat_ptr;\n\n\t/* Repeat as long as we have more pattern to process and more output\n\t   space */\n\twhile (*pat_ptr) {\n\t\tif (*pat_ptr != '%') {\n\t\t\terr = cn_printf(cn, \"%c\", *pat_ptr++);\n\t\t} else {\n\t\t\tswitch (*++pat_ptr) {\n\t\t\t/* single % at the end, drop that */\n\t\t\tcase 0:\n\t\t\t\tgoto out;\n\t\t\t/* Double percent, output one percent */\n\t\t\tcase '%':\n\t\t\t\terr = cn_printf(cn, \"%c\", '%');\n\t\t\t\tbreak;\n\t\t\t/* pid */\n\t\t\tcase 'p':\n\t\t\t\tpid_in_pattern = 1;\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_vnr(current));\n\t\t\t\tbreak;\n\t\t\t/* global pid */\n\t\t\tcase 'P':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_nr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_vnr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_nr(current));\n\t\t\t\tbreak;\n\t\t\t/* uid */\n\t\t\tcase 'u':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->uid));\n\t\t\t\tbreak;\n\t\t\t/* gid */\n\t\t\tcase 'g':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->gid));\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t__get_dumpable(cprm->mm_flags));\n\t\t\t\tbreak;\n\t\t\t/* signal that caused the coredump */\n\t\t\tcase 's':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t\tcprm->siginfo->si_signo);\n\t\t\t\tbreak;\n\t\t\t/* UNIX time of coredump */\n\t\t\tcase 't': {\n\t\t\t\ttime64_t time;\n\n\t\t\t\ttime = ktime_get_real_seconds();\n\t\t\t\terr = cn_printf(cn, \"%lld\", time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* hostname */\n\t\t\tcase 'h':\n\t\t\t\tdown_read(&uts_sem);\n\t\t\t\terr = cn_esc_printf(cn, \"%s\",\n\t\t\t\t\t      utsname()->nodename);\n\t\t\t\tup_read(&uts_sem);\n\t\t\t\tbreak;\n\t\t\t/* executable */\n\t\t\tcase 'e':\n\t\t\t\terr = cn_esc_printf(cn, \"%s\", current->comm);\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\terr = cn_print_exe_file(cn);\n\t\t\t\tbreak;\n\t\t\t/* core limit size */\n\t\t\tcase 'c':\n\t\t\t\terr = cn_printf(cn, \"%lu\",\n\t\t\t\t\t      rlimit(RLIMIT_CORE));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pat_ptr;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nout:\n\t/* Backward compatibility with core_uses_pid:\n\t *\n\t * If core_pattern does not include a %p (as is the default)\n\t * and core_uses_pid is set, then .%pid will be appended to\n\t * the filename. Do not do this for piped commands. */\n\tif (!ispipe && !pid_in_pattern && core_uses_pid) {\n\t\terr = cn_printf(cn, \".%d\", task_tgid_vnr(current));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn ispipe;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int core_uses_pid;",
      "char core_pattern[CORENAME_MAX_SIZE] = \"core\";",
      "static int core_name_size = CORENAME_MAX_SIZE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cn_printf",
          "args": [
            "cn",
            "\".%d\"",
            "task_tgid_vnr(current)"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "cn_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "105-115",
          "snippet": "int cn_printf(struct core_name *cn, const char *fmt, ...)\n{\n\tva_list arg;\n\tint ret;\n\n\tva_start(arg, fmt);\n\tret = cn_vprintf(cn, fmt, arg);\n\tva_end(arg);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "va_list arg;",
            "int ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nva_list arg;\nint ret;\n\nint cn_printf(struct core_name *cn, const char *fmt, ...)\n{\n\tva_list arg;\n\tint ret;\n\n\tva_start(arg, fmt);\n\tret = cn_vprintf(cn, fmt, arg);\n\tva_end(arg);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "current"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_CORE"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cn_print_exe_file",
          "args": [
            "cn"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "cn_print_exe_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "155-184",
          "snippet": "static int cn_print_exe_file(struct core_name *cn)\n{\n\tstruct file *exe_file;\n\tchar *pathbuf, *path;\n\tint ret;\n\n\texe_file = get_mm_exe_file(current->mm);\n\tif (!exe_file)\n\t\treturn cn_esc_printf(cn, \"%s (path unknown)\", current->comm);\n\n\tpathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto put_exe_file;\n\t}\n\n\tpath = file_path(exe_file, pathbuf, PATH_MAX);\n\tif (IS_ERR(path)) {\n\t\tret = PTR_ERR(path);\n\t\tgoto free_buf;\n\t}\n\n\tret = cn_esc_printf(cn, \"%s\", path);\n\nfree_buf:\n\tkfree(pathbuf);\nput_exe_file:\n\tfput(exe_file);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint ret;\n\nstatic int cn_print_exe_file(struct core_name *cn)\n{\n\tstruct file *exe_file;\n\tchar *pathbuf, *path;\n\tint ret;\n\n\texe_file = get_mm_exe_file(current->mm);\n\tif (!exe_file)\n\t\treturn cn_esc_printf(cn, \"%s (path unknown)\", current->comm);\n\n\tpathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto put_exe_file;\n\t}\n\n\tpath = file_path(exe_file, pathbuf, PATH_MAX);\n\tif (IS_ERR(path)) {\n\t\tret = PTR_ERR(path);\n\t\tgoto free_buf;\n\t}\n\n\tret = cn_esc_printf(cn, \"%s\", path);\n\nfree_buf:\n\tkfree(pathbuf);\nput_exe_file:\n\tfput(exe_file);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cn_esc_printf",
          "args": [
            "cn",
            "\"%s\"",
            "current->comm"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uts_sem"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cn_esc_printf",
          "args": [
            "cn",
            "\"%s\"",
            "utsname()->nodename"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utsname",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uts_sem"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_dumpable",
          "args": [
            "cprm->mm_flags"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "cred->gid"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "cred->uid"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "current"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_corename",
          "args": [
            "cn",
            "core_name_size"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "expand_corename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
          "lines": "66-79",
          "snippet": "static int expand_corename(struct core_name *cn, int size)\n{\n\tchar *corename = krealloc(cn->corename, size, GFP_KERNEL);\n\n\tif (!corename)\n\t\treturn -ENOMEM;\n\n\tif (size > core_name_size) /* racy but harmless */\n\t\tcore_name_size = size;\n\n\tcn->size = ksize(corename);\n\tcn->corename = corename;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/exec.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/mm.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int core_name_size = CORENAME_MAX_SIZE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int core_name_size = CORENAME_MAX_SIZE;\n\nstatic int expand_corename(struct core_name *cn, int size)\n{\n\tchar *corename = krealloc(cn->corename, size, GFP_KERNEL);\n\n\tif (!corename)\n\t\treturn -ENOMEM;\n\n\tif (size > core_name_size) /* racy but harmless */\n\t\tcore_name_size = size;\n\n\tcn->size = ksize(corename);\n\tcn->corename = corename;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint core_uses_pid;\nchar core_pattern[CORENAME_MAX_SIZE] = \"core\";\nstatic int core_name_size = CORENAME_MAX_SIZE;\n\nstatic int format_corename(struct core_name *cn, struct coredump_params *cprm)\n{\n\tconst struct cred *cred = current_cred();\n\tconst char *pat_ptr = core_pattern;\n\tint ispipe = (*pat_ptr == '|');\n\tint pid_in_pattern = 0;\n\tint err = 0;\n\n\tcn->used = 0;\n\tcn->corename = NULL;\n\tif (expand_corename(cn, core_name_size))\n\t\treturn -ENOMEM;\n\tcn->corename[0] = '\\0';\n\n\tif (ispipe)\n\t\t++pat_ptr;\n\n\t/* Repeat as long as we have more pattern to process and more output\n\t   space */\n\twhile (*pat_ptr) {\n\t\tif (*pat_ptr != '%') {\n\t\t\terr = cn_printf(cn, \"%c\", *pat_ptr++);\n\t\t} else {\n\t\t\tswitch (*++pat_ptr) {\n\t\t\t/* single % at the end, drop that */\n\t\t\tcase 0:\n\t\t\t\tgoto out;\n\t\t\t/* Double percent, output one percent */\n\t\t\tcase '%':\n\t\t\t\terr = cn_printf(cn, \"%c\", '%');\n\t\t\t\tbreak;\n\t\t\t/* pid */\n\t\t\tcase 'p':\n\t\t\t\tpid_in_pattern = 1;\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_vnr(current));\n\t\t\t\tbreak;\n\t\t\t/* global pid */\n\t\t\tcase 'P':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_tgid_nr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_vnr(current));\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t      task_pid_nr(current));\n\t\t\t\tbreak;\n\t\t\t/* uid */\n\t\t\tcase 'u':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->uid));\n\t\t\t\tbreak;\n\t\t\t/* gid */\n\t\t\tcase 'g':\n\t\t\t\terr = cn_printf(cn, \"%u\",\n\t\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\t\t  cred->gid));\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t__get_dumpable(cprm->mm_flags));\n\t\t\t\tbreak;\n\t\t\t/* signal that caused the coredump */\n\t\t\tcase 's':\n\t\t\t\terr = cn_printf(cn, \"%d\",\n\t\t\t\t\t\tcprm->siginfo->si_signo);\n\t\t\t\tbreak;\n\t\t\t/* UNIX time of coredump */\n\t\t\tcase 't': {\n\t\t\t\ttime64_t time;\n\n\t\t\t\ttime = ktime_get_real_seconds();\n\t\t\t\terr = cn_printf(cn, \"%lld\", time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* hostname */\n\t\t\tcase 'h':\n\t\t\t\tdown_read(&uts_sem);\n\t\t\t\terr = cn_esc_printf(cn, \"%s\",\n\t\t\t\t\t      utsname()->nodename);\n\t\t\t\tup_read(&uts_sem);\n\t\t\t\tbreak;\n\t\t\t/* executable */\n\t\t\tcase 'e':\n\t\t\t\terr = cn_esc_printf(cn, \"%s\", current->comm);\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\terr = cn_print_exe_file(cn);\n\t\t\t\tbreak;\n\t\t\t/* core limit size */\n\t\t\tcase 'c':\n\t\t\t\terr = cn_printf(cn, \"%lu\",\n\t\t\t\t\t      rlimit(RLIMIT_CORE));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++pat_ptr;\n\t\t}\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\nout:\n\t/* Backward compatibility with core_uses_pid:\n\t *\n\t * If core_pattern does not include a %p (as is the default)\n\t * and core_uses_pid is set, then .%pid will be appended to\n\t * the filename. Do not do this for piped commands. */\n\tif (!ispipe && !pid_in_pattern && core_uses_pid) {\n\t\terr = cn_printf(cn, \".%d\", task_tgid_vnr(current));\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn ispipe;\n}"
  },
  {
    "function_name": "cn_print_exe_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "155-184",
    "snippet": "static int cn_print_exe_file(struct core_name *cn)\n{\n\tstruct file *exe_file;\n\tchar *pathbuf, *path;\n\tint ret;\n\n\texe_file = get_mm_exe_file(current->mm);\n\tif (!exe_file)\n\t\treturn cn_esc_printf(cn, \"%s (path unknown)\", current->comm);\n\n\tpathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto put_exe_file;\n\t}\n\n\tpath = file_path(exe_file, pathbuf, PATH_MAX);\n\tif (IS_ERR(path)) {\n\t\tret = PTR_ERR(path);\n\t\tgoto free_buf;\n\t}\n\n\tret = cn_esc_printf(cn, \"%s\", path);\n\nfree_buf:\n\tkfree(pathbuf);\nput_exe_file:\n\tfput(exe_file);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "exe_file"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathbuf"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cn_esc_printf",
          "args": [
            "cn",
            "\"%s\"",
            "path"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "path"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "path"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_path",
          "args": [
            "exe_file",
            "pathbuf",
            "PATH_MAX"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "seq_file_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "480-483",
          "snippet": "int seq_file_path(struct seq_file *m, struct file *file, const char *esc)\n{\n\treturn seq_path(m, &file->f_path, esc);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nint seq_file_path(struct seq_file *m, struct file *file, const char *esc)\n{\n\treturn seq_path(m, &file->f_path, esc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cn_esc_printf",
          "args": [
            "cn",
            "\"%s (path unknown)\"",
            "current->comm"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_exe_file",
          "args": [
            "current->mm"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint ret;\n\nstatic int cn_print_exe_file(struct core_name *cn)\n{\n\tstruct file *exe_file;\n\tchar *pathbuf, *path;\n\tint ret;\n\n\texe_file = get_mm_exe_file(current->mm);\n\tif (!exe_file)\n\t\treturn cn_esc_printf(cn, \"%s (path unknown)\", current->comm);\n\n\tpathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\tif (!pathbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto put_exe_file;\n\t}\n\n\tpath = file_path(exe_file, pathbuf, PATH_MAX);\n\tif (IS_ERR(path)) {\n\t\tret = PTR_ERR(path);\n\t\tgoto free_buf;\n\t}\n\n\tret = cn_esc_printf(cn, \"%s\", path);\n\nfree_buf:\n\tkfree(pathbuf);\nput_exe_file:\n\tfput(exe_file);\n\treturn ret;\n}"
  },
  {
    "function_name": "cn_printf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "105-115",
    "snippet": "int cn_printf(struct core_name *cn, const char *fmt, ...)\n{\n\tva_list arg;\n\tint ret;\n\n\tva_start(arg, fmt);\n\tret = cn_vprintf(cn, fmt, arg);\n\tva_end(arg);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "va_list arg;",
      "int ret;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "arg"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cn_vprintf",
          "args": [
            "cn",
            "fmt",
            "arg"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "arg",
            "fmt"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nva_list arg;\nint ret;\n\nint cn_printf(struct core_name *cn, const char *fmt, ...)\n{\n\tva_list arg;\n\tint ret;\n\n\tva_start(arg, fmt);\n\tret = cn_vprintf(cn, fmt, arg);\n\tva_end(arg);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "expand_corename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/coredump.c",
    "lines": "66-79",
    "snippet": "static int expand_corename(struct core_name *cn, int size)\n{\n\tchar *corename = krealloc(cn->corename, size, GFP_KERNEL);\n\n\tif (!corename)\n\t\treturn -ENOMEM;\n\n\tif (size > core_name_size) /* racy but harmless */\n\t\tcore_name_size = size;\n\n\tcn->size = ksize(corename);\n\tcn->corename = corename;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/exec.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/path.h>",
      "#include <linux/fs.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/mm.h>",
      "#include <linux/freezer.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int core_name_size = CORENAME_MAX_SIZE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ksize",
          "args": [
            "corename"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krealloc",
          "args": [
            "cn->corename",
            "size",
            "GFP_KERNEL"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/exec.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/timekeeping.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/mm.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int core_name_size = CORENAME_MAX_SIZE;\n\nstatic int expand_corename(struct core_name *cn, int size)\n{\n\tchar *corename = krealloc(cn->corename, size, GFP_KERNEL);\n\n\tif (!corename)\n\t\treturn -ENOMEM;\n\n\tif (size > core_name_size) /* racy but harmless */\n\t\tcore_name_size = size;\n\n\tcn->size = ksize(corename);\n\tcn->corename = corename;\n\treturn 0;\n}"
  }
]