[
  {
    "function_name": "init_flat_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "1007-1011",
    "snippet": "static int __init init_flat_binfmt(void)\n{\n\tregister_binfmt(&flat_format);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n\t.core_dump\t= flat_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_binfmt",
          "args": [
            "&flat_format"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "94-99",
          "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n\t.core_dump\t= flat_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};\n\nstatic int __init init_flat_binfmt(void)\n{\n\tregister_binfmt(&flat_format);\n\treturn 0;\n}"
  },
  {
    "function_name": "load_flat_binary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "908-1003",
    "snippet": "static int load_flat_binary(struct linux_binprm *bprm)\n{\n\tstruct lib_info libinfo;\n\tstruct pt_regs *regs = current_pt_regs();\n\tunsigned long stack_len = 0;\n\tunsigned long start_addr;\n\tint res;\n\tint i, j;\n\n\tmemset(&libinfo, 0, sizeof(libinfo));\n\n\t/*\n\t * We have to add the size of our arguments to our stack size\n\t * otherwise it's too easy for users to create stack overflows\n\t * by passing in a huge argument list.  And yes,  we have to be\n\t * pedantic and include space for the argv/envp array as it may have\n\t * a lot of entries.\n\t */\n#ifndef CONFIG_MMU\n\tstack_len += PAGE_SIZE * MAX_ARG_PAGES - bprm->p; /* the strings */\n#endif\n\tstack_len += (bprm->argc + 1) * sizeof(char *);   /* the argv array */\n\tstack_len += (bprm->envc + 1) * sizeof(char *);   /* the envp array */\n\tstack_len = ALIGN(stack_len, FLAT_STACK_ALIGN);\n\n\tres = load_flat_file(bprm, &libinfo, 0, &stack_len);\n\tif (res < 0)\n\t\treturn res;\n\n\t/* Update data segment pointers for all libraries */\n\tfor (i = 0; i < MAX_SHARED_LIBS; i++) {\n\t\tif (!libinfo.lib_list[i].loaded)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < MAX_SHARED_LIBS; j++) {\n\t\t\tunsigned long val = libinfo.lib_list[j].loaded ?\n\t\t\t\tlibinfo.lib_list[j].start_data : UNLOADED_LIB;\n\t\t\tunsigned long __user *p = (unsigned long __user *)\n\t\t\t\tlibinfo.lib_list[i].start_data;\n\t\t\tp -= j + 1;\n\t\t\tif (put_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tinstall_exec_creds(bprm);\n\n\tset_binfmt(&flat_format);\n\n#ifdef CONFIG_MMU\n\tres = setup_arg_pages(bprm, STACK_TOP, EXSTACK_DEFAULT);\n\tif (!res)\n\t\tres = create_flat_tables(bprm, bprm->p);\n#else\n\t/* Stash our initial stack pointer into the mm structure */\n\tcurrent->mm->start_stack =\n\t\t((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;\n\tpr_debug(\"sp=%lx\\n\", current->mm->start_stack);\n\n\t/* copy the arg pages onto the stack */\n\tres = transfer_args_to_stack(bprm, &current->mm->start_stack);\n\tif (!res)\n\t\tres = create_flat_tables(bprm, current->mm->start_stack);\n#endif\n\tif (res)\n\t\treturn res;\n\n\t/* Fake some return addresses to ensure the call chain will\n\t * initialise library in order for us.  We are required to call\n\t * lib 1 first, then 2, ... and finally the main program (id 0).\n\t */\n\tstart_addr = libinfo.lib_list[0].entry;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tfor (i = MAX_SHARED_LIBS-1; i > 0; i--) {\n\t\tif (libinfo.lib_list[i].loaded) {\n\t\t\t/* Push previos first to call address */\n\t\t\tunsigned long __user *sp;\n\t\t\tcurrent->mm->start_stack -= sizeof(unsigned long);\n\t\t\tsp = (unsigned long __user *)current->mm->start_stack;\n\t\t\t__put_user(start_addr, sp);\n\t\t\tstart_addr = libinfo.lib_list[i].entry;\n\t\t}\n\t}\n#endif\n\n#ifdef FLAT_PLAT_INIT\n\tFLAT_PLAT_INIT(regs);\n#endif\n\n\tfinalize_exec(bprm);\n\tpr_debug(\"start_thread(regs=0x%p, entry=0x%lx, start_stack=0x%lx)\\n\",\n\t\t regs, start_addr, current->mm->start_stack);\n\tstart_thread(regs, start_addr, current->mm->start_stack);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define UNLOADED_LIB 0x7ff000ff\t\t/* Placeholder for unused library */",
      "#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)"
    ],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);",
      "static struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n\t.core_dump\t= flat_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_thread",
          "args": [
            "regs",
            "start_addr",
            "current->mm->start_stack"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"start_thread(regs=0x%p, entry=0x%lx, start_stack=0x%lx)\\n\"",
            "regs",
            "start_addr",
            "current->mm->start_stack"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finalize_exec",
          "args": [
            "bprm"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "finalize_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1388-1394",
          "snippet": "void finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid finalize_exec(struct linux_binprm *bprm)\n{\n\t/* Store any stack rlimit changes before starting thread. */\n\ttask_lock(current->group_leader);\n\tcurrent->signal->rlim[RLIMIT_STACK] = bprm->rlim_stack;\n\ttask_unlock(current->group_leader);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FLAT_PLAT_INIT",
          "args": [
            "regs"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "start_addr",
            "sp"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_flat_tables",
          "args": [
            "bprm",
            "current->mm->start_stack"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "create_flat_tables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
          "lines": "112-161",
          "snippet": "static int create_flat_tables(struct linux_binprm *bprm, unsigned long arg_start)\n{\n\tchar __user *p;\n\tunsigned long __user *sp;\n\tlong i, len;\n\n\tp = (char __user *)arg_start;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\tsp -= bprm->envc + 1;\n\tsp -= bprm->argc + 1;\n\tsp -= flat_argvp_envp_on_stack() ? 2 : 0;\n\tsp -= 1;  /* &argc */\n\n\tcurrent->mm->start_stack = (unsigned long)sp & -FLAT_STACK_ALIGN;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\t__put_user(bprm->argc, sp++);\n\tif (flat_argvp_envp_on_stack()) {\n\t\tunsigned long argv, envp;\n\t\targv = (unsigned long)(sp + 2);\n\t\tenvp = (unsigned long)(sp + 2 + bprm->argc + 1);\n\t\t__put_user(argv, sp++);\n\t\t__put_user(envp, sp++);\n\t}\n\n\tcurrent->mm->arg_start = (unsigned long)p;\n\tfor (i = bprm->argc; i > 0; i--) {\n\t\t__put_user((unsigned long)p, sp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(0, sp++);\n\tcurrent->mm->arg_end = (unsigned long)p;\n\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (i = bprm->envc; i > 0; i--) {\n\t\t__put_user((unsigned long)p, sp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(0, sp++);\n\tcurrent->mm->env_end = (unsigned long)p;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)"
          ],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int create_flat_tables(struct linux_binprm *bprm, unsigned long arg_start)\n{\n\tchar __user *p;\n\tunsigned long __user *sp;\n\tlong i, len;\n\n\tp = (char __user *)arg_start;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\tsp -= bprm->envc + 1;\n\tsp -= bprm->argc + 1;\n\tsp -= flat_argvp_envp_on_stack() ? 2 : 0;\n\tsp -= 1;  /* &argc */\n\n\tcurrent->mm->start_stack = (unsigned long)sp & -FLAT_STACK_ALIGN;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\t__put_user(bprm->argc, sp++);\n\tif (flat_argvp_envp_on_stack()) {\n\t\tunsigned long argv, envp;\n\t\targv = (unsigned long)(sp + 2);\n\t\tenvp = (unsigned long)(sp + 2 + bprm->argc + 1);\n\t\t__put_user(argv, sp++);\n\t\t__put_user(envp, sp++);\n\t}\n\n\tcurrent->mm->arg_start = (unsigned long)p;\n\tfor (i = bprm->argc; i > 0; i--) {\n\t\t__put_user((unsigned long)p, sp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(0, sp++);\n\tcurrent->mm->arg_end = (unsigned long)p;\n\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (i = bprm->envc; i > 0; i--) {\n\t\t__put_user((unsigned long)p, sp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(0, sp++);\n\tcurrent->mm->env_end = (unsigned long)p;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transfer_args_to_stack",
          "args": [
            "bprm",
            "&current->mm->start_stack"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "transfer_args_to_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "807-831",
          "snippet": "int transfer_args_to_stack(struct linux_binprm *bprm,\n\t\t\t   unsigned long *sp_location)\n{\n\tunsigned long index, stop, sp;\n\tint ret = 0;\n\n\tstop = bprm->p >> PAGE_SHIFT;\n\tsp = *sp_location;\n\n\tfor (index = MAX_ARG_PAGES - 1; index >= stop; index--) {\n\t\tunsigned int offset = index == stop ? bprm->p & ~PAGE_MASK : 0;\n\t\tchar *src = kmap(bprm->page[index]) + offset;\n\t\tsp -= PAGE_SIZE - offset;\n\t\tif (copy_to_user((void *) sp, src, PAGE_SIZE - offset) != 0)\n\t\t\tret = -EFAULT;\n\t\tkunmap(bprm->page[index]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t*sp_location = sp;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint transfer_args_to_stack(struct linux_binprm *bprm,\n\t\t\t   unsigned long *sp_location)\n{\n\tunsigned long index, stop, sp;\n\tint ret = 0;\n\n\tstop = bprm->p >> PAGE_SHIFT;\n\tsp = *sp_location;\n\n\tfor (index = MAX_ARG_PAGES - 1; index >= stop; index--) {\n\t\tunsigned int offset = index == stop ? bprm->p & ~PAGE_MASK : 0;\n\t\tchar *src = kmap(bprm->page[index]) + offset;\n\t\tsp -= PAGE_SIZE - offset;\n\t\tif (copy_to_user((void *) sp, src, PAGE_SIZE - offset) != 0)\n\t\t\tret = -EFAULT;\n\t\tkunmap(bprm->page[index]);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t*sp_location = sp;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"sp=%lx\\n\"",
            "current->mm->start_stack"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_arg_pages",
          "args": [
            "bprm",
            "STACK_TOP",
            "EXSTACK_DEFAULT"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "setup_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "688-798",
          "snippet": "int setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = bprm->rlim_stack.rlim_max;\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Add space for stack randomization. */\n\tstack_base += (STACK_RND_MASK << PAGE_SHIFT);\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = bprm->rlim_stack.rlim_cur & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_binfmt",
          "args": [
            "&flat_format"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "set_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1931-1941",
          "snippet": "void set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_exec_creds",
          "args": [
            "bprm"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "install_exec_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1448-1470",
          "snippet": "void install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "val",
            "p"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_flat_file",
          "args": [
            "bprm",
            "&libinfo",
            "0",
            "&stack_len"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "load_flat_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
          "lines": "411-846",
          "snippet": "static int load_flat_file(struct linux_binprm *bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr *hdr;\n\tunsigned long textpos, datapos, realdatastart;\n\tu32 text_len, data_len, bss_len, stack_len, full_data, flags;\n\tunsigned long len, memp, memp_size, extra, rlim;\n\tu32 __user *reloc, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tssize_t result;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tpr_info(\"Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tpr_err(\"bad flat file version 0x%x (supported 0x%lx and 0x%lx)\\n\",\n\t\t       rev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tpr_err(\"shared libraries are not available before rev 0x%lx\\n\",\n\t\t       FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Make sure the header params are sane.\n\t * 28 bits (256 MB) is way more than reasonable in this case.\n\t * If some top bits are set we have probable binary corruption.\n\t*/\n\tif ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {\n\t\tpr_err(\"bad header\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tpr_err(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tret = flush_old_exec(bprm);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !(flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP))) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tpr_debug(\"ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to mmap process text, errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tret = realdatastart;\n\t\t\tif (!realdatastart)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tpr_debug(\"Allocated data+bss+stack (%u bytes): %lx\\n\",\n\t\t\t data_len + bss_len + stack_len, datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *)datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(u32);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process text/data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n#ifndef CONFIG_MMU\n\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t (((char *)textpos) + sizeof(struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof(struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n#else\n\t\t\t/*\n\t\t\t * This is used on MMU systems mainly for testing.\n\t\t\t * Let's use a kernel buffer to simplify things.\n\t\t\t */\n\t\t\tlong unz_text_len = text_len - sizeof(struct flat_hdr);\n\t\t\tlong unz_len = unz_text_len + full_data;\n\t\t\tchar *unz_data = vmalloc(unz_len);\n\t\t\tif (!unz_data) {\n\t\t\t\tresult = -ENOMEM;\n\t\t\t} else {\n\t\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t\t\t unz_data, unz_len, 0);\n\t\t\t\tif (result == 0 &&\n\t\t\t\t    (copy_to_user((void __user *)textpos + sizeof(struct flat_hdr),\n\t\t\t\t\t\t  unz_data, unz_text_len) ||\n\t\t\t\t     copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t  unz_data + unz_text_len, full_data)))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t\tvfree(unz_data);\n\t\t\t}\n#endif\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result)) {\n#ifndef CONFIG_MMU\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n#else\n\t\t\t\tchar *unz_data = vmalloc(full_data);\n\t\t\t\tif (!unz_data) {\n\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tresult = decompress_exec(bprm, text_len,\n\t\t\t\t\t\t       unz_data, full_data, 0);\n\t\t\t\t\tif (result == 0 &&\n\t\t\t\t\t    copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t\t unz_data, full_data))\n\t\t\t\t\t\tresult = -EFAULT;\n\t\t\t\t\tvfree(unz_data);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_BINFMT_ZFLAT */\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read code+data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tstart_code = textpos + sizeof(struct flat_hdr);\n\tend_code = textpos + text_len;\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* The main program needs a little extra setup in the task structure */\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n#ifndef CONFIG_MMU\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n#endif\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE) {\n\t\tpr_info(\"Mapping is %lx, Entry point is %x, data_start is %x\\n\",\n\t\t\ttextpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\t\tpr_info(\"%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\tstart_code, end_code, datapos, datapos + data_len,\n\t\t\tdatapos + data_len, (datapos + data_len + bss_len + 3) & ~3);\n\t}\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (u32 __user *)datapos; ; rp++) {\n\t\t\tu32 addr, rp_val;\n\t\t\tif (get_user(rp_val, rp))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rp_val == 0xffffffff)\n\t\t\t\tbreak;\n\t\t\tif (rp_val) {\n\t\t\t\taddr = calc_reloc(rp_val, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (put_user(addr, rp))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tu32 __maybe_unused persistent = 0;\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 addr, relval;\n\n\t\t\t/*\n\t\t\t * Get the address of the pointer to be\n\t\t\t * relocated (of course, the address has to be\n\t\t\t * relocated first).\n\t\t\t */\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\tif (flat_set_persistent(relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (u32 __user *)calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (u32 __user *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\tret = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&addr, &persistent);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto err;\n\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tret = flat_put_addr_at_rp(rp, addr, relval);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 relval;\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\told_reloc(relval);\n\t\t}\n\t}\n\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tif (clear_user((void __user *)(datapos + data_len), bss_len +\n\t\t       (memp + memp_size - stack_len -\t\t/* end brk */\n\t\t       libinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t       stack_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\nerr:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */",
            "#define FLAT_DATA_ALIGN\t(0x20)"
          ],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n#define FLAT_DATA_ALIGN\t(0x20)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_file(struct linux_binprm *bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr *hdr;\n\tunsigned long textpos, datapos, realdatastart;\n\tu32 text_len, data_len, bss_len, stack_len, full_data, flags;\n\tunsigned long len, memp, memp_size, extra, rlim;\n\tu32 __user *reloc, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tssize_t result;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tpr_info(\"Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tpr_err(\"bad flat file version 0x%x (supported 0x%lx and 0x%lx)\\n\",\n\t\t       rev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tpr_err(\"shared libraries are not available before rev 0x%lx\\n\",\n\t\t       FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Make sure the header params are sane.\n\t * 28 bits (256 MB) is way more than reasonable in this case.\n\t * If some top bits are set we have probable binary corruption.\n\t*/\n\tif ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {\n\t\tpr_err(\"bad header\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tpr_err(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tret = flush_old_exec(bprm);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !(flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP))) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tpr_debug(\"ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to mmap process text, errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tret = realdatastart;\n\t\t\tif (!realdatastart)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tpr_debug(\"Allocated data+bss+stack (%u bytes): %lx\\n\",\n\t\t\t data_len + bss_len + stack_len, datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *)datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(u32);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process text/data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n#ifndef CONFIG_MMU\n\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t (((char *)textpos) + sizeof(struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof(struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n#else\n\t\t\t/*\n\t\t\t * This is used on MMU systems mainly for testing.\n\t\t\t * Let's use a kernel buffer to simplify things.\n\t\t\t */\n\t\t\tlong unz_text_len = text_len - sizeof(struct flat_hdr);\n\t\t\tlong unz_len = unz_text_len + full_data;\n\t\t\tchar *unz_data = vmalloc(unz_len);\n\t\t\tif (!unz_data) {\n\t\t\t\tresult = -ENOMEM;\n\t\t\t} else {\n\t\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t\t\t unz_data, unz_len, 0);\n\t\t\t\tif (result == 0 &&\n\t\t\t\t    (copy_to_user((void __user *)textpos + sizeof(struct flat_hdr),\n\t\t\t\t\t\t  unz_data, unz_text_len) ||\n\t\t\t\t     copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t  unz_data + unz_text_len, full_data)))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t\tvfree(unz_data);\n\t\t\t}\n#endif\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result)) {\n#ifndef CONFIG_MMU\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n#else\n\t\t\t\tchar *unz_data = vmalloc(full_data);\n\t\t\t\tif (!unz_data) {\n\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tresult = decompress_exec(bprm, text_len,\n\t\t\t\t\t\t       unz_data, full_data, 0);\n\t\t\t\t\tif (result == 0 &&\n\t\t\t\t\t    copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t\t unz_data, full_data))\n\t\t\t\t\t\tresult = -EFAULT;\n\t\t\t\t\tvfree(unz_data);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_BINFMT_ZFLAT */\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read code+data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tstart_code = textpos + sizeof(struct flat_hdr);\n\tend_code = textpos + text_len;\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* The main program needs a little extra setup in the task structure */\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n#ifndef CONFIG_MMU\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n#endif\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE) {\n\t\tpr_info(\"Mapping is %lx, Entry point is %x, data_start is %x\\n\",\n\t\t\ttextpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\t\tpr_info(\"%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\tstart_code, end_code, datapos, datapos + data_len,\n\t\t\tdatapos + data_len, (datapos + data_len + bss_len + 3) & ~3);\n\t}\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (u32 __user *)datapos; ; rp++) {\n\t\t\tu32 addr, rp_val;\n\t\t\tif (get_user(rp_val, rp))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rp_val == 0xffffffff)\n\t\t\t\tbreak;\n\t\t\tif (rp_val) {\n\t\t\t\taddr = calc_reloc(rp_val, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (put_user(addr, rp))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tu32 __maybe_unused persistent = 0;\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 addr, relval;\n\n\t\t\t/*\n\t\t\t * Get the address of the pointer to be\n\t\t\t * relocated (of course, the address has to be\n\t\t\t * relocated first).\n\t\t\t */\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\tif (flat_set_persistent(relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (u32 __user *)calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (u32 __user *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\tret = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&addr, &persistent);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto err;\n\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tret = flat_put_addr_at_rp(rp, addr, relval);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 relval;\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\told_reloc(relval);\n\t\t}\n\t}\n\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tif (clear_user((void __user *)(datapos + data_len), bss_len +\n\t\t       (memp + memp_size - stack_len -\t\t/* end brk */\n\t\t       libinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t       stack_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\nerr:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "stack_len",
            "FLAT_STACK_ALIGN"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&libinfo",
            "0",
            "sizeof(libinfo)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define UNLOADED_LIB 0x7ff000ff\t\t/* Placeholder for unused library */\n#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)\n\nstatic int load_flat_binary(struct linux_binprm *);\nstatic struct linux_binfmt flat_format = {\n\t.module\t\t= THIS_MODULE,\n\t.load_binary\t= load_flat_binary,\n\t.core_dump\t= flat_core_dump,\n\t.min_coredump\t= PAGE_SIZE\n};\n\nstatic int load_flat_binary(struct linux_binprm *bprm)\n{\n\tstruct lib_info libinfo;\n\tstruct pt_regs *regs = current_pt_regs();\n\tunsigned long stack_len = 0;\n\tunsigned long start_addr;\n\tint res;\n\tint i, j;\n\n\tmemset(&libinfo, 0, sizeof(libinfo));\n\n\t/*\n\t * We have to add the size of our arguments to our stack size\n\t * otherwise it's too easy for users to create stack overflows\n\t * by passing in a huge argument list.  And yes,  we have to be\n\t * pedantic and include space for the argv/envp array as it may have\n\t * a lot of entries.\n\t */\n#ifndef CONFIG_MMU\n\tstack_len += PAGE_SIZE * MAX_ARG_PAGES - bprm->p; /* the strings */\n#endif\n\tstack_len += (bprm->argc + 1) * sizeof(char *);   /* the argv array */\n\tstack_len += (bprm->envc + 1) * sizeof(char *);   /* the envp array */\n\tstack_len = ALIGN(stack_len, FLAT_STACK_ALIGN);\n\n\tres = load_flat_file(bprm, &libinfo, 0, &stack_len);\n\tif (res < 0)\n\t\treturn res;\n\n\t/* Update data segment pointers for all libraries */\n\tfor (i = 0; i < MAX_SHARED_LIBS; i++) {\n\t\tif (!libinfo.lib_list[i].loaded)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < MAX_SHARED_LIBS; j++) {\n\t\t\tunsigned long val = libinfo.lib_list[j].loaded ?\n\t\t\t\tlibinfo.lib_list[j].start_data : UNLOADED_LIB;\n\t\t\tunsigned long __user *p = (unsigned long __user *)\n\t\t\t\tlibinfo.lib_list[i].start_data;\n\t\t\tp -= j + 1;\n\t\t\tif (put_user(val, p))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tinstall_exec_creds(bprm);\n\n\tset_binfmt(&flat_format);\n\n#ifdef CONFIG_MMU\n\tres = setup_arg_pages(bprm, STACK_TOP, EXSTACK_DEFAULT);\n\tif (!res)\n\t\tres = create_flat_tables(bprm, bprm->p);\n#else\n\t/* Stash our initial stack pointer into the mm structure */\n\tcurrent->mm->start_stack =\n\t\t((current->mm->context.end_brk + stack_len + 3) & ~3) - 4;\n\tpr_debug(\"sp=%lx\\n\", current->mm->start_stack);\n\n\t/* copy the arg pages onto the stack */\n\tres = transfer_args_to_stack(bprm, &current->mm->start_stack);\n\tif (!res)\n\t\tres = create_flat_tables(bprm, current->mm->start_stack);\n#endif\n\tif (res)\n\t\treturn res;\n\n\t/* Fake some return addresses to ensure the call chain will\n\t * initialise library in order for us.  We are required to call\n\t * lib 1 first, then 2, ... and finally the main program (id 0).\n\t */\n\tstart_addr = libinfo.lib_list[0].entry;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tfor (i = MAX_SHARED_LIBS-1; i > 0; i--) {\n\t\tif (libinfo.lib_list[i].loaded) {\n\t\t\t/* Push previos first to call address */\n\t\t\tunsigned long __user *sp;\n\t\t\tcurrent->mm->start_stack -= sizeof(unsigned long);\n\t\t\tsp = (unsigned long __user *)current->mm->start_stack;\n\t\t\t__put_user(start_addr, sp);\n\t\t\tstart_addr = libinfo.lib_list[i].entry;\n\t\t}\n\t}\n#endif\n\n#ifdef FLAT_PLAT_INIT\n\tFLAT_PLAT_INIT(regs);\n#endif\n\n\tfinalize_exec(bprm);\n\tpr_debug(\"start_thread(regs=0x%p, entry=0x%lx, start_stack=0x%lx)\\n\",\n\t\t regs, start_addr, current->mm->start_stack);\n\tstart_thread(regs, start_addr, current->mm->start_stack);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "load_flat_shared_library",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "857-898",
    "snippet": "static int load_flat_shared_library(int id, struct lib_info *libs)\n{\n\tstruct linux_binprm bprm;\n\tint res;\n\tchar buf[16];\n\n\tmemset(&bprm, 0, sizeof(bprm));\n\n\t/* Create the file name */\n\tsprintf(buf, \"/lib/lib%d.so\", id);\n\n\t/* Open the file up */\n\tbprm.filename = buf;\n\tbprm.file = open_exec(bprm.filename);\n\tres = PTR_ERR(bprm.file);\n\tif (IS_ERR(bprm.file))\n\t\treturn res;\n\n\tbprm.cred = prepare_exec_creds();\n\tres = -ENOMEM;\n\tif (!bprm.cred)\n\t\tgoto out;\n\n\t/* We don't really care about recalculating credentials at this point\n\t * as we're past the point of no return and are dealing with shared\n\t * libraries.\n\t */\n\tbprm.called_set_creds = 1;\n\n\tres = prepare_binprm(&bprm);\n\n\tif (!res)\n\t\tres = load_flat_file(&bprm, libs, id, NULL);\n\n\tabort_creds(bprm.cred);\n\nout:\n\tallow_write_access(bprm.file);\n\tfput(bprm.file);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "bprm.file"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "bprm.file"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "bprm.cred"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_flat_file",
          "args": [
            "&bprm",
            "libs",
            "id",
            "NULL"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "load_flat_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
          "lines": "411-846",
          "snippet": "static int load_flat_file(struct linux_binprm *bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr *hdr;\n\tunsigned long textpos, datapos, realdatastart;\n\tu32 text_len, data_len, bss_len, stack_len, full_data, flags;\n\tunsigned long len, memp, memp_size, extra, rlim;\n\tu32 __user *reloc, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tssize_t result;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tpr_info(\"Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tpr_err(\"bad flat file version 0x%x (supported 0x%lx and 0x%lx)\\n\",\n\t\t       rev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tpr_err(\"shared libraries are not available before rev 0x%lx\\n\",\n\t\t       FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Make sure the header params are sane.\n\t * 28 bits (256 MB) is way more than reasonable in this case.\n\t * If some top bits are set we have probable binary corruption.\n\t*/\n\tif ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {\n\t\tpr_err(\"bad header\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tpr_err(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tret = flush_old_exec(bprm);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !(flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP))) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tpr_debug(\"ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to mmap process text, errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tret = realdatastart;\n\t\t\tif (!realdatastart)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tpr_debug(\"Allocated data+bss+stack (%u bytes): %lx\\n\",\n\t\t\t data_len + bss_len + stack_len, datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *)datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(u32);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process text/data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n#ifndef CONFIG_MMU\n\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t (((char *)textpos) + sizeof(struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof(struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n#else\n\t\t\t/*\n\t\t\t * This is used on MMU systems mainly for testing.\n\t\t\t * Let's use a kernel buffer to simplify things.\n\t\t\t */\n\t\t\tlong unz_text_len = text_len - sizeof(struct flat_hdr);\n\t\t\tlong unz_len = unz_text_len + full_data;\n\t\t\tchar *unz_data = vmalloc(unz_len);\n\t\t\tif (!unz_data) {\n\t\t\t\tresult = -ENOMEM;\n\t\t\t} else {\n\t\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t\t\t unz_data, unz_len, 0);\n\t\t\t\tif (result == 0 &&\n\t\t\t\t    (copy_to_user((void __user *)textpos + sizeof(struct flat_hdr),\n\t\t\t\t\t\t  unz_data, unz_text_len) ||\n\t\t\t\t     copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t  unz_data + unz_text_len, full_data)))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t\tvfree(unz_data);\n\t\t\t}\n#endif\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result)) {\n#ifndef CONFIG_MMU\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n#else\n\t\t\t\tchar *unz_data = vmalloc(full_data);\n\t\t\t\tif (!unz_data) {\n\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tresult = decompress_exec(bprm, text_len,\n\t\t\t\t\t\t       unz_data, full_data, 0);\n\t\t\t\t\tif (result == 0 &&\n\t\t\t\t\t    copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t\t unz_data, full_data))\n\t\t\t\t\t\tresult = -EFAULT;\n\t\t\t\t\tvfree(unz_data);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_BINFMT_ZFLAT */\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read code+data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tstart_code = textpos + sizeof(struct flat_hdr);\n\tend_code = textpos + text_len;\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* The main program needs a little extra setup in the task structure */\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n#ifndef CONFIG_MMU\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n#endif\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE) {\n\t\tpr_info(\"Mapping is %lx, Entry point is %x, data_start is %x\\n\",\n\t\t\ttextpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\t\tpr_info(\"%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\tstart_code, end_code, datapos, datapos + data_len,\n\t\t\tdatapos + data_len, (datapos + data_len + bss_len + 3) & ~3);\n\t}\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (u32 __user *)datapos; ; rp++) {\n\t\t\tu32 addr, rp_val;\n\t\t\tif (get_user(rp_val, rp))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rp_val == 0xffffffff)\n\t\t\t\tbreak;\n\t\t\tif (rp_val) {\n\t\t\t\taddr = calc_reloc(rp_val, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (put_user(addr, rp))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tu32 __maybe_unused persistent = 0;\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 addr, relval;\n\n\t\t\t/*\n\t\t\t * Get the address of the pointer to be\n\t\t\t * relocated (of course, the address has to be\n\t\t\t * relocated first).\n\t\t\t */\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\tif (flat_set_persistent(relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (u32 __user *)calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (u32 __user *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\tret = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&addr, &persistent);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto err;\n\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tret = flat_put_addr_at_rp(rp, addr, relval);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 relval;\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\told_reloc(relval);\n\t\t}\n\t}\n\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tif (clear_user((void __user *)(datapos + data_len), bss_len +\n\t\t       (memp + memp_size - stack_len -\t\t/* end brk */\n\t\t       libinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t       stack_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\nerr:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */",
            "#define FLAT_DATA_ALIGN\t(0x20)"
          ],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n#define FLAT_DATA_ALIGN\t(0x20)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_file(struct linux_binprm *bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr *hdr;\n\tunsigned long textpos, datapos, realdatastart;\n\tu32 text_len, data_len, bss_len, stack_len, full_data, flags;\n\tunsigned long len, memp, memp_size, extra, rlim;\n\tu32 __user *reloc, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tssize_t result;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tpr_info(\"Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tpr_err(\"bad flat file version 0x%x (supported 0x%lx and 0x%lx)\\n\",\n\t\t       rev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tpr_err(\"shared libraries are not available before rev 0x%lx\\n\",\n\t\t       FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Make sure the header params are sane.\n\t * 28 bits (256 MB) is way more than reasonable in this case.\n\t * If some top bits are set we have probable binary corruption.\n\t*/\n\tif ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {\n\t\tpr_err(\"bad header\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tpr_err(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tret = flush_old_exec(bprm);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !(flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP))) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tpr_debug(\"ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to mmap process text, errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tret = realdatastart;\n\t\t\tif (!realdatastart)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tpr_debug(\"Allocated data+bss+stack (%u bytes): %lx\\n\",\n\t\t\t data_len + bss_len + stack_len, datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *)datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(u32);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process text/data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n#ifndef CONFIG_MMU\n\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t (((char *)textpos) + sizeof(struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof(struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n#else\n\t\t\t/*\n\t\t\t * This is used on MMU systems mainly for testing.\n\t\t\t * Let's use a kernel buffer to simplify things.\n\t\t\t */\n\t\t\tlong unz_text_len = text_len - sizeof(struct flat_hdr);\n\t\t\tlong unz_len = unz_text_len + full_data;\n\t\t\tchar *unz_data = vmalloc(unz_len);\n\t\t\tif (!unz_data) {\n\t\t\t\tresult = -ENOMEM;\n\t\t\t} else {\n\t\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t\t\t unz_data, unz_len, 0);\n\t\t\t\tif (result == 0 &&\n\t\t\t\t    (copy_to_user((void __user *)textpos + sizeof(struct flat_hdr),\n\t\t\t\t\t\t  unz_data, unz_text_len) ||\n\t\t\t\t     copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t  unz_data + unz_text_len, full_data)))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t\tvfree(unz_data);\n\t\t\t}\n#endif\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result)) {\n#ifndef CONFIG_MMU\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n#else\n\t\t\t\tchar *unz_data = vmalloc(full_data);\n\t\t\t\tif (!unz_data) {\n\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tresult = decompress_exec(bprm, text_len,\n\t\t\t\t\t\t       unz_data, full_data, 0);\n\t\t\t\t\tif (result == 0 &&\n\t\t\t\t\t    copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t\t unz_data, full_data))\n\t\t\t\t\t\tresult = -EFAULT;\n\t\t\t\t\tvfree(unz_data);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_BINFMT_ZFLAT */\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read code+data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tstart_code = textpos + sizeof(struct flat_hdr);\n\tend_code = textpos + text_len;\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* The main program needs a little extra setup in the task structure */\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n#ifndef CONFIG_MMU\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n#endif\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE) {\n\t\tpr_info(\"Mapping is %lx, Entry point is %x, data_start is %x\\n\",\n\t\t\ttextpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\t\tpr_info(\"%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\tstart_code, end_code, datapos, datapos + data_len,\n\t\t\tdatapos + data_len, (datapos + data_len + bss_len + 3) & ~3);\n\t}\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (u32 __user *)datapos; ; rp++) {\n\t\t\tu32 addr, rp_val;\n\t\t\tif (get_user(rp_val, rp))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rp_val == 0xffffffff)\n\t\t\t\tbreak;\n\t\t\tif (rp_val) {\n\t\t\t\taddr = calc_reloc(rp_val, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (put_user(addr, rp))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tu32 __maybe_unused persistent = 0;\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 addr, relval;\n\n\t\t\t/*\n\t\t\t * Get the address of the pointer to be\n\t\t\t * relocated (of course, the address has to be\n\t\t\t * relocated first).\n\t\t\t */\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\tif (flat_set_persistent(relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (u32 __user *)calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (u32 __user *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\tret = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&addr, &persistent);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto err;\n\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tret = flat_put_addr_at_rp(rp, addr, relval);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 relval;\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\told_reloc(relval);\n\t\t}\n\t}\n\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tif (clear_user((void __user *)(datapos + data_len), bss_len +\n\t\t       (memp + memp_size - stack_len -\t\t/* end brk */\n\t\t       libinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t       stack_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\nerr:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_binprm",
          "args": [
            "&bprm"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_binprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1568-1583",
          "snippet": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\tloff_t pos = 0;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->called_set_creds = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\tloff_t pos = 0;\n\n\tbprm_fill_uid(bprm);\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->called_set_creds = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_exec_creds",
          "args": [],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bprm.file"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bprm.file"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open_exec",
          "args": [
            "bprm.filename"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "open_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "880-890",
          "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"/lib/lib%d.so\"",
            "id"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&bprm",
            "0",
            "sizeof(bprm)"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_shared_library(int id, struct lib_info *libs)\n{\n\tstruct linux_binprm bprm;\n\tint res;\n\tchar buf[16];\n\n\tmemset(&bprm, 0, sizeof(bprm));\n\n\t/* Create the file name */\n\tsprintf(buf, \"/lib/lib%d.so\", id);\n\n\t/* Open the file up */\n\tbprm.filename = buf;\n\tbprm.file = open_exec(bprm.filename);\n\tres = PTR_ERR(bprm.file);\n\tif (IS_ERR(bprm.file))\n\t\treturn res;\n\n\tbprm.cred = prepare_exec_creds();\n\tres = -ENOMEM;\n\tif (!bprm.cred)\n\t\tgoto out;\n\n\t/* We don't really care about recalculating credentials at this point\n\t * as we're past the point of no return and are dealing with shared\n\t * libraries.\n\t */\n\tbprm.called_set_creds = 1;\n\n\tres = prepare_binprm(&bprm);\n\n\tif (!res)\n\t\tres = load_flat_file(&bprm, libs, id, NULL);\n\n\tabort_creds(bprm.cred);\n\nout:\n\tallow_write_access(bprm.file);\n\tfput(bprm.file);\n\n\treturn res;\n}"
  },
  {
    "function_name": "load_flat_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "411-846",
    "snippet": "static int load_flat_file(struct linux_binprm *bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr *hdr;\n\tunsigned long textpos, datapos, realdatastart;\n\tu32 text_len, data_len, bss_len, stack_len, full_data, flags;\n\tunsigned long len, memp, memp_size, extra, rlim;\n\tu32 __user *reloc, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tssize_t result;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tpr_info(\"Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tpr_err(\"bad flat file version 0x%x (supported 0x%lx and 0x%lx)\\n\",\n\t\t       rev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tpr_err(\"shared libraries are not available before rev 0x%lx\\n\",\n\t\t       FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Make sure the header params are sane.\n\t * 28 bits (256 MB) is way more than reasonable in this case.\n\t * If some top bits are set we have probable binary corruption.\n\t*/\n\tif ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {\n\t\tpr_err(\"bad header\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tpr_err(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tret = flush_old_exec(bprm);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !(flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP))) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tpr_debug(\"ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to mmap process text, errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tret = realdatastart;\n\t\t\tif (!realdatastart)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tpr_debug(\"Allocated data+bss+stack (%u bytes): %lx\\n\",\n\t\t\t data_len + bss_len + stack_len, datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *)datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(u32);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process text/data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n#ifndef CONFIG_MMU\n\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t (((char *)textpos) + sizeof(struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof(struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n#else\n\t\t\t/*\n\t\t\t * This is used on MMU systems mainly for testing.\n\t\t\t * Let's use a kernel buffer to simplify things.\n\t\t\t */\n\t\t\tlong unz_text_len = text_len - sizeof(struct flat_hdr);\n\t\t\tlong unz_len = unz_text_len + full_data;\n\t\t\tchar *unz_data = vmalloc(unz_len);\n\t\t\tif (!unz_data) {\n\t\t\t\tresult = -ENOMEM;\n\t\t\t} else {\n\t\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t\t\t unz_data, unz_len, 0);\n\t\t\t\tif (result == 0 &&\n\t\t\t\t    (copy_to_user((void __user *)textpos + sizeof(struct flat_hdr),\n\t\t\t\t\t\t  unz_data, unz_text_len) ||\n\t\t\t\t     copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t  unz_data + unz_text_len, full_data)))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t\tvfree(unz_data);\n\t\t\t}\n#endif\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result)) {\n#ifndef CONFIG_MMU\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n#else\n\t\t\t\tchar *unz_data = vmalloc(full_data);\n\t\t\t\tif (!unz_data) {\n\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tresult = decompress_exec(bprm, text_len,\n\t\t\t\t\t\t       unz_data, full_data, 0);\n\t\t\t\t\tif (result == 0 &&\n\t\t\t\t\t    copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t\t unz_data, full_data))\n\t\t\t\t\t\tresult = -EFAULT;\n\t\t\t\t\tvfree(unz_data);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_BINFMT_ZFLAT */\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read code+data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tstart_code = textpos + sizeof(struct flat_hdr);\n\tend_code = textpos + text_len;\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* The main program needs a little extra setup in the task structure */\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n#ifndef CONFIG_MMU\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n#endif\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE) {\n\t\tpr_info(\"Mapping is %lx, Entry point is %x, data_start is %x\\n\",\n\t\t\ttextpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\t\tpr_info(\"%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\tstart_code, end_code, datapos, datapos + data_len,\n\t\t\tdatapos + data_len, (datapos + data_len + bss_len + 3) & ~3);\n\t}\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (u32 __user *)datapos; ; rp++) {\n\t\t\tu32 addr, rp_val;\n\t\t\tif (get_user(rp_val, rp))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rp_val == 0xffffffff)\n\t\t\t\tbreak;\n\t\t\tif (rp_val) {\n\t\t\t\taddr = calc_reloc(rp_val, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (put_user(addr, rp))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tu32 __maybe_unused persistent = 0;\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 addr, relval;\n\n\t\t\t/*\n\t\t\t * Get the address of the pointer to be\n\t\t\t * relocated (of course, the address has to be\n\t\t\t * relocated first).\n\t\t\t */\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\tif (flat_set_persistent(relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (u32 __user *)calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (u32 __user *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\tret = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&addr, &persistent);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto err;\n\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tret = flat_put_addr_at_rp(rp, addr, relval);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 relval;\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\told_reloc(relval);\n\t\t}\n\t}\n\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tif (clear_user((void __user *)(datapos + data_len), bss_len +\n\t\t       (memp + memp_size - stack_len -\t\t/* end brk */\n\t\t       libinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t       stack_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\nerr:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */",
      "#define FLAT_DATA_ALIGN\t(0x20)"
    ],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "(void __user *)(datapos + data_len)",
            "bss_len +\n\t\t       (memp + memp_size - stack_len -\t\t/* end brk */\n\t\t       libinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t       stack_len"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "start_code",
            "end_code"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_reloc",
          "args": [
            "relval"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "old_reloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
          "lines": "371-407",
          "snippet": "static void old_reloc(unsigned long rl)\n{\n\tstatic const char *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n\tflat_v2_reloc_t\tr;\n\tunsigned long __user *ptr;\n\tunsigned long val;\n\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long __user *)(current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long __user *)(current->mm->start_data + r.reloc.offset);\n#endif\n\tget_user(val, ptr);\n\n\tpr_debug(\"Relocation of variable at DATASEG+%x \"\n\t\t \"(address %p, currently %lx) into segment %s\\n\",\n\t\t r.reloc.offset, ptr, val, segment[r.reloc.type]);\n\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\tval += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\tval += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\tval += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\tput_user(val, ptr);\n\n\tpr_debug(\"Relocation became %lx\\n\", val);\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void old_reloc(unsigned long rl)\n{\n\tstatic const char *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n\tflat_v2_reloc_t\tr;\n\tunsigned long __user *ptr;\n\tunsigned long val;\n\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long __user *)(current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long __user *)(current->mm->start_data + r.reloc.offset);\n#endif\n\tget_user(val, ptr);\n\n\tpr_debug(\"Relocation of variable at DATASEG+%x \"\n\t\t \"(address %p, currently %lx) into segment %s\\n\",\n\t\t r.reloc.offset, ptr, val, segment[r.reloc.type]);\n\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\tval += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\tval += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\tval += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\tput_user(val, ptr);\n\n\tpr_debug(\"Relocation became %lx\\n\", val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "relval"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "relval",
            "reloc + i"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_put_addr_at_rp",
          "args": [
            "rp",
            "addr",
            "relval"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_reloc",
          "args": [
            "addr",
            "libinfo",
            "id",
            "0"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "calc_reloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
          "lines": "301-367",
          "snippet": "static unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\n{\n\tunsigned long addr;\n\tint id;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tif (r == 0)\n\t\tid = curid;\t/* Relocs of 0 are always self referring */\n\telse {\n\t\tid = (r >> 24) & 0xff;\t/* Find ID for this reloc */\n\t\tr &= 0x00ffffff;\t/* Trim ID off here */\n\t}\n\tif (id >= MAX_SHARED_LIBS) {\n\t\tpr_err(\"reference 0x%lx to shared library %d\", r, id);\n\t\tgoto failed;\n\t}\n\tif (curid != id) {\n\t\tif (internalp) {\n\t\t\tpr_err(\"reloc address 0x%lx not in same module \"\n\t\t\t       \"(%d != %d)\", r, curid, id);\n\t\t\tgoto failed;\n\t\t} else if (!p->lib_list[id].loaded &&\n\t\t\t   load_flat_shared_library(id, p) < 0) {\n\t\t\tpr_err(\"failed to load library %d\", id);\n\t\t\tgoto failed;\n\t\t}\n\t\t/* Check versioning information (i.e. time stamps) */\n\t\tif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\n\t\t\t\tp->lib_list[curid].build_date < p->lib_list[id].build_date) {\n\t\t\tpr_err(\"library %d is younger than %d\", id, curid);\n\t\t\tgoto failed;\n\t\t}\n\t}\n#else\n\tid = 0;\n#endif\n\n\tstart_brk = p->lib_list[id].start_brk;\n\tstart_data = p->lib_list[id].start_data;\n\tstart_code = p->lib_list[id].start_code;\n\ttext_len = p->lib_list[id].text_len;\n\n\tif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\n\t\tpr_err(\"reloc outside program 0x%lx (0 - 0x%lx/0x%lx)\",\n\t\t       r, start_brk-start_data+text_len, text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t/* In text segment */\n\t\taddr = r + start_code;\n\telse\t\t\t\t\t/* In data segment */\n\t\taddr = r - text_len + start_data;\n\n\t/* Range checked already above so doing the range tests is redundant...*/\n\treturn addr;\n\nfailed:\n\tpr_cont(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n\nstatic unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\n{\n\tunsigned long addr;\n\tint id;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tif (r == 0)\n\t\tid = curid;\t/* Relocs of 0 are always self referring */\n\telse {\n\t\tid = (r >> 24) & 0xff;\t/* Find ID for this reloc */\n\t\tr &= 0x00ffffff;\t/* Trim ID off here */\n\t}\n\tif (id >= MAX_SHARED_LIBS) {\n\t\tpr_err(\"reference 0x%lx to shared library %d\", r, id);\n\t\tgoto failed;\n\t}\n\tif (curid != id) {\n\t\tif (internalp) {\n\t\t\tpr_err(\"reloc address 0x%lx not in same module \"\n\t\t\t       \"(%d != %d)\", r, curid, id);\n\t\t\tgoto failed;\n\t\t} else if (!p->lib_list[id].loaded &&\n\t\t\t   load_flat_shared_library(id, p) < 0) {\n\t\t\tpr_err(\"failed to load library %d\", id);\n\t\t\tgoto failed;\n\t\t}\n\t\t/* Check versioning information (i.e. time stamps) */\n\t\tif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\n\t\t\t\tp->lib_list[curid].build_date < p->lib_list[id].build_date) {\n\t\t\tpr_err(\"library %d is younger than %d\", id, curid);\n\t\t\tgoto failed;\n\t\t}\n\t}\n#else\n\tid = 0;\n#endif\n\n\tstart_brk = p->lib_list[id].start_brk;\n\tstart_data = p->lib_list[id].start_data;\n\tstart_code = p->lib_list[id].start_code;\n\ttext_len = p->lib_list[id].text_len;\n\n\tif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\n\t\tpr_err(\"reloc outside program 0x%lx (0 - 0x%lx/0x%lx)\",\n\t\t       r, start_brk-start_data+text_len, text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t/* In text segment */\n\t\taddr = r + start_code;\n\telse\t\t\t\t\t/* In data segment */\n\t\taddr = r - text_len + start_data;\n\n\t/* Range checked already above so doing the range tests is redundant...*/\n\treturn addr;\n\nfailed:\n\tpr_cont(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "addr"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_get_addr_from_rp",
          "args": [
            "rp",
            "relval",
            "flags",
            "&addr",
            "&persistent"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_get_relocate_addr",
          "args": [
            "relval"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_set_persistent",
          "args": [
            "relval",
            "&persistent"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "relval"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "addr",
            "rp"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->build_date"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->entry"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\\n\"",
            "id ? \"Lib\" : \"Load\"",
            "bprm->filename",
            "start_code",
            "end_code",
            "datapos",
            "datapos + data_len",
            "datapos + data_len",
            "(datapos + data_len + bss_len + 3) & ~3"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Mapping is %lx, Entry point is %x, data_start is %x\\n\"",
            "textpos",
            "0x00ffffff&ntohl(hdr->entry)",
            "ntohl(hdr->data_start)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->entry"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "textpos",
            "text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to read code+data+bss, errno %d\\n\"",
            "ret"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_code",
          "args": [
            "bprm->file",
            "datapos",
            "ntohl(hdr->data_start)",
            "full_data"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "read_code",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "998-1004",
          "snippet": "ssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "unz_data"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user *)datapos",
            "unz_data",
            "full_data"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decompress_exec",
          "args": [
            "bprm",
            "text_len",
            "unz_data",
            "full_data",
            "0"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "decompress_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
          "lines": "180-295",
          "snippet": "static int decompress_exec(struct linux_binprm *bprm, loff_t fpos, char *dst,\n\t\tlong len, int fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tint ret, retval;\n\n\tpr_debug(\"decompress_exec(offset=%llx,buf=%p,len=%lx)\\n\", fpos, dst, len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!strm.workspace)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* Read in first chunk of data and parse gzip header. */\n\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\n\tretval = -ENOEXEC;\n\n\t/* Check minimum size -- gzip header */\n\tif (ret < 10) {\n\t\tpr_debug(\"file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip magic number */\n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tpr_debug(\"unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip method */\n\tif (buf[2] != 8) {\n\t\tpr_debug(\"unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t/* Check gzip flags */\n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tpr_debug(\"unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(ret >= LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tpr_debug(\"zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t}\n\n\tif (ret < 0) {\n\t\tpr_debug(\"decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define RESERVED     0xC0 /* bit 6,7:   reserved */",
            "#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */",
            "#define COMMENT      0x10 /* bit 4 set: file comment present */",
            "#define ORIG_NAME    0x08 /* bit 3 set: original file name present */",
            "#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */",
            "#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */",
            "#define LBUFSIZE\t4000"
          ],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define RESERVED     0xC0 /* bit 6,7:   reserved */\n#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */\n#define COMMENT      0x10 /* bit 4 set: file comment present */\n#define ORIG_NAME    0x08 /* bit 3 set: original file name present */\n#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */\n#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */\n#define LBUFSIZE\t4000\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int decompress_exec(struct linux_binprm *bprm, loff_t fpos, char *dst,\n\t\tlong len, int fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tint ret, retval;\n\n\tpr_debug(\"decompress_exec(offset=%llx,buf=%p,len=%lx)\\n\", fpos, dst, len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!strm.workspace)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* Read in first chunk of data and parse gzip header. */\n\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\n\tretval = -ENOEXEC;\n\n\t/* Check minimum size -- gzip header */\n\tif (ret < 10) {\n\t\tpr_debug(\"file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip magic number */\n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tpr_debug(\"unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip method */\n\tif (buf[2] != 8) {\n\t\tpr_debug(\"unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t/* Check gzip flags */\n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tpr_debug(\"unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(ret >= LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tpr_debug(\"zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t}\n\n\tif (ret < 0) {\n\t\tpr_debug(\"decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "full_data"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "jffs2_blocks_use_vmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/jffs2/nodelist.h",
          "lines": "296-299",
          "snippet": "static inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"os-linux.h\"",
            "#include \"os-ecos.h\"",
            "#include \"summary.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"jffs2_fs_i.h\"",
            "#include \"jffs2_fs_sb.h\"",
            "#include <linux/jffs2.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"os-linux.h\"\n#include \"os-ecos.h\"\n#include \"summary.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"jffs2_fs_i.h\"\n#include \"jffs2_fs_sb.h\"\n#include <linux/jffs2.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "unz_data"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user *)datapos",
            "unz_data + unz_text_len",
            "full_data"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "(void *) datapos",
            "(void *) realdatastart",
            "full_data"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->reloc_start"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32)",
            "FLAT_DATA_ALIGN"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to allocate RAM for process text/data, \"\n\t\t\t       \"errno %d\\n\"",
            "ret"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "textpos"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "NULL",
            "0",
            "len",
            "PROT_READ | PROT_EXEC | PROT_WRITE",
            "MAP_PRIVATE",
            "0"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->reloc_start"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "realdatastart",
            "len"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "textpos",
            "text_len"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to read data+bss, errno %d\\n\"",
            "ret"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "result"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Allocated data+bss+stack (%u bytes): %lx\\n\"",
            "data_len + bss_len + stack_len",
            "datapos"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long)",
            "FLAT_DATA_ALIGN"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_munmap",
          "args": [
            "textpos",
            "text_len"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to allocate RAM for process data, \"\n\t\t\t       \"errno %d\\n\"",
            "ret"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "realdatastart"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "NULL",
            "0",
            "len",
            "PROT_READ|PROT_WRITE|PROT_EXEC",
            "MAP_PRIVATE",
            "0"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to mmap process text, errno %d\\n\"",
            "ret"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_VALUE",
          "args": [
            "textpos"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_mmap",
          "args": [
            "bprm->file",
            "0",
            "text_len",
            "PROT_READ|PROT_EXEC",
            "MAP_PRIVATE|MAP_EXECUTABLE",
            "0"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ROM mapping of file (we hope)\\n\""
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MMU"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "bss_len + stack_len",
            "relocs * sizeof(unsigned long)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_new_exec",
          "args": [
            "bprm"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1330-1384",
          "snippet": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int suid_dumpable = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint suid_dumpable = 0;\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\t/*\n\t * Once here, prepare_binrpm() will not be called any more, so\n\t * the final state of setuid/setgid/fscaps can be merged into the\n\t * secureexec flag.\n\t */\n\tbprm->secureexec |= bprm->cap_elevated;\n\n\tif (bprm->secureexec) {\n\t\t/* Make sure parent cannot signal privileged process. */\n\t\tcurrent->pdeath_signal = 0;\n\n\t\t/*\n\t\t * For secureexec, reset the stack limit to sane default to\n\t\t * avoid bad behavior from the prior rlimits. This has to\n\t\t * happen before arch_pick_mmap_layout(), which examines\n\t\t * RLIMIT_STACK, but after the point of no return to avoid\n\t\t * needing to clean up the change on failure.\n\t\t */\n\t\tif (bprm->rlim_stack.rlim_cur > _STK_LIM)\n\t\t\tbprm->rlim_stack.rlim_cur = _STK_LIM;\n\t}\n\n\tarch_pick_mmap_layout(current->mm, &bprm->rlim_stack);\n\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\t/*\n\t * Figure out dumpability. Note that this checking only of current\n\t * is wrong, but userspace depends on it. This should be testing\n\t * bprm->secureexec instead.\n\t */\n\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP ||\n\t    !(uid_eq(current_euid(), current_uid()) &&\n\t      gid_eq(current_egid(), current_gid())))\n\t\tset_dumpable(current->mm, suid_dumpable);\n\telse\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\n\tarch_setup_new_exec();\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_personality",
          "args": [
            "PER_LINUX_32BIT"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_old_exec",
          "args": [
            "bprm"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "flush_old_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "1254-1306",
          "snippet": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * Must be called _before_ exec_mmap() as bprm->mm is\n\t * not visibile until then. This also enables the update\n\t * to be lockless.\n\t */\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\t/*\n\t * After clearing bprm->mm (to mark that current is using the\n\t * prepared mm now), we have nothing left of the original\n\t * process. If anything from here on returns an error, the check\n\t * in search_binary_handler() will SEGV current.\n\t */\n\tbprm->mm = NULL;\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\t/*\n\t * We have to apply CLOEXEC before we change whether the process is\n\t * dumpable (in setup_new_exec) to avoid a race with a process in userspace\n\t * trying to access the should-be-closed file descriptors of a process\n\t * undergoing exec(2).\n\t */\n\tdo_close_on_exec(current->files);\n\treturn 0;\n\nout:\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_DATA"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Support for ZFLAT executables is not enabled.\\n\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_old_ram_flag",
          "args": [
            "flags"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad header\\n\""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"shared libraries are not available before rev 0x%lx\\n\"",
            "FLAT_VERSION"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"bad flat file version 0x%x (supported 0x%lx and 0x%lx)\\n\"",
            "rev",
            "FLAT_VERSION",
            "OLD_FLAT_VERSION"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Loading file: %s\\n\"",
            "bprm->filename"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "hdr->magic",
            "\"bFLT\"",
            "4"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->rev"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->flags"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->reloc_count"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->stack_size"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_end"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->bss_end"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_end"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "hdr->data_start"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "bprm->file"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n#define FLAT_DATA_ALIGN\t(0x20)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_file(struct linux_binprm *bprm,\n\t\tstruct lib_info *libinfo, int id, unsigned long *extra_stack)\n{\n\tstruct flat_hdr *hdr;\n\tunsigned long textpos, datapos, realdatastart;\n\tu32 text_len, data_len, bss_len, stack_len, full_data, flags;\n\tunsigned long len, memp, memp_size, extra, rlim;\n\tu32 __user *reloc, *rp;\n\tstruct inode *inode;\n\tint i, rev, relocs;\n\tloff_t fpos;\n\tunsigned long start_code, end_code;\n\tssize_t result;\n\tint ret;\n\n\thdr = ((struct flat_hdr *) bprm->buf);\t\t/* exec-header */\n\tinode = file_inode(bprm->file);\n\n\ttext_len  = ntohl(hdr->data_start);\n\tdata_len  = ntohl(hdr->data_end) - ntohl(hdr->data_start);\n\tbss_len   = ntohl(hdr->bss_end) - ntohl(hdr->data_end);\n\tstack_len = ntohl(hdr->stack_size);\n\tif (extra_stack) {\n\t\tstack_len += *extra_stack;\n\t\t*extra_stack = stack_len;\n\t}\n\trelocs    = ntohl(hdr->reloc_count);\n\tflags     = ntohl(hdr->flags);\n\trev       = ntohl(hdr->rev);\n\tfull_data = data_len + relocs * sizeof(unsigned long);\n\n\tif (strncmp(hdr->magic, \"bFLT\", 4)) {\n\t\t/*\n\t\t * Previously, here was a printk to tell people\n\t\t *   \"BINFMT_FLAT: bad header magic\".\n\t\t * But for the kernel which also use ELF FD-PIC format, this\n\t\t * error message is confusing.\n\t\t * because a lot of people do not manage to produce good\n\t\t */\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE)\n\t\tpr_info(\"Loading file: %s\\n\", bprm->filename);\n\n\tif (rev != FLAT_VERSION && rev != OLD_FLAT_VERSION) {\n\t\tpr_err(\"bad flat file version 0x%x (supported 0x%lx and 0x%lx)\\n\",\n\t\t       rev, FLAT_VERSION, OLD_FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/* Don't allow old format executables to use shared libraries */\n\tif (rev == OLD_FLAT_VERSION && id != 0) {\n\t\tpr_err(\"shared libraries are not available before rev 0x%lx\\n\",\n\t\t       FLAT_VERSION);\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Make sure the header params are sane.\n\t * 28 bits (256 MB) is way more than reasonable in this case.\n\t * If some top bits are set we have probable binary corruption.\n\t*/\n\tif ((text_len | data_len | bss_len | stack_len | full_data) >> 28) {\n\t\tpr_err(\"bad header\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * fix up the flags for the older format,  there were all kinds\n\t * of endian hacks,  this only works for the simple cases\n\t */\n\tif (rev == OLD_FLAT_VERSION && flat_old_ram_flag(flags))\n\t\tflags = FLAT_FLAG_RAM;\n\n#ifndef CONFIG_BINFMT_ZFLAT\n\tif (flags & (FLAT_FLAG_GZIP|FLAT_FLAG_GZDATA)) {\n\t\tpr_err(\"Support for ZFLAT executables is not enabled.\\n\");\n\t\tret = -ENOEXEC;\n\t\tgoto err;\n\t}\n#endif\n\n\t/*\n\t * Check initial limits. This avoids letting people circumvent\n\t * size limits imposed on them by creating programs with large\n\t * arrays in the data or bss.\n\t */\n\trlim = rlimit(RLIMIT_DATA);\n\tif (rlim >= RLIM_INFINITY)\n\t\trlim = ~0;\n\tif (data_len + bss_len > rlim) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\t/* Flush all traces of the currently running executable */\n\tif (id == 0) {\n\t\tret = flush_old_exec(bprm);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t/* OK, This is the point of no return */\n\t\tset_personality(PER_LINUX_32BIT);\n\t\tsetup_new_exec(bprm);\n\t}\n\n\t/*\n\t * calculate the extra space we need to map in\n\t */\n\textra = max_t(unsigned long, bss_len + stack_len,\n\t\t\trelocs * sizeof(unsigned long));\n\n\t/*\n\t * there are a couple of cases here,  the separate code/data\n\t * case,  and then the fully copied to RAM case which lumps\n\t * it all together.\n\t */\n\tif (!IS_ENABLED(CONFIG_MMU) && !(flags & (FLAT_FLAG_RAM|FLAT_FLAG_GZIP))) {\n\t\t/*\n\t\t * this should give us a ROM ptr,  but if it doesn't we don't\n\t\t * really care\n\t\t */\n\t\tpr_debug(\"ROM mapping of file (we hope)\\n\");\n\n\t\ttextpos = vm_mmap(bprm->file, 0, text_len, PROT_READ|PROT_EXEC,\n\t\t\t\t  MAP_PRIVATE|MAP_EXECUTABLE, 0);\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to mmap process text, errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tlen = data_len + extra + MAX_SHARED_LIBS * sizeof(unsigned long);\n\t\tlen = PAGE_ALIGN(len);\n\t\trealdatastart = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE, 0);\n\n\t\tif (realdatastart == 0 || IS_ERR_VALUE(realdatastart)) {\n\t\t\tret = realdatastart;\n\t\t\tif (!realdatastart)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tgoto err;\n\t\t}\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(unsigned long),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\tpr_debug(\"Allocated data+bss+stack (%u bytes): %lx\\n\",\n\t\t\t data_len + bss_len + stack_len, datapos);\n\n\t\tfpos = ntohl(hdr->data_start);\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\tif (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = decompress_exec(bprm, fpos, (char *)datapos,\n\t\t\t\t\t\t full_data, 0);\n\t\t} else\n#endif\n\t\t{\n\t\t\tresult = read_code(bprm->file, datapos, fpos,\n\t\t\t\t\tfull_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len);\n\t\t\tvm_munmap(realdatastart, len);\n\t\t\tgoto err;\n\t\t}\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = realdatastart;\n\t\tmemp_size = len;\n\t} else {\n\n\t\tlen = text_len + data_len + extra + MAX_SHARED_LIBS * sizeof(u32);\n\t\tlen = PAGE_ALIGN(len);\n\t\ttextpos = vm_mmap(NULL, 0, len,\n\t\t\tPROT_READ | PROT_EXEC | PROT_WRITE, MAP_PRIVATE, 0);\n\n\t\tif (!textpos || IS_ERR_VALUE(textpos)) {\n\t\t\tret = textpos;\n\t\t\tif (!textpos)\n\t\t\t\tret = -ENOMEM;\n\t\t\tpr_err(\"Unable to allocate RAM for process text/data, \"\n\t\t\t       \"errno %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\trealdatastart = textpos + ntohl(hdr->data_start);\n\t\tdatapos = ALIGN(realdatastart +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32),\n\t\t\t\tFLAT_DATA_ALIGN);\n\n\t\treloc = (u32 __user *)\n\t\t\t(datapos + (ntohl(hdr->reloc_start) - text_len));\n\t\tmemp = textpos;\n\t\tmemp_size = len;\n#ifdef CONFIG_BINFMT_ZFLAT\n\t\t/*\n\t\t * load it all in and treat it like a RAM load from now on\n\t\t */\n\t\tif (flags & FLAT_FLAG_GZIP) {\n#ifndef CONFIG_MMU\n\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t (((char *)textpos) + sizeof(struct flat_hdr)),\n\t\t\t\t\t (text_len + full_data\n\t\t\t\t\t\t  - sizeof(struct flat_hdr)),\n\t\t\t\t\t 0);\n\t\t\tmemmove((void *) datapos, (void *) realdatastart,\n\t\t\t\t\tfull_data);\n#else\n\t\t\t/*\n\t\t\t * This is used on MMU systems mainly for testing.\n\t\t\t * Let's use a kernel buffer to simplify things.\n\t\t\t */\n\t\t\tlong unz_text_len = text_len - sizeof(struct flat_hdr);\n\t\t\tlong unz_len = unz_text_len + full_data;\n\t\t\tchar *unz_data = vmalloc(unz_len);\n\t\t\tif (!unz_data) {\n\t\t\t\tresult = -ENOMEM;\n\t\t\t} else {\n\t\t\t\tresult = decompress_exec(bprm, sizeof(struct flat_hdr),\n\t\t\t\t\t\t\t unz_data, unz_len, 0);\n\t\t\t\tif (result == 0 &&\n\t\t\t\t    (copy_to_user((void __user *)textpos + sizeof(struct flat_hdr),\n\t\t\t\t\t\t  unz_data, unz_text_len) ||\n\t\t\t\t     copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t  unz_data + unz_text_len, full_data)))\n\t\t\t\t\tresult = -EFAULT;\n\t\t\t\tvfree(unz_data);\n\t\t\t}\n#endif\n\t\t} else if (flags & FLAT_FLAG_GZDATA) {\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result)) {\n#ifndef CONFIG_MMU\n\t\t\t\tresult = decompress_exec(bprm, text_len, (char *) datapos,\n\t\t\t\t\t\t full_data, 0);\n#else\n\t\t\t\tchar *unz_data = vmalloc(full_data);\n\t\t\t\tif (!unz_data) {\n\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tresult = decompress_exec(bprm, text_len,\n\t\t\t\t\t\t       unz_data, full_data, 0);\n\t\t\t\t\tif (result == 0 &&\n\t\t\t\t\t    copy_to_user((void __user *)datapos,\n\t\t\t\t\t\t\t unz_data, full_data))\n\t\t\t\t\t\tresult = -EFAULT;\n\t\t\t\t\tvfree(unz_data);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t} else\n#endif /* CONFIG_BINFMT_ZFLAT */\n\t\t{\n\t\t\tresult = read_code(bprm->file, textpos, 0, text_len);\n\t\t\tif (!IS_ERR_VALUE(result))\n\t\t\t\tresult = read_code(bprm->file, datapos,\n\t\t\t\t\t\t   ntohl(hdr->data_start),\n\t\t\t\t\t\t   full_data);\n\t\t}\n\t\tif (IS_ERR_VALUE(result)) {\n\t\t\tret = result;\n\t\t\tpr_err(\"Unable to read code+data+bss, errno %d\\n\", ret);\n\t\t\tvm_munmap(textpos, text_len + data_len + extra +\n\t\t\t\tMAX_SHARED_LIBS * sizeof(u32));\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tstart_code = textpos + sizeof(struct flat_hdr);\n\tend_code = textpos + text_len;\n\ttext_len -= sizeof(struct flat_hdr); /* the real code len */\n\n\t/* The main program needs a little extra setup in the task structure */\n\tif (id == 0) {\n\t\tcurrent->mm->start_code = start_code;\n\t\tcurrent->mm->end_code = end_code;\n\t\tcurrent->mm->start_data = datapos;\n\t\tcurrent->mm->end_data = datapos + data_len;\n\t\t/*\n\t\t * set up the brk stuff, uses any slack left in data/bss/stack\n\t\t * allocation.  We put the brk after the bss (between the bss\n\t\t * and stack) like other platforms.\n\t\t * Userspace code relies on the stack pointer starting out at\n\t\t * an address right at the end of a page.\n\t\t */\n\t\tcurrent->mm->start_brk = datapos + data_len + bss_len;\n\t\tcurrent->mm->brk = (current->mm->start_brk + 3) & ~3;\n#ifndef CONFIG_MMU\n\t\tcurrent->mm->context.end_brk = memp + memp_size - stack_len;\n#endif\n\t}\n\n\tif (flags & FLAT_FLAG_KTRACE) {\n\t\tpr_info(\"Mapping is %lx, Entry point is %x, data_start is %x\\n\",\n\t\t\ttextpos, 0x00ffffff&ntohl(hdr->entry), ntohl(hdr->data_start));\n\t\tpr_info(\"%s %s: TEXT=%lx-%lx DATA=%lx-%lx BSS=%lx-%lx\\n\",\n\t\t\tid ? \"Lib\" : \"Load\", bprm->filename,\n\t\t\tstart_code, end_code, datapos, datapos + data_len,\n\t\t\tdatapos + data_len, (datapos + data_len + bss_len + 3) & ~3);\n\t}\n\n\t/* Store the current module values into the global library structure */\n\tlibinfo->lib_list[id].start_code = start_code;\n\tlibinfo->lib_list[id].start_data = datapos;\n\tlibinfo->lib_list[id].start_brk = datapos + data_len + bss_len;\n\tlibinfo->lib_list[id].text_len = text_len;\n\tlibinfo->lib_list[id].loaded = 1;\n\tlibinfo->lib_list[id].entry = (0x00ffffff & ntohl(hdr->entry)) + textpos;\n\tlibinfo->lib_list[id].build_date = ntohl(hdr->build_date);\n\n\t/*\n\t * We just load the allocations into some temporary memory to\n\t * help simplify all this mumbo jumbo\n\t *\n\t * We've got two different sections of relocation entries.\n\t * The first is the GOT which resides at the beginning of the data segment\n\t * and is terminated with a -1.  This one can be relocated in place.\n\t * The second is the extra relocation entries tacked after the image's\n\t * data segment. These require a little more processing as the entry is\n\t * really an offset into the image which contains an offset into the\n\t * image.\n\t */\n\tif (flags & FLAT_FLAG_GOTPIC) {\n\t\tfor (rp = (u32 __user *)datapos; ; rp++) {\n\t\t\tu32 addr, rp_val;\n\t\t\tif (get_user(rp_val, rp))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (rp_val == 0xffffffff)\n\t\t\t\tbreak;\n\t\t\tif (rp_val) {\n\t\t\t\taddr = calc_reloc(rp_val, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (put_user(addr, rp))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now run through the relocation entries.\n\t * We've got to be careful here as C++ produces relocatable zero\n\t * entries in the constructor and destructor tables which are then\n\t * tested for being not zero (which will always occur unless we're\n\t * based from address zero).  This causes an endless loop as __start\n\t * is at zero.  The solution used is to not relocate zero addresses.\n\t * This has the negative side effect of not allowing a global data\n\t * reference to be statically initialised to _stext (I've moved\n\t * __start to address 4 so that is okay).\n\t */\n\tif (rev > OLD_FLAT_VERSION) {\n\t\tu32 __maybe_unused persistent = 0;\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 addr, relval;\n\n\t\t\t/*\n\t\t\t * Get the address of the pointer to be\n\t\t\t * relocated (of course, the address has to be\n\t\t\t * relocated first).\n\t\t\t */\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\tif (flat_set_persistent(relval, &persistent))\n\t\t\t\tcontinue;\n\t\t\taddr = flat_get_relocate_addr(relval);\n\t\t\trp = (u32 __user *)calc_reloc(addr, libinfo, id, 1);\n\t\t\tif (rp == (u32 __user *)RELOC_FAILED) {\n\t\t\t\tret = -ENOEXEC;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t/* Get the pointer's value.  */\n\t\t\tret = flat_get_addr_from_rp(rp, relval, flags,\n\t\t\t\t\t\t\t&addr, &persistent);\n\t\t\tif (unlikely(ret))\n\t\t\t\tgoto err;\n\n\t\t\tif (addr != 0) {\n\t\t\t\t/*\n\t\t\t\t * Do the relocation.  PIC relocs in the data section are\n\t\t\t\t * already in target order\n\t\t\t\t */\n\t\t\t\tif ((flags & FLAT_FLAG_GOTPIC) == 0)\n\t\t\t\t\taddr = ntohl(addr);\n\t\t\t\taddr = calc_reloc(addr, libinfo, id, 0);\n\t\t\t\tif (addr == RELOC_FAILED) {\n\t\t\t\t\tret = -ENOEXEC;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\n\t\t\t\t/* Write back the relocated pointer.  */\n\t\t\t\tret = flat_put_addr_at_rp(rp, addr, relval);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < relocs; i++) {\n\t\t\tu32 relval;\n\t\t\tif (get_user(relval, reloc + i))\n\t\t\t\treturn -EFAULT;\n\t\t\trelval = ntohl(relval);\n\t\t\told_reloc(relval);\n\t\t}\n\t}\n\n\tflush_icache_range(start_code, end_code);\n\n\t/* zero the BSS,  BRK and stack areas */\n\tif (clear_user((void __user *)(datapos + data_len), bss_len +\n\t\t       (memp + memp_size - stack_len -\t\t/* end brk */\n\t\t       libinfo->lib_list[id].start_brk) +\t/* start brk */\n\t\t       stack_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\nerr:\n\treturn ret;\n}"
  },
  {
    "function_name": "old_reloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "371-407",
    "snippet": "static void old_reloc(unsigned long rl)\n{\n\tstatic const char *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n\tflat_v2_reloc_t\tr;\n\tunsigned long __user *ptr;\n\tunsigned long val;\n\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long __user *)(current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long __user *)(current->mm->start_data + r.reloc.offset);\n#endif\n\tget_user(val, ptr);\n\n\tpr_debug(\"Relocation of variable at DATASEG+%x \"\n\t\t \"(address %p, currently %lx) into segment %s\\n\",\n\t\t r.reloc.offset, ptr, val, segment[r.reloc.type]);\n\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\tval += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\tval += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\tval += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\tput_user(val, ptr);\n\n\tpr_debug(\"Relocation became %lx\\n\", val);\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Relocation became %lx\\n\"",
            "val"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "val",
            "ptr"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unknown relocation type=%x\\n\"",
            "r.reloc.type"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Relocation of variable at DATASEG+%x \"\n\t\t \"(address %p, currently %lx) into segment %s\\n\"",
            "r.reloc.offset",
            "ptr",
            "val",
            "segment[r.reloc.type]"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "val",
            "ptr"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/exec.c",
          "lines": "446-465",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/freezer.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/freezer.h>\n#include <linux/vmalloc.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/sched/task.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic void old_reloc(unsigned long rl)\n{\n\tstatic const char *segment[] = { \"TEXT\", \"DATA\", \"BSS\", \"*UNKNOWN*\" };\n\tflat_v2_reloc_t\tr;\n\tunsigned long __user *ptr;\n\tunsigned long val;\n\n\tr.value = rl;\n#if defined(CONFIG_COLDFIRE)\n\tptr = (unsigned long __user *)(current->mm->start_code + r.reloc.offset);\n#else\n\tptr = (unsigned long __user *)(current->mm->start_data + r.reloc.offset);\n#endif\n\tget_user(val, ptr);\n\n\tpr_debug(\"Relocation of variable at DATASEG+%x \"\n\t\t \"(address %p, currently %lx) into segment %s\\n\",\n\t\t r.reloc.offset, ptr, val, segment[r.reloc.type]);\n\n\tswitch (r.reloc.type) {\n\tcase OLD_FLAT_RELOC_TYPE_TEXT:\n\t\tval += current->mm->start_code;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_DATA:\n\t\tval += current->mm->start_data;\n\t\tbreak;\n\tcase OLD_FLAT_RELOC_TYPE_BSS:\n\t\tval += current->mm->end_data;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown relocation type=%x\\n\", r.reloc.type);\n\t\tbreak;\n\t}\n\tput_user(val, ptr);\n\n\tpr_debug(\"Relocation became %lx\\n\", val);\n}"
  },
  {
    "function_name": "calc_reloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "301-367",
    "snippet": "static unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\n{\n\tunsigned long addr;\n\tint id;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tif (r == 0)\n\t\tid = curid;\t/* Relocs of 0 are always self referring */\n\telse {\n\t\tid = (r >> 24) & 0xff;\t/* Find ID for this reloc */\n\t\tr &= 0x00ffffff;\t/* Trim ID off here */\n\t}\n\tif (id >= MAX_SHARED_LIBS) {\n\t\tpr_err(\"reference 0x%lx to shared library %d\", r, id);\n\t\tgoto failed;\n\t}\n\tif (curid != id) {\n\t\tif (internalp) {\n\t\t\tpr_err(\"reloc address 0x%lx not in same module \"\n\t\t\t       \"(%d != %d)\", r, curid, id);\n\t\t\tgoto failed;\n\t\t} else if (!p->lib_list[id].loaded &&\n\t\t\t   load_flat_shared_library(id, p) < 0) {\n\t\t\tpr_err(\"failed to load library %d\", id);\n\t\t\tgoto failed;\n\t\t}\n\t\t/* Check versioning information (i.e. time stamps) */\n\t\tif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\n\t\t\t\tp->lib_list[curid].build_date < p->lib_list[id].build_date) {\n\t\t\tpr_err(\"library %d is younger than %d\", id, curid);\n\t\t\tgoto failed;\n\t\t}\n\t}\n#else\n\tid = 0;\n#endif\n\n\tstart_brk = p->lib_list[id].start_brk;\n\tstart_data = p->lib_list[id].start_data;\n\tstart_code = p->lib_list[id].start_code;\n\ttext_len = p->lib_list[id].text_len;\n\n\tif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\n\t\tpr_err(\"reloc outside program 0x%lx (0 - 0x%lx/0x%lx)\",\n\t\t       r, start_brk-start_data+text_len, text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t/* In text segment */\n\t\taddr = r + start_code;\n\telse\t\t\t\t\t/* In data segment */\n\t\taddr = r - text_len + start_data;\n\n\t/* Range checked already above so doing the range tests is redundant...*/\n\treturn addr;\n\nfailed:\n\tpr_cont(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGSEGV",
            "current",
            "0"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fcntl.c",
          "lines": "808-813",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <linux/poll.h>",
            "#include <linux/compat.h>",
            "#include <linux/memfd.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/siginfo.h>\n#include <linux/poll.h>\n#include <linux/compat.h>\n#include <linux/memfd.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/task.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, enum pid_type type)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\", killing %s!\\n\"",
            "current->comm"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"reloc outside program 0x%lx (0 - 0x%lx/0x%lx)\"",
            "r",
            "start_brk-start_data+text_len",
            "text_len"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_reloc_valid",
          "args": [
            "r",
            "start_brk - start_data + text_len"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"library %d is younger than %d\"",
            "id",
            "curid"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to load library %d\"",
            "id"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_flat_shared_library",
          "args": [
            "id",
            "p"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "load_flat_shared_library",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
          "lines": "857-898",
          "snippet": "static int load_flat_shared_library(int id, struct lib_info *libs)\n{\n\tstruct linux_binprm bprm;\n\tint res;\n\tchar buf[16];\n\n\tmemset(&bprm, 0, sizeof(bprm));\n\n\t/* Create the file name */\n\tsprintf(buf, \"/lib/lib%d.so\", id);\n\n\t/* Open the file up */\n\tbprm.filename = buf;\n\tbprm.file = open_exec(bprm.filename);\n\tres = PTR_ERR(bprm.file);\n\tif (IS_ERR(bprm.file))\n\t\treturn res;\n\n\tbprm.cred = prepare_exec_creds();\n\tres = -ENOMEM;\n\tif (!bprm.cred)\n\t\tgoto out;\n\n\t/* We don't really care about recalculating credentials at this point\n\t * as we're past the point of no return and are dealing with shared\n\t * libraries.\n\t */\n\tbprm.called_set_creds = 1;\n\n\tres = prepare_binprm(&bprm);\n\n\tif (!res)\n\t\tres = load_flat_file(&bprm, libs, id, NULL);\n\n\tabort_creds(bprm.cred);\n\nout:\n\tallow_write_access(bprm.file);\n\tfput(bprm.file);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/zlib.h>",
            "#include <asm/page.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/flat.h>",
            "#include <linux/init.h>",
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/slab.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/signal.h>",
            "#include <linux/errno.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int load_flat_binary(struct linux_binprm *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int load_flat_shared_library(int id, struct lib_info *libs)\n{\n\tstruct linux_binprm bprm;\n\tint res;\n\tchar buf[16];\n\n\tmemset(&bprm, 0, sizeof(bprm));\n\n\t/* Create the file name */\n\tsprintf(buf, \"/lib/lib%d.so\", id);\n\n\t/* Open the file up */\n\tbprm.filename = buf;\n\tbprm.file = open_exec(bprm.filename);\n\tres = PTR_ERR(bprm.file);\n\tif (IS_ERR(bprm.file))\n\t\treturn res;\n\n\tbprm.cred = prepare_exec_creds();\n\tres = -ENOMEM;\n\tif (!bprm.cred)\n\t\tgoto out;\n\n\t/* We don't really care about recalculating credentials at this point\n\t * as we're past the point of no return and are dealing with shared\n\t * libraries.\n\t */\n\tbprm.called_set_creds = 1;\n\n\tres = prepare_binprm(&bprm);\n\n\tif (!res)\n\t\tres = load_flat_file(&bprm, libs, id, NULL);\n\n\tabort_creds(bprm.cred);\n\nout:\n\tallow_write_access(bprm.file);\n\tfput(bprm.file);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"reloc address 0x%lx not in same module \"\n\t\t\t       \"(%d != %d)\"",
            "r",
            "curid",
            "id"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"reference 0x%lx to shared library %d\"",
            "r",
            "id"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define RELOC_FAILED 0xff00ff01\t\t/* Relocation incorrect somewhere */\n\nstatic unsigned long\ncalc_reloc(unsigned long r, struct lib_info *p, int curid, int internalp)\n{\n\tunsigned long addr;\n\tint id;\n\tunsigned long start_brk;\n\tunsigned long start_data;\n\tunsigned long text_len;\n\tunsigned long start_code;\n\n#ifdef CONFIG_BINFMT_SHARED_FLAT\n\tif (r == 0)\n\t\tid = curid;\t/* Relocs of 0 are always self referring */\n\telse {\n\t\tid = (r >> 24) & 0xff;\t/* Find ID for this reloc */\n\t\tr &= 0x00ffffff;\t/* Trim ID off here */\n\t}\n\tif (id >= MAX_SHARED_LIBS) {\n\t\tpr_err(\"reference 0x%lx to shared library %d\", r, id);\n\t\tgoto failed;\n\t}\n\tif (curid != id) {\n\t\tif (internalp) {\n\t\t\tpr_err(\"reloc address 0x%lx not in same module \"\n\t\t\t       \"(%d != %d)\", r, curid, id);\n\t\t\tgoto failed;\n\t\t} else if (!p->lib_list[id].loaded &&\n\t\t\t   load_flat_shared_library(id, p) < 0) {\n\t\t\tpr_err(\"failed to load library %d\", id);\n\t\t\tgoto failed;\n\t\t}\n\t\t/* Check versioning information (i.e. time stamps) */\n\t\tif (p->lib_list[id].build_date && p->lib_list[curid].build_date &&\n\t\t\t\tp->lib_list[curid].build_date < p->lib_list[id].build_date) {\n\t\t\tpr_err(\"library %d is younger than %d\", id, curid);\n\t\t\tgoto failed;\n\t\t}\n\t}\n#else\n\tid = 0;\n#endif\n\n\tstart_brk = p->lib_list[id].start_brk;\n\tstart_data = p->lib_list[id].start_data;\n\tstart_code = p->lib_list[id].start_code;\n\ttext_len = p->lib_list[id].text_len;\n\n\tif (!flat_reloc_valid(r, start_brk - start_data + text_len)) {\n\t\tpr_err(\"reloc outside program 0x%lx (0 - 0x%lx/0x%lx)\",\n\t\t       r, start_brk-start_data+text_len, text_len);\n\t\tgoto failed;\n\t}\n\n\tif (r < text_len)\t\t\t/* In text segment */\n\t\taddr = r + start_code;\n\telse\t\t\t\t\t/* In data segment */\n\t\taddr = r - text_len + start_data;\n\n\t/* Range checked already above so doing the range tests is redundant...*/\n\treturn addr;\n\nfailed:\n\tpr_cont(\", killing %s!\\n\", current->comm);\n\tsend_sig(SIGSEGV, current, 0);\n\n\treturn RELOC_FAILED;\n}"
  },
  {
    "function_name": "decompress_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "180-295",
    "snippet": "static int decompress_exec(struct linux_binprm *bprm, loff_t fpos, char *dst,\n\t\tlong len, int fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tint ret, retval;\n\n\tpr_debug(\"decompress_exec(offset=%llx,buf=%p,len=%lx)\\n\", fpos, dst, len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!strm.workspace)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* Read in first chunk of data and parse gzip header. */\n\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\n\tretval = -ENOEXEC;\n\n\t/* Check minimum size -- gzip header */\n\tif (ret < 10) {\n\t\tpr_debug(\"file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip magic number */\n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tpr_debug(\"unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip method */\n\tif (buf[2] != 8) {\n\t\tpr_debug(\"unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t/* Check gzip flags */\n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tpr_debug(\"unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(ret >= LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tpr_debug(\"zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t}\n\n\tif (ret < 0) {\n\t\tpr_debug(\"decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define RESERVED     0xC0 /* bit 6,7:   reserved */",
      "#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */",
      "#define COMMENT      0x10 /* bit 4 set: file comment present */",
      "#define ORIG_NAME    0x08 /* bit 3 set: original file name present */",
      "#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */",
      "#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */",
      "#define LBUFSIZE\t4000"
    ],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "strm.workspace"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zlib_inflateEnd",
          "args": [
            "&strm"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"decompression failed (%d), %s\\n\"",
            "ret",
            "strm.msg"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "bprm->file",
            "buf",
            "LBUFSIZE",
            "&fpos"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/splice.c",
          "lines": "352-366",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched/signal.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bvec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bvec.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct kvec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos, 0);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zlib_inflate",
          "args": [
            "&strm",
            "Z_NO_FLUSH"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"zlib init failed?\\n\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_inflateInit2",
          "args": [
            "&strm",
            "-MAX_WBITS"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"buffer overflow (COMMENT)?\\n\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == LBUFSIZE"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"buffer overflow (ORIG_NAME)?\\n\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret == LBUFSIZE"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"buffer overflow (EXTRA)?\\n\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret >= LBUFSIZE"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"unknown flags?\\n\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"unknown compression method?\\n\""
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"unknown compression magic?\\n\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"file too small?\\n\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "LBUFSIZE",
            "GFP_KERNEL"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zlib_inflate_workspacesize",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&strm",
            "0",
            "sizeof(strm)"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"decompress_exec(offset=%llx,buf=%p,len=%lx)\\n\"",
            "fpos",
            "dst",
            "len"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define RESERVED     0xC0 /* bit 6,7:   reserved */\n#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */\n#define COMMENT      0x10 /* bit 4 set: file comment present */\n#define ORIG_NAME    0x08 /* bit 3 set: original file name present */\n#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */\n#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */\n#define LBUFSIZE\t4000\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int decompress_exec(struct linux_binprm *bprm, loff_t fpos, char *dst,\n\t\tlong len, int fd)\n{\n\tunsigned char *buf;\n\tz_stream strm;\n\tint ret, retval;\n\n\tpr_debug(\"decompress_exec(offset=%llx,buf=%p,len=%lx)\\n\", fpos, dst, len);\n\n\tmemset(&strm, 0, sizeof(strm));\n\tstrm.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!strm.workspace)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\n\tif (!buf) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\t/* Read in first chunk of data and parse gzip header. */\n\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\n\tstrm.next_in = buf;\n\tstrm.avail_in = ret;\n\tstrm.total_in = 0;\n\n\tretval = -ENOEXEC;\n\n\t/* Check minimum size -- gzip header */\n\tif (ret < 10) {\n\t\tpr_debug(\"file too small?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip magic number */\n\tif ((buf[0] != 037) || ((buf[1] != 0213) && (buf[1] != 0236))) {\n\t\tpr_debug(\"unknown compression magic?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\t/* Check gzip method */\n\tif (buf[2] != 8) {\n\t\tpr_debug(\"unknown compression method?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\t/* Check gzip flags */\n\tif ((buf[3] & ENCRYPTED) || (buf[3] & CONTINUATION) ||\n\t    (buf[3] & RESERVED)) {\n\t\tpr_debug(\"unknown flags?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\tret = 10;\n\tif (buf[3] & EXTRA_FIELD) {\n\t\tret += 2 + buf[10] + (buf[11] << 8);\n\t\tif (unlikely(ret >= LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (EXTRA)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & ORIG_NAME) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (ORIG_NAME)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\tif (buf[3] & COMMENT) {\n\t\twhile (ret < LBUFSIZE && buf[ret++] != 0)\n\t\t\t;\n\t\tif (unlikely(ret == LBUFSIZE)) {\n\t\t\tpr_debug(\"buffer overflow (COMMENT)?\\n\");\n\t\t\tgoto out_free_buf;\n\t\t}\n\t}\n\n\tstrm.next_in += ret;\n\tstrm.avail_in -= ret;\n\n\tstrm.next_out = dst;\n\tstrm.avail_out = len;\n\tstrm.total_out = 0;\n\n\tif (zlib_inflateInit2(&strm, -MAX_WBITS) != Z_OK) {\n\t\tpr_debug(\"zlib init failed?\\n\");\n\t\tgoto out_free_buf;\n\t}\n\n\twhile ((ret = zlib_inflate(&strm, Z_NO_FLUSH)) == Z_OK) {\n\t\tret = kernel_read(bprm->file, buf, LBUFSIZE, &fpos);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tlen -= ret;\n\n\t\tstrm.next_in = buf;\n\t\tstrm.avail_in = ret;\n\t\tstrm.total_in = 0;\n\t}\n\n\tif (ret < 0) {\n\t\tpr_debug(\"decompression failed (%d), %s\\n\",\n\t\t\tret, strm.msg);\n\t\tgoto out_zlib;\n\t}\n\n\tretval = 0;\nout_zlib:\n\tzlib_inflateEnd(&strm);\nout_free_buf:\n\tkfree(buf);\nout_free:\n\tkfree(strm.workspace);\n\treturn retval;\n}"
  },
  {
    "function_name": "create_flat_tables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "112-161",
    "snippet": "static int create_flat_tables(struct linux_binprm *bprm, unsigned long arg_start)\n{\n\tchar __user *p;\n\tunsigned long __user *sp;\n\tlong i, len;\n\n\tp = (char __user *)arg_start;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\tsp -= bprm->envc + 1;\n\tsp -= bprm->argc + 1;\n\tsp -= flat_argvp_envp_on_stack() ? 2 : 0;\n\tsp -= 1;  /* &argc */\n\n\tcurrent->mm->start_stack = (unsigned long)sp & -FLAT_STACK_ALIGN;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\t__put_user(bprm->argc, sp++);\n\tif (flat_argvp_envp_on_stack()) {\n\t\tunsigned long argv, envp;\n\t\targv = (unsigned long)(sp + 2);\n\t\tenvp = (unsigned long)(sp + 2 + bprm->argc + 1);\n\t\t__put_user(argv, sp++);\n\t\t__put_user(envp, sp++);\n\t}\n\n\tcurrent->mm->arg_start = (unsigned long)p;\n\tfor (i = bprm->argc; i > 0; i--) {\n\t\t__put_user((unsigned long)p, sp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(0, sp++);\n\tcurrent->mm->arg_end = (unsigned long)p;\n\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (i = bprm->envc; i > 0; i--) {\n\t\t__put_user((unsigned long)p, sp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(0, sp++);\n\tcurrent->mm->env_end = (unsigned long)p;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)"
    ],
    "globals_used": [
      "static int load_flat_binary(struct linux_binprm *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "sp++"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "p",
            "MAX_ARG_STRLEN"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(unsigned long)p",
            "sp++"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "sp++"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "p",
            "MAX_ARG_STRLEN"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(unsigned long)p",
            "sp++"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "envp",
            "sp++"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "argv",
            "sp++"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_argvp_envp_on_stack",
          "args": [],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "bprm->argc",
            "sp++"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flat_argvp_envp_on_stack",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define FLAT_STACK_ALIGN\tmax_t(unsigned long, sizeof(void *), ARCH_SLAB_MINALIGN)\n\nstatic int load_flat_binary(struct linux_binprm *);\n\nstatic int create_flat_tables(struct linux_binprm *bprm, unsigned long arg_start)\n{\n\tchar __user *p;\n\tunsigned long __user *sp;\n\tlong i, len;\n\n\tp = (char __user *)arg_start;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\tsp -= bprm->envc + 1;\n\tsp -= bprm->argc + 1;\n\tsp -= flat_argvp_envp_on_stack() ? 2 : 0;\n\tsp -= 1;  /* &argc */\n\n\tcurrent->mm->start_stack = (unsigned long)sp & -FLAT_STACK_ALIGN;\n\tsp = (unsigned long __user *)current->mm->start_stack;\n\n\t__put_user(bprm->argc, sp++);\n\tif (flat_argvp_envp_on_stack()) {\n\t\tunsigned long argv, envp;\n\t\targv = (unsigned long)(sp + 2);\n\t\tenvp = (unsigned long)(sp + 2 + bprm->argc + 1);\n\t\t__put_user(argv, sp++);\n\t\t__put_user(envp, sp++);\n\t}\n\n\tcurrent->mm->arg_start = (unsigned long)p;\n\tfor (i = bprm->argc; i > 0; i--) {\n\t\t__put_user((unsigned long)p, sp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(0, sp++);\n\tcurrent->mm->arg_end = (unsigned long)p;\n\n\tcurrent->mm->env_start = (unsigned long) p;\n\tfor (i = bprm->envc; i > 0; i--) {\n\t\t__put_user((unsigned long)p, sp++);\n\t\tlen = strnlen_user(p, MAX_ARG_STRLEN);\n\t\tif (!len || len > MAX_ARG_STRLEN)\n\t\t\treturn -EINVAL;\n\t\tp += len;\n\t}\n\t__put_user(0, sp++);\n\tcurrent->mm->env_end = (unsigned long)p;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "flat_core_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/binfmt_flat.c",
    "lines": "98-103",
    "snippet": "static int flat_core_dump(struct coredump_params *cprm)\n{\n\tpr_warn(\"Process %s:%d received signr %d and should have core dumped\\n\",\n\t\tcurrent->comm, current->pid, cprm->siginfo->si_signo);\n\treturn 1;\n}",
    "includes": [
      "#include <linux/zlib.h>",
      "#include <asm/page.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unaligned.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/flat.h>",
      "#include <linux/init.h>",
      "#include <linux/personality.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/slab.h>",
      "#include <linux/user.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/string.h>",
      "#include <linux/signal.h>",
      "#include <linux/errno.h>",
      "#include <linux/mman.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int flat_core_dump(struct coredump_params *cprm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Process %s:%d received signr %d and should have core dumped\\n\"",
            "current->comm",
            "current->pid",
            "cprm->siginfo->si_signo"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/zlib.h>\n#include <asm/page.h>\n#include <asm/cacheflush.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/flat.h>\n#include <linux/init.h>\n#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/slab.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int flat_core_dump(struct coredump_params *cprm);\n\nstatic int flat_core_dump(struct coredump_params *cprm)\n{\n\tpr_warn(\"Process %s:%d received signr %d and should have core dumped\\n\",\n\t\tcurrent->comm, current->pid, cprm->siginfo->si_signo);\n\treturn 1;\n}"
  }
]