[
  {
    "function_name": "iterate_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "961-981",
    "snippet": "int iterate_fd(struct files_struct *files, unsigned n,\n\t\tint (*f)(const void *, struct file *, unsigned),\n\t\tconst void *p)\n{\n\tstruct fdtable *fdt;\n\tint res = 0;\n\tif (!files)\n\t\treturn 0;\n\tspin_lock(&files->file_lock);\n\tfor (fdt = files_fdtable(files); n < fdt->max_fds; n++) {\n\t\tstruct file *file;\n\t\tfile = rcu_dereference_check_fdtable(files, fdt->fd[n]);\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tres = f(p, file, n);\n\t\tif (res)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&files->file_lock);\n\treturn res;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "p",
            "file",
            "n"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "f_dupfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "948-959",
          "snippet": "int f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tint err;\n\tif (from >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tint err;\n\tif (from >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check_fdtable",
          "args": [
            "files",
            "fdt->fd[n]"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint iterate_fd(struct files_struct *files, unsigned n,\n\t\tint (*f)(const void *, struct file *, unsigned),\n\t\tconst void *p)\n{\n\tstruct fdtable *fdt;\n\tint res = 0;\n\tif (!files)\n\t\treturn 0;\n\tspin_lock(&files->file_lock);\n\tfor (fdt = files_fdtable(files); n < fdt->max_fds; n++) {\n\t\tstruct file *file;\n\t\tfile = rcu_dereference_check_fdtable(files, fdt->fd[n]);\n\t\tif (!file)\n\t\t\tcontinue;\n\t\tres = f(p, file, n);\n\t\tif (res)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&files->file_lock);\n\treturn res;\n}"
  },
  {
    "function_name": "f_dupfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "948-959",
    "snippet": "int f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tint err;\n\tif (from >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "err",
            "file"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "400-411",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_fd",
          "args": [
            "from",
            "flags"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "537-540",
          "snippet": "static int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint f_dupfd(unsigned int from, struct file *file, unsigned flags)\n{\n\tint err;\n\tif (from >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\terr = alloc_fd(from, flags);\n\tif (err >= 0) {\n\t\tget_file(file);\n\t\tfd_install(err, file);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "ksys_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "928-941",
    "snippet": "int ksys_dup(unsigned int fildes)\n{\n\tint ret = -EBADF;\n\tstruct file *file = fget_raw(fildes);\n\n\tif (file) {\n\t\tret = get_unused_fd_flags(0);\n\t\tif (ret >= 0)\n\t\t\tfd_install(ret, file);\n\t\telse\n\t\t\tfput(file);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "ret",
            "file"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "0"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "542-545",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fget_raw",
          "args": [
            "fildes"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "fget_raw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "708-711",
          "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint ksys_dup(unsigned int fildes)\n{\n\tint ret = -EBADF;\n\tstruct file *file = fget_raw(fildes);\n\n\tif (file) {\n\t\tret = get_unused_fd_flags(0);\n\t\tif (ret >= 0)\n\t\t\tfd_install(ret, file);\n\t\telse\n\t\t\tfput(file);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ksys_dup3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "874-906",
    "snippet": "static int ksys_dup3(unsigned int oldfd, unsigned int newfd, int flags)\n{\n\tint err = -EBADF;\n\tstruct file *file;\n\tstruct files_struct *files = current->files;\n\n\tif ((flags & ~O_CLOEXEC) != 0)\n\t\treturn -EINVAL;\n\n\tif (unlikely(oldfd == newfd))\n\t\treturn -EINVAL;\n\n\tif (newfd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, newfd);\n\tfile = fcheck(oldfd);\n\tif (unlikely(!file))\n\t\tgoto Ebadf;\n\tif (unlikely(err < 0)) {\n\t\tif (err == -EMFILE)\n\t\t\tgoto Ebadf;\n\t\tgoto out_unlock;\n\t}\n\treturn do_dup2(files, file, newfd, flags);\n\nEbadf:\n\terr = -EBADF;\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_dup2",
          "args": [
            "files",
            "file",
            "newfd",
            "flags"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "do_dup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "808-850",
          "snippet": "static int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!file"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcheck",
          "args": [
            "oldfd"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_files",
          "args": [
            "files",
            "newfd"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "expand_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "193-226",
          "snippet": "static int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t/* All good, so we try */\n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t/* All good, so we try */\n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "oldfd == newfd"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int ksys_dup3(unsigned int oldfd, unsigned int newfd, int flags)\n{\n\tint err = -EBADF;\n\tstruct file *file;\n\tstruct files_struct *files = current->files;\n\n\tif ((flags & ~O_CLOEXEC) != 0)\n\t\treturn -EINVAL;\n\n\tif (unlikely(oldfd == newfd))\n\t\treturn -EINVAL;\n\n\tif (newfd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, newfd);\n\tfile = fcheck(oldfd);\n\tif (unlikely(!file))\n\t\tgoto Ebadf;\n\tif (unlikely(err < 0)) {\n\t\tif (err == -EMFILE)\n\t\t\tgoto Ebadf;\n\t\tgoto out_unlock;\n\t}\n\treturn do_dup2(files, file, newfd, flags);\n\nEbadf:\n\terr = -EBADF;\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "replace_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "852-872",
    "snippet": "int replace_fd(unsigned fd, struct file *file, unsigned flags)\n{\n\tint err;\n\tstruct files_struct *files = current->files;\n\n\tif (!file)\n\t\treturn __close_fd(files, fd);\n\n\tif (fd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, fd);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\treturn do_dup2(files, file, fd, flags);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_dup2",
          "args": [
            "files",
            "file",
            "fd",
            "flags"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "do_dup2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "808-850",
          "snippet": "static int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err < 0"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "expand_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "193-226",
          "snippet": "static int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t/* All good, so we try */\n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t/* All good, so we try */\n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__close_fd",
          "args": [
            "files",
            "fd"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "__close_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "620-640",
          "snippet": "int __close_fd(struct files_struct *files, unsigned fd)\n{\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn -EBADF;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __close_fd(struct files_struct *files, unsigned fd)\n{\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn -EBADF;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint replace_fd(unsigned fd, struct file *file, unsigned flags)\n{\n\tint err;\n\tstruct files_struct *files = current->files;\n\n\tif (!file)\n\t\treturn __close_fd(files, fd);\n\n\tif (fd >= rlimit(RLIMIT_NOFILE))\n\t\treturn -EBADF;\n\n\tspin_lock(&files->file_lock);\n\terr = expand_files(files, fd);\n\tif (unlikely(err < 0))\n\t\tgoto out_unlock;\n\treturn do_dup2(files, file, fd, flags);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "do_dup2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "808-850",
    "snippet": "static int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "tofree",
            "files"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1130-1148",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "233-237",
          "snippet": "static inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "__set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "228-231",
          "snippet": "static inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_open_fd",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "__set_open_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "239-245",
          "snippet": "static inline void __set_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n\tfd /= BITS_PER_LONG;\n\tif (!~fdt->open_fds[fd])\n\t\t__set_bit(fd, fdt->full_fds_bits);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n\tfd /= BITS_PER_LONG;\n\tif (!~fdt->open_fds[fd])\n\t\t__set_bit(fd, fdt->full_fds_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "file"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "400-411",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_is_open",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&files->file_lock"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int do_dup2(struct files_struct *files,\n\tstruct file *file, unsigned fd, unsigned flags)\n__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\n\t/*\n\t * We need to detect attempts to do dup2() over allocated but still\n\t * not finished descriptor.  NB: OpenBSD avoids that at the price of\n\t * extra work in their equivalent of fget() - they insert struct\n\t * file immediately after grabbing descriptor, mark it larval if\n\t * more work (e.g. actual opening) is needed and make sure that\n\t * fget() treats larval files as absent.  Potentially interesting,\n\t * but while extra work in fget() is trivial, locking implications\n\t * and amount of surgery on open()-related paths in VFS are not.\n\t * FreeBSD fails with -EBADF in the same situation, NetBSD \"solution\"\n\t * deadlocks in rather amusing ways, AFAICS.  All of that is out of\n\t * scope of POSIX or SUS, since neither considers shared descriptor\n\t * tables and this condition does not arise without those.\n\t */\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\n\treturn fd;\n\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}"
  },
  {
    "function_name": "get_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "796-806",
    "snippet": "bool get_close_on_exec(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tbool res;\n\trcu_read_lock();\n\tfdt = files_fdtable(files);\n\tres = close_on_exec(fd, fdt);\n\trcu_read_unlock();\n\treturn res;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "783-794",
          "snippet": "void set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nbool get_close_on_exec(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tbool res;\n\trcu_read_lock();\n\tfdt = files_fdtable(files);\n\tres = close_on_exec(fd, fdt);\n\trcu_read_unlock();\n\treturn res;\n}"
  },
  {
    "function_name": "set_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "783-794",
    "snippet": "void set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "233-237",
          "snippet": "static inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "__set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "228-231",
          "snippet": "static inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}"
  },
  {
    "function_name": "__f_unlock_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "772-775",
    "snippet": "void __f_unlock_pos(struct file *f)\n{\n\tmutex_unlock(&f->f_pos_lock);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&f->f_pos_lock"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid __f_unlock_pos(struct file *f)\n{\n\tmutex_unlock(&f->f_pos_lock);\n}"
  },
  {
    "function_name": "__fdget_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "758-770",
    "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&file->f_pos_lock"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_count",
          "args": [
            "file"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fdget",
          "args": [
            "fd"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
  },
  {
    "function_name": "__fdget_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "753-756",
    "snippet": "unsigned long __fdget_raw(unsigned int fd)\n{\n\treturn __fget_light(fd, 0);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget_light",
          "args": [
            "fd",
            "0"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "730-746",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_raw(unsigned int fd)\n{\n\treturn __fget_light(fd, 0);\n}"
  },
  {
    "function_name": "__fdget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "747-750",
    "snippet": "unsigned long __fdget(unsigned int fd)\n{\n\treturn __fget_light(fd, FMODE_PATH);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget_light",
          "args": [
            "fd",
            "FMODE_PATH"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "730-746",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget(unsigned int fd)\n{\n\treturn __fget_light(fd, FMODE_PATH);\n}"
  },
  {
    "function_name": "__fget_light",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "730-746",
    "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget",
          "args": [
            "fd",
            "mask"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "730-746",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "file->f_mode & mask"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&files->count"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
  },
  {
    "function_name": "fget_raw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "708-711",
    "snippet": "struct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget",
          "args": [
            "fd",
            "0"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "730-746",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget_raw(unsigned int fd)\n{\n\treturn __fget(fd, 0);\n}"
  },
  {
    "function_name": "fget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "702-705",
    "snippet": "struct file *fget(unsigned int fd)\n{\n\treturn __fget(fd, FMODE_PATH);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fget",
          "args": [
            "fd",
            "FMODE_PATH"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__fget_light",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "730-746",
          "snippet": "static unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned long __fget_light(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\tif (atomic_read(&files->count) == 1) {\n\t\tfile = __fcheck_files(files, fd);\n\t\tif (!file || unlikely(file->f_mode & mask))\n\t\t\treturn 0;\n\t\treturn (unsigned long)file;\n\t} else {\n\t\tfile = __fget(fd, mask);\n\t\tif (!file)\n\t\t\treturn 0;\n\t\treturn FDPUT_FPUT | (unsigned long)file;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct file *fget(unsigned int fd)\n{\n\treturn __fget(fd, FMODE_PATH);\n}"
  },
  {
    "function_name": "__fget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "679-700",
    "snippet": "static struct file *__fget(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\trcu_read_lock();\nloop:\n\tfile = fcheck_files(files, fd);\n\tif (file) {\n\t\t/* File object ref couldn't be taken.\n\t\t * dup2() atomicity guarantee is the reason\n\t\t * we loop to catch the new file (or NULL pointer)\n\t\t */\n\t\tif (file->f_mode & mask)\n\t\t\tfile = NULL;\n\t\telse if (!get_file_rcu(file))\n\t\t\tgoto loop;\n\t}\n\trcu_read_unlock();\n\n\treturn file;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file_rcu",
          "args": [
            "file"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct file *__fget(unsigned int fd, fmode_t mask)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\n\trcu_read_lock();\nloop:\n\tfile = fcheck_files(files, fd);\n\tif (file) {\n\t\t/* File object ref couldn't be taken.\n\t\t * dup2() atomicity guarantee is the reason\n\t\t * we loop to catch the new file (or NULL pointer)\n\t\t */\n\t\tif (file->f_mode & mask)\n\t\t\tfile = NULL;\n\t\telse if (!get_file_rcu(file))\n\t\t\tgoto loop;\n\t}\n\trcu_read_unlock();\n\n\treturn file;\n}"
  },
  {
    "function_name": "do_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "643-677",
    "snippet": "void do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t/* exec unshares first */\n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "files"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1130-1148",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_unused_fd",
          "args": [
            "files",
            "fd"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "548-554",
          "snippet": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "NULL"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t/* exec unshares first */\n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}"
  },
  {
    "function_name": "__close_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "620-640",
    "snippet": "int __close_fd(struct files_struct *files, unsigned fd)\n{\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn -EBADF;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "files"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1130-1148",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_unused_fd",
          "args": [
            "files",
            "fd"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "548-554",
          "snippet": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "NULL"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __close_fd(struct files_struct *files, unsigned fd)\n{\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\treturn -EBADF;\n}"
  },
  {
    "function_name": "fd_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "610-613",
    "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fd_install",
          "args": [
            "current->files",
            "fd",
            "file"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "__fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "586-608",
          "snippet": "void __fd_install(struct files_struct *files, unsigned int fd,\n\t\tstruct file *file)\n{\n\tstruct fdtable *fdt;\n\n\trcu_read_lock_sched();\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\trcu_read_unlock_sched();\n\t\tspin_lock(&files->file_lock);\n\t\tfdt = files_fdtable(files);\n\t\tBUG_ON(fdt->fd[fd] != NULL);\n\t\trcu_assign_pointer(fdt->fd[fd], file);\n\t\tspin_unlock(&files->file_lock);\n\t\treturn;\n\t}\n\t/* coupled with smp_wmb() in expand_fdtable() */\n\tsmp_rmb();\n\tfdt = rcu_dereference_sched(files->fdt);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\trcu_read_unlock_sched();\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid __fd_install(struct files_struct *files, unsigned int fd,\n\t\tstruct file *file)\n{\n\tstruct fdtable *fdt;\n\n\trcu_read_lock_sched();\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\trcu_read_unlock_sched();\n\t\tspin_lock(&files->file_lock);\n\t\tfdt = files_fdtable(files);\n\t\tBUG_ON(fdt->fd[fd] != NULL);\n\t\trcu_assign_pointer(fdt->fd[fd], file);\n\t\tspin_unlock(&files->file_lock);\n\t\treturn;\n\t}\n\t/* coupled with smp_wmb() in expand_fdtable() */\n\tsmp_rmb();\n\tfdt = rcu_dereference_sched(files->fdt);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\trcu_read_unlock_sched();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
  },
  {
    "function_name": "__fd_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "586-608",
    "snippet": "void __fd_install(struct files_struct *files, unsigned int fd,\n\t\tstruct file *file)\n{\n\tstruct fdtable *fdt;\n\n\trcu_read_lock_sched();\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\trcu_read_unlock_sched();\n\t\tspin_lock(&files->file_lock);\n\t\tfdt = files_fdtable(files);\n\t\tBUG_ON(fdt->fd[fd] != NULL);\n\t\trcu_assign_pointer(fdt->fd[fd], file);\n\t\tspin_unlock(&files->file_lock);\n\t\treturn;\n\t}\n\t/* coupled with smp_wmb() in expand_fdtable() */\n\tsmp_rmb();\n\tfdt = rcu_dereference_sched(files->fdt);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\trcu_read_unlock_sched();\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "file"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fdt->fd[fd] != NULL"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "files->fdt"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "file"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fdt->fd[fd] != NULL"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "files->resize_in_progress"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid __fd_install(struct files_struct *files, unsigned int fd,\n\t\tstruct file *file)\n{\n\tstruct fdtable *fdt;\n\n\trcu_read_lock_sched();\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\trcu_read_unlock_sched();\n\t\tspin_lock(&files->file_lock);\n\t\tfdt = files_fdtable(files);\n\t\tBUG_ON(fdt->fd[fd] != NULL);\n\t\trcu_assign_pointer(fdt->fd[fd], file);\n\t\tspin_unlock(&files->file_lock);\n\t\treturn;\n\t}\n\t/* coupled with smp_wmb() in expand_fdtable() */\n\tsmp_rmb();\n\tfdt = rcu_dereference_sched(files->fdt);\n\tBUG_ON(fdt->fd[fd] != NULL);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\trcu_read_unlock_sched();\n}"
  },
  {
    "function_name": "put_unused_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "556-562",
    "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_unused_fd",
          "args": [
            "files",
            "fd"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "__put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "548-554",
          "snippet": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
  },
  {
    "function_name": "__put_unused_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "548-554",
    "snippet": "static void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_open_fd",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_open_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "247-251",
          "snippet": "static inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __put_unused_fd(struct files_struct *files, unsigned int fd)\n{\n\tstruct fdtable *fdt = files_fdtable(files);\n\t__clear_open_fd(fd, fdt);\n\tif (fd < files->next_fd)\n\t\tfiles->next_fd = fd;\n}"
  },
  {
    "function_name": "get_unused_fd_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "542-545",
    "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alloc_fd",
          "args": [
            "current->files",
            "0",
            "rlimit(RLIMIT_NOFILE)",
            "flags"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "479-535",
          "snippet": "int __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_fd(fdt, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_fd(fdt, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
  },
  {
    "function_name": "alloc_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "537-540",
    "snippet": "static int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__alloc_fd",
          "args": [
            "current->files",
            "start",
            "rlimit(RLIMIT_NOFILE)",
            "flags"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "479-535",
          "snippet": "int __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_fd(fdt, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_fd(fdt, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic int alloc_fd(unsigned start, unsigned flags)\n{\n\treturn __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);\n}"
  },
  {
    "function_name": "__alloc_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "479-535",
    "snippet": "int __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_fd(fdt, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fdt->fd[fd]",
            "NULL"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\"",
            "fd"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "cachefiles_printk_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/cachefiles/namei.c",
          "lines": "74-81",
          "snippet": "static noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic noinline void cachefiles_printk_object(struct cachefiles_object *object,\n\t\t\t\t\t      struct cachefiles_object *xobject)\n{\n\tif (object)\n\t\t__cachefiles_printk_object(object, \"\");\n\tif (xobject)\n\t\t__cachefiles_printk_object(xobject, \"x\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "fdt->fd[fd]"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "233-237",
          "snippet": "static inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_close_on_exec",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "__set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "228-231",
          "snippet": "static inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_open_fd",
          "args": [
            "fd",
            "fdt"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "__set_open_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "239-245",
          "snippet": "static inline void __set_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n\tfd /= BITS_PER_LONG;\n\tif (!~fdt->open_fds[fd])\n\t\t__set_bit(fd, fdt->full_fds_bits);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n\tfd /= BITS_PER_LONG;\n\tif (!~fdt->open_fds[fd])\n\t\t__set_bit(fd, fdt->full_fds_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expand_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "expand_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "193-226",
          "snippet": "static int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t/* All good, so we try */\n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t/* All good, so we try */\n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_fd",
          "args": [
            "fdt",
            "fd"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "462-474",
          "snippet": "static unsigned int find_next_fd(struct fdtable *fdt, unsigned int start)\n{\n\tunsigned int maxfd = fdt->max_fds;\n\tunsigned int maxbit = maxfd / BITS_PER_LONG;\n\tunsigned int bitbit = start / BITS_PER_LONG;\n\n\tbitbit = find_next_zero_bit(fdt->full_fds_bits, maxbit, bitbit) * BITS_PER_LONG;\n\tif (bitbit > maxfd)\n\t\treturn maxfd;\n\tif (bitbit > start)\n\t\tstart = bitbit;\n\treturn find_next_zero_bit(fdt->open_fds, maxfd, start);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int find_next_fd(struct fdtable *fdt, unsigned int start)\n{\n\tunsigned int maxfd = fdt->max_fds;\n\tunsigned int maxbit = maxfd / BITS_PER_LONG;\n\tunsigned int bitbit = start / BITS_PER_LONG;\n\n\tbitbit = find_next_zero_bit(fdt->full_fds_bits, maxbit, bitbit) * BITS_PER_LONG;\n\tif (bitbit > maxfd)\n\t\treturn maxfd;\n\tif (bitbit > start)\n\t\tstart = bitbit;\n\treturn find_next_zero_bit(fdt->open_fds, maxfd, start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint __alloc_fd(struct files_struct *files,\n\t       unsigned start, unsigned end, unsigned flags)\n{\n\tunsigned int fd;\n\tint error;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\nrepeat:\n\tfdt = files_fdtable(files);\n\tfd = start;\n\tif (fd < files->next_fd)\n\t\tfd = files->next_fd;\n\n\tif (fd < fdt->max_fds)\n\t\tfd = find_next_fd(fdt, fd);\n\n\t/*\n\t * N.B. For clone tasks sharing a files structure, this test\n\t * will limit the total number of files that can be opened.\n\t */\n\terror = -EMFILE;\n\tif (fd >= end)\n\t\tgoto out;\n\n\terror = expand_files(files, fd);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/*\n\t * If we needed to expand the fs array we\n\t * might have blocked - try again.\n\t */\n\tif (error)\n\t\tgoto repeat;\n\n\tif (start <= files->next_fd)\n\t\tfiles->next_fd = fd + 1;\n\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\terror = fd;\n#if 1\n\t/* Sanity check */\n\tif (rcu_access_pointer(fdt->fd[fd]) != NULL) {\n\t\tprintk(KERN_WARNING \"alloc_fd: slot %d not NULL!\\n\", fd);\n\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t}\n#endif\n\nout:\n\tspin_unlock(&files->file_lock);\n\treturn error;\n}"
  },
  {
    "function_name": "find_next_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "462-474",
    "snippet": "static unsigned int find_next_fd(struct fdtable *fdt, unsigned int start)\n{\n\tunsigned int maxfd = fdt->max_fds;\n\tunsigned int maxbit = maxfd / BITS_PER_LONG;\n\tunsigned int bitbit = start / BITS_PER_LONG;\n\n\tbitbit = find_next_zero_bit(fdt->full_fds_bits, maxbit, bitbit) * BITS_PER_LONG;\n\tif (bitbit > maxfd)\n\t\treturn maxfd;\n\tif (bitbit > start)\n\t\tstart = bitbit;\n\treturn find_next_zero_bit(fdt->open_fds, maxfd, start);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "fdt->open_fds",
            "maxfd",
            "start"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_next_zero_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "932-944",
          "snippet": "static inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_find_next_zero_bit find_next_zero_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_find_next_zero_bit find_next_zero_bit_le\n\nstatic inline int ocfs2_find_next_zero_bit_unaligned(void *bitmap, int max,\n\t\t\t\t\t\t\tint start)\n{\n\tint fix = 0, ret, tmpmax;\n\tbitmap = correct_addr_and_bit_unaligned(&fix, bitmap);\n\ttmpmax = max + fix;\n\tstart += fix;\n\n\tret = ocfs2_find_next_zero_bit(bitmap, tmpmax, start) - fix;\n\tif (ret > max)\n\t\treturn max;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int find_next_fd(struct fdtable *fdt, unsigned int start)\n{\n\tunsigned int maxfd = fdt->max_fds;\n\tunsigned int maxbit = maxfd / BITS_PER_LONG;\n\tunsigned int bitbit = start / BITS_PER_LONG;\n\n\tbitbit = find_next_zero_bit(fdt->full_fds_bits, maxbit, bitbit) * BITS_PER_LONG;\n\tif (bitbit > maxfd)\n\t\treturn maxfd;\n\tif (bitbit > start)\n\t\tstart = bitbit;\n\treturn find_next_zero_bit(fdt->open_fds, maxfd, start);\n}"
  },
  {
    "function_name": "exit_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "437-447",
    "snippet": "void exit_files(struct task_struct *tsk)\n{\n\tstruct files_struct * files = tsk->files;\n\n\tif (files) {\n\t\ttask_lock(tsk);\n\t\ttsk->files = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_files_struct(files);\n\t}\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "files"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "413-423",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid exit_files(struct task_struct *tsk)\n{\n\tstruct files_struct * files = tsk->files;\n\n\tif (files) {\n\t\ttask_lock(tsk);\n\t\ttsk->files = NULL;\n\t\ttask_unlock(tsk);\n\t\tput_files_struct(files);\n\t}\n}"
  },
  {
    "function_name": "reset_files_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "425-435",
    "snippet": "void reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "old"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "413-423",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}"
  },
  {
    "function_name": "put_files_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "413-423",
    "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "files_cachep",
            "files"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_fdtable",
          "args": [
            "fdt"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "__free_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "29-34",
          "snippet": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_files",
          "args": [
            "files"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "close_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "368-398",
          "snippet": "static struct fdtable *close_files(struct files_struct * files)\n{\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct fdtable *close_files(struct files_struct * files)\n{\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&files->count"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
  },
  {
    "function_name": "get_files_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "400-411",
    "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&files->count"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
  },
  {
    "function_name": "close_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "368-398",
    "snippet": "static struct fdtable *close_files(struct files_struct * files)\n{\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_close",
          "args": [
            "file",
            "files"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "filp_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/open.c",
          "lines": "1130-1148",
          "snippet": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tif (likely(!(filp->f_mode & FMODE_PATH))) {\n\t\tdnotify_flush(filp, id);\n\t\tlocks_remove_posix(filp, id);\n\t}\n\tfput(filp);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&fdt->fd[i]",
            "NULL"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "files->fdt"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic struct fdtable *close_files(struct files_struct * files)\n{\n\t/*\n\t * It is safe to dereference the fd table without RCU or\n\t * ->file_lock because this is the last reference to the\n\t * files structure.\n\t */\n\tstruct fdtable *fdt = rcu_dereference_raw(files->fdt);\n\tunsigned int i, j = 0;\n\n\tfor (;;) {\n\t\tunsigned long set;\n\t\ti = j * BITS_PER_LONG;\n\t\tif (i >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->open_fds[j++];\n\t\twhile (set) {\n\t\t\tif (set & 1) {\n\t\t\t\tstruct file * file = xchg(&fdt->fd[i], NULL);\n\t\t\t\tif (file) {\n\t\t\t\t\tfilp_close(file, files);\n\t\t\t\t\tcond_resched();\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\tset >>= 1;\n\t\t}\n\t}\n\n\treturn fdt;\n}"
  },
  {
    "function_name": "dup_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "272-366",
    "snippet": "struct files_struct *dup_fd(struct files_struct *oldf, int *errorp)\n{\n\tstruct files_struct *newf;\n\tstruct file **old_fds, **new_fds;\n\tunsigned int open_files, i;\n\tstruct fdtable *old_fdt, *new_fdt;\n\n\t*errorp = -ENOMEM;\n\tnewf = kmem_cache_alloc(files_cachep, GFP_KERNEL);\n\tif (!newf)\n\t\tgoto out;\n\n\tatomic_set(&newf->count, 1);\n\n\tspin_lock_init(&newf->file_lock);\n\tnewf->resize_in_progress = false;\n\tinit_waitqueue_head(&newf->resize_wait);\n\tnewf->next_fd = 0;\n\tnew_fdt = &newf->fdtab;\n\tnew_fdt->max_fds = NR_OPEN_DEFAULT;\n\tnew_fdt->close_on_exec = newf->close_on_exec_init;\n\tnew_fdt->open_fds = newf->open_fds_init;\n\tnew_fdt->full_fds_bits = newf->full_fds_bits_init;\n\tnew_fdt->fd = &newf->fd_array[0];\n\n\tspin_lock(&oldf->file_lock);\n\told_fdt = files_fdtable(oldf);\n\topen_files = count_open_files(old_fdt);\n\n\t/*\n\t * Check whether we need to allocate a larger fd array and fd set.\n\t */\n\twhile (unlikely(open_files > new_fdt->max_fds)) {\n\t\tspin_unlock(&oldf->file_lock);\n\n\t\tif (new_fdt != &newf->fdtab)\n\t\t\t__free_fdtable(new_fdt);\n\n\t\tnew_fdt = alloc_fdtable(open_files - 1);\n\t\tif (!new_fdt) {\n\t\t\t*errorp = -ENOMEM;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t/* beyond sysctl_nr_open; nothing to do */\n\t\tif (unlikely(new_fdt->max_fds < open_files)) {\n\t\t\t__free_fdtable(new_fdt);\n\t\t\t*errorp = -EMFILE;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t/*\n\t\t * Reacquire the oldf lock and a pointer to its fd table\n\t\t * who knows it may have a new bigger fd table. We need\n\t\t * the latest pointer.\n\t\t */\n\t\tspin_lock(&oldf->file_lock);\n\t\told_fdt = files_fdtable(oldf);\n\t\topen_files = count_open_files(old_fdt);\n\t}\n\n\tcopy_fd_bitmaps(new_fdt, old_fdt, open_files);\n\n\told_fds = old_fdt->fd;\n\tnew_fds = new_fdt->fd;\n\n\tfor (i = open_files; i != 0; i--) {\n\t\tstruct file *f = *old_fds++;\n\t\tif (f) {\n\t\t\tget_file(f);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The fd may be claimed in the fd bitmap but not yet\n\t\t\t * instantiated in the files array if a sibling thread\n\t\t\t * is partway through open().  So make sure that this\n\t\t\t * fd is available to the new process.\n\t\t\t */\n\t\t\t__clear_open_fd(open_files - i, new_fdt);\n\t\t}\n\t\trcu_assign_pointer(*new_fds++, f);\n\t}\n\tspin_unlock(&oldf->file_lock);\n\n\t/* clear the remainder */\n\tmemset(new_fds, 0, (new_fdt->max_fds - open_files) * sizeof(struct file *));\n\n\trcu_assign_pointer(newf->fdt, new_fdt);\n\n\treturn newf;\n\nout_release:\n\tkmem_cache_free(files_cachep, newf);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int sysctl_nr_open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "files_cachep",
            "newf"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "newf->fdt",
            "new_fdt"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_fds",
            "0",
            "(new_fdt->max_fds - open_files) * sizeof(struct file *)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oldf->file_lock"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "*new_fds++",
            "f"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_open_fd",
          "args": [
            "open_files - i",
            "new_fdt"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_open_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "247-251",
          "snippet": "static inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "f"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "400-411",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fd_bitmaps",
          "args": [
            "new_fdt",
            "old_fdt",
            "open_files"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fd_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "49-65",
          "snippet": "static void copy_fd_bitmaps(struct fdtable *nfdt, struct fdtable *ofdt,\n\t\t\t    unsigned int count)\n{\n\tunsigned int cpy, set;\n\n\tcpy = count / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - count) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)nfdt->open_fds + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)nfdt->close_on_exec + cpy, 0, set);\n\n\tcpy = BITBIT_SIZE(count);\n\tset = BITBIT_SIZE(nfdt->max_fds) - cpy;\n\tmemcpy(nfdt->full_fds_bits, ofdt->full_fds_bits, cpy);\n\tmemset((char *)nfdt->full_fds_bits + cpy, 0, set);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void copy_fd_bitmaps(struct fdtable *nfdt, struct fdtable *ofdt,\n\t\t\t    unsigned int count)\n{\n\tunsigned int cpy, set;\n\n\tcpy = count / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - count) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)nfdt->open_fds + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)nfdt->close_on_exec + cpy, 0, set);\n\n\tcpy = BITBIT_SIZE(count);\n\tset = BITBIT_SIZE(nfdt->max_fds) - cpy;\n\tmemcpy(nfdt->full_fds_bits, ofdt->full_fds_bits, cpy);\n\tmemset((char *)nfdt->full_fds_bits + cpy, 0, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count_open_files",
          "args": [
            "old_fdt"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "count_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "253-265",
          "snippet": "static unsigned int count_open_files(struct fdtable *fdt)\n{\n\tunsigned int size = fdt->max_fds;\n\tunsigned int i;\n\n\t/* Find the last open fd */\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int count_open_files(struct fdtable *fdt)\n{\n\tunsigned int size = fdt->max_fds;\n\tunsigned int i;\n\n\t/* Find the last open fd */\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "oldf"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oldf->file_lock"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_fdtable",
          "args": [
            "new_fdt"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__free_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "29-34",
          "snippet": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_fdt->max_fds < open_files"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fdtable",
          "args": [
            "open_files - 1"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "85-139",
          "snippet": "static struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL_ACCOUNT);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = kvmalloc_array(nr, sizeof(struct file *), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = kvmalloc(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr), L1_CACHE_BYTES),\n\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->full_fds_bits = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL_ACCOUNT);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = kvmalloc_array(nr, sizeof(struct file *), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = kvmalloc(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr), L1_CACHE_BYTES),\n\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->full_fds_bits = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "open_files > new_fdt->max_fds"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "oldf"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&newf->resize_wait"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&newf->file_lock"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&newf->count",
            "1"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "files_cachep",
            "GFP_KERNEL"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstruct files_struct *dup_fd(struct files_struct *oldf, int *errorp)\n{\n\tstruct files_struct *newf;\n\tstruct file **old_fds, **new_fds;\n\tunsigned int open_files, i;\n\tstruct fdtable *old_fdt, *new_fdt;\n\n\t*errorp = -ENOMEM;\n\tnewf = kmem_cache_alloc(files_cachep, GFP_KERNEL);\n\tif (!newf)\n\t\tgoto out;\n\n\tatomic_set(&newf->count, 1);\n\n\tspin_lock_init(&newf->file_lock);\n\tnewf->resize_in_progress = false;\n\tinit_waitqueue_head(&newf->resize_wait);\n\tnewf->next_fd = 0;\n\tnew_fdt = &newf->fdtab;\n\tnew_fdt->max_fds = NR_OPEN_DEFAULT;\n\tnew_fdt->close_on_exec = newf->close_on_exec_init;\n\tnew_fdt->open_fds = newf->open_fds_init;\n\tnew_fdt->full_fds_bits = newf->full_fds_bits_init;\n\tnew_fdt->fd = &newf->fd_array[0];\n\n\tspin_lock(&oldf->file_lock);\n\told_fdt = files_fdtable(oldf);\n\topen_files = count_open_files(old_fdt);\n\n\t/*\n\t * Check whether we need to allocate a larger fd array and fd set.\n\t */\n\twhile (unlikely(open_files > new_fdt->max_fds)) {\n\t\tspin_unlock(&oldf->file_lock);\n\n\t\tif (new_fdt != &newf->fdtab)\n\t\t\t__free_fdtable(new_fdt);\n\n\t\tnew_fdt = alloc_fdtable(open_files - 1);\n\t\tif (!new_fdt) {\n\t\t\t*errorp = -ENOMEM;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t/* beyond sysctl_nr_open; nothing to do */\n\t\tif (unlikely(new_fdt->max_fds < open_files)) {\n\t\t\t__free_fdtable(new_fdt);\n\t\t\t*errorp = -EMFILE;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\t/*\n\t\t * Reacquire the oldf lock and a pointer to its fd table\n\t\t * who knows it may have a new bigger fd table. We need\n\t\t * the latest pointer.\n\t\t */\n\t\tspin_lock(&oldf->file_lock);\n\t\told_fdt = files_fdtable(oldf);\n\t\topen_files = count_open_files(old_fdt);\n\t}\n\n\tcopy_fd_bitmaps(new_fdt, old_fdt, open_files);\n\n\told_fds = old_fdt->fd;\n\tnew_fds = new_fdt->fd;\n\n\tfor (i = open_files; i != 0; i--) {\n\t\tstruct file *f = *old_fds++;\n\t\tif (f) {\n\t\t\tget_file(f);\n\t\t} else {\n\t\t\t/*\n\t\t\t * The fd may be claimed in the fd bitmap but not yet\n\t\t\t * instantiated in the files array if a sibling thread\n\t\t\t * is partway through open().  So make sure that this\n\t\t\t * fd is available to the new process.\n\t\t\t */\n\t\t\t__clear_open_fd(open_files - i, new_fdt);\n\t\t}\n\t\trcu_assign_pointer(*new_fds++, f);\n\t}\n\tspin_unlock(&oldf->file_lock);\n\n\t/* clear the remainder */\n\tmemset(new_fds, 0, (new_fdt->max_fds - open_files) * sizeof(struct file *));\n\n\trcu_assign_pointer(newf->fdt, new_fdt);\n\n\treturn newf;\n\nout_release:\n\tkmem_cache_free(files_cachep, newf);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "count_open_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "253-265",
    "snippet": "static unsigned int count_open_files(struct fdtable *fdt)\n{\n\tunsigned int size = fdt->max_fds;\n\tunsigned int i;\n\n\t/* Find the last open fd */\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic unsigned int count_open_files(struct fdtable *fdt)\n{\n\tunsigned int size = fdt->max_fds;\n\tunsigned int i;\n\n\t/* Find the last open fd */\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}"
  },
  {
    "function_name": "__clear_open_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "247-251",
    "snippet": "static inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "fd / BITS_PER_LONG",
            "fdt->full_fds_bits"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "fd",
            "fdt->open_fds"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__clear_bit(fd, fdt->open_fds);\n\t__clear_bit(fd / BITS_PER_LONG, fdt->full_fds_bits);\n}"
  },
  {
    "function_name": "__set_open_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "239-245",
    "snippet": "static inline void __set_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n\tfd /= BITS_PER_LONG;\n\tif (!~fdt->open_fds[fd])\n\t\t__set_bit(fd, fdt->full_fds_bits);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "fd",
            "fdt->full_fds_bits"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "fd",
            "fdt->open_fds"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n\tfd /= BITS_PER_LONG;\n\tif (!~fdt->open_fds[fd])\n\t\t__set_bit(fd, fdt->full_fds_bits);\n}"
  },
  {
    "function_name": "__clear_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "233-237",
    "snippet": "static inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "fd",
            "fdt->close_on_exec"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "fd",
            "fdt->close_on_exec"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/ocfs2.h",
          "lines": "926-930",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __clear_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\tif (test_bit(fd, fdt->close_on_exec))\n\t\t__clear_bit(fd, fdt->close_on_exec);\n}"
  },
  {
    "function_name": "__set_close_on_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "228-231",
    "snippet": "static inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "fd",
            "fdt->close_on_exec"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic inline void __set_close_on_exec(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->close_on_exec);\n}"
  },
  {
    "function_name": "expand_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "193-226",
    "snippet": "static int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t/* All good, so we try */\n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int sysctl_nr_open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&files->resize_wait"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_fdtable",
          "args": [
            "files",
            "nr"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "expand_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "148-183",
          "snippet": "static int expand_fdtable(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\n\t/* make sure all __fd_install() have seen resize_in_progress\n\t * or have finished their rcu_read_lock_sched() section.\n\t */\n\tif (atomic_read(&files->count) > 1)\n\t\tsynchronize_sched();\n\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t/*\n\t * extremely unlikely race - sysctl_nr_open decreased between the check in\n\t * caller and alloc_fdtable().  Cheaper to catch it here...\n\t */\n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\tcur_fdt = files_fdtable(files);\n\tBUG_ON(nr < cur_fdt->max_fds);\n\tcopy_fdtable(new_fdt, cur_fdt);\n\trcu_assign_pointer(files->fdt, new_fdt);\n\tif (cur_fdt != &files->fdtab)\n\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t/* coupled with smp_rmb() in __fd_install() */\n\tsmp_wmb();\n\treturn 1;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic int expand_fdtable(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\n\t/* make sure all __fd_install() have seen resize_in_progress\n\t * or have finished their rcu_read_lock_sched() section.\n\t */\n\tif (atomic_read(&files->count) > 1)\n\t\tsynchronize_sched();\n\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t/*\n\t * extremely unlikely race - sysctl_nr_open decreased between the check in\n\t * caller and alloc_fdtable().  Cheaper to catch it here...\n\t */\n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\tcur_fdt = files_fdtable(files);\n\tBUG_ON(nr < cur_fdt->max_fds);\n\tcopy_fdtable(new_fdt, cur_fdt);\n\trcu_assign_pointer(files->fdt, new_fdt);\n\tif (cur_fdt != &files->fdtab)\n\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t/* coupled with smp_rmb() in __fd_install() */\n\tsmp_wmb();\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "files->resize_wait",
            "!files->resize_in_progress"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "files->resize_in_progress"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "files->file_lock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "files->file_lock"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic int expand_files(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *fdt;\n\tint expanded = 0;\n\nrepeat:\n\tfdt = files_fdtable(files);\n\n\t/* Do we need to expand? */\n\tif (nr < fdt->max_fds)\n\t\treturn expanded;\n\n\t/* Can we expand? */\n\tif (nr >= sysctl_nr_open)\n\t\treturn -EMFILE;\n\n\tif (unlikely(files->resize_in_progress)) {\n\t\tspin_unlock(&files->file_lock);\n\t\texpanded = 1;\n\t\twait_event(files->resize_wait, !files->resize_in_progress);\n\t\tspin_lock(&files->file_lock);\n\t\tgoto repeat;\n\t}\n\n\t/* All good, so we try */\n\tfiles->resize_in_progress = true;\n\texpanded = expand_fdtable(files, nr);\n\tfiles->resize_in_progress = false;\n\n\twake_up_all(&files->resize_wait);\n\treturn expanded;\n}"
  },
  {
    "function_name": "expand_fdtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "148-183",
    "snippet": "static int expand_fdtable(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\n\t/* make sure all __fd_install() have seen resize_in_progress\n\t * or have finished their rcu_read_lock_sched() section.\n\t */\n\tif (atomic_read(&files->count) > 1)\n\t\tsynchronize_sched();\n\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t/*\n\t * extremely unlikely race - sysctl_nr_open decreased between the check in\n\t * caller and alloc_fdtable().  Cheaper to catch it here...\n\t */\n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\tcur_fdt = files_fdtable(files);\n\tBUG_ON(nr < cur_fdt->max_fds);\n\tcopy_fdtable(new_fdt, cur_fdt);\n\trcu_assign_pointer(files->fdt, new_fdt);\n\tif (cur_fdt != &files->fdtab)\n\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t/* coupled with smp_rmb() in __fd_install() */\n\tsmp_wmb();\n\treturn 1;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int sysctl_nr_open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&cur_fdt->rcu",
            "free_fdtable_rcu"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "files->fdt",
            "new_fdt"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_fdtable",
          "args": [
            "new_fdt",
            "cur_fdt"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "71-83",
          "snippet": "static void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tunsigned int cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)nfdt->fd + cpy, 0, set);\n\n\tcopy_fd_bitmaps(nfdt, ofdt, ofdt->max_fds);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tunsigned int cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)nfdt->fd + cpy, 0, set);\n\n\tcopy_fd_bitmaps(nfdt, ofdt, ofdt->max_fds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr < cur_fdt->max_fds"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "files"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_fdtable",
          "args": [
            "new_fdt"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__free_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "29-34",
          "snippet": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "new_fdt->max_fds <= nr"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&files->count"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_fdtable",
          "args": [
            "nr"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_fdtable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "85-139",
          "snippet": "static struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL_ACCOUNT);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = kvmalloc_array(nr, sizeof(struct file *), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = kvmalloc(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr), L1_CACHE_BYTES),\n\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->full_fds_bits = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int sysctl_nr_open"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL_ACCOUNT);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = kvmalloc_array(nr, sizeof(struct file *), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = kvmalloc(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr), L1_CACHE_BYTES),\n\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->full_fds_bits = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "files->file_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "files->file_lock"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic int expand_fdtable(struct files_struct *files, unsigned int nr)\n\t__releases(files->file_lock)\n\t__acquires(files->file_lock)\n{\n\tstruct fdtable *new_fdt, *cur_fdt;\n\n\tspin_unlock(&files->file_lock);\n\tnew_fdt = alloc_fdtable(nr);\n\n\t/* make sure all __fd_install() have seen resize_in_progress\n\t * or have finished their rcu_read_lock_sched() section.\n\t */\n\tif (atomic_read(&files->count) > 1)\n\t\tsynchronize_sched();\n\n\tspin_lock(&files->file_lock);\n\tif (!new_fdt)\n\t\treturn -ENOMEM;\n\t/*\n\t * extremely unlikely race - sysctl_nr_open decreased between the check in\n\t * caller and alloc_fdtable().  Cheaper to catch it here...\n\t */\n\tif (unlikely(new_fdt->max_fds <= nr)) {\n\t\t__free_fdtable(new_fdt);\n\t\treturn -EMFILE;\n\t}\n\tcur_fdt = files_fdtable(files);\n\tBUG_ON(nr < cur_fdt->max_fds);\n\tcopy_fdtable(new_fdt, cur_fdt);\n\trcu_assign_pointer(files->fdt, new_fdt);\n\tif (cur_fdt != &files->fdtab)\n\t\tcall_rcu(&cur_fdt->rcu, free_fdtable_rcu);\n\t/* coupled with smp_rmb() in __fd_install() */\n\tsmp_wmb();\n\treturn 1;\n}"
  },
  {
    "function_name": "alloc_fdtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "85-139",
    "snippet": "static struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL_ACCOUNT);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = kvmalloc_array(nr, sizeof(struct file *), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = kvmalloc(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr), L1_CACHE_BYTES),\n\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->full_fds_bits = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int sysctl_nr_open"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fdt"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "fdt->fd"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr), L1_CACHE_BYTES)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/super.c",
          "lines": "183-191",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"fsmap.h\"",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/iversion.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/dax.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/iversion.h>\n#include <linux/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/dax.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr)",
            "L1_CACHE_BYTES"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITBIT_SIZE",
          "args": [
            "nr"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc_array",
          "args": [
            "nr",
            "sizeof(struct file *)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct fdtable)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nr > sysctl_nr_open"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "nr + 1"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned int sysctl_nr_open;\n\nstatic struct fdtable * alloc_fdtable(unsigned int nr)\n{\n\tstruct fdtable *fdt;\n\tvoid *data;\n\n\t/*\n\t * Figure out how many fds we actually want to support in this fdtable.\n\t * Allocation steps are keyed to the size of the fdarray, since it\n\t * grows far faster than any of the other dynamic data. We try to fit\n\t * the fdarray into comfortable page-tuned chunks: starting at 1024B\n\t * and growing in powers of two from there on.\n\t */\n\tnr /= (1024 / sizeof(struct file *));\n\tnr = roundup_pow_of_two(nr + 1);\n\tnr *= (1024 / sizeof(struct file *));\n\t/*\n\t * Note that this can drive nr *below* what we had passed if sysctl_nr_open\n\t * had been set lower between the check in expand_files() and here.  Deal\n\t * with that in caller, it's cheaper that way.\n\t *\n\t * We make sure that nr remains a multiple of BITS_PER_LONG - otherwise\n\t * bitmaps handling below becomes unpleasant, to put it mildly...\n\t */\n\tif (unlikely(nr > sysctl_nr_open))\n\t\tnr = ((sysctl_nr_open - 1) | (BITS_PER_LONG - 1)) + 1;\n\n\tfdt = kmalloc(sizeof(struct fdtable), GFP_KERNEL_ACCOUNT);\n\tif (!fdt)\n\t\tgoto out;\n\tfdt->max_fds = nr;\n\tdata = kvmalloc_array(nr, sizeof(struct file *), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_fdt;\n\tfdt->fd = data;\n\n\tdata = kvmalloc(max_t(size_t,\n\t\t\t\t 2 * nr / BITS_PER_BYTE + BITBIT_SIZE(nr), L1_CACHE_BYTES),\n\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto out_arr;\n\tfdt->open_fds = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->close_on_exec = data;\n\tdata += nr / BITS_PER_BYTE;\n\tfdt->full_fds_bits = data;\n\n\treturn fdt;\n\nout_arr:\n\tkvfree(fdt->fd);\nout_fdt:\n\tkfree(fdt);\nout:\n\treturn NULL;\n}"
  },
  {
    "function_name": "copy_fdtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "71-83",
    "snippet": "static void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tunsigned int cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)nfdt->fd + cpy, 0, set);\n\n\tcopy_fd_bitmaps(nfdt, ofdt, ofdt->max_fds);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_fd_bitmaps",
          "args": [
            "nfdt",
            "ofdt",
            "ofdt->max_fds"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fd_bitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "49-65",
          "snippet": "static void copy_fd_bitmaps(struct fdtable *nfdt, struct fdtable *ofdt,\n\t\t\t    unsigned int count)\n{\n\tunsigned int cpy, set;\n\n\tcpy = count / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - count) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)nfdt->open_fds + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)nfdt->close_on_exec + cpy, 0, set);\n\n\tcpy = BITBIT_SIZE(count);\n\tset = BITBIT_SIZE(nfdt->max_fds) - cpy;\n\tmemcpy(nfdt->full_fds_bits, ofdt->full_fds_bits, cpy);\n\tmemset((char *)nfdt->full_fds_bits + cpy, 0, set);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void copy_fd_bitmaps(struct fdtable *nfdt, struct fdtable *ofdt,\n\t\t\t    unsigned int count)\n{\n\tunsigned int cpy, set;\n\n\tcpy = count / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - count) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)nfdt->open_fds + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)nfdt->close_on_exec + cpy, 0, set);\n\n\tcpy = BITBIT_SIZE(count);\n\tset = BITBIT_SIZE(nfdt->max_fds) - cpy;\n\tmemcpy(nfdt->full_fds_bits, ofdt->full_fds_bits, cpy);\n\tmemset((char *)nfdt->full_fds_bits + cpy, 0, set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)nfdt->fd + cpy",
            "0",
            "set"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nfdt->fd",
            "ofdt->fd",
            "cpy"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nfdt->max_fds < ofdt->max_fds"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void copy_fdtable(struct fdtable *nfdt, struct fdtable *ofdt)\n{\n\tunsigned int cpy, set;\n\n\tBUG_ON(nfdt->max_fds < ofdt->max_fds);\n\n\tcpy = ofdt->max_fds * sizeof(struct file *);\n\tset = (nfdt->max_fds - ofdt->max_fds) * sizeof(struct file *);\n\tmemcpy(nfdt->fd, ofdt->fd, cpy);\n\tmemset((char *)nfdt->fd + cpy, 0, set);\n\n\tcopy_fd_bitmaps(nfdt, ofdt, ofdt->max_fds);\n}"
  },
  {
    "function_name": "copy_fd_bitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "49-65",
    "snippet": "static void copy_fd_bitmaps(struct fdtable *nfdt, struct fdtable *ofdt,\n\t\t\t    unsigned int count)\n{\n\tunsigned int cpy, set;\n\n\tcpy = count / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - count) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)nfdt->open_fds + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)nfdt->close_on_exec + cpy, 0, set);\n\n\tcpy = BITBIT_SIZE(count);\n\tset = BITBIT_SIZE(nfdt->max_fds) - cpy;\n\tmemcpy(nfdt->full_fds_bits, ofdt->full_fds_bits, cpy);\n\tmemset((char *)nfdt->full_fds_bits + cpy, 0, set);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)nfdt->full_fds_bits + cpy",
            "0",
            "set"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nfdt->full_fds_bits",
            "ofdt->full_fds_bits",
            "cpy"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITBIT_SIZE",
          "args": [
            "nfdt->max_fds"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITBIT_SIZE",
          "args": [
            "count"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)nfdt->close_on_exec + cpy",
            "0",
            "set"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nfdt->close_on_exec",
            "ofdt->close_on_exec",
            "cpy"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)nfdt->open_fds + cpy",
            "0",
            "set"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nfdt->open_fds",
            "ofdt->open_fds",
            "cpy"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void copy_fd_bitmaps(struct fdtable *nfdt, struct fdtable *ofdt,\n\t\t\t    unsigned int count)\n{\n\tunsigned int cpy, set;\n\n\tcpy = count / BITS_PER_BYTE;\n\tset = (nfdt->max_fds - count) / BITS_PER_BYTE;\n\tmemcpy(nfdt->open_fds, ofdt->open_fds, cpy);\n\tmemset((char *)nfdt->open_fds + cpy, 0, set);\n\tmemcpy(nfdt->close_on_exec, ofdt->close_on_exec, cpy);\n\tmemset((char *)nfdt->close_on_exec + cpy, 0, set);\n\n\tcpy = BITBIT_SIZE(count);\n\tset = BITBIT_SIZE(nfdt->max_fds) - cpy;\n\tmemcpy(nfdt->full_fds_bits, ofdt->full_fds_bits, cpy);\n\tmemset((char *)nfdt->full_fds_bits + cpy, 0, set);\n}"
  },
  {
    "function_name": "free_fdtable_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "36-39",
    "snippet": "static void free_fdtable_rcu(struct rcu_head *rcu)\n{\n\t__free_fdtable(container_of(rcu, struct fdtable, rcu));\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void free_fdtable_rcu(struct rcu_head *rcu)\n{\n\t__free_fdtable(container_of(rcu, struct fdtable, rcu));\n}"
  },
  {
    "function_name": "__free_fdtable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "29-34",
    "snippet": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fdt"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "fdt->open_fds"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "fdt->fd"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}"
  },
  {
    "function_name": "dup3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "908-911",
    "snippet": "SYSCALL_DEFINE3(dup3, unsigned int, oldfd, unsigned int, newfd, int, flags)\n{\n\treturn ksys_dup3(oldfd, newfd, flags);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE3(dup3, unsigned int, oldfd, unsigned int, newfd, int, flags)\n{\n\treturn ksys_dup3(oldfd, newfd, flags);\n}"
  },
  {
    "function_name": "dup2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "913-926",
    "snippet": "SYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)\n{\n\tif (unlikely(newfd == oldfd)) { /* corner case */\n\t\tstruct files_struct *files = current->files;\n\t\tint retval = oldfd;\n\n\t\trcu_read_lock();\n\t\tif (!fcheck_files(files, oldfd))\n\t\t\tretval = -EBADF;\n\t\trcu_read_unlock();\n\t\treturn retval;\n\t}\n\treturn ksys_dup3(oldfd, newfd, 0);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE2(dup2, unsigned int, oldfd, unsigned int, newfd)\n{\n\tif (unlikely(newfd == oldfd)) { /* corner case */\n\t\tstruct files_struct *files = current->files;\n\t\tint retval = oldfd;\n\n\t\trcu_read_lock();\n\t\tif (!fcheck_files(files, oldfd))\n\t\t\tretval = -EBADF;\n\t\trcu_read_unlock();\n\t\treturn retval;\n\t}\n\treturn ksys_dup3(oldfd, newfd, 0);\n}"
  },
  {
    "function_name": "dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
    "lines": "943-946",
    "snippet": "SYSCALL_DEFINE1(dup, unsigned int, fildes)\n{\n\treturn ksys_dup(fildes);\n}",
    "includes": [
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bitops.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/mm.h>",
      "#include <linux/fs.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE1(dup, unsigned int, fildes)\n{\n\treturn ksys_dup(fildes);\n}"
  }
]