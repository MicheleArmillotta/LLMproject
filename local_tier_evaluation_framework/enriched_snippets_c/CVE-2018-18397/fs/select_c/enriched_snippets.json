[
  {
    "function_name": "do_compat_pselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1308-1354",
    "snippet": "static long do_compat_pselect(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct old_timespec32 __user *tsp, compat_sigset_t __user *sigmask,\n\tcompat_size_t sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_old_timespec32(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (get_compat_sigset(&ksigmask, sigmask))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = compat_core_sys_select(n, inp, outp, exp, to);\n\tret = compat_poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\tif (ret == -ERESTARTNOHAND) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&sigsaved",
            "NULL"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_restore_sigmask",
          "args": [],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&current->saved_sigmask",
            "&sigsaved",
            "sizeof(sigsaved)"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_poll_select_copy_remaining",
          "args": [
            "&end_time",
            "tsp",
            "0",
            "ret"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "compat_poll_select_copy_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1101-1146",
          "snippet": "static\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_core_sys_select",
          "args": [
            "n",
            "inp",
            "outp",
            "exp",
            "to"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "compat_core_sys_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1187-1256",
          "snippet": "static int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&ksigmask",
            "&sigsaved"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "&ksigmask",
            "sigmask(SIGKILL)|sigmask(SIGSTOP)"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_compat_sigset",
          "args": [
            "&ksigmask",
            "sigmask"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_select_set_timeout",
          "args": [
            "to",
            "ts.tv_sec",
            "ts.tv_nsec"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "poll_select_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "273-288",
          "snippet": "int poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_old_timespec32",
          "args": [
            "&ts",
            "tsp"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic long do_compat_pselect(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct old_timespec32 __user *tsp, compat_sigset_t __user *sigmask,\n\tcompat_size_t sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_old_timespec32(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (get_compat_sigset(&ksigmask, sigmask))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = compat_core_sys_select(n, inp, outp, exp, to);\n\tret = compat_poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\tif (ret == -ERESTARTNOHAND) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_compat_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1258-1281",
    "snippet": "static int do_compat_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct old_timeval32 __user *tvp)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tstruct old_timeval32 tv;\n\tint ret;\n\n\tif (tvp) {\n\t\tif (copy_from_user(&tv, tvp, sizeof(tv)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to,\n\t\t\t\ttv.tv_sec + (tv.tv_usec / USEC_PER_SEC),\n\t\t\t\t(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = compat_core_sys_select(n, inp, outp, exp, to);\n\tret = compat_poll_select_copy_remaining(&end_time, tvp, 1, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_poll_select_copy_remaining",
          "args": [
            "&end_time",
            "tvp",
            "1",
            "ret"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "compat_poll_select_copy_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1101-1146",
          "snippet": "static\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_core_sys_select",
          "args": [
            "n",
            "inp",
            "outp",
            "exp",
            "to"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "compat_core_sys_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1187-1256",
          "snippet": "static int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_select_set_timeout",
          "args": [
            "to",
            "tv.tv_sec + (tv.tv_usec / USEC_PER_SEC)",
            "(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "poll_select_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "273-288",
          "snippet": "int poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&tv",
            "tvp",
            "sizeof(tv)"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int do_compat_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct old_timeval32 __user *tvp)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tstruct old_timeval32 tv;\n\tint ret;\n\n\tif (tvp) {\n\t\tif (copy_from_user(&tv, tvp, sizeof(tv)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to,\n\t\t\t\ttv.tv_sec + (tv.tv_usec / USEC_PER_SEC),\n\t\t\t\t(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = compat_core_sys_select(n, inp, outp, exp, to);\n\tret = compat_poll_select_copy_remaining(&end_time, tvp, 1, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_core_sys_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1187-1256",
    "snippet": "static int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bits"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_set_fd_set",
          "args": [
            "n",
            "exp",
            "fds.res_ex"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "compat_set_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1164-1171",
          "snippet": "static\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tif (!ufdset)\n\t\treturn 0;\n\treturn compat_put_bitmap(ufdset, fdset, nr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tif (!ufdset)\n\t\treturn 0;\n\treturn compat_put_bitmap(ufdset, fdset, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_select",
          "args": [
            "n",
            "&fds",
            "end_time"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "do_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "449-584",
          "snippet": "static int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\t\t\t__poll_t mask;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\twait_key_set(wait, in, out, bit,\n\t\t\t\t\t\t     busy_flag);\n\t\t\t\t\tmask = vfs_poll(f.file, wait);\n\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define POLLEX_SET (EPOLLPRI)",
            "#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)",
            "#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (EPOLLPRI)\n#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)\n#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)\n\nstatic int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\t\t\t__poll_t mask;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\twait_key_set(wait, in, out, bit,\n\t\t\t\t\t\t     busy_flag);\n\t\t\t\t\tmask = vfs_poll(f.file, wait);\n\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fd_set",
          "args": [
            "n",
            "fds.res_ex"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "380-384",
          "snippet": "static inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_get_fd_set",
          "args": [
            "n",
            "exp",
            "fds.ex"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "compat_get_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1152-1162",
          "snippet": "static\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tif (ufdset) {\n\t\treturn compat_get_bitmap(fdset, ufdset, nr);\n\t} else {\n\t\tzero_fd_set(nr, fdset);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tif (ufdset) {\n\t\treturn compat_get_bitmap(fdset, ufdset, nr);\n\t} else {\n\t\tzero_fd_set(nr, fdset);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "6",
            "size",
            "GFP_KERNEL"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FDS_BYTES",
          "args": [
            "n"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "current->files"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}"
  },
  {
    "function_name": "compat_set_fd_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1164-1171",
    "snippet": "static\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tif (!ufdset)\n\t\treturn 0;\n\treturn compat_put_bitmap(ufdset, fdset, nr);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_put_bitmap",
          "args": [
            "ufdset",
            "fdset",
            "nr"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tif (!ufdset)\n\t\treturn 0;\n\treturn compat_put_bitmap(ufdset, fdset, nr);\n}"
  },
  {
    "function_name": "compat_get_fd_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1152-1162",
    "snippet": "static\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tif (ufdset) {\n\t\treturn compat_get_bitmap(fdset, ufdset, nr);\n\t} else {\n\t\tzero_fd_set(nr, fdset);\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_fd_set",
          "args": [
            "nr",
            "fdset"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "380-384",
          "snippet": "static inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_get_bitmap",
          "args": [
            "fdset",
            "ufdset",
            "nr"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tif (ufdset) {\n\t\treturn compat_get_bitmap(fdset, ufdset, nr);\n\t} else {\n\t\tzero_fd_set(nr, fdset);\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "compat_poll_select_copy_remaining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1101-1146",
    "snippet": "static\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_old_timespec32",
          "args": [
            "&ts",
            "p"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "p",
            "&rtv",
            "sizeof(rtv)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "*end_time",
            "ts"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts64",
          "args": [
            "&ts"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}"
  },
  {
    "function_name": "do_restart_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "991-1011",
    "snippet": "static long do_restart_poll(struct restart_block *restart_block)\n{\n\tstruct pollfd __user *ufds = restart_block->poll.ufds;\n\tint nfds = restart_block->poll.nfds;\n\tstruct timespec64 *to = NULL, end_time;\n\tint ret;\n\n\tif (restart_block->poll.has_timeout) {\n\t\tend_time.tv_sec = restart_block->poll.tv_sec;\n\t\tend_time.tv_nsec = restart_block->poll.tv_nsec;\n\t\tto = &end_time;\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\tif (ret == -EINTR) {\n\t\trestart_block->fn = do_restart_poll;\n\t\tret = -ERESTART_RESTARTBLOCK;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_sys_poll",
          "args": [
            "ufds",
            "nfds",
            "to"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "do_sys_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "926-989",
          "snippet": "static int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec64 *end_time)\n{\n\tstruct poll_wqueues table;\n \tint err = -EFAULT, fdcount, len, size;\n\t/* Allocate small arguments on the stack to save memory and be\n\t   faster - use long to make sure the buffer is aligned properly\n\t   on 64 bit archs to avoid unaligned access */\n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\tsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\n\t\twalk = walk->next = kmalloc(size, GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = 0; j < walk->len; j++, ufds++)\n\t\t\tif (__put_user(fds[j].revents, &ufds->revents))\n\t\t\t\tgoto out_fds;\n  \t}\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))",
            "#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))\n#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))\n\nstatic int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec64 *end_time)\n{\n\tstruct poll_wqueues table;\n \tint err = -EFAULT, fdcount, len, size;\n\t/* Allocate small arguments on the stack to save memory and be\n\t   faster - use long to make sure the buffer is aligned properly\n\t   on 64 bit archs to avoid unaligned access */\n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\tsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\n\t\twalk = walk->next = kmalloc(size, GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = 0; j < walk->len; j++, ufds++)\n\t\t\tif (__put_user(fds[j].revents, &ufds->revents))\n\t\t\t\tgoto out_fds;\n  \t}\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic long do_restart_poll(struct restart_block *restart_block)\n{\n\tstruct pollfd __user *ufds = restart_block->poll.ufds;\n\tint nfds = restart_block->poll.nfds;\n\tstruct timespec64 *to = NULL, end_time;\n\tint ret;\n\n\tif (restart_block->poll.has_timeout) {\n\t\tend_time.tv_sec = restart_block->poll.tv_sec;\n\t\tend_time.tv_nsec = restart_block->poll.tv_nsec;\n\t\tto = &end_time;\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\tif (ret == -EINTR) {\n\t\trestart_block->fn = do_restart_poll;\n\t\tret = -ERESTART_RESTARTBLOCK;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "do_sys_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "926-989",
    "snippet": "static int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec64 *end_time)\n{\n\tstruct poll_wqueues table;\n \tint err = -EFAULT, fdcount, len, size;\n\t/* Allocate small arguments on the stack to save memory and be\n\t   faster - use long to make sure the buffer is aligned properly\n\t   on 64 bit archs to avoid unaligned access */\n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\tsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\n\t\twalk = walk->next = kmalloc(size, GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = 0; j < walk->len; j++, ufds++)\n\t\t\tif (__put_user(fds[j].revents, &ufds->revents))\n\t\t\t\tgoto out_fds;\n  \t}\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))",
      "#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pos"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "fds[j].revents",
            "&ufds->revents"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_freewait",
          "args": [
            "&table"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "poll_freewait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "138-157",
          "snippet": "void poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nvoid poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_poll",
          "args": [
            "head",
            "&table",
            "end_time"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "do_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "837-921",
          "snippet": "static int do_poll(struct poll_list *list, struct poll_wqueues *wait,\n\t\t   struct timespec64 *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\t/* Optimise the no-wait case */\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t/*\n\t\t\t\t * Fish for events. If we found one, record it\n\t\t\t\t * and kill poll_table->_qproc, so we don't\n\t\t\t\t * needlessly register any other waiters after\n\t\t\t\t * this. They'll get immediately deregistered\n\t\t\t\t * when we break out and return.\n\t\t\t\t */\n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t/* found something, stop busy polling */\n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * All waiters have already been registered, so don't provide\n\t\t * a poll_table->_qproc to them on the next loop iteration.\n\t\t */\n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -EINTR;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int do_poll(struct poll_list *list, struct poll_wqueues *wait,\n\t\t   struct timespec64 *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\t/* Optimise the no-wait case */\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t/*\n\t\t\t\t * Fish for events. If we found one, record it\n\t\t\t\t * and kill poll_table->_qproc, so we don't\n\t\t\t\t * needlessly register any other waiters after\n\t\t\t\t * this. They'll get immediately deregistered\n\t\t\t\t * when we break out and return.\n\t\t\t\t */\n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t/* found something, stop busy polling */\n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * All waiters have already been registered, so don't provide\n\t\t * a poll_table->_qproc to them on the next loop iteration.\n\t\t */\n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -EINTR;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_initwait",
          "args": [
            "&table"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "poll_initwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "121-129",
          "snippet": "void poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "todo",
            "POLLFD_PER_PAGE"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/pnode.c",
          "lines": "60-71",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "walk->entries",
            "ufds + nfds-todo",
            "sizeof(struct pollfd) * walk->len"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedint",
            "nfds",
            "N_STACK_PPS"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NOFILE"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \\\n\t\t\tsizeof(struct pollfd))\n#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))\n\nstatic int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,\n\t\tstruct timespec64 *end_time)\n{\n\tstruct poll_wqueues table;\n \tint err = -EFAULT, fdcount, len, size;\n\t/* Allocate small arguments on the stack to save memory and be\n\t   faster - use long to make sure the buffer is aligned properly\n\t   on 64 bit archs to avoid unaligned access */\n\tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)];\n\tstruct poll_list *const head = (struct poll_list *)stack_pps;\n \tstruct poll_list *walk = head;\n \tunsigned long todo = nfds;\n\n\tif (nfds > rlimit(RLIMIT_NOFILE))\n\t\treturn -EINVAL;\n\n\tlen = min_t(unsigned int, nfds, N_STACK_PPS);\n\tfor (;;) {\n\t\twalk->next = NULL;\n\t\twalk->len = len;\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tif (copy_from_user(walk->entries, ufds + nfds-todo,\n\t\t\t\t\tsizeof(struct pollfd) * walk->len))\n\t\t\tgoto out_fds;\n\n\t\ttodo -= walk->len;\n\t\tif (!todo)\n\t\t\tbreak;\n\n\t\tlen = min(todo, POLLFD_PER_PAGE);\n\t\tsize = sizeof(struct poll_list) + sizeof(struct pollfd) * len;\n\t\twalk = walk->next = kmalloc(size, GFP_KERNEL);\n\t\tif (!walk) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_fds;\n\t\t}\n\t}\n\n\tpoll_initwait(&table);\n\tfdcount = do_poll(head, &table, end_time);\n\tpoll_freewait(&table);\n\n\tfor (walk = head; walk; walk = walk->next) {\n\t\tstruct pollfd *fds = walk->entries;\n\t\tint j;\n\n\t\tfor (j = 0; j < walk->len; j++, ufds++)\n\t\t\tif (__put_user(fds[j].revents, &ufds->revents))\n\t\t\t\tgoto out_fds;\n  \t}\n\n\terr = fdcount;\nout_fds:\n\twalk = head->next;\n\twhile (walk) {\n\t\tstruct poll_list *pos = walk;\n\t\twalk = walk->next;\n\t\tkfree(pos);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "do_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "837-921",
    "snippet": "static int do_poll(struct poll_list *list, struct poll_wqueues *wait,\n\t\t   struct timespec64 *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\t/* Optimise the no-wait case */\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t/*\n\t\t\t\t * Fish for events. If we found one, record it\n\t\t\t\t * and kill poll_table->_qproc, so we don't\n\t\t\t\t * needlessly register any other waiters after\n\t\t\t\t * this. They'll get immediately deregistered\n\t\t\t\t * when we break out and return.\n\t\t\t\t */\n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t/* found something, stop busy polling */\n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * All waiters have already been registered, so don't provide\n\t\t * a poll_table->_qproc to them on the next loop iteration.\n\t\t */\n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -EINTR;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_schedule_timeout",
          "args": [
            "wait",
            "TASK_INTERRUPTIBLE",
            "to",
            "slack"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "poll_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "236-260",
          "snippet": "static int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following smp_store_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tsmp_store_mb(pwq->triggered, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following smp_store_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tsmp_store_mb(pwq->triggered, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*end_time"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "busy_loop_timeout",
          "args": [
            "busy_start"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "busy_loop_current_time",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_pollfd",
          "args": [
            "pfd",
            "pt",
            "&can_busy_loop",
            "busy_flag"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "do_pollfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "807-835",
          "snippet": "static inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     __poll_t busy_flag)\n{\n\tint fd = pollfd->fd;\n\t__poll_t mask = 0, filter;\n\tstruct fd f;\n\n\tif (fd < 0)\n\t\tgoto out;\n\tmask = EPOLLNVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* userland u16 ->events contains POLL... bitmap */\n\tfilter = demangle_poll(pollfd->events) | EPOLLERR | EPOLLHUP;\n\tpwait->_key = filter | busy_flag;\n\tmask = vfs_poll(f.file, pwait);\n\tif (mask & busy_flag)\n\t\t*can_busy_poll = true;\n\tmask &= filter;\t\t/* Mask out unneeded events. */\n\tfdput(f);\n\nout:\n\t/* ... and so does ->revents */\n\tpollfd->revents = mangle_poll(mask);\n\treturn mask;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     __poll_t busy_flag)\n{\n\tint fd = pollfd->fd;\n\t__poll_t mask = 0, filter;\n\tstruct fd f;\n\n\tif (fd < 0)\n\t\tgoto out;\n\tmask = EPOLLNVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* userland u16 ->events contains POLL... bitmap */\n\tfilter = demangle_poll(pollfd->events) | EPOLLERR | EPOLLHUP;\n\tpwait->_key = filter | busy_flag;\n\tmask = vfs_poll(f.file, pwait);\n\tif (mask & busy_flag)\n\t\t*can_busy_poll = true;\n\tmask &= filter;\t\t/* Mask out unneeded events. */\n\tfdput(f);\n\nout:\n\t/* ... and so does ->revents */\n\tpollfd->revents = mangle_poll(mask);\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_estimate_accuracy",
          "args": [
            "end_time"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "select_estimate_accuracy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "75-93",
          "snippet": "u64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nu64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_busy_loop_on",
          "args": [],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int do_poll(struct poll_list *list, struct poll_wqueues *wait,\n\t\t   struct timespec64 *end_time)\n{\n\tpoll_table* pt = &wait->pt;\n\tktime_t expire, *to = NULL;\n\tint timed_out = 0, count = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\t/* Optimise the no-wait case */\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\tpt->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tfor (;;) {\n\t\tstruct poll_list *walk;\n\t\tbool can_busy_loop = false;\n\n\t\tfor (walk = list; walk != NULL; walk = walk->next) {\n\t\t\tstruct pollfd * pfd, * pfd_end;\n\n\t\t\tpfd = walk->entries;\n\t\t\tpfd_end = pfd + walk->len;\n\t\t\tfor (; pfd != pfd_end; pfd++) {\n\t\t\t\t/*\n\t\t\t\t * Fish for events. If we found one, record it\n\t\t\t\t * and kill poll_table->_qproc, so we don't\n\t\t\t\t * needlessly register any other waiters after\n\t\t\t\t * this. They'll get immediately deregistered\n\t\t\t\t * when we break out and return.\n\t\t\t\t */\n\t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop,\n\t\t\t\t\t      busy_flag)) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tpt->_qproc = NULL;\n\t\t\t\t\t/* found something, stop busy polling */\n\t\t\t\t\tbusy_flag = 0;\n\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * All waiters have already been registered, so don't provide\n\t\t * a poll_table->_qproc to them on the next loop iteration.\n\t\t */\n\t\tpt->_qproc = NULL;\n\t\tif (!count) {\n\t\t\tcount = wait->error;\n\t\t\tif (signal_pending(current))\n\t\t\t\tcount = -EINTR;\n\t\t}\n\t\tif (count || timed_out)\n\t\t\tbreak;\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "do_pollfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "807-835",
    "snippet": "static inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     __poll_t busy_flag)\n{\n\tint fd = pollfd->fd;\n\t__poll_t mask = 0, filter;\n\tstruct fd f;\n\n\tif (fd < 0)\n\t\tgoto out;\n\tmask = EPOLLNVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* userland u16 ->events contains POLL... bitmap */\n\tfilter = demangle_poll(pollfd->events) | EPOLLERR | EPOLLHUP;\n\tpwait->_key = filter | busy_flag;\n\tmask = vfs_poll(f.file, pwait);\n\tif (mask & busy_flag)\n\t\t*can_busy_poll = true;\n\tmask &= filter;\t\t/* Mask out unneeded events. */\n\tfdput(f);\n\nout:\n\t/* ... and so does ->revents */\n\tpollfd->revents = mangle_poll(mask);\n\treturn mask;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mangle_poll",
          "args": [
            "mask"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_poll",
          "args": [
            "f.file",
            "pwait"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "demangle_poll",
          "args": [
            "pollfd->events"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait,\n\t\t\t\t     bool *can_busy_poll,\n\t\t\t\t     __poll_t busy_flag)\n{\n\tint fd = pollfd->fd;\n\t__poll_t mask = 0, filter;\n\tstruct fd f;\n\n\tif (fd < 0)\n\t\tgoto out;\n\tmask = EPOLLNVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\tgoto out;\n\n\t/* userland u16 ->events contains POLL... bitmap */\n\tfilter = demangle_poll(pollfd->events) | EPOLLERR | EPOLLHUP;\n\tpwait->_key = filter | busy_flag;\n\tmask = vfs_poll(f.file, pwait);\n\tif (mask & busy_flag)\n\t\t*can_busy_poll = true;\n\tmask &= filter;\t\t/* Mask out unneeded events. */\n\tfdput(f);\n\nout:\n\t/* ... and so does ->revents */\n\tpollfd->revents = mangle_poll(mask);\n\treturn mask;\n}"
  },
  {
    "function_name": "do_pselect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "703-749",
    "snippet": "static long do_pselect(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t       fd_set __user *exp, struct timespec __user *tsp,\n\t\t       const sigset_t __user *sigmask, size_t sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_timespec64(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\t\tif (sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = core_sys_select(n, inp, outp, exp, to);\n\tret = poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\tif (ret == -ERESTARTNOHAND) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&sigsaved",
            "NULL"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_restore_sigmask",
          "args": [],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&current->saved_sigmask",
            "&sigsaved",
            "sizeof(sigsaved)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_select_copy_remaining",
          "args": [
            "&end_time",
            "tsp",
            "0",
            "ret"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "compat_poll_select_copy_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1101-1146",
          "snippet": "static\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "core_sys_select",
          "args": [
            "n",
            "inp",
            "outp",
            "exp",
            "to"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "compat_core_sys_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1187-1256",
          "snippet": "static int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigprocmask",
          "args": [
            "SIG_SETMASK",
            "&ksigmask",
            "&sigsaved"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "&ksigmask",
            "sigmask(SIGKILL)|sigmask(SIGSTOP)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&ksigmask",
            "sigmask",
            "sizeof(ksigmask)"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_select_set_timeout",
          "args": [
            "to",
            "ts.tv_sec",
            "ts.tv_nsec"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "poll_select_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "273-288",
          "snippet": "int poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_timespec64",
          "args": [
            "&ts",
            "tsp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic long do_pselect(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t       fd_set __user *exp, struct timespec __user *tsp,\n\t\t       const sigset_t __user *sigmask, size_t sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_timespec64(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\t\tif (sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = core_sys_select(n, inp, outp, exp, to);\n\tret = poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\tif (ret == -ERESTARTNOHAND) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kern_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "673-695",
    "snippet": "static int kern_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t       fd_set __user *exp, struct timeval __user *tvp)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tstruct timeval tv;\n\tint ret;\n\n\tif (tvp) {\n\t\tif (copy_from_user(&tv, tvp, sizeof(tv)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to,\n\t\t\t\ttv.tv_sec + (tv.tv_usec / USEC_PER_SEC),\n\t\t\t\t(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = core_sys_select(n, inp, outp, exp, to);\n\tret = poll_select_copy_remaining(&end_time, tvp, 1, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_select_copy_remaining",
          "args": [
            "&end_time",
            "tvp",
            "1",
            "ret"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "compat_poll_select_copy_remaining",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1101-1146",
          "snippet": "static\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic\nint compat_poll_select_copy_remaining(struct timespec64 *end_time, void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 ts;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&ts);\n\tts = timespec64_sub(*end_time, ts);\n\tif (ts.tv_sec < 0)\n\t\tts.tv_sec = ts.tv_nsec = 0;\n\n\tif (timeval) {\n\t\tstruct old_timeval32 rtv;\n\n\t\trtv.tv_sec = ts.tv_sec;\n\t\trtv.tv_usec = ts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\t} else {\n\t\tif (!put_old_timespec32(&ts, p))\n\t\t\treturn ret;\n\t}\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "core_sys_select",
          "args": [
            "n",
            "inp",
            "outp",
            "exp",
            "to"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "compat_core_sys_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1187-1256",
          "snippet": "static int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int compat_core_sys_select(int n, compat_ulong_t __user *inp,\n\tcompat_ulong_t __user *outp, compat_ulong_t __user *exp,\n\tstruct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint size, max_fds, ret = -EINVAL;\n\tstruct fdtable *fdt;\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words.\n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\tbits = kmalloc_array(6, size, GFP_KERNEL);\n\t\tret = -ENOMEM;\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = (unsigned long *)  bits;\n\tfds.out     = (unsigned long *) (bits +   size);\n\tfds.ex      = (unsigned long *) (bits + 2*size);\n\tfds.res_in  = (unsigned long *) (bits + 3*size);\n\tfds.res_out = (unsigned long *) (bits + 4*size);\n\tfds.res_ex  = (unsigned long *) (bits + 5*size);\n\n\tif ((ret = compat_get_fd_set(n, inp, fds.in)) ||\n\t    (ret = compat_get_fd_set(n, outp, fds.out)) ||\n\t    (ret = compat_get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (compat_set_fd_set(n, inp, fds.res_in) ||\n\t    compat_set_fd_set(n, outp, fds.res_out) ||\n\t    compat_set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\nout:\n\tif (bits != stack_fds)\n\t\tkfree(bits);\nout_nofds:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_select_set_timeout",
          "args": [
            "to",
            "tv.tv_sec + (tv.tv_usec / USEC_PER_SEC)",
            "(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "poll_select_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "273-288",
          "snippet": "int poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&tv",
            "tvp",
            "sizeof(tv)"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int kern_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t       fd_set __user *exp, struct timeval __user *tvp)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tstruct timeval tv;\n\tint ret;\n\n\tif (tvp) {\n\t\tif (copy_from_user(&tv, tvp, sizeof(tv)))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to,\n\t\t\t\ttv.tv_sec + (tv.tv_usec / USEC_PER_SEC),\n\t\t\t\t(tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = core_sys_select(n, inp, outp, exp, to);\n\tret = poll_select_copy_remaining(&end_time, tvp, 1, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "core_sys_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "594-671",
    "snippet": "int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *exp, struct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint ret, max_fds;\n\tsize_t size, alloc_size;\n\tstruct fdtable *fdt;\n\t/* Allocate small arguments on the stack to save memory and be faster */\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tret = -EINVAL;\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words. \n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\t/* Not enough space in on-stack array; must use kmalloc */\n\t\tret = -ENOMEM;\n\t\tif (size > (SIZE_MAX / 6))\n\t\t\tgoto out_nofds;\n\n\t\talloc_size = 6 * size;\n\t\tbits = kvmalloc(alloc_size, GFP_KERNEL);\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + 2*size;\n\tfds.res_in  = bits + 3*size;\n\tfds.res_out = bits + 4*size;\n\tfds.res_ex  = bits + 5*size;\n\n\tif ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\tif (bits != stack_fds)\n\t\tkvfree(bits);\nout_nofds:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "bits"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fd_set",
          "args": [
            "n",
            "exp",
            "fds.res_ex"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "compat_set_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1164-1171",
          "snippet": "static\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tif (!ufdset)\n\t\treturn 0;\n\treturn compat_put_bitmap(ufdset, fdset, nr);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic\nint compat_set_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t      unsigned long *fdset)\n{\n\tif (!ufdset)\n\t\treturn 0;\n\treturn compat_put_bitmap(ufdset, fdset, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_select",
          "args": [
            "n",
            "&fds",
            "end_time"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "do_select",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "449-584",
          "snippet": "static int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\t\t\t__poll_t mask;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\twait_key_set(wait, in, out, bit,\n\t\t\t\t\t\t     busy_flag);\n\t\t\t\t\tmask = vfs_poll(f.file, wait);\n\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define POLLEX_SET (EPOLLPRI)",
            "#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)",
            "#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (EPOLLPRI)\n#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)\n#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)\n\nstatic int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\t\t\t__poll_t mask;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\twait_key_set(wait, in, out, bit,\n\t\t\t\t\t\t     busy_flag);\n\t\t\t\t\tmask = vfs_poll(f.file, wait);\n\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_fd_set",
          "args": [
            "n",
            "fds.res_ex"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "zero_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "380-384",
          "snippet": "static inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fd_set",
          "args": [
            "n",
            "exp",
            "fds.ex"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "compat_get_fd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "1152-1162",
          "snippet": "static\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tif (ufdset) {\n\t\treturn compat_get_bitmap(fdset, ufdset, nr);\n\t} else {\n\t\tzero_fd_set(nr, fdset);\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic\nint compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tif (ufdset) {\n\t\treturn compat_get_bitmap(fdset, ufdset, nr);\n\t} else {\n\t\tzero_fd_set(nr, fdset);\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "alloc_size",
            "GFP_KERNEL"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_kvmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/super.c",
          "lines": "183-191",
          "snippet": "void *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"fsmap.h\"",
            "#include \"mballoc.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4_extents.h\"\t/* Needed for trace points definition */",
            "#include \"ext4.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/iversion.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/dax.h>",
            "#include <linux/crc16.h>",
            "#include <linux/log2.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"fsmap.h\"\n#include \"mballoc.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4_extents.h\"\t/* Needed for trace points definition */\n#include \"ext4.h\"\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/iversion.h>\n#include <linux/uaccess.h>\n#include <linux/cleancache.h>\n#include <linux/dax.h>\n#include <linux/crc16.h>\n#include <linux/log2.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n#include <linux/string.h>\n#include <linux/module.h>\n\nvoid *ext4_kvmalloc(size_t size, gfp_t flags)\n{\n\tvoid *ret;\n\n\tret = kmalloc(size, flags | __GFP_NOWARN);\n\tif (!ret)\n\t\tret = __vmalloc(size, flags, PAGE_KERNEL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FDS_BYTES",
          "args": [
            "n"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "current->files"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,\n\t\t\t   fd_set __user *exp, struct timespec64 *end_time)\n{\n\tfd_set_bits fds;\n\tvoid *bits;\n\tint ret, max_fds;\n\tsize_t size, alloc_size;\n\tstruct fdtable *fdt;\n\t/* Allocate small arguments on the stack to save memory and be faster */\n\tlong stack_fds[SELECT_STACK_ALLOC/sizeof(long)];\n\n\tret = -EINVAL;\n\tif (n < 0)\n\t\tgoto out_nofds;\n\n\t/* max_fds can increase, so grab it once to avoid race */\n\trcu_read_lock();\n\tfdt = files_fdtable(current->files);\n\tmax_fds = fdt->max_fds;\n\trcu_read_unlock();\n\tif (n > max_fds)\n\t\tn = max_fds;\n\n\t/*\n\t * We need 6 bitmaps (in/out/ex for both incoming and outgoing),\n\t * since we used fdset we need to allocate memory in units of\n\t * long-words. \n\t */\n\tsize = FDS_BYTES(n);\n\tbits = stack_fds;\n\tif (size > sizeof(stack_fds) / 6) {\n\t\t/* Not enough space in on-stack array; must use kmalloc */\n\t\tret = -ENOMEM;\n\t\tif (size > (SIZE_MAX / 6))\n\t\t\tgoto out_nofds;\n\n\t\talloc_size = 6 * size;\n\t\tbits = kvmalloc(alloc_size, GFP_KERNEL);\n\t\tif (!bits)\n\t\t\tgoto out_nofds;\n\t}\n\tfds.in      = bits;\n\tfds.out     = bits +   size;\n\tfds.ex      = bits + 2*size;\n\tfds.res_in  = bits + 3*size;\n\tfds.res_out = bits + 4*size;\n\tfds.res_ex  = bits + 5*size;\n\n\tif ((ret = get_fd_set(n, inp, fds.in)) ||\n\t    (ret = get_fd_set(n, outp, fds.out)) ||\n\t    (ret = get_fd_set(n, exp, fds.ex)))\n\t\tgoto out;\n\tzero_fd_set(n, fds.res_in);\n\tzero_fd_set(n, fds.res_out);\n\tzero_fd_set(n, fds.res_ex);\n\n\tret = do_select(n, &fds, end_time);\n\n\tif (ret < 0)\n\t\tgoto out;\n\tif (!ret) {\n\t\tret = -ERESTARTNOHAND;\n\t\tif (signal_pending(current))\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tif (set_fd_set(n, inp, fds.res_in) ||\n\t    set_fd_set(n, outp, fds.res_out) ||\n\t    set_fd_set(n, exp, fds.res_ex))\n\t\tret = -EFAULT;\n\nout:\n\tif (bits != stack_fds)\n\t\tkvfree(bits);\nout_nofds:\n\treturn ret;\n}"
  },
  {
    "function_name": "do_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "449-584",
    "snippet": "static int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\t\t\t__poll_t mask;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\twait_key_set(wait, in, out, bit,\n\t\t\t\t\t\t     busy_flag);\n\t\t\t\t\tmask = vfs_poll(f.file, wait);\n\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define POLLEX_SET (EPOLLPRI)",
      "#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)",
      "#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_freewait",
          "args": [
            "&table"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "poll_freewait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "138-157",
          "snippet": "void poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nvoid poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_schedule_timeout",
          "args": [
            "&table",
            "TASK_INTERRUPTIBLE",
            "to",
            "slack"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "poll_schedule_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "236-260",
          "snippet": "static int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following smp_store_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tsmp_store_mb(pwq->triggered, 0);\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following smp_store_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tsmp_store_mb(pwq->triggered, 0);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*end_time"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "busy_loop_timeout",
          "args": [
            "busy_start"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "busy_loop_current_time",
          "args": [],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_poll",
          "args": [
            "f.file",
            "wait"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_key_set",
          "args": [
            "wait",
            "in",
            "out",
            "bit",
            "busy_flag"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "wait_key_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "438-447",
          "snippet": "static inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\t__poll_t ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define POLLEX_SET (EPOLLPRI)",
            "#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)",
            "#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (EPOLLPRI)\n#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)\n#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)\n\nstatic inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\t__poll_t ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "i"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "select_estimate_accuracy",
          "args": [
            "end_time"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "select_estimate_accuracy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "75-93",
          "snippet": "u64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nu64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_initwait",
          "args": [
            "&table"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "poll_initwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "121-129",
          "snippet": "void poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max_select_fd",
          "args": [
            "n",
            "fds"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "392-432",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_busy_loop_on",
          "args": [],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (EPOLLPRI)\n#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)\n#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)\n\nstatic int do_select(int n, fd_set_bits *fds, struct timespec64 *end_time)\n{\n\tktime_t expire, *to = NULL;\n\tstruct poll_wqueues table;\n\tpoll_table *wait;\n\tint retval, i, timed_out = 0;\n\tu64 slack = 0;\n\t__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;\n\tunsigned long busy_start = 0;\n\n\trcu_read_lock();\n\tretval = max_select_fd(n, fds);\n\trcu_read_unlock();\n\n\tif (retval < 0)\n\t\treturn retval;\n\tn = retval;\n\n\tpoll_initwait(&table);\n\twait = &table.pt;\n\tif (end_time && !end_time->tv_sec && !end_time->tv_nsec) {\n\t\twait->_qproc = NULL;\n\t\ttimed_out = 1;\n\t}\n\n\tif (end_time && !timed_out)\n\t\tslack = select_estimate_accuracy(end_time);\n\n\tretval = 0;\n\tfor (;;) {\n\t\tunsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;\n\t\tbool can_busy_loop = false;\n\n\t\tinp = fds->in; outp = fds->out; exp = fds->ex;\n\t\trinp = fds->res_in; routp = fds->res_out; rexp = fds->res_ex;\n\n\t\tfor (i = 0; i < n; ++rinp, ++routp, ++rexp) {\n\t\t\tunsigned long in, out, ex, all_bits, bit = 1, j;\n\t\t\tunsigned long res_in = 0, res_out = 0, res_ex = 0;\n\t\t\t__poll_t mask;\n\n\t\t\tin = *inp++; out = *outp++; ex = *exp++;\n\t\t\tall_bits = in | out | ex;\n\t\t\tif (all_bits == 0) {\n\t\t\t\ti += BITS_PER_LONG;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (j = 0; j < BITS_PER_LONG; ++j, ++i, bit <<= 1) {\n\t\t\t\tstruct fd f;\n\t\t\t\tif (i >= n)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!(bit & all_bits))\n\t\t\t\t\tcontinue;\n\t\t\t\tf = fdget(i);\n\t\t\t\tif (f.file) {\n\t\t\t\t\twait_key_set(wait, in, out, bit,\n\t\t\t\t\t\t     busy_flag);\n\t\t\t\t\tmask = vfs_poll(f.file, wait);\n\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tif ((mask & POLLIN_SET) && (in & bit)) {\n\t\t\t\t\t\tres_in |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLOUT_SET) && (out & bit)) {\n\t\t\t\t\t\tres_out |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((mask & POLLEX_SET) && (ex & bit)) {\n\t\t\t\t\t\tres_ex |= bit;\n\t\t\t\t\t\tretval++;\n\t\t\t\t\t\twait->_qproc = NULL;\n\t\t\t\t\t}\n\t\t\t\t\t/* got something, stop busy polling */\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tcan_busy_loop = false;\n\t\t\t\t\t\tbusy_flag = 0;\n\n\t\t\t\t\t/*\n\t\t\t\t\t * only remember a returned\n\t\t\t\t\t * POLL_BUSY_LOOP if we asked for it\n\t\t\t\t\t */\n\t\t\t\t\t} else if (busy_flag & mask)\n\t\t\t\t\t\tcan_busy_loop = true;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (res_in)\n\t\t\t\t*rinp = res_in;\n\t\t\tif (res_out)\n\t\t\t\t*routp = res_out;\n\t\t\tif (res_ex)\n\t\t\t\t*rexp = res_ex;\n\t\t\tcond_resched();\n\t\t}\n\t\twait->_qproc = NULL;\n\t\tif (retval || timed_out || signal_pending(current))\n\t\t\tbreak;\n\t\tif (table.error) {\n\t\t\tretval = table.error;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* only if found POLL_BUSY_LOOP sockets && not out of time */\n\t\tif (can_busy_loop && !need_resched()) {\n\t\t\tif (!busy_start) {\n\t\t\t\tbusy_start = busy_loop_current_time();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!busy_loop_timeout(busy_start))\n\t\t\t\tcontinue;\n\t\t}\n\t\tbusy_flag = 0;\n\n\t\t/*\n\t\t * If this is the first loop and we have a timeout\n\t\t * given, then we convert to ktime_t and set the to\n\t\t * pointer to the expiry value.\n\t\t */\n\t\tif (end_time && !to) {\n\t\t\texpire = timespec64_to_ktime(*end_time);\n\t\t\tto = &expire;\n\t\t}\n\n\t\tif (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,\n\t\t\t\t\t   to, slack))\n\t\t\ttimed_out = 1;\n\t}\n\n\tpoll_freewait(&table);\n\n\treturn retval;\n}"
  },
  {
    "function_name": "wait_key_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "438-447",
    "snippet": "static inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\t__poll_t ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define POLLEX_SET (EPOLLPRI)",
      "#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)",
      "#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define POLLEX_SET (EPOLLPRI)\n#define POLLOUT_SET (EPOLLWRBAND | EPOLLWRNORM | EPOLLOUT | EPOLLERR)\n#define POLLIN_SET (EPOLLRDNORM | EPOLLRDBAND | EPOLLIN | EPOLLHUP | EPOLLERR)\n\nstatic inline void wait_key_set(poll_table *wait, unsigned long in,\n\t\t\t\tunsigned long out, unsigned long bit,\n\t\t\t\t__poll_t ll_flag)\n{\n\twait->_key = POLLEX_SET | ll_flag;\n\tif (in & bit)\n\t\twait->_key |= POLLIN_SET;\n\tif (out & bit)\n\t\twait->_key |= POLLOUT_SET;\n}"
  },
  {
    "function_name": "max_select_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "392-432",
    "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BITS",
          "args": [
            "fds",
            "n"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS",
          "args": [
            "fds",
            "n"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_fdtable",
          "args": [
            "current->files"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
  },
  {
    "function_name": "zero_fd_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "380-384",
    "snippet": "static inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fdset",
            "0",
            "FDS_BYTES(nr)"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FDS_BYTES",
          "args": [
            "nr"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline\nvoid zero_fd_set(unsigned long nr, unsigned long *fdset)\n{\n\tmemset(fdset, 0, FDS_BYTES(nr));\n}"
  },
  {
    "function_name": "set_fd_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "372-378",
    "snippet": "static inline unsigned long __must_check\nset_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)\n{\n\tif (ufdset)\n\t\treturn __copy_to_user(ufdset, fdset, FDS_BYTES(nr));\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "ufdset",
            "fdset",
            "FDS_BYTES(nr)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FDS_BYTES",
          "args": [
            "nr"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline unsigned long __must_check\nset_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)\n{\n\tif (ufdset)\n\t\treturn __copy_to_user(ufdset, fdset, FDS_BYTES(nr));\n\treturn 0;\n}"
  },
  {
    "function_name": "get_fd_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "361-370",
    "snippet": "static inline\nint get_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)\n{\n\tnr = FDS_BYTES(nr);\n\tif (ufdset)\n\t\treturn copy_from_user(fdset, ufdset, nr) ? -EFAULT : 0;\n\n\tmemset(fdset, 0, nr);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fdset",
            "0",
            "nr"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "fdset",
            "ufdset",
            "nr"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "2647-2669",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\tcurrent->kernel_uaccess_faults_ok++;\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\tcurrent->kernel_uaccess_faults_ok--;\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FDS_BYTES",
          "args": [
            "nr"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline\nint get_fd_set(unsigned long nr, void __user *ufdset, unsigned long *fdset)\n{\n\tnr = FDS_BYTES(nr);\n\tif (ufdset)\n\t\treturn copy_from_user(fdset, ufdset, nr) ? -EFAULT : 0;\n\n\tmemset(fdset, 0, nr);\n\treturn 0;\n}"
  },
  {
    "function_name": "poll_select_copy_remaining",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "290-337",
    "snippet": "static int poll_select_copy_remaining(struct timespec64 *end_time,\n\t\t\t\t      void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 rts;\n\tstruct timeval rtv;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&rts);\n\trts = timespec64_sub(*end_time, rts);\n\tif (rts.tv_sec < 0)\n\t\trts.tv_sec = rts.tv_nsec = 0;\n\n\n\tif (timeval) {\n\t\tif (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))\n\t\t\tmemset(&rtv, 0, sizeof(rtv));\n\t\trtv.tv_sec = rts.tv_sec;\n\t\trtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\n\t} else if (!put_timespec64(&rts, p))\n\t\treturn ret;\n\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_timespec64",
          "args": [
            "&rts",
            "p"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "p",
            "&rtv",
            "sizeof(rtv)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rtv",
            "0",
            "sizeof(rtv)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "*end_time",
            "rts"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts64",
          "args": [
            "&rts"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic int poll_select_copy_remaining(struct timespec64 *end_time,\n\t\t\t\t      void __user *p,\n\t\t\t\t      int timeval, int ret)\n{\n\tstruct timespec64 rts;\n\tstruct timeval rtv;\n\n\tif (!p)\n\t\treturn ret;\n\n\tif (current->personality & STICKY_TIMEOUTS)\n\t\tgoto sticky;\n\n\t/* No update for zero timeout */\n\tif (!end_time->tv_sec && !end_time->tv_nsec)\n\t\treturn ret;\n\n\tktime_get_ts64(&rts);\n\trts = timespec64_sub(*end_time, rts);\n\tif (rts.tv_sec < 0)\n\t\trts.tv_sec = rts.tv_nsec = 0;\n\n\n\tif (timeval) {\n\t\tif (sizeof(rtv) > sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))\n\t\t\tmemset(&rtv, 0, sizeof(rtv));\n\t\trtv.tv_sec = rts.tv_sec;\n\t\trtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;\n\n\t\tif (!copy_to_user(p, &rtv, sizeof(rtv)))\n\t\t\treturn ret;\n\n\t} else if (!put_timespec64(&rts, p))\n\t\treturn ret;\n\n\t/*\n\t * If an application puts its timeval in read-only memory, we\n\t * don't want the Linux-specific update to the timeval to\n\t * cause a fault after the select has completed\n\t * successfully. However, because we're not updating the\n\t * timeval, we can't restart the system call.\n\t */\n\nsticky:\n\tif (ret == -ERESTARTNOHAND)\n\t\tret = -EINTR;\n\treturn ret;\n}"
  },
  {
    "function_name": "poll_select_set_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "273-288",
    "snippet": "int poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add_safe",
          "args": [
            "*to",
            "ts"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts64",
          "args": [
            "to"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid",
          "args": [
            "&ts"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nint poll_select_set_timeout(struct timespec64 *to, time64_t sec, long nsec)\n{\n\tstruct timespec64 ts = {.tv_sec = sec, .tv_nsec = nsec};\n\n\tif (!timespec64_valid(&ts))\n\t\treturn -EINVAL;\n\n\t/* Optimize for the zero timeout value here */\n\tif (!sec && !nsec) {\n\t\tto->tv_sec = to->tv_nsec = 0;\n\t} else {\n\t\tktime_get_ts64(to);\n\t\t*to = timespec64_add_safe(*to, ts);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "poll_schedule_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "236-260",
    "snippet": "static int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following smp_store_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tsmp_store_mb(pwq->triggered, 0);\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "pwq->triggered",
            "0"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range",
          "args": [
            "expires",
            "slack",
            "HRTIMER_MODE_ABS"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "state"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int poll_schedule_timeout(struct poll_wqueues *pwq, int state,\n\t\t\t  ktime_t *expires, unsigned long slack)\n{\n\tint rc = -EINTR;\n\n\tset_current_state(state);\n\tif (!pwq->triggered)\n\t\trc = schedule_hrtimeout_range(expires, slack, HRTIMER_MODE_ABS);\n\t__set_current_state(TASK_RUNNING);\n\n\t/*\n\t * Prepare for the next iteration.\n\t *\n\t * The following smp_store_mb() serves two purposes.  First, it's\n\t * the counterpart rmb of the wmb in pollwake() such that data\n\t * written before wake up is always visible after wake up.\n\t * Second, the full barrier guarantees that triggered clearing\n\t * doesn't pass event check of the next iteration.  Note that\n\t * this problem doesn't exist for the first iteration as\n\t * add_wait_queue() has full barrier semantics.\n\t */\n\tsmp_store_mb(pwq->triggered, 0);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "__pollwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "221-234",
    "snippet": "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t\t\tpoll_table *p)\n{\n\tstruct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);\n\tstruct poll_table_entry *entry = poll_get_entry(pwq);\n\tif (!entry)\n\t\treturn;\n\tentry->filp = get_file(filp);\n\tentry->wait_address = wait_address;\n\tentry->key = p->_key;\n\tinit_waitqueue_func_entry(&entry->wait, pollwake);\n\tentry->wait.private = pwq;\n\tadd_wait_queue(wait_address, &entry->wait);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "wait_address",
            "&entry->wait"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&entry->wait",
            "pollwake"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "filp"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "get_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "400-411",
          "snippet": "struct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstruct files_struct *get_files_struct(struct task_struct *task)\n{\n\tstruct files_struct *files;\n\n\ttask_lock(task);\n\tfiles = task->files;\n\tif (files)\n\t\tatomic_inc(&files->count);\n\ttask_unlock(task);\n\n\treturn files;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_get_entry",
          "args": [
            "pwq"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "poll_get_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "160-182",
          "snippet": "static struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structpoll_wqueues",
            "pt"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t\t\tpoll_table *p)\n{\n\tstruct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);\n\tstruct poll_table_entry *entry = poll_get_entry(pwq);\n\tif (!entry)\n\t\treturn;\n\tentry->filp = get_file(filp);\n\tentry->wait_address = wait_address;\n\tentry->key = p->_key;\n\tinit_waitqueue_func_entry(&entry->wait, pollwake);\n\tentry->wait.private = pwq;\n\tadd_wait_queue(wait_address, &entry->wait);\n}"
  },
  {
    "function_name": "pollwake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "210-218",
    "snippet": "static int pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_table_entry *entry;\n\n\tentry = container_of(wait, struct poll_table_entry, wait);\n\tif (key && !(key_to_poll(key) & entry->key))\n\t\treturn 0;\n\treturn __pollwake(wait, mode, sync, key);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pollwake",
          "args": [
            "wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "__pollwake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "184-208",
          "snippet": "static int __pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t/*\n\t * Although this function is called under waitqueue lock, LOCK\n\t * doesn't imply write barrier and the users expect write\n\t * barrier semantics on wakeup functions.  The following\n\t * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()\n\t * and is paired with smp_store_mb() in poll_schedule_timeout.\n\t */\n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t/*\n\t * Perform the default wake up operation using a dummy\n\t * waitqueue.\n\t *\n\t * TODO: This is hacky but there currently is no interface to\n\t * pass in @sync.  @sync is scheduled to be removed and once\n\t * that happens, wake_up_process() can be used directly.\n\t */\n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int __pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t/*\n\t * Although this function is called under waitqueue lock, LOCK\n\t * doesn't imply write barrier and the users expect write\n\t * barrier semantics on wakeup functions.  The following\n\t * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()\n\t * and is paired with smp_store_mb() in poll_schedule_timeout.\n\t */\n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t/*\n\t * Perform the default wake up operation using a dummy\n\t * waitqueue.\n\t *\n\t * TODO: This is hacky but there currently is no interface to\n\t * pass in @sync.  @sync is scheduled to be removed and once\n\t * that happens, wake_up_process() can be used directly.\n\t */\n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_to_poll",
          "args": [
            "key"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "wait",
            "structpoll_table_entry",
            "wait"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_table_entry *entry;\n\n\tentry = container_of(wait, struct poll_table_entry, wait);\n\tif (key && !(key_to_poll(key) & entry->key))\n\t\treturn 0;\n\treturn __pollwake(wait, mode, sync, key);\n}"
  },
  {
    "function_name": "__pollwake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "184-208",
    "snippet": "static int __pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t/*\n\t * Although this function is called under waitqueue lock, LOCK\n\t * doesn't imply write barrier and the users expect write\n\t * barrier semantics on wakeup functions.  The following\n\t * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()\n\t * and is paired with smp_store_mb() in poll_schedule_timeout.\n\t */\n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t/*\n\t * Perform the default wake up operation using a dummy\n\t * waitqueue.\n\t *\n\t * TODO: This is hacky but there currently is no interface to\n\t * pass in @sync.  @sync is scheduled to be removed and once\n\t * that happens, wake_up_process() can be used directly.\n\t */\n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "default_wake_function",
          "args": [
            "&dummy_wait",
            "mode",
            "sync",
            "key"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_WAITQUEUE",
          "args": [
            "dummy_wait",
            "pwq->polling_task"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic int __pollwake(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tstruct poll_wqueues *pwq = wait->private;\n\tDECLARE_WAITQUEUE(dummy_wait, pwq->polling_task);\n\n\t/*\n\t * Although this function is called under waitqueue lock, LOCK\n\t * doesn't imply write barrier and the users expect write\n\t * barrier semantics on wakeup functions.  The following\n\t * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()\n\t * and is paired with smp_store_mb() in poll_schedule_timeout.\n\t */\n\tsmp_wmb();\n\tpwq->triggered = 1;\n\n\t/*\n\t * Perform the default wake up operation using a dummy\n\t * waitqueue.\n\t *\n\t * TODO: This is hacky but there currently is no interface to\n\t * pass in @sync.  @sync is scheduled to be removed and once\n\t * that happens, wake_up_process() can be used directly.\n\t */\n\treturn default_wake_function(&dummy_wait, mode, sync, key);\n}"
  },
  {
    "function_name": "poll_get_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "160-182",
    "snippet": "static struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "POLL_TABLE_FULL",
          "args": [
            "table"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nstatic struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)\n{\n\tstruct poll_table_page *table = p->table;\n\n\tif (p->inline_index < N_INLINE_POLL_ENTRIES)\n\t\treturn p->inline_entries + p->inline_index++;\n\n\tif (!table || POLL_TABLE_FULL(table)) {\n\t\tstruct poll_table_page *new_table;\n\n\t\tnew_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);\n\t\tif (!new_table) {\n\t\t\tp->error = -ENOMEM;\n\t\t\treturn NULL;\n\t\t}\n\t\tnew_table->entry = new_table->entries;\n\t\tnew_table->next = table;\n\t\tp->table = new_table;\n\t\ttable = new_table;\n\t}\n\n\treturn table->entry++;\n}"
  },
  {
    "function_name": "poll_freewait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "138-157",
    "snippet": "void poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) old"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xfs/xfs_buf.c",
          "lines": "305-313",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_errortag.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_errortag.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_poll_entry",
          "args": [
            "entry"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "free_poll_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "132-136",
          "snippet": "static void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void __pollwait(struct file *filp, wait_queue_head_t *wait_address,\n\t\t       poll_table *p);\n\nvoid poll_freewait(struct poll_wqueues *pwq)\n{\n\tstruct poll_table_page * p = pwq->table;\n\tint i;\n\tfor (i = 0; i < pwq->inline_index; i++)\n\t\tfree_poll_entry(pwq->inline_entries + i);\n\twhile (p) {\n\t\tstruct poll_table_entry * entry;\n\t\tstruct poll_table_page *old;\n\n\t\tentry = p->entry;\n\t\tdo {\n\t\t\tentry--;\n\t\t\tfree_poll_entry(entry);\n\t\t} while (entry > p->entries);\n\t\told = p;\n\t\tp = p->next;\n\t\tfree_page((unsigned long) old);\n\t}\n}"
  },
  {
    "function_name": "free_poll_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "132-136",
    "snippet": "static void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "entry->filp"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file_table.c",
          "lines": "358-365",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/swap.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/swap.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "entry->wait_address",
            "&entry->wait"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic void free_poll_entry(struct poll_table_entry *entry)\n{\n\tremove_wait_queue(entry->wait_address, &entry->wait);\n\tfput(entry->filp);\n}"
  },
  {
    "function_name": "poll_initwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "121-129",
    "snippet": "void poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&pwq->pt",
            "__pollwait"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid poll_initwait(struct poll_wqueues *pwq)\n{\n\tinit_poll_funcptr(&pwq->pt, __pollwait);\n\tpwq->polling_task = current;\n\tpwq->triggered = 0;\n\tpwq->error = 0;\n\tpwq->table = NULL;\n\tpwq->inline_index = 0;\n}"
  },
  {
    "function_name": "select_estimate_accuracy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "75-93",
    "snippet": "u64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__estimate_accuracy",
          "args": [
            "&now"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "__estimate_accuracy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "52-73",
          "snippet": "static long __estimate_accuracy(struct timespec64 *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MAX_SLACK\t(100 * NSEC_PER_MSEC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define MAX_SLACK\t(100 * NSEC_PER_MSEC)\n\nstatic long __estimate_accuracy(struct timespec64 *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "*tv",
            "now"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts64",
          "args": [
            "&now"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_task",
          "args": [
            "current"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nu64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}"
  },
  {
    "function_name": "__estimate_accuracy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "52-73",
    "snippet": "static long __estimate_accuracy(struct timespec64 *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MAX_SLACK\t(100 * NSEC_PER_MSEC)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_nice",
          "args": [
            "current"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define MAX_SLACK\t(100 * NSEC_PER_MSEC)\n\nstatic long __estimate_accuracy(struct timespec64 *tv)\n{\n\tlong slack;\n\tint divfactor = 1000;\n\n\tif (tv->tv_sec < 0)\n\t\treturn 0;\n\n\tif (task_nice(current) > 0)\n\t\tdivfactor = divfactor / 5;\n\n\tif (tv->tv_sec > MAX_SLACK / (NSEC_PER_SEC/divfactor))\n\t\treturn MAX_SLACK;\n\n\tslack = tv->tv_nsec / divfactor;\n\tslack += tv->tv_sec * (NSEC_PER_SEC/divfactor);\n\n\tif (slack > MAX_SLACK)\n\t\treturn MAX_SLACK;\n\n\treturn slack;\n}"
  },
  {
    "function_name": "select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "697-701",
    "snippet": "SYSCALL_DEFINE5(select, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct timeval __user *, tvp)\n{\n\treturn kern_select(n, inp, outp, exp, tvp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(select, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct timeval __user *, tvp)\n{\n\treturn kern_select(n, inp, outp, exp, tvp);\n}"
  },
  {
    "function_name": "pselect6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "757-773",
    "snippet": "SYSCALL_DEFINE6(pselect6, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct timespec __user *, tsp,\n\t\tvoid __user *, sig)\n{\n\tsize_t sigsetsize = 0;\n\tsigset_t __user *up = NULL;\n\n\tif (sig) {\n\t\tif (!access_ok(VERIFY_READ, sig, sizeof(void *)+sizeof(size_t))\n\t\t    || __get_user(up, (sigset_t __user * __user *)sig)\n\t\t    || __get_user(sigsetsize,\n\t\t\t\t(size_t __user *)(sig+sizeof(void *))))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn do_pselect(n, inp, outp, exp, tsp, up, sigsetsize);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE6(pselect6, int, n, fd_set __user *, inp, fd_set __user *, outp,\n\t\tfd_set __user *, exp, struct timespec __user *, tsp,\n\t\tvoid __user *, sig)\n{\n\tsize_t sigsetsize = 0;\n\tsigset_t __user *up = NULL;\n\n\tif (sig) {\n\t\tif (!access_ok(VERIFY_READ, sig, sizeof(void *)+sizeof(size_t))\n\t\t    || __get_user(up, (sigset_t __user * __user *)sig)\n\t\t    || __get_user(sigsetsize,\n\t\t\t\t(size_t __user *)(sig+sizeof(void *))))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn do_pselect(n, inp, outp, exp, tsp, up, sigsetsize);\n}"
  },
  {
    "function_name": "old_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "782-789",
    "snippet": "SYSCALL_DEFINE1(old_select, struct sel_arg_struct __user *, arg)\n{\n\tstruct sel_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\treturn kern_select(a.n, a.inp, a.outp, a.exp, a.tvp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE1(old_select, struct sel_arg_struct __user *, arg)\n{\n\tstruct sel_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\treturn kern_select(a.n, a.inp, a.outp, a.exp, a.tvp);\n}"
  },
  {
    "function_name": "poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1013-1045",
    "snippet": "SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,\n\t\tint, timeout_msecs)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tint ret;\n\n\tif (timeout_msecs >= 0) {\n\t\tto = &end_time;\n\t\tpoll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,\n\t\t\tNSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\tif (ret == -EINTR) {\n\t\tstruct restart_block *restart_block;\n\n\t\trestart_block = &current->restart_block;\n\t\trestart_block->fn = do_restart_poll;\n\t\trestart_block->poll.ufds = ufds;\n\t\trestart_block->poll.nfds = nfds;\n\n\t\tif (timeout_msecs >= 0) {\n\t\t\trestart_block->poll.tv_sec = end_time.tv_sec;\n\t\t\trestart_block->poll.tv_nsec = end_time.tv_nsec;\n\t\t\trestart_block->poll.has_timeout = 1;\n\t\t} else\n\t\t\trestart_block->poll.has_timeout = 0;\n\n\t\tret = -ERESTART_RESTARTBLOCK;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,\n\t\tint, timeout_msecs)\n{\n\tstruct timespec64 end_time, *to = NULL;\n\tint ret;\n\n\tif (timeout_msecs >= 0) {\n\t\tto = &end_time;\n\t\tpoll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,\n\t\t\tNSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\tif (ret == -EINTR) {\n\t\tstruct restart_block *restart_block;\n\n\t\trestart_block = &current->restart_block;\n\t\trestart_block->fn = do_restart_poll;\n\t\trestart_block->poll.ufds = ufds;\n\t\trestart_block->poll.nfds = nfds;\n\n\t\tif (timeout_msecs >= 0) {\n\t\t\trestart_block->poll.tv_sec = end_time.tv_sec;\n\t\t\trestart_block->poll.tv_nsec = end_time.tv_nsec;\n\t\t\trestart_block->poll.has_timeout = 1;\n\t\t} else\n\t\t\trestart_block->poll.has_timeout = 0;\n\n\t\tret = -ERESTART_RESTARTBLOCK;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ppoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1047-1096",
    "snippet": "SYSCALL_DEFINE5(ppoll, struct pollfd __user *, ufds, unsigned int, nfds,\n\t\tstruct timespec __user *, tsp, const sigset_t __user *, sigmask,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_timespec64(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\t\tif (sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\t/* We can restart this syscall, usually */\n\tif (ret == -EINTR) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\tret = poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(ppoll, struct pollfd __user *, ufds, unsigned int, nfds,\n\t\tstruct timespec __user *, tsp, const sigset_t __user *, sigmask,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_timespec64(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\t\tif (sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\t/* We can restart this syscall, usually */\n\tif (ret == -EINTR) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\tret = poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1283-1288",
    "snippet": "SYSCALL_DEFINE5(select, int, n, compat_ulong_t __user *, inp,\n\tcompat_ulong_t __user *, outp, compat_ulong_t __user *, exp,\n\tstruct old_timeval32 __user *, tvp)\n{\n\treturn do_compat_select(n, inp, outp, exp, tvp);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(select, int, n, compat_ulong_t __user *, inp,\n\tcompat_ulong_t __user *, outp, compat_ulong_t __user *, exp,\n\tstruct old_timeval32 __user *, tvp)\n{\n\treturn do_compat_select(n, inp, outp, exp, tvp);\n}"
  },
  {
    "function_name": "old_select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1298-1306",
    "snippet": "SYSCALL_DEFINE1(old_select, struct compat_sel_arg_struct __user *, arg)\n{\n\tstruct compat_sel_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\treturn do_compat_select(a.n, compat_ptr(a.inp), compat_ptr(a.outp),\n\t\t\t\tcompat_ptr(a.exp), compat_ptr(a.tvp));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE1(old_select, struct compat_sel_arg_struct __user *, arg)\n{\n\tstruct compat_sel_arg_struct a;\n\n\tif (copy_from_user(&a, arg, sizeof(a)))\n\t\treturn -EFAULT;\n\treturn do_compat_select(a.n, compat_ptr(a.inp), compat_ptr(a.outp),\n\t\t\t\tcompat_ptr(a.exp), compat_ptr(a.tvp));\n}"
  },
  {
    "function_name": "pselect6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1356-1373",
    "snippet": "SYSCALL_DEFINE6(pselect6, int, n, compat_ulong_t __user *, inp,\n\tcompat_ulong_t __user *, outp, compat_ulong_t __user *, exp,\n\tstruct old_timespec32 __user *, tsp, void __user *, sig)\n{\n\tcompat_size_t sigsetsize = 0;\n\tcompat_uptr_t up = 0;\n\n\tif (sig) {\n\t\tif (!access_ok(VERIFY_READ, sig,\n\t\t\t\tsizeof(compat_uptr_t)+sizeof(compat_size_t)) ||\n\t\t    \t__get_user(up, (compat_uptr_t __user *)sig) ||\n\t\t    \t__get_user(sigsetsize,\n\t\t\t\t(compat_size_t __user *)(sig+sizeof(up))))\n\t\t\treturn -EFAULT;\n\t}\n\treturn do_compat_pselect(n, inp, outp, exp, tsp, compat_ptr(up),\n\t\t\t\t sigsetsize);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE6(pselect6, int, n, compat_ulong_t __user *, inp,\n\tcompat_ulong_t __user *, outp, compat_ulong_t __user *, exp,\n\tstruct old_timespec32 __user *, tsp, void __user *, sig)\n{\n\tcompat_size_t sigsetsize = 0;\n\tcompat_uptr_t up = 0;\n\n\tif (sig) {\n\t\tif (!access_ok(VERIFY_READ, sig,\n\t\t\t\tsizeof(compat_uptr_t)+sizeof(compat_size_t)) ||\n\t\t    \t__get_user(up, (compat_uptr_t __user *)sig) ||\n\t\t    \t__get_user(sigsetsize,\n\t\t\t\t(compat_size_t __user *)(sig+sizeof(up))))\n\t\t\treturn -EFAULT;\n\t}\n\treturn do_compat_pselect(n, inp, outp, exp, tsp, compat_ptr(up),\n\t\t\t\t sigsetsize);\n}"
  },
  {
    "function_name": "ppoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
    "lines": "1375-1423",
    "snippet": "SYSCALL_DEFINE5(ppoll, struct pollfd __user *, ufds,\n\tunsigned int,  nfds, struct old_timespec32 __user *, tsp,\n\tconst compat_sigset_t __user *, sigmask, compat_size_t, sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_old_timespec32(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (get_compat_sigset(&ksigmask, sigmask))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\t/* We can restart this syscall, usually */\n\tif (ret == -EINTR) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\tret = compat_poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/freezer.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/fs.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched/rt.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nSYSCALL_DEFINE5(ppoll, struct pollfd __user *, ufds,\n\tunsigned int,  nfds, struct old_timespec32 __user *, tsp,\n\tconst compat_sigset_t __user *, sigmask, compat_size_t, sigsetsize)\n{\n\tsigset_t ksigmask, sigsaved;\n\tstruct timespec64 ts, end_time, *to = NULL;\n\tint ret;\n\n\tif (tsp) {\n\t\tif (get_old_timespec32(&ts, tsp))\n\t\t\treturn -EFAULT;\n\n\t\tto = &end_time;\n\t\tif (poll_select_set_timeout(to, ts.tv_sec, ts.tv_nsec))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (get_compat_sigset(&ksigmask, sigmask))\n\t\t\treturn -EFAULT;\n\n\t\tsigdelsetmask(&ksigmask, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\t\tsigprocmask(SIG_SETMASK, &ksigmask, &sigsaved);\n\t}\n\n\tret = do_sys_poll(ufds, nfds, to);\n\n\t/* We can restart this syscall, usually */\n\tif (ret == -EINTR) {\n\t\t/*\n\t\t * Don't restore the signal mask yet. Let do_signal() deliver\n\t\t * the signal on the way back to userspace, before the signal\n\t\t * mask is restored.\n\t\t */\n\t\tif (sigmask) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t\tsizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t}\n\t\tret = -ERESTARTNOHAND;\n\t} else if (sigmask)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\n\tret = compat_poll_select_copy_remaining(&end_time, tsp, 0, ret);\n\n\treturn ret;\n}"
  }
]