[
  {
    "function_name": "eventpoll_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "2299-2337",
    "snippet": "static int __init eventpoll_init(void)\n{\n\tstruct sysinfo si;\n\n\tsi_meminfo(&si);\n\t/*\n\t * Allows top 4% of lomem to be allocated for epoll watches (per user).\n\t */\n\tmax_user_watches = (((si.totalram - si.totalhigh) / 25) << PAGE_SHIFT) /\n\t\tEP_ITEM_COST;\n\tBUG_ON(max_user_watches < 0);\n\n\t/*\n\t * Initialize the structure used to perform epoll file descriptor\n\t * inclusion loops checks.\n\t */\n\tep_nested_calls_init(&poll_loop_ncalls);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/* Initialize the structure used to perform safe poll wait head wake ups */\n\tep_nested_calls_init(&poll_safewake_ncalls);\n#endif\n\n\t/*\n\t * We can have many thousands of epitems, so prevent this from\n\t * using an extra cache line on 64-bit (and smaller) CPUs\n\t */\n\tBUILD_BUG_ON(sizeof(void *) <= 8 && sizeof(struct epitem) > 128);\n\n\t/* Allocates slab cache used to allocate \"struct epitem\" items */\n\tepi_cache = kmem_cache_create(\"eventpoll_epi\", sizeof(struct epitem),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);\n\n\t/* Allocates slab cache used to allocate \"struct eppoll_entry\" */\n\tpwq_cache = kmem_cache_create(\"eventpoll_pwq\",\n\t\tsizeof(struct eppoll_entry), 0, SLAB_PANIC|SLAB_ACCOUNT, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_ITEM_COST (sizeof(struct epitem) + sizeof(struct eppoll_entry))"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"eventpoll_pwq\"",
            "sizeof(struct eppoll_entry)",
            "0",
            "SLAB_PANIC|SLAB_ACCOUNT",
            "NULL"
          ],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"eventpoll_epi\"",
            "sizeof(struct epitem)",
            "0",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT",
            "NULL"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(void *) <= 8 && sizeof(struct epitem) > 128"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_nested_calls_init",
          "args": [
            "&poll_safewake_ncalls"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "ep_nested_calls_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "368-372",
          "snippet": "static void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "max_user_watches < 0"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "&si"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_ITEM_COST (sizeof(struct epitem) + sizeof(struct eppoll_entry))\n\nstatic struct nested_calls poll_loop_ncalls;\n\nstatic int __init eventpoll_init(void)\n{\n\tstruct sysinfo si;\n\n\tsi_meminfo(&si);\n\t/*\n\t * Allows top 4% of lomem to be allocated for epoll watches (per user).\n\t */\n\tmax_user_watches = (((si.totalram - si.totalhigh) / 25) << PAGE_SHIFT) /\n\t\tEP_ITEM_COST;\n\tBUG_ON(max_user_watches < 0);\n\n\t/*\n\t * Initialize the structure used to perform epoll file descriptor\n\t * inclusion loops checks.\n\t */\n\tep_nested_calls_init(&poll_loop_ncalls);\n\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/* Initialize the structure used to perform safe poll wait head wake ups */\n\tep_nested_calls_init(&poll_safewake_ncalls);\n#endif\n\n\t/*\n\t * We can have many thousands of epitems, so prevent this from\n\t * using an extra cache line on 64-bit (and smaller) CPUs\n\t */\n\tBUILD_BUG_ON(sizeof(void *) <= 8 && sizeof(struct epitem) > 128);\n\n\t/* Allocates slab cache used to allocate \"struct epitem\" items */\n\tepi_cache = kmem_cache_create(\"eventpoll_epi\", sizeof(struct epitem),\n\t\t\t0, SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);\n\n\t/* Allocates slab cache used to allocate \"struct eppoll_entry\" */\n\tpwq_cache = kmem_cache_create(\"eventpoll_pwq\",\n\t\tsizeof(struct eppoll_entry), 0, SLAB_PANIC|SLAB_ACCOUNT, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_epoll_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "2163-2203",
    "snippet": "static int do_epoll_wait(int epfd, struct epoll_event __user *events,\n\t\t\t int maxevents, int timeout)\n{\n\tint error;\n\tstruct fd f;\n\tstruct eventpoll *ep;\n\n\t/* The maximum number of event must be greater than zero */\n\tif (maxevents <= 0 || maxevents > EP_MAX_EVENTS)\n\t\treturn -EINVAL;\n\n\t/* Verify that the area passed by the user is writeable */\n\tif (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event)))\n\t\treturn -EFAULT;\n\n\t/* Get the \"struct file *\" for the eventpoll file */\n\tf = fdget(epfd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\t/*\n\t * We have to check that the file structure underneath the fd\n\t * the user passed to us _is_ an eventpoll file.\n\t */\n\terror = -EINVAL;\n\tif (!is_file_epoll(f.file))\n\t\tgoto error_fput;\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = f.file->private_data;\n\n\t/* Time to fish for events ... */\n\terror = ep_poll(ep, events, maxevents, timeout);\n\nerror_fput:\n\tfdput(f);\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_EVENTS (INT_MAX / sizeof(struct epoll_event))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_poll",
          "args": [
            "ep",
            "events",
            "maxevents",
            "timeout"
          ],
          "line": 2198
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1745-1844",
          "snippet": "static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   int maxevents, long timeout)\n{\n\tint res = 0, eavail, timed_out = 0;\n\tu64 slack = 0;\n\twait_queue_entry_t wait;\n\tktime_t expires, *to = NULL;\n\n\tlockdep_assert_irqs_enabled();\n\n\tif (timeout > 0) {\n\t\tstruct timespec64 end_time = ep_set_mstimeout(timeout);\n\n\t\tslack = select_estimate_accuracy(&end_time);\n\t\tto = &expires;\n\t\t*to = timespec64_to_ktime(end_time);\n\t} else if (timeout == 0) {\n\t\t/*\n\t\t * Avoid the unnecessary trip to the wait queue loop, if the\n\t\t * caller specified a non blocking operation.\n\t\t */\n\t\ttimed_out = 1;\n\t\tspin_lock_irq(&ep->wq.lock);\n\t\tgoto check_events;\n\t}\n\nfetch_events:\n\n\tif (!ep_events_available(ep))\n\t\tep_busy_loop(ep, timed_out);\n\n\tspin_lock_irq(&ep->wq.lock);\n\n\tif (!ep_events_available(ep)) {\n\t\t/*\n\t\t * Busy poll timed out.  Drop NAPI ID for now, we can add\n\t\t * it back in when we have moved a socket with a valid NAPI\n\t\t * ID onto the ready list.\n\t\t */\n\t\tep_reset_busy_poll_napi_id(ep);\n\n\t\t/*\n\t\t * We don't have any available event to return to the caller.\n\t\t * We need to sleep here, and we will be wake up by\n\t\t * ep_poll_callback() when events will become available.\n\t\t */\n\t\tinit_waitqueue_entry(&wait, current);\n\t\t__add_wait_queue_exclusive(&ep->wq, &wait);\n\n\t\tfor (;;) {\n\t\t\t/*\n\t\t\t * We don't want to sleep if the ep_poll_callback() sends us\n\t\t\t * a wakeup in between. That's why we set the task state\n\t\t\t * to TASK_INTERRUPTIBLE before doing the checks.\n\t\t\t */\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t/*\n\t\t\t * Always short-circuit for fatal signals to allow\n\t\t\t * threads to make a timely exit without the chance of\n\t\t\t * finding more events available and fetching\n\t\t\t * repeatedly.\n\t\t\t */\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ep_events_available(ep) || timed_out)\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_unlock_irq(&ep->wq.lock);\n\t\t\tif (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))\n\t\t\t\ttimed_out = 1;\n\n\t\t\tspin_lock_irq(&ep->wq.lock);\n\t\t}\n\n\t\t__remove_wait_queue(&ep->wq, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\ncheck_events:\n\t/* Is it worth to try to dig for events ? */\n\teavail = ep_events_available(ep);\n\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Try to transfer events to user space. In case we get 0 events and\n\t * there's still timeout left over, we go trying again in search of\n\t * more luck.\n\t */\n\tif (!res && eavail &&\n\t    !(res = ep_send_events(ep, events, maxevents)) && !timed_out)\n\t\tgoto fetch_events;\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   int maxevents, long timeout)\n{\n\tint res = 0, eavail, timed_out = 0;\n\tu64 slack = 0;\n\twait_queue_entry_t wait;\n\tktime_t expires, *to = NULL;\n\n\tlockdep_assert_irqs_enabled();\n\n\tif (timeout > 0) {\n\t\tstruct timespec64 end_time = ep_set_mstimeout(timeout);\n\n\t\tslack = select_estimate_accuracy(&end_time);\n\t\tto = &expires;\n\t\t*to = timespec64_to_ktime(end_time);\n\t} else if (timeout == 0) {\n\t\t/*\n\t\t * Avoid the unnecessary trip to the wait queue loop, if the\n\t\t * caller specified a non blocking operation.\n\t\t */\n\t\ttimed_out = 1;\n\t\tspin_lock_irq(&ep->wq.lock);\n\t\tgoto check_events;\n\t}\n\nfetch_events:\n\n\tif (!ep_events_available(ep))\n\t\tep_busy_loop(ep, timed_out);\n\n\tspin_lock_irq(&ep->wq.lock);\n\n\tif (!ep_events_available(ep)) {\n\t\t/*\n\t\t * Busy poll timed out.  Drop NAPI ID for now, we can add\n\t\t * it back in when we have moved a socket with a valid NAPI\n\t\t * ID onto the ready list.\n\t\t */\n\t\tep_reset_busy_poll_napi_id(ep);\n\n\t\t/*\n\t\t * We don't have any available event to return to the caller.\n\t\t * We need to sleep here, and we will be wake up by\n\t\t * ep_poll_callback() when events will become available.\n\t\t */\n\t\tinit_waitqueue_entry(&wait, current);\n\t\t__add_wait_queue_exclusive(&ep->wq, &wait);\n\n\t\tfor (;;) {\n\t\t\t/*\n\t\t\t * We don't want to sleep if the ep_poll_callback() sends us\n\t\t\t * a wakeup in between. That's why we set the task state\n\t\t\t * to TASK_INTERRUPTIBLE before doing the checks.\n\t\t\t */\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t/*\n\t\t\t * Always short-circuit for fatal signals to allow\n\t\t\t * threads to make a timely exit without the chance of\n\t\t\t * finding more events available and fetching\n\t\t\t * repeatedly.\n\t\t\t */\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ep_events_available(ep) || timed_out)\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_unlock_irq(&ep->wq.lock);\n\t\t\tif (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))\n\t\t\t\ttimed_out = 1;\n\n\t\t\tspin_lock_irq(&ep->wq.lock);\n\t\t}\n\n\t\t__remove_wait_queue(&ep->wq, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\ncheck_events:\n\t/* Is it worth to try to dig for events ? */\n\teavail = ep_events_available(ep);\n\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Try to transfer events to user space. In case we get 0 events and\n\t * there's still timeout left over, we go trying again in search of\n\t * more luck.\n\t */\n\tif (!res && eavail &&\n\t    !(res = ep_send_events(ep, events, maxevents)) && !timed_out)\n\t\tgoto fetch_events;\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_file_epoll",
          "args": [
            "f.file"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "is_file_epoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "317-320",
          "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventpoll_fops;",
            "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "epfd"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "__fdget_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "758-770",
          "snippet": "unsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nunsigned long __fdget_pos(unsigned int fd)\n{\n\tunsigned long v = __fdget(fd);\n\tstruct file *file = (struct file *)(v & ~3);\n\n\tif (file && (file->f_mode & FMODE_ATOMIC_POS)) {\n\t\tif (file_count(file) > 1) {\n\t\t\tv |= FDPUT_POS_UNLOCK;\n\t\t\tmutex_lock(&file->f_pos_lock);\n\t\t}\n\t}\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "events",
            "maxevents * sizeof(struct epoll_event)"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_EVENTS (INT_MAX / sizeof(struct epoll_event))\n\nstatic int do_epoll_wait(int epfd, struct epoll_event __user *events,\n\t\t\t int maxevents, int timeout)\n{\n\tint error;\n\tstruct fd f;\n\tstruct eventpoll *ep;\n\n\t/* The maximum number of event must be greater than zero */\n\tif (maxevents <= 0 || maxevents > EP_MAX_EVENTS)\n\t\treturn -EINVAL;\n\n\t/* Verify that the area passed by the user is writeable */\n\tif (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event)))\n\t\treturn -EFAULT;\n\n\t/* Get the \"struct file *\" for the eventpoll file */\n\tf = fdget(epfd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\t/*\n\t * We have to check that the file structure underneath the fd\n\t * the user passed to us _is_ an eventpoll file.\n\t */\n\terror = -EINVAL;\n\tif (!is_file_epoll(f.file))\n\t\tgoto error_fput;\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = f.file->private_data;\n\n\t/* Time to fish for events ... */\n\terror = ep_poll(ep, events, maxevents, timeout);\n\nerror_fput:\n\tfdput(f);\n\treturn error;\n}"
  },
  {
    "function_name": "do_epoll_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1946-1987",
    "snippet": "static int do_epoll_create(int flags)\n{\n\tint error, fd;\n\tstruct eventpoll *ep = NULL;\n\tstruct file *file;\n\n\t/* Check the EPOLL_* constant for consistency.  */\n\tBUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);\n\n\tif (flags & ~EPOLL_CLOEXEC)\n\t\treturn -EINVAL;\n\t/*\n\t * Create the internal data structure (\"struct eventpoll\").\n\t */\n\terror = ep_alloc(&ep);\n\tif (error < 0)\n\t\treturn error;\n\t/*\n\t * Creates all the items needed to setup an eventpoll file. That is,\n\t * a file structure and a free file descriptor.\n\t */\n\tfd = get_unused_fd_flags(O_RDWR | (flags & O_CLOEXEC));\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_free_ep;\n\t}\n\tfile = anon_inode_getfile(\"[eventpoll]\", &eventpoll_fops, ep,\n\t\t\t\t O_RDWR | (flags & O_CLOEXEC));\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto out_free_fd;\n\t}\n\tep->file = file;\n\tfd_install(fd, file);\n\treturn fd;\n\nout_free_fd:\n\tput_unused_fd(fd);\nout_free_ep:\n\tep_free(ep);\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventpoll_fops;",
      "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_free",
          "args": [
            "ep"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "ep_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "812-862",
          "snippet": "static void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->wq.lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first_cached(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(epmutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(epmutex);\n\nstatic void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->wq.lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first_cached(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unused_fd",
          "args": [
            "fd"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "put_unused_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "556-562",
          "snippet": "void put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_unused_fd(unsigned int fd)\n{\n\tstruct files_struct *files = current->files;\n\tspin_lock(&files->file_lock);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_install",
          "args": [
            "fd",
            "file"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "fd_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "610-613",
          "snippet": "void fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid fd_install(unsigned int fd, struct file *file)\n{\n\t__fd_install(current->files, fd, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "anon_inode_getfile",
          "args": [
            "\"[eventpoll]\"",
            "&eventpoll_fops",
            "ep",
            "O_RDWR | (flags & O_CLOEXEC)"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "anon_inode_getfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/anon_inodes.c",
          "lines": "70-102",
          "snippet": "struct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\tstruct file *file;\n\n\tif (IS_ERR(anon_inode_inode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * We know the anon_inode inode count is always greater than zero,\n\t * so ihold() is safe.\n\t */\n\tihold(anon_inode_inode);\n\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,\n\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);\n\tif (IS_ERR(file))\n\t\tgoto err;\n\n\tfile->f_mapping = anon_inode_inode->i_mapping;\n\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr:\n\tiput(anon_inode_inode);\n\tmodule_put(fops->owner);\n\treturn file;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *anon_inode_mnt",
            "static struct inode *anon_inode_inode;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/anon_inodes.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n\nstatic struct vfsmount *anon_inode_mnt;\nstatic struct inode *anon_inode_inode;\n\nstruct file *anon_inode_getfile(const char *name,\n\t\t\t\tconst struct file_operations *fops,\n\t\t\t\tvoid *priv, int flags)\n{\n\tstruct file *file;\n\n\tif (IS_ERR(anon_inode_inode))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (fops->owner && !try_module_get(fops->owner))\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * We know the anon_inode inode count is always greater than zero,\n\t * so ihold() is safe.\n\t */\n\tihold(anon_inode_inode);\n\tfile = alloc_file_pseudo(anon_inode_inode, anon_inode_mnt, name,\n\t\t\t\t flags & (O_ACCMODE | O_NONBLOCK), fops);\n\tif (IS_ERR(file))\n\t\tgoto err;\n\n\tfile->f_mapping = anon_inode_inode->i_mapping;\n\n\tfile->private_data = priv;\n\n\treturn file;\n\nerr:\n\tiput(anon_inode_inode);\n\tmodule_put(fops->owner);\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_unused_fd_flags",
          "args": [
            "O_RDWR | (flags & O_CLOEXEC)"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "get_unused_fd_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/file.c",
          "lines": "542-545",
          "snippet": "int get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}",
          "includes": [
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nint get_unused_fd_flags(unsigned flags)\n{\n\treturn __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_alloc",
          "args": [
            "&ep"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "ep_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1013-1040",
          "snippet": "static int ep_alloc(struct eventpoll **pep)\n{\n\tint error;\n\tstruct user_struct *user;\n\tstruct eventpoll *ep;\n\n\tuser = get_current_user();\n\terror = -ENOMEM;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (unlikely(!ep))\n\t\tgoto free_uid;\n\n\tmutex_init(&ep->mtx);\n\tinit_waitqueue_head(&ep->wq);\n\tinit_waitqueue_head(&ep->poll_wait);\n\tINIT_LIST_HEAD(&ep->rdllist);\n\tep->rbr = RB_ROOT_CACHED;\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tep->user = user;\n\n\t*pep = ep;\n\n\treturn 0;\n\nfree_uid:\n\tfree_uid(user);\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic int ep_alloc(struct eventpoll **pep)\n{\n\tint error;\n\tstruct user_struct *user;\n\tstruct eventpoll *ep;\n\n\tuser = get_current_user();\n\terror = -ENOMEM;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (unlikely(!ep))\n\t\tgoto free_uid;\n\n\tmutex_init(&ep->mtx);\n\tinit_waitqueue_head(&ep->wq);\n\tinit_waitqueue_head(&ep->poll_wait);\n\tINIT_LIST_HEAD(&ep->rdllist);\n\tep->rbr = RB_ROOT_CACHED;\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tep->user = user;\n\n\t*pep = ep;\n\n\treturn 0;\n\nfree_uid:\n\tfree_uid(user);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "EPOLL_CLOEXEC != O_CLOEXEC"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic int do_epoll_create(int flags)\n{\n\tint error, fd;\n\tstruct eventpoll *ep = NULL;\n\tstruct file *file;\n\n\t/* Check the EPOLL_* constant for consistency.  */\n\tBUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);\n\n\tif (flags & ~EPOLL_CLOEXEC)\n\t\treturn -EINVAL;\n\t/*\n\t * Create the internal data structure (\"struct eventpoll\").\n\t */\n\terror = ep_alloc(&ep);\n\tif (error < 0)\n\t\treturn error;\n\t/*\n\t * Creates all the items needed to setup an eventpoll file. That is,\n\t * a file structure and a free file descriptor.\n\t */\n\tfd = get_unused_fd_flags(O_RDWR | (flags & O_CLOEXEC));\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_free_ep;\n\t}\n\tfile = anon_inode_getfile(\"[eventpoll]\", &eventpoll_fops, ep,\n\t\t\t\t O_RDWR | (flags & O_CLOEXEC));\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto out_free_fd;\n\t}\n\tep->file = file;\n\tfd_install(fd, file);\n\treturn fd;\n\nout_free_fd:\n\tput_unused_fd(fd);\nout_free_ep:\n\tep_free(ep);\n\treturn error;\n}"
  },
  {
    "function_name": "clear_tfile_check_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1930-1941",
    "snippet": "static void clear_tfile_check_list(void)\n{\n\tstruct file *file;\n\n\t/* first clear the tfile_check_list */\n\twhile (!list_empty(&tfile_check_list)) {\n\t\tfile = list_first_entry(&tfile_check_list, struct file,\n\t\t\t\t\tf_tfile_llink);\n\t\tlist_del_init(&file->f_tfile_llink);\n\t}\n\tINIT_LIST_HEAD(&tfile_check_list);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tfile_check_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tfile_check_list"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&file->f_tfile_llink"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&tfile_check_list",
            "structfile",
            "f_tfile_llink"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tfile_check_list"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(tfile_check_list);\n\nstatic void clear_tfile_check_list(void)\n{\n\tstruct file *file;\n\n\t/* first clear the tfile_check_list */\n\twhile (!list_empty(&tfile_check_list)) {\n\t\tfile = list_first_entry(&tfile_check_list, struct file,\n\t\t\t\t\tf_tfile_llink);\n\t\tlist_del_init(&file->f_tfile_llink);\n\t}\n\tINIT_LIST_HEAD(&tfile_check_list);\n}"
  },
  {
    "function_name": "ep_loop_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1914-1928",
    "snippet": "static int ep_loop_check(struct eventpoll *ep, struct file *file)\n{\n\tint ret;\n\tstruct eventpoll *ep_cur, *ep_next;\n\n\tret = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t      ep_loop_check_proc, file, ep, current);\n\t/* clear visited list */\n\tlist_for_each_entry_safe(ep_cur, ep_next, &visited_list,\n\t\t\t\t\t\t\tvisited_list_link) {\n\t\tep_cur->visited = 0;\n\t\tlist_del(&ep_cur->visited_list_link);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;",
      "static LIST_HEAD(visited_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ep_cur->visited_list_link"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ep_cur",
            "ep_next",
            "&visited_list",
            "visited_list_link"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_loop_ncalls",
            "EP_MAX_NESTS",
            "ep_loop_check_proc",
            "file",
            "ep",
            "current"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "483-529",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic LIST_HEAD(visited_list);\n\nstatic int ep_loop_check(struct eventpoll *ep, struct file *file)\n{\n\tint ret;\n\tstruct eventpoll *ep_cur, *ep_next;\n\n\tret = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t      ep_loop_check_proc, file, ep, current);\n\t/* clear visited list */\n\tlist_for_each_entry_safe(ep_cur, ep_next, &visited_list,\n\t\t\t\t\t\t\tvisited_list_link) {\n\t\tep_cur->visited = 0;\n\t\tlist_del(&ep_cur->visited_list_link);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ep_loop_check_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1861-1901",
    "snippet": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If we've reached a file that is not associated with\n\t\t\t * an ep, then we need to check if the newly added\n\t\t\t * links are going to add too many wakeup paths. We do\n\t\t\t * this by adding it to the tfile_check_list, if it's\n\t\t\t * not already there, and calling reverse_path_check()\n\t\t\t * during ep_insert().\n\t\t\t */\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;",
      "static LIST_HEAD(visited_list);",
      "static LIST_HEAD(tfile_check_list);",
      "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&epi->ffd.file->f_tfile_llink",
            "&tfile_check_list"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&epi->ffd.file->f_tfile_llink"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_loop_ncalls",
            "EP_MAX_NESTS",
            "ep_loop_check_proc",
            "epi->ffd.file",
            "ep_tovisit",
            "current"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "483-529",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_file_epoll(epi->ffd.file)"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_epoll",
          "args": [
            "epi->ffd.file"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "is_file_epoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "317-320",
          "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventpoll_fops;",
            "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rbp"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first_cached",
          "args": [
            "&ep->rbr"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&ep->mtx",
            "call_nests + 1"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic LIST_HEAD(visited_list);\nstatic LIST_HEAD(tfile_check_list);\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If we've reached a file that is not associated with\n\t\t\t * an ep, then we need to check if the newly added\n\t\t\t * links are going to add too many wakeup paths. We do\n\t\t\t * this by adding it to the tfile_check_list, if it's\n\t\t\t * not already there, and calling reverse_path_check()\n\t\t\t * during ep_insert().\n\t\t\t */\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ep_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1745-1844",
    "snippet": "static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   int maxevents, long timeout)\n{\n\tint res = 0, eavail, timed_out = 0;\n\tu64 slack = 0;\n\twait_queue_entry_t wait;\n\tktime_t expires, *to = NULL;\n\n\tlockdep_assert_irqs_enabled();\n\n\tif (timeout > 0) {\n\t\tstruct timespec64 end_time = ep_set_mstimeout(timeout);\n\n\t\tslack = select_estimate_accuracy(&end_time);\n\t\tto = &expires;\n\t\t*to = timespec64_to_ktime(end_time);\n\t} else if (timeout == 0) {\n\t\t/*\n\t\t * Avoid the unnecessary trip to the wait queue loop, if the\n\t\t * caller specified a non blocking operation.\n\t\t */\n\t\ttimed_out = 1;\n\t\tspin_lock_irq(&ep->wq.lock);\n\t\tgoto check_events;\n\t}\n\nfetch_events:\n\n\tif (!ep_events_available(ep))\n\t\tep_busy_loop(ep, timed_out);\n\n\tspin_lock_irq(&ep->wq.lock);\n\n\tif (!ep_events_available(ep)) {\n\t\t/*\n\t\t * Busy poll timed out.  Drop NAPI ID for now, we can add\n\t\t * it back in when we have moved a socket with a valid NAPI\n\t\t * ID onto the ready list.\n\t\t */\n\t\tep_reset_busy_poll_napi_id(ep);\n\n\t\t/*\n\t\t * We don't have any available event to return to the caller.\n\t\t * We need to sleep here, and we will be wake up by\n\t\t * ep_poll_callback() when events will become available.\n\t\t */\n\t\tinit_waitqueue_entry(&wait, current);\n\t\t__add_wait_queue_exclusive(&ep->wq, &wait);\n\n\t\tfor (;;) {\n\t\t\t/*\n\t\t\t * We don't want to sleep if the ep_poll_callback() sends us\n\t\t\t * a wakeup in between. That's why we set the task state\n\t\t\t * to TASK_INTERRUPTIBLE before doing the checks.\n\t\t\t */\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t/*\n\t\t\t * Always short-circuit for fatal signals to allow\n\t\t\t * threads to make a timely exit without the chance of\n\t\t\t * finding more events available and fetching\n\t\t\t * repeatedly.\n\t\t\t */\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ep_events_available(ep) || timed_out)\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_unlock_irq(&ep->wq.lock);\n\t\t\tif (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))\n\t\t\t\ttimed_out = 1;\n\n\t\t\tspin_lock_irq(&ep->wq.lock);\n\t\t}\n\n\t\t__remove_wait_queue(&ep->wq, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\ncheck_events:\n\t/* Is it worth to try to dig for events ? */\n\teavail = ep_events_available(ep);\n\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Try to transfer events to user space. In case we get 0 events and\n\t * there's still timeout left over, we go trying again in search of\n\t * more luck.\n\t */\n\tif (!res && eavail &&\n\t    !(res = ep_send_events(ep, events, maxevents)) && !timed_out)\n\t\tgoto fetch_events;\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_send_events",
          "args": [
            "ep",
            "events",
            "maxevents"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "ep_send_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1705-1715",
          "snippet": "static int ep_send_events(struct eventpoll *ep,\n\t\t\t  struct epoll_event __user *events, int maxevents)\n{\n\tstruct ep_send_events_data esed;\n\n\tesed.maxevents = maxevents;\n\tesed.events = events;\n\n\tep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);\n\treturn esed.res;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_send_events(struct eventpoll *ep,\n\t\t\t  struct epoll_event __user *events, int maxevents)\n{\n\tstruct ep_send_events_data esed;\n\n\tesed.maxevents = maxevents;\n\tesed.events = events;\n\n\tep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);\n\treturn esed.res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_events_available",
          "args": [
            "ep"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "ep_events_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "382-385",
          "snippet": "static inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ep->wq",
            "&wait"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range",
          "args": [
            "to",
            "slack",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_exclusive",
          "args": [
            "&ep->wq",
            "&wait"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_entry",
          "args": [
            "&wait",
            "current"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_reset_busy_poll_napi_id",
          "args": [
            "ep"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "ep_reset_busy_poll_napi_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "457-459",
          "snippet": "static inline void ep_reset_busy_poll_napi_id(struct eventpoll *ep)\n{\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_reset_busy_poll_napi_id(struct eventpoll *ep)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_busy_loop",
          "args": [
            "ep",
            "timed_out"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "ep_busy_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "453-455",
          "snippet": "static inline void ep_busy_loop(struct eventpoll *ep, int nonblock)\n{\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_busy_loop(struct eventpoll *ep, int nonblock)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "end_time"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_estimate_accuracy",
          "args": [
            "&end_time"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "select_estimate_accuracy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/select.c",
          "lines": "75-93",
          "snippet": "u64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nu64 select_estimate_accuracy(struct timespec64 *tv)\n{\n\tu64 ret;\n\tstruct timespec64 now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts64(&now);\n\tnow = timespec64_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_set_mstimeout",
          "args": [
            "timeout"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_mstimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1717-1726",
          "snippet": "static inline struct timespec64 ep_set_mstimeout(long ms)\n{\n\tstruct timespec64 now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts64(&now);\n\treturn timespec64_add_safe(now, ts);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct timespec64 ep_set_mstimeout(long ms)\n{\n\tstruct timespec64 now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts64(&now);\n\treturn timespec64_add_safe(now, ts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   int maxevents, long timeout)\n{\n\tint res = 0, eavail, timed_out = 0;\n\tu64 slack = 0;\n\twait_queue_entry_t wait;\n\tktime_t expires, *to = NULL;\n\n\tlockdep_assert_irqs_enabled();\n\n\tif (timeout > 0) {\n\t\tstruct timespec64 end_time = ep_set_mstimeout(timeout);\n\n\t\tslack = select_estimate_accuracy(&end_time);\n\t\tto = &expires;\n\t\t*to = timespec64_to_ktime(end_time);\n\t} else if (timeout == 0) {\n\t\t/*\n\t\t * Avoid the unnecessary trip to the wait queue loop, if the\n\t\t * caller specified a non blocking operation.\n\t\t */\n\t\ttimed_out = 1;\n\t\tspin_lock_irq(&ep->wq.lock);\n\t\tgoto check_events;\n\t}\n\nfetch_events:\n\n\tif (!ep_events_available(ep))\n\t\tep_busy_loop(ep, timed_out);\n\n\tspin_lock_irq(&ep->wq.lock);\n\n\tif (!ep_events_available(ep)) {\n\t\t/*\n\t\t * Busy poll timed out.  Drop NAPI ID for now, we can add\n\t\t * it back in when we have moved a socket with a valid NAPI\n\t\t * ID onto the ready list.\n\t\t */\n\t\tep_reset_busy_poll_napi_id(ep);\n\n\t\t/*\n\t\t * We don't have any available event to return to the caller.\n\t\t * We need to sleep here, and we will be wake up by\n\t\t * ep_poll_callback() when events will become available.\n\t\t */\n\t\tinit_waitqueue_entry(&wait, current);\n\t\t__add_wait_queue_exclusive(&ep->wq, &wait);\n\n\t\tfor (;;) {\n\t\t\t/*\n\t\t\t * We don't want to sleep if the ep_poll_callback() sends us\n\t\t\t * a wakeup in between. That's why we set the task state\n\t\t\t * to TASK_INTERRUPTIBLE before doing the checks.\n\t\t\t */\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t/*\n\t\t\t * Always short-circuit for fatal signals to allow\n\t\t\t * threads to make a timely exit without the chance of\n\t\t\t * finding more events available and fetching\n\t\t\t * repeatedly.\n\t\t\t */\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ep_events_available(ep) || timed_out)\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_unlock_irq(&ep->wq.lock);\n\t\t\tif (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))\n\t\t\t\ttimed_out = 1;\n\n\t\t\tspin_lock_irq(&ep->wq.lock);\n\t\t}\n\n\t\t__remove_wait_queue(&ep->wq, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\ncheck_events:\n\t/* Is it worth to try to dig for events ? */\n\teavail = ep_events_available(ep);\n\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Try to transfer events to user space. In case we get 0 events and\n\t * there's still timeout left over, we go trying again in search of\n\t * more luck.\n\t */\n\tif (!res && eavail &&\n\t    !(res = ep_send_events(ep, events, maxevents)) && !timed_out)\n\t\tgoto fetch_events;\n\n\treturn res;\n}"
  },
  {
    "function_name": "ep_set_mstimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1717-1726",
    "snippet": "static inline struct timespec64 ep_set_mstimeout(long ms)\n{\n\tstruct timespec64 now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts64(&now);\n\treturn timespec64_add_safe(now, ts);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec64_add_safe",
          "args": [
            "now",
            "ts"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts64",
          "args": [
            "&now"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct timespec64 ep_set_mstimeout(long ms)\n{\n\tstruct timespec64 now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts64(&now);\n\treturn timespec64_add_safe(now, ts);\n}"
  },
  {
    "function_name": "ep_send_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1705-1715",
    "snippet": "static int ep_send_events(struct eventpoll *ep,\n\t\t\t  struct epoll_event __user *events, int maxevents)\n{\n\tstruct ep_send_events_data esed;\n\n\tesed.maxevents = maxevents;\n\tesed.events = events;\n\n\tep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);\n\treturn esed.res;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_scan_ready_list",
          "args": [
            "ep",
            "ep_send_events_proc",
            "&esed",
            "0",
            "false"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "ep_scan_ready_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "672-762",
          "snippet": "static __poll_t ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      __poll_t (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\t__poll_t res;\n\tint pwake = 0;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\tres = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irq(&ep->wq.lock);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [
            "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic __poll_t ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      __poll_t (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\t__poll_t res;\n\tint pwake = 0;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\tres = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irq(&ep->wq.lock);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_send_events(struct eventpoll *ep,\n\t\t\t  struct epoll_event __user *events, int maxevents)\n{\n\tstruct ep_send_events_data esed;\n\n\tesed.maxevents = maxevents;\n\tesed.events = events;\n\n\tep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);\n\treturn esed.res;\n}"
  },
  {
    "function_name": "ep_send_events_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1624-1703",
    "snippet": "static __poll_t ep_send_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct ep_send_events_data *esed = priv;\n\t__poll_t revents;\n\tstruct epitem *epi;\n\tstruct epoll_event __user *uevent;\n\tstruct wakeup_source *ws;\n\tpoll_table pt;\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\t/*\n\t * We can loop without lock because we are passed a task private list.\n\t * Items cannot vanish during the loop because ep_scan_ready_list() is\n\t * holding \"mtx\" during this call.\n\t */\n\tfor (esed->res = 0, uevent = esed->events;\n\t     !list_empty(head) && esed->res < esed->maxevents;) {\n\t\tepi = list_first_entry(head, struct epitem, rdllink);\n\n\t\t/*\n\t\t * Activate ep->ws before deactivating epi->ws to prevent\n\t\t * triggering auto-suspend here (in case we reactive epi->ws\n\t\t * below).\n\t\t *\n\t\t * This could be rearranged to delay the deactivation of epi->ws\n\t\t * instead, but then epi->ws would temporarily be out of sync\n\t\t * with ep_is_linked().\n\t\t */\n\t\tws = ep_wakeup_source(epi);\n\t\tif (ws) {\n\t\t\tif (ws->active)\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t__pm_relax(ws);\n\t\t}\n\n\t\tlist_del_init(&epi->rdllink);\n\n\t\trevents = ep_item_poll(epi, &pt, 1);\n\n\t\t/*\n\t\t * If the event mask intersect the caller-requested one,\n\t\t * deliver the event to userspace. Again, ep_scan_ready_list()\n\t\t * is holding \"mtx\", so no operations coming from userspace\n\t\t * can change the item.\n\t\t */\n\t\tif (revents) {\n\t\t\tif (__put_user(revents, &uevent->events) ||\n\t\t\t    __put_user(epi->event.data, &uevent->data)) {\n\t\t\t\tlist_add(&epi->rdllink, head);\n\t\t\t\tep_pm_stay_awake(epi);\n\t\t\t\tif (!esed->res)\n\t\t\t\t\tesed->res = -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tesed->res++;\n\t\t\tuevent++;\n\t\t\tif (epi->event.events & EPOLLONESHOT)\n\t\t\t\tepi->event.events &= EP_PRIVATE_BITS;\n\t\t\telse if (!(epi->event.events & EPOLLET)) {\n\t\t\t\t/*\n\t\t\t\t * If this file has been added with Level\n\t\t\t\t * Trigger mode, we need to insert back inside\n\t\t\t\t * the ready list, so that the next call to\n\t\t\t\t * epoll_wait() will check again the events\n\t\t\t\t * availability. At this point, no one can insert\n\t\t\t\t * into ep->rdllist besides us. The epoll_ctl()\n\t\t\t\t * callers are locked out by\n\t\t\t\t * ep_scan_ready_list() holding \"mtx\" and the\n\t\t\t\t * poll callback will queue them in ep->ovflist.\n\t\t\t\t */\n\t\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\t\tep_pm_stay_awake(epi);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET | EPOLLEXCLUSIVE)"
    ],
    "globals_used": [
      "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);",
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_pm_stay_awake",
          "args": [
            "epi"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "648-657",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&epi->rdllink",
            "head"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "epi->event.data",
            "&uevent->data"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "revents",
            "&uevent->events"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_item_poll",
          "args": [
            "epi",
            "&pt",
            "1"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "884-901",
          "snippet": "static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "ws"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "ep->ws"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "628-631",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structepitem",
            "rdllink"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&pt",
            "NULL"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET | EPOLLEXCLUSIVE)\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic __poll_t ep_send_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct ep_send_events_data *esed = priv;\n\t__poll_t revents;\n\tstruct epitem *epi;\n\tstruct epoll_event __user *uevent;\n\tstruct wakeup_source *ws;\n\tpoll_table pt;\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\t/*\n\t * We can loop without lock because we are passed a task private list.\n\t * Items cannot vanish during the loop because ep_scan_ready_list() is\n\t * holding \"mtx\" during this call.\n\t */\n\tfor (esed->res = 0, uevent = esed->events;\n\t     !list_empty(head) && esed->res < esed->maxevents;) {\n\t\tepi = list_first_entry(head, struct epitem, rdllink);\n\n\t\t/*\n\t\t * Activate ep->ws before deactivating epi->ws to prevent\n\t\t * triggering auto-suspend here (in case we reactive epi->ws\n\t\t * below).\n\t\t *\n\t\t * This could be rearranged to delay the deactivation of epi->ws\n\t\t * instead, but then epi->ws would temporarily be out of sync\n\t\t * with ep_is_linked().\n\t\t */\n\t\tws = ep_wakeup_source(epi);\n\t\tif (ws) {\n\t\t\tif (ws->active)\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t__pm_relax(ws);\n\t\t}\n\n\t\tlist_del_init(&epi->rdllink);\n\n\t\trevents = ep_item_poll(epi, &pt, 1);\n\n\t\t/*\n\t\t * If the event mask intersect the caller-requested one,\n\t\t * deliver the event to userspace. Again, ep_scan_ready_list()\n\t\t * is holding \"mtx\", so no operations coming from userspace\n\t\t * can change the item.\n\t\t */\n\t\tif (revents) {\n\t\t\tif (__put_user(revents, &uevent->events) ||\n\t\t\t    __put_user(epi->event.data, &uevent->data)) {\n\t\t\t\tlist_add(&epi->rdllink, head);\n\t\t\t\tep_pm_stay_awake(epi);\n\t\t\t\tif (!esed->res)\n\t\t\t\t\tesed->res = -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tesed->res++;\n\t\t\tuevent++;\n\t\t\tif (epi->event.events & EPOLLONESHOT)\n\t\t\t\tepi->event.events &= EP_PRIVATE_BITS;\n\t\t\telse if (!(epi->event.events & EPOLLET)) {\n\t\t\t\t/*\n\t\t\t\t * If this file has been added with Level\n\t\t\t\t * Trigger mode, we need to insert back inside\n\t\t\t\t * the ready list, so that the next call to\n\t\t\t\t * epoll_wait() will check again the events\n\t\t\t\t * availability. At this point, no one can insert\n\t\t\t\t * into ep->rdllist besides us. The epoll_ctl()\n\t\t\t\t * callers are locked out by\n\t\t\t\t * ep_scan_ready_list() holding \"mtx\" and the\n\t\t\t\t * poll callback will queue them in ep->ovflist.\n\t\t\t\t */\n\t\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\t\tep_pm_stay_awake(epi);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_modify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1552-1622",
    "snippet": "static int ep_modify(struct eventpoll *ep, struct epitem *epi,\n\t\t     const struct epoll_event *event)\n{\n\tint pwake = 0;\n\tpoll_table pt;\n\n\tlockdep_assert_irqs_enabled();\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\t/*\n\t * Set the new event interest mask before calling f_op->poll();\n\t * otherwise we might miss an event that happens between the\n\t * f_op->poll() call and the new event set registering.\n\t */\n\tepi->event.events = event->events; /* need barrier below */\n\tepi->event.data = event->data; /* protected by mtx */\n\tif (epi->event.events & EPOLLWAKEUP) {\n\t\tif (!ep_has_wakeup_source(epi))\n\t\t\tep_create_wakeup_source(epi);\n\t} else if (ep_has_wakeup_source(epi)) {\n\t\tep_destroy_wakeup_source(epi);\n\t}\n\n\t/*\n\t * The following barrier has two effects:\n\t *\n\t * 1) Flush epi changes above to other CPUs.  This ensures\n\t *    we do not miss events from ep_poll_callback if an\n\t *    event occurs immediately after we call f_op->poll().\n\t *    We need this because we did not take ep->wq.lock while\n\t *    changing epi above (but ep_poll_callback does take\n\t *    ep->wq.lock).\n\t *\n\t * 2) We also need to ensure we do not miss _past_ events\n\t *    when calling f_op->poll().  This barrier also\n\t *    pairs with the barrier in wq_has_sleeper (see\n\t *    comments for wq_has_sleeper).\n\t *\n\t * This barrier will now guarantee ep_poll_callback or f_op->poll\n\t * (or both) will notice the readiness of an item.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Get current event bits. We can safely use the file* here because\n\t * its usage count has been increased by the caller of this function.\n\t * If the item is \"hot\" and it is not registered inside the ready\n\t * list, push it inside.\n\t */\n\tif (ep_item_poll(epi, &pt, 1)) {\n\t\tspin_lock_irq(&ep->wq.lock);\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\n\t\t\t/* Notify waiting tasks that events are available */\n\t\t\tif (waitqueue_active(&ep->wq))\n\t\t\t\twake_up_locked(&ep->wq);\n\t\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\t\tpwake++;\n\t\t}\n\t\tspin_unlock_irq(&ep->wq.lock);\n\t}\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "584-587",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ep->wq"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->wq"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pm_stay_awake",
          "args": [
            "epi"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "648-657",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "epi"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "339-342",
          "snippet": "static inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_item_poll",
          "args": [
            "epi",
            "&pt",
            "1"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "884-901",
          "snippet": "static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_destroy_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "ep_destroy_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1401-1414",
          "snippet": "static noinline void ep_destroy_wakeup_source(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tRCU_INIT_POINTER(epi->ws, NULL);\n\n\t/*\n\t * wait for ep_pm_stay_awake_rcu to finish, synchronize_rcu is\n\t * used internally by wakeup_source_remove, too (called by\n\t * wakeup_source_unregister), so we cannot use call_rcu\n\t */\n\tsynchronize_rcu();\n\twakeup_source_unregister(ws);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic noinline void ep_destroy_wakeup_source(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tRCU_INIT_POINTER(epi->ws, NULL);\n\n\t/*\n\t * wait for ep_pm_stay_awake_rcu to finish, synchronize_rcu is\n\t * used internally by wakeup_source_remove, too (called by\n\t * wakeup_source_unregister), so we cannot use call_rcu\n\t */\n\tsynchronize_rcu();\n\twakeup_source_unregister(ws);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_has_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "ep_has_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "642-645",
          "snippet": "static inline bool ep_has_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_access_pointer(epi->ws) ? true : false;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline bool ep_has_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_access_pointer(epi->ws) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_create_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "ep_create_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1379-1398",
          "snippet": "static int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&pt",
            "NULL"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic int ep_modify(struct eventpoll *ep, struct epitem *epi,\n\t\t     const struct epoll_event *event)\n{\n\tint pwake = 0;\n\tpoll_table pt;\n\n\tlockdep_assert_irqs_enabled();\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\t/*\n\t * Set the new event interest mask before calling f_op->poll();\n\t * otherwise we might miss an event that happens between the\n\t * f_op->poll() call and the new event set registering.\n\t */\n\tepi->event.events = event->events; /* need barrier below */\n\tepi->event.data = event->data; /* protected by mtx */\n\tif (epi->event.events & EPOLLWAKEUP) {\n\t\tif (!ep_has_wakeup_source(epi))\n\t\t\tep_create_wakeup_source(epi);\n\t} else if (ep_has_wakeup_source(epi)) {\n\t\tep_destroy_wakeup_source(epi);\n\t}\n\n\t/*\n\t * The following barrier has two effects:\n\t *\n\t * 1) Flush epi changes above to other CPUs.  This ensures\n\t *    we do not miss events from ep_poll_callback if an\n\t *    event occurs immediately after we call f_op->poll().\n\t *    We need this because we did not take ep->wq.lock while\n\t *    changing epi above (but ep_poll_callback does take\n\t *    ep->wq.lock).\n\t *\n\t * 2) We also need to ensure we do not miss _past_ events\n\t *    when calling f_op->poll().  This barrier also\n\t *    pairs with the barrier in wq_has_sleeper (see\n\t *    comments for wq_has_sleeper).\n\t *\n\t * This barrier will now guarantee ep_poll_callback or f_op->poll\n\t * (or both) will notice the readiness of an item.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Get current event bits. We can safely use the file* here because\n\t * its usage count has been increased by the caller of this function.\n\t * If the item is \"hot\" and it is not registered inside the ready\n\t * list, push it inside.\n\t */\n\tif (ep_item_poll(epi, &pt, 1)) {\n\t\tspin_lock_irq(&ep->wq.lock);\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\n\t\t\t/* Notify waiting tasks that events are available */\n\t\t\tif (waitqueue_active(&ep->wq))\n\t\t\t\twake_up_locked(&ep->wq);\n\t\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\t\tpwake++;\n\t\t}\n\t\tspin_unlock_irq(&ep->wq.lock);\n\t}\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1419-1546",
    "snippet": "static int ep_insert(struct eventpoll *ep, const struct epoll_event *event,\n\t\t     struct file *tfile, int fd, int full_check)\n{\n\tint error, pwake = 0;\n\t__poll_t revents;\n\tlong user_watches;\n\tstruct epitem *epi;\n\tstruct ep_pqueue epq;\n\n\tlockdep_assert_irqs_enabled();\n\n\tuser_watches = atomic_long_read(&ep->user->epoll_watches);\n\tif (unlikely(user_watches >= max_user_watches))\n\t\treturn -ENOSPC;\n\tif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t/* Item initialization follow here ... */\n\tINIT_LIST_HEAD(&epi->rdllink);\n\tINIT_LIST_HEAD(&epi->fllink);\n\tINIT_LIST_HEAD(&epi->pwqlist);\n\tepi->ep = ep;\n\tep_set_ffd(&epi->ffd, tfile, fd);\n\tepi->event = *event;\n\tepi->nwait = 0;\n\tepi->next = EP_UNACTIVE_PTR;\n\tif (epi->event.events & EPOLLWAKEUP) {\n\t\terror = ep_create_wakeup_source(epi);\n\t\tif (error)\n\t\t\tgoto error_create_wakeup_source;\n\t} else {\n\t\tRCU_INIT_POINTER(epi->ws, NULL);\n\t}\n\n\t/* Initialize the poll table using the queue callback */\n\tepq.epi = epi;\n\tinit_poll_funcptr(&epq.pt, ep_ptable_queue_proc);\n\n\t/*\n\t * Attach the item to the poll hooks and get current event bits.\n\t * We can safely use the file* here because its usage count has\n\t * been increased by the caller of this function. Note that after\n\t * this operation completes, the poll callback can start hitting\n\t * the new item.\n\t */\n\trevents = ep_item_poll(epi, &epq.pt, 1);\n\n\t/*\n\t * We have to check if something went wrong during the poll wait queue\n\t * install process. Namely an allocation for a wait queue failed due\n\t * high memory pressure.\n\t */\n\terror = -ENOMEM;\n\tif (epi->nwait < 0)\n\t\tgoto error_unregister;\n\n\t/* Add the current item to the list of active epoll hook for this file */\n\tspin_lock(&tfile->f_lock);\n\tlist_add_tail_rcu(&epi->fllink, &tfile->f_ep_links);\n\tspin_unlock(&tfile->f_lock);\n\n\t/*\n\t * Add the current item to the RB tree. All RB tree operations are\n\t * protected by \"mtx\", and ep_insert() is called with \"mtx\" held.\n\t */\n\tep_rbtree_insert(ep, epi);\n\n\t/* now check if we've created too many backpaths */\n\terror = -EINVAL;\n\tif (full_check && reverse_path_check())\n\t\tgoto error_remove_epi;\n\n\t/* We have to drop the new item inside our item list to keep track of it */\n\tspin_lock_irq(&ep->wq.lock);\n\n\t/* record NAPI ID of new item if present */\n\tep_set_busy_poll_napi_id(epi);\n\n\t/* If the file is already \"ready\" we drop it inside the ready list */\n\tif (revents && !ep_is_linked(epi)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake(epi);\n\n\t\t/* Notify waiting tasks that events are available */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tatomic_long_inc(&ep->user->epoll_watches);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n\nerror_remove_epi:\n\tspin_lock(&tfile->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&tfile->f_lock);\n\n\trb_erase_cached(&epi->rbn, &ep->rbr);\n\nerror_unregister:\n\tep_unregister_pollwait(ep, epi);\n\n\t/*\n\t * We need to do this because an event could have been arrived on some\n\t * allocated wait queue. Note that we don't care about the ep->ovflist\n\t * list, since that is used/cleaned only inside a section bound by \"mtx\".\n\t * And ep_insert() is called with \"mtx\" held.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tif (ep_is_linked(epi))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irq(&ep->wq.lock);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\nerror_create_wakeup_source:\n\tkmem_cache_free(epi_cache, epi);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)"
    ],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "epi_cache",
            "epi"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "ep_wakeup_source(epi)"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "628-631",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "epi"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "339-342",
          "snippet": "static inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_unregister_pollwait",
          "args": [
            "ep",
            "epi"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "ep_unregister_pollwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "613-625",
          "snippet": "static void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase_cached",
          "args": [
            "&epi->rbn",
            "&ep->rbr"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tfile->f_lock"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&epi->fllink"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tfile->f_lock"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "584-587",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&ep->user->epoll_watches"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ep->wq"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->wq"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pm_stay_awake",
          "args": [
            "epi"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "648-657",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_set_busy_poll_napi_id",
          "args": [
            "epi"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_busy_poll_napi_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "461-463",
          "snippet": "static inline void ep_set_busy_poll_napi_id(struct epitem *epi)\n{\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_busy_poll_napi_id(struct epitem *epi)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reverse_path_check",
          "args": [],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_path_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1362-1377",
          "snippet": "static int reverse_path_check(void)\n{\n\tint error = 0;\n\tstruct file *current_file;\n\n\t/* let's call this for all tfiles */\n\tlist_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {\n\t\tpath_count_init();\n\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\treverse_path_check_proc, current_file,\n\t\t\t\t\tcurrent_file, current);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_MAX_NESTS 4"
          ],
          "globals_used": [
            "static struct nested_calls poll_loop_ncalls;",
            "static LIST_HEAD(tfile_check_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic LIST_HEAD(tfile_check_list);\n\nstatic int reverse_path_check(void)\n{\n\tint error = 0;\n\tstruct file *current_file;\n\n\t/* let's call this for all tfiles */\n\tlist_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {\n\t\tpath_count_init();\n\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\treverse_path_check_proc, current_file,\n\t\t\t\t\tcurrent_file, current);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_rbtree_insert",
          "args": [
            "ep",
            "epi"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "ep_rbtree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1260-1279",
          "snippet": "static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_root.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\tbool leftmost = true;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0) {\n\t\t\tp = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t} else\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color_cached(&epi->rbn, &ep->rbr, leftmost);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_root.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\tbool leftmost = true;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0) {\n\t\t\tp = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t} else\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color_cached(&epi->rbn, &ep->rbr, leftmost);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&epi->fllink",
            "&tfile->f_ep_links"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_item_poll",
          "args": [
            "epi",
            "&epq.pt",
            "1"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "884-901",
          "snippet": "static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&epq.pt",
            "ep_ptable_queue_proc"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "epi->ws",
            "NULL"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_create_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "ep_create_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1379-1398",
          "snippet": "static int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_set_ffd",
          "args": [
            "&epi->ffd",
            "tfile",
            "fd"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_ffd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "323-328",
          "snippet": "static inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&epi->pwqlist"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&epi->fllink"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "epi_cache",
            "GFP_KERNEL"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "user_watches >= max_user_watches"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&ep->user->epoll_watches"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic int ep_insert(struct eventpoll *ep, const struct epoll_event *event,\n\t\t     struct file *tfile, int fd, int full_check)\n{\n\tint error, pwake = 0;\n\t__poll_t revents;\n\tlong user_watches;\n\tstruct epitem *epi;\n\tstruct ep_pqueue epq;\n\n\tlockdep_assert_irqs_enabled();\n\n\tuser_watches = atomic_long_read(&ep->user->epoll_watches);\n\tif (unlikely(user_watches >= max_user_watches))\n\t\treturn -ENOSPC;\n\tif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t/* Item initialization follow here ... */\n\tINIT_LIST_HEAD(&epi->rdllink);\n\tINIT_LIST_HEAD(&epi->fllink);\n\tINIT_LIST_HEAD(&epi->pwqlist);\n\tepi->ep = ep;\n\tep_set_ffd(&epi->ffd, tfile, fd);\n\tepi->event = *event;\n\tepi->nwait = 0;\n\tepi->next = EP_UNACTIVE_PTR;\n\tif (epi->event.events & EPOLLWAKEUP) {\n\t\terror = ep_create_wakeup_source(epi);\n\t\tif (error)\n\t\t\tgoto error_create_wakeup_source;\n\t} else {\n\t\tRCU_INIT_POINTER(epi->ws, NULL);\n\t}\n\n\t/* Initialize the poll table using the queue callback */\n\tepq.epi = epi;\n\tinit_poll_funcptr(&epq.pt, ep_ptable_queue_proc);\n\n\t/*\n\t * Attach the item to the poll hooks and get current event bits.\n\t * We can safely use the file* here because its usage count has\n\t * been increased by the caller of this function. Note that after\n\t * this operation completes, the poll callback can start hitting\n\t * the new item.\n\t */\n\trevents = ep_item_poll(epi, &epq.pt, 1);\n\n\t/*\n\t * We have to check if something went wrong during the poll wait queue\n\t * install process. Namely an allocation for a wait queue failed due\n\t * high memory pressure.\n\t */\n\terror = -ENOMEM;\n\tif (epi->nwait < 0)\n\t\tgoto error_unregister;\n\n\t/* Add the current item to the list of active epoll hook for this file */\n\tspin_lock(&tfile->f_lock);\n\tlist_add_tail_rcu(&epi->fllink, &tfile->f_ep_links);\n\tspin_unlock(&tfile->f_lock);\n\n\t/*\n\t * Add the current item to the RB tree. All RB tree operations are\n\t * protected by \"mtx\", and ep_insert() is called with \"mtx\" held.\n\t */\n\tep_rbtree_insert(ep, epi);\n\n\t/* now check if we've created too many backpaths */\n\terror = -EINVAL;\n\tif (full_check && reverse_path_check())\n\t\tgoto error_remove_epi;\n\n\t/* We have to drop the new item inside our item list to keep track of it */\n\tspin_lock_irq(&ep->wq.lock);\n\n\t/* record NAPI ID of new item if present */\n\tep_set_busy_poll_napi_id(epi);\n\n\t/* If the file is already \"ready\" we drop it inside the ready list */\n\tif (revents && !ep_is_linked(epi)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake(epi);\n\n\t\t/* Notify waiting tasks that events are available */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tatomic_long_inc(&ep->user->epoll_watches);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n\nerror_remove_epi:\n\tspin_lock(&tfile->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&tfile->f_lock);\n\n\trb_erase_cached(&epi->rbn, &ep->rbr);\n\nerror_unregister:\n\tep_unregister_pollwait(ep, epi);\n\n\t/*\n\t * We need to do this because an event could have been arrived on some\n\t * allocated wait queue. Note that we don't care about the ep->ovflist\n\t * list, since that is used/cleaned only inside a section bound by \"mtx\".\n\t * And ep_insert() is called with \"mtx\" held.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tif (ep_is_linked(epi))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irq(&ep->wq.lock);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\nerror_create_wakeup_source:\n\tkmem_cache_free(epi_cache, epi);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ep_destroy_wakeup_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1401-1414",
    "snippet": "static noinline void ep_destroy_wakeup_source(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tRCU_INIT_POINTER(epi->ws, NULL);\n\n\t/*\n\t * wait for ep_pm_stay_awake_rcu to finish, synchronize_rcu is\n\t * used internally by wakeup_source_remove, too (called by\n\t * wakeup_source_unregister), so we cannot use call_rcu\n\t */\n\tsynchronize_rcu();\n\twakeup_source_unregister(ws);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "ws"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "epi->ws",
            "NULL"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "628-631",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic noinline void ep_destroy_wakeup_source(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tRCU_INIT_POINTER(epi->ws, NULL);\n\n\t/*\n\t * wait for ep_pm_stay_awake_rcu to finish, synchronize_rcu is\n\t * used internally by wakeup_source_remove, too (called by\n\t * wakeup_source_unregister), so we cannot use call_rcu\n\t */\n\tsynchronize_rcu();\n\twakeup_source_unregister(ws);\n}"
  },
  {
    "function_name": "ep_create_wakeup_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1379-1398",
    "snippet": "static int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "epi->ws",
            "ws"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_register",
          "args": [
            "name"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_register",
          "args": [
            "\"eventpoll\""
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reverse_path_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1362-1377",
    "snippet": "static int reverse_path_check(void)\n{\n\tint error = 0;\n\tstruct file *current_file;\n\n\t/* let's call this for all tfiles */\n\tlist_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {\n\t\tpath_count_init();\n\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\treverse_path_check_proc, current_file,\n\t\t\t\t\tcurrent_file, current);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;",
      "static LIST_HEAD(tfile_check_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_loop_ncalls",
            "EP_MAX_NESTS",
            "reverse_path_check_proc",
            "current_file",
            "current_file",
            "current"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "483-529",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_count_init",
          "args": [],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "path_count_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1309-1315",
          "snippet": "static void path_count_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PATH_ARR_SIZE; i++)\n\t\tpath_count[i] = 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define PATH_ARR_SIZE 5"
          ],
          "globals_used": [
            "static int path_count[PATH_ARR_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define PATH_ARR_SIZE 5\n\nstatic int path_count[PATH_ARR_SIZE];\n\nstatic void path_count_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PATH_ARR_SIZE; i++)\n\t\tpath_count[i] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "current_file",
            "&tfile_check_list",
            "f_tfile_llink"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic LIST_HEAD(tfile_check_list);\n\nstatic int reverse_path_check(void)\n{\n\tint error = 0;\n\tstruct file *current_file;\n\n\t/* let's call this for all tfiles */\n\tlist_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {\n\t\tpath_count_init();\n\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\treverse_path_check_proc, current_file,\n\t\t\t\t\tcurrent_file, current);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "reverse_path_check_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1317-1350",
    "snippet": "static int reverse_path_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct file *child_file;\n\tstruct epitem *epi;\n\n\t/* CTL_DEL can remove links here, but that can't increase our count */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(epi, &file->f_ep_links, fllink) {\n\t\tchild_file = epi->ep->file;\n\t\tif (is_file_epoll(child_file)) {\n\t\t\tif (list_empty(&child_file->f_ep_links)) {\n\t\t\t\tif (path_count_inc(call_nests)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\t\t\tEP_MAX_NESTS,\n\t\t\t\t\t\t\treverse_path_check_proc,\n\t\t\t\t\t\t\tchild_file, child_file,\n\t\t\t\t\t\t\tcurrent);\n\t\t\t}\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"reverse_path_check_proc: \"\n\t\t\t\t\"file is not an ep!\\n\");\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;",
      "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"reverse_path_check_proc: \"\n\t\t\t\t\"file is not an ep!\\n\""
          ],
          "line": 1344
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_loop_ncalls",
            "EP_MAX_NESTS",
            "reverse_path_check_proc",
            "child_file",
            "child_file",
            "current"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "483-529",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_count_inc",
          "args": [
            "call_nests"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "path_count_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1298-1307",
          "snippet": "static int path_count_inc(int nests)\n{\n\t/* Allow an arbitrary number of depth 1 paths */\n\tif (nests == 0)\n\t\treturn 0;\n\n\tif (++path_count[nests] > path_limits[nests])\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };",
            "static int path_count[PATH_ARR_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };\nstatic int path_count[PATH_ARR_SIZE];\n\nstatic int path_count_inc(int nests)\n{\n\t/* Allow an arbitrary number of depth 1 paths */\n\tif (nests == 0)\n\t\treturn 0;\n\n\tif (++path_count[nests] > path_limits[nests])\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child_file->f_ep_links"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_file_epoll",
          "args": [
            "child_file"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "is_file_epoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "317-320",
          "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventpoll_fops;",
            "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "epi",
            "&file->f_ep_links",
            "fllink"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int reverse_path_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct file *child_file;\n\tstruct epitem *epi;\n\n\t/* CTL_DEL can remove links here, but that can't increase our count */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(epi, &file->f_ep_links, fllink) {\n\t\tchild_file = epi->ep->file;\n\t\tif (is_file_epoll(child_file)) {\n\t\t\tif (list_empty(&child_file->f_ep_links)) {\n\t\t\t\tif (path_count_inc(call_nests)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\t\t\tEP_MAX_NESTS,\n\t\t\t\t\t\t\treverse_path_check_proc,\n\t\t\t\t\t\t\tchild_file, child_file,\n\t\t\t\t\t\t\tcurrent);\n\t\t\t}\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"reverse_path_check_proc: \"\n\t\t\t\t\"file is not an ep!\\n\");\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn error;\n}"
  },
  {
    "function_name": "path_count_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1309-1315",
    "snippet": "static void path_count_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PATH_ARR_SIZE; i++)\n\t\tpath_count[i] = 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define PATH_ARR_SIZE 5"
    ],
    "globals_used": [
      "static int path_count[PATH_ARR_SIZE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define PATH_ARR_SIZE 5\n\nstatic int path_count[PATH_ARR_SIZE];\n\nstatic void path_count_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PATH_ARR_SIZE; i++)\n\t\tpath_count[i] = 0;\n}"
  },
  {
    "function_name": "path_count_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1298-1307",
    "snippet": "static int path_count_inc(int nests)\n{\n\t/* Allow an arbitrary number of depth 1 paths */\n\tif (nests == 0)\n\t\treturn 0;\n\n\tif (++path_count[nests] > path_limits[nests])\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };",
      "static int path_count[PATH_ARR_SIZE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };\nstatic int path_count[PATH_ARR_SIZE];\n\nstatic int path_count_inc(int nests)\n{\n\t/* Allow an arbitrary number of depth 1 paths */\n\tif (nests == 0)\n\t\treturn 0;\n\n\tif (++path_count[nests] > path_limits[nests])\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_rbtree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1260-1279",
    "snippet": "static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_root.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\tbool leftmost = true;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0) {\n\t\t\tp = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t} else\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color_cached(&epi->rbn, &ep->rbr, leftmost);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color_cached",
          "args": [
            "&epi->rbn",
            "&ep->rbr",
            "leftmost"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&epi->rbn",
            "parent",
            "p"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_cmp_ffd",
          "args": [
            "&epi->ffd",
            "&epic->ffd"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "ep_cmp_ffd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "331-336",
          "snippet": "static inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structepitem",
            "rbn"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_root.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\tbool leftmost = true;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0) {\n\t\t\tp = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t} else\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color_cached(&epi->rbn, &ep->rbr, leftmost);\n}"
  },
  {
    "function_name": "ep_ptable_queue_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1238-1258",
    "snippet": "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tif (epi->event.events & EPOLLEXCLUSIVE)\n\t\t\tadd_wait_queue_exclusive(whead, &pwq->wait);\n\t\telse\n\t\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\t/* We have to signal that an error occurred */\n\t\tepi->nwait = -1;\n\t}\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pwq->llink",
            "&epi->pwqlist"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "whead",
            "&pwq->wait"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue_exclusive",
          "args": [
            "whead",
            "&pwq->wait"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&pwq->wait",
            "ep_poll_callback"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "pwq_cache",
            "GFP_KERNEL"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/f2fs/f2fs.h",
          "lines": "2114-2123",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}",
          "includes": [
            "#include <linux/fscrypt.h>",
            "#include <crypto/hash.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/cred.h>",
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>",
            "#include <linux/uio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fscrypt.h>\n#include <crypto/hash.h>\n#include <linux/quotaops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/cred.h>\n#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n#include <linux/uio.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\n\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry)\n\t\tentry = kmem_cache_alloc(cachep, flags | __GFP_NOFAIL);\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_item_from_epqueue",
          "args": [
            "pt"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_from_epqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "356-359",
          "snippet": "static inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tif (epi->event.events & EPOLLEXCLUSIVE)\n\t\t\tadd_wait_queue_exclusive(whead, &pwq->wait);\n\t\telse\n\t\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\t/* We have to signal that an error occurred */\n\t\tepi->nwait = -1;\n\t}\n}"
  },
  {
    "function_name": "ep_poll_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1120-1232",
    "snippet": "static int ep_poll_callback(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\t__poll_t pollflags = key_to_poll(key);\n\tint ewake = 0;\n\n\tspin_lock_irqsave(&ep->wq.lock, flags);\n\n\tep_set_busy_poll_napi_id(epi);\n\n\t/*\n\t * If the event mask does not contain any poll(2) event, we consider the\n\t * descriptor to be disabled. This condition is likely the effect of the\n\t * EPOLLONESHOT bit that disables the descriptor when an event is received,\n\t * until the next EPOLL_CTL_MOD will be issued.\n\t */\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the events coming with the callback. At this stage, not\n\t * every device reports the events in the \"key\" parameter of the\n\t * callback. We need to be able to handle both cases here, hence the\n\t * test for \"key\" != NULL before the event match test.\n\t */\n\tif (pollflags && !(pollflags & epi->event.events))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If we are transferring events to userspace, we can hold no locks\n\t * (because we're accessing user memory, and because of linux f_op->poll()\n\t * semantics). All the events that happen during that period of time are\n\t * chained in ep->ovflist and requeued later on.\n\t */\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t\tif (epi->ws) {\n\t\t\t\t/*\n\t\t\t\t * Activate ep->ws since epi->ws may get\n\t\t\t\t * deactivated at any time.\n\t\t\t\t */\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t}\n\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\t/* If this file is already in the ready list we exit soon */\n\tif (!ep_is_linked(epi)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake_rcu(epi);\n\t}\n\n\t/*\n\t * Wake up ( if active ) both the eventpoll wait list and the ->poll()\n\t * wait list.\n\t */\n\tif (waitqueue_active(&ep->wq)) {\n\t\tif ((epi->event.events & EPOLLEXCLUSIVE) &&\n\t\t\t\t\t!(pollflags & POLLFREE)) {\n\t\t\tswitch (pollflags & EPOLLINOUT_BITS) {\n\t\t\tcase EPOLLIN:\n\t\t\t\tif (epi->event.events & EPOLLIN)\n\t\t\t\t\tewake = 1;\n\t\t\t\tbreak;\n\t\t\tcase EPOLLOUT:\n\t\t\t\tif (epi->event.events & EPOLLOUT)\n\t\t\t\t\tewake = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tewake = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twake_up_locked(&ep->wq);\n\t}\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->wq.lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\tif (!(epi->event.events & EPOLLEXCLUSIVE))\n\t\tewake = 1;\n\n\tif (pollflags & POLLFREE) {\n\t\t/*\n\t\t * If we race with ep_remove_wait_queue() it can miss\n\t\t * ->whead = NULL and do another remove_wait_queue() after\n\t\t * us, so we can't use __remove_wait_queue().\n\t\t */\n\t\tlist_del_init(&wait->entry);\n\t\t/*\n\t\t * ->whead != NULL protects us from the race with ep_free()\n\t\t * or ep_remove(), ep_remove_wait_queue() takes whead->lock\n\t\t * held by the caller. Once we nullify it, nothing protects\n\t\t * ep/epi or even wait.\n\t\t */\n\t\tsmp_store_release(&ep_pwq_from_wait(wait)->whead, NULL);\n\t}\n\n\treturn ewake;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)",
      "#define EPOLLINOUT_BITS (EPOLLIN | EPOLLOUT)",
      "#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET | EPOLLEXCLUSIVE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&ep_pwq_from_wait(wait)->whead",
            "NULL"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pwq_from_wait",
          "args": [
            "wait"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pwq_from_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "344-347",
          "snippet": "static inline struct eppoll_entry *ep_pwq_from_wait(wait_queue_entry_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct eppoll_entry *ep_pwq_from_wait(wait_queue_entry_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wait->entry"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "584-587",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->wq.lock",
            "flags"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ep->wq"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->wq"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pm_stay_awake_rcu",
          "args": [
            "epi"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "648-657",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "epi"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "339-342",
          "snippet": "static inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "ep->ws"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ep->ovflist != EP_UNACTIVE_PTR"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_set_busy_poll_napi_id",
          "args": [
            "epi"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_busy_poll_napi_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "461-463",
          "snippet": "static inline void ep_set_busy_poll_napi_id(struct epitem *epi)\n{\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_busy_poll_napi_id(struct epitem *epi)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->wq.lock",
            "flags"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_to_poll",
          "args": [
            "key"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_item_from_wait",
          "args": [
            "wait"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_from_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "350-353",
          "snippet": "static inline struct epitem *ep_item_from_wait(wait_queue_entry_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct epitem *ep_item_from_wait(wait_queue_entry_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n#define EPOLLINOUT_BITS (EPOLLIN | EPOLLOUT)\n#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET | EPOLLEXCLUSIVE)\n\nstatic int ep_poll_callback(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\t__poll_t pollflags = key_to_poll(key);\n\tint ewake = 0;\n\n\tspin_lock_irqsave(&ep->wq.lock, flags);\n\n\tep_set_busy_poll_napi_id(epi);\n\n\t/*\n\t * If the event mask does not contain any poll(2) event, we consider the\n\t * descriptor to be disabled. This condition is likely the effect of the\n\t * EPOLLONESHOT bit that disables the descriptor when an event is received,\n\t * until the next EPOLL_CTL_MOD will be issued.\n\t */\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the events coming with the callback. At this stage, not\n\t * every device reports the events in the \"key\" parameter of the\n\t * callback. We need to be able to handle both cases here, hence the\n\t * test for \"key\" != NULL before the event match test.\n\t */\n\tif (pollflags && !(pollflags & epi->event.events))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If we are transferring events to userspace, we can hold no locks\n\t * (because we're accessing user memory, and because of linux f_op->poll()\n\t * semantics). All the events that happen during that period of time are\n\t * chained in ep->ovflist and requeued later on.\n\t */\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t\tif (epi->ws) {\n\t\t\t\t/*\n\t\t\t\t * Activate ep->ws since epi->ws may get\n\t\t\t\t * deactivated at any time.\n\t\t\t\t */\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t}\n\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\t/* If this file is already in the ready list we exit soon */\n\tif (!ep_is_linked(epi)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake_rcu(epi);\n\t}\n\n\t/*\n\t * Wake up ( if active ) both the eventpoll wait list and the ->poll()\n\t * wait list.\n\t */\n\tif (waitqueue_active(&ep->wq)) {\n\t\tif ((epi->event.events & EPOLLEXCLUSIVE) &&\n\t\t\t\t\t!(pollflags & POLLFREE)) {\n\t\t\tswitch (pollflags & EPOLLINOUT_BITS) {\n\t\t\tcase EPOLLIN:\n\t\t\t\tif (epi->event.events & EPOLLIN)\n\t\t\t\t\tewake = 1;\n\t\t\t\tbreak;\n\t\t\tcase EPOLLOUT:\n\t\t\t\tif (epi->event.events & EPOLLOUT)\n\t\t\t\t\tewake = 1;\n\t\t\t\tbreak;\n\t\t\tcase 0:\n\t\t\t\tewake = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twake_up_locked(&ep->wq);\n\t}\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->wq.lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\tif (!(epi->event.events & EPOLLEXCLUSIVE))\n\t\tewake = 1;\n\n\tif (pollflags & POLLFREE) {\n\t\t/*\n\t\t * If we race with ep_remove_wait_queue() it can miss\n\t\t * ->whead = NULL and do another remove_wait_queue() after\n\t\t * us, so we can't use __remove_wait_queue().\n\t\t */\n\t\tlist_del_init(&wait->entry);\n\t\t/*\n\t\t * ->whead != NULL protects us from the race with ep_free()\n\t\t * or ep_remove(), ep_remove_wait_queue() takes whead->lock\n\t\t * held by the caller. Once we nullify it, nothing protects\n\t\t * ep/epi or even wait.\n\t\t */\n\t\tsmp_store_release(&ep_pwq_from_wait(wait)->whead, NULL);\n\t}\n\n\treturn ewake;\n}"
  },
  {
    "function_name": "get_epoll_tfile_raw_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1091-1112",
    "snippet": "struct file *get_epoll_tfile_raw_ptr(struct file *file, int tfd,\n\t\t\t\t     unsigned long toff)\n{\n\tstruct file *file_raw;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\n\tif (!is_file_epoll(file))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tep = file->private_data;\n\n\tmutex_lock(&ep->mtx);\n\tepi = ep_find_tfd(ep, tfd, toff);\n\tif (epi)\n\t\tfile_raw = epi->ffd.file;\n\telse\n\t\tfile_raw = ERR_PTR(-ENOENT);\n\tmutex_unlock(&ep->mtx);\n\n\treturn file_raw;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_find_tfd",
          "args": [
            "ep",
            "tfd",
            "toff"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "ep_find_tfd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "1072-1089",
          "snippet": "static struct epitem *ep_find_tfd(struct eventpoll *ep, int tfd, unsigned long toff)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (epi->ffd.fd == tfd) {\n\t\t\tif (toff == 0)\n\t\t\t\treturn epi;\n\t\t\telse\n\t\t\t\ttoff--;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct epitem *ep_find_tfd(struct eventpoll *ep, int tfd, unsigned long toff)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (epi->ffd.fd == tfd) {\n\t\t\tif (toff == 0)\n\t\t\t\treturn epi;\n\t\t\telse\n\t\t\t\ttoff--;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ep->mtx"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_epoll",
          "args": [
            "file"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "is_file_epoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "317-320",
          "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventpoll_fops;",
            "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstruct file *get_epoll_tfile_raw_ptr(struct file *file, int tfd,\n\t\t\t\t     unsigned long toff)\n{\n\tstruct file *file_raw;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\n\tif (!is_file_epoll(file))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tep = file->private_data;\n\n\tmutex_lock(&ep->mtx);\n\tepi = ep_find_tfd(ep, tfd, toff);\n\tif (epi)\n\t\tfile_raw = epi->ffd.file;\n\telse\n\t\tfile_raw = ERR_PTR(-ENOENT);\n\tmutex_unlock(&ep->mtx);\n\n\treturn file_raw;\n}"
  },
  {
    "function_name": "ep_find_tfd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1072-1089",
    "snippet": "static struct epitem *ep_find_tfd(struct eventpoll *ep, int tfd, unsigned long toff)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (epi->ffd.fd == tfd) {\n\t\t\tif (toff == 0)\n\t\t\t\treturn epi;\n\t\t\telse\n\t\t\t\ttoff--;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rbp"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first_cached",
          "args": [
            "&ep->rbr"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct epitem *ep_find_tfd(struct eventpoll *ep, int tfd, unsigned long toff)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (epi->ffd.fd == tfd) {\n\t\t\tif (toff == 0)\n\t\t\t\treturn epi;\n\t\t\telse\n\t\t\t\ttoff--;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ep_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1047-1069",
    "snippet": "static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)\n{\n\tint kcmp;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi, *epir = NULL;\n\tstruct epoll_filefd ffd;\n\n\tep_set_ffd(&ffd, file, fd);\n\tfor (rbp = ep->rbr.rb_root.rb_node; rbp; ) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&ffd, &epi->ffd);\n\t\tif (kcmp > 0)\n\t\t\trbp = rbp->rb_right;\n\t\telse if (kcmp < 0)\n\t\t\trbp = rbp->rb_left;\n\t\telse {\n\t\t\tepir = epi;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn epir;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_cmp_ffd",
          "args": [
            "&ffd",
            "&epi->ffd"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "ep_cmp_ffd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "331-336",
          "snippet": "static inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_set_ffd",
          "args": [
            "&ffd",
            "file",
            "fd"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_ffd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "323-328",
          "snippet": "static inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)\n{\n\tint kcmp;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi, *epir = NULL;\n\tstruct epoll_filefd ffd;\n\n\tep_set_ffd(&ffd, file, fd);\n\tfor (rbp = ep->rbr.rb_root.rb_node; rbp; ) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&ffd, &epi->ffd);\n\t\tif (kcmp > 0)\n\t\t\trbp = rbp->rb_right;\n\t\telse if (kcmp < 0)\n\t\t\trbp = rbp->rb_left;\n\t\telse {\n\t\t\tepir = epi;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn epir;\n}"
  },
  {
    "function_name": "ep_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1013-1040",
    "snippet": "static int ep_alloc(struct eventpoll **pep)\n{\n\tint error;\n\tstruct user_struct *user;\n\tstruct eventpoll *ep;\n\n\tuser = get_current_user();\n\terror = -ENOMEM;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (unlikely(!ep))\n\t\tgoto free_uid;\n\n\tmutex_init(&ep->mtx);\n\tinit_waitqueue_head(&ep->wq);\n\tinit_waitqueue_head(&ep->poll_wait);\n\tINIT_LIST_HEAD(&ep->rdllist);\n\tep->rbr = RB_ROOT_CACHED;\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tep->user = user;\n\n\t*pep = ep;\n\n\treturn 0;\n\nfree_uid:\n\tfree_uid(user);\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ep->rdllist"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ep->wq"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ep->mtx"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ep"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ep)",
            "GFP_KERNEL"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_user",
          "args": [],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic int ep_alloc(struct eventpoll **pep)\n{\n\tint error;\n\tstruct user_struct *user;\n\tstruct eventpoll *ep;\n\n\tuser = get_current_user();\n\terror = -ENOMEM;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (unlikely(!ep))\n\t\tgoto free_uid;\n\n\tmutex_init(&ep->mtx);\n\tinit_waitqueue_head(&ep->wq);\n\tinit_waitqueue_head(&ep->poll_wait);\n\tINIT_LIST_HEAD(&ep->rdllist);\n\tep->rbr = RB_ROOT_CACHED;\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tep->user = user;\n\n\t*pep = ep;\n\n\treturn 0;\n\nfree_uid:\n\tfree_uid(user);\n\treturn error;\n}"
  },
  {
    "function_name": "eventpoll_release_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "985-1011",
    "snippet": "void eventpoll_release_file(struct file *file)\n{\n\tstruct eventpoll *ep;\n\tstruct epitem *epi, *next;\n\n\t/*\n\t * We don't want to get \"file->f_lock\" because it is not\n\t * necessary. It is not necessary because we're in the \"struct file\"\n\t * cleanup path, and this means that no one is using this file anymore.\n\t * So, for example, epoll_ctl() cannot hit here since if we reach this\n\t * point, the file counter already went to zero and fget() would fail.\n\t * The only hit might come from ep_free() but by holding the mutex\n\t * will correctly serialize the operation. We do need to acquire\n\t * \"ep->mtx\" after \"epmutex\" because ep_remove() requires it when called\n\t * from anywhere but ep_free().\n\t *\n\t * Besides, ep_remove() acquires the lock, so we can't hold it here.\n\t */\n\tmutex_lock(&epmutex);\n\tlist_for_each_entry_safe(epi, next, &file->f_ep_links, fllink) {\n\t\tep = epi->ep;\n\t\tmutex_lock_nested(&ep->mtx, 0);\n\t\tep_remove(ep, epi);\n\t\tmutex_unlock(&ep->mtx);\n\t}\n\tmutex_unlock(&epmutex);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(epmutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&epmutex"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_remove",
          "args": [
            "ep",
            "epi"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "ep_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "774-810",
          "snippet": "static int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct file *file = epi->ffd.file;\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * Removes poll wait queue hooks.\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase_cached(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irq(&ep->wq.lock);\n\tif (ep_is_linked(epi))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irq(&ep->wq.lock);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct file *file = epi->ffd.file;\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * Removes poll wait queue hooks.\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase_cached(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irq(&ep->wq.lock);\n\tif (ep_is_linked(epi))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irq(&ep->wq.lock);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&ep->mtx",
            "0"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "epi",
            "next",
            "&file->f_ep_links",
            "fllink"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&epmutex"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(epmutex);\n\nvoid eventpoll_release_file(struct file *file)\n{\n\tstruct eventpoll *ep;\n\tstruct epitem *epi, *next;\n\n\t/*\n\t * We don't want to get \"file->f_lock\" because it is not\n\t * necessary. It is not necessary because we're in the \"struct file\"\n\t * cleanup path, and this means that no one is using this file anymore.\n\t * So, for example, epoll_ctl() cannot hit here since if we reach this\n\t * point, the file counter already went to zero and fget() would fail.\n\t * The only hit might come from ep_free() but by holding the mutex\n\t * will correctly serialize the operation. We do need to acquire\n\t * \"ep->mtx\" after \"epmutex\" because ep_remove() requires it when called\n\t * from anywhere but ep_free().\n\t *\n\t * Besides, ep_remove() acquires the lock, so we can't hold it here.\n\t */\n\tmutex_lock(&epmutex);\n\tlist_for_each_entry_safe(epi, next, &file->f_ep_links, fllink) {\n\t\tep = epi->ep;\n\t\tmutex_lock_nested(&ep->mtx, 0);\n\t\tep_remove(ep, epi);\n\t\tmutex_unlock(&ep->mtx);\n\t}\n\tmutex_unlock(&epmutex);\n}"
  },
  {
    "function_name": "ep_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "947-967",
    "snippet": "static void ep_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventpoll *ep = f->private_data;\n\tstruct rb_node *rbp;\n\n\tmutex_lock(&ep->mtx);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tstruct epitem *epi = rb_entry(rbp, struct epitem, rbn);\n\t\tstruct inode *inode = file_inode(epi->ffd.file);\n\n\t\tseq_printf(m, \"tfd: %8d events: %8x data: %16llx \"\n\t\t\t   \" pos:%lli ino:%lx sdev:%x\\n\",\n\t\t\t   epi->ffd.fd, epi->event.events,\n\t\t\t   (long long)epi->event.data,\n\t\t\t   (long long)epi->ffd.file->f_pos,\n\t\t\t   inode->i_ino, inode->i_sb->s_dev);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "m"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"tfd: %8d events: %8x data: %16llx \"\n\t\t\t   \" pos:%lli ino:%lx sdev:%x\\n\"",
            "epi->ffd.fd",
            "epi->event.events",
            "(long long)epi->event.data",
            "(long long)epi->ffd.file->f_pos",
            "inode->i_ino",
            "inode->i_sb->s_dev"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/seq_file.c",
          "lines": "401-408",
          "snippet": "void seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string_helpers.h>",
            "#include <linux/printk.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>",
            "#include <linux/cache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/string_helpers.h>\n#include <linux/printk.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/cache.h>\n\nvoid seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tva_list args;\n\n\tva_start(args, f);\n\tseq_vprintf(m, f, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "epi->ffd.file"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "162-165",
          "snippet": "static struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic struct inode *bdev_file_inode(struct file *file)\n{\n\treturn file->f_mapping->host;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rbp"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first_cached",
          "args": [
            "&ep->rbr"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ep->mtx"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventpoll *ep = f->private_data;\n\tstruct rb_node *rbp;\n\n\tmutex_lock(&ep->mtx);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tstruct epitem *epi = rb_entry(rbp, struct epitem, rbn);\n\t\tstruct inode *inode = file_inode(epi->ffd.file);\n\n\t\tseq_printf(m, \"tfd: %8d events: %8x data: %16llx \"\n\t\t\t   \" pos:%lli ino:%lx sdev:%x\\n\",\n\t\t\t   epi->ffd.fd, epi->event.events,\n\t\t\t   (long long)epi->event.data,\n\t\t\t   (long long)epi->ffd.file->f_pos,\n\t\t\t   inode->i_ino, inode->i_sb->s_dev);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n}"
  },
  {
    "function_name": "ep_eventpoll_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "930-944",
    "snippet": "static __poll_t ep_eventpoll_poll(struct file *file, poll_table *wait)\n{\n\tstruct eventpoll *ep = file->private_data;\n\tint depth = 0;\n\n\t/* Insert inside our poll wait queue */\n\tpoll_wait(file, &ep->poll_wait, wait);\n\n\t/*\n\t * Proceed to find out if wanted events are really available inside\n\t * the ready list.\n\t */\n\treturn ep_scan_ready_list(ep, ep_read_events_proc,\n\t\t\t\t  &depth, depth, false);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_scan_ready_list",
          "args": [
            "ep",
            "ep_read_events_proc",
            "&depth",
            "depth",
            "false"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "ep_scan_ready_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "672-762",
          "snippet": "static __poll_t ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      __poll_t (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\t__poll_t res;\n\tint pwake = 0;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\tres = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irq(&ep->wq.lock);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [
            "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic __poll_t ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      __poll_t (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\t__poll_t res;\n\tint pwake = 0;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\tres = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irq(&ep->wq.lock);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&ep->poll_wait",
            "wait"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_eventpoll_poll(struct file *file, poll_table *wait)\n{\n\tstruct eventpoll *ep = file->private_data;\n\tint depth = 0;\n\n\t/* Insert inside our poll wait queue */\n\tpoll_wait(file, &ep->poll_wait, wait);\n\n\t/*\n\t * Proceed to find out if wanted events are really available inside\n\t * the ready list.\n\t */\n\treturn ep_scan_ready_list(ep, ep_read_events_proc,\n\t\t\t\t  &depth, depth, false);\n}"
  },
  {
    "function_name": "ep_read_events_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "903-928",
    "snippet": "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct epitem *epi, *tmp;\n\tpoll_table pt;\n\tint depth = *(int *)priv;\n\n\tinit_poll_funcptr(&pt, NULL);\n\tdepth++;\n\n\tlist_for_each_entry_safe(epi, tmp, head, rdllink) {\n\t\tif (ep_item_poll(epi, &pt, depth)) {\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Item has been dropped into the ready list by the poll\n\t\t\t * callback, but it's not actually ready, as far as\n\t\t\t * caller requested events goes. We can remove it here.\n\t\t\t */\n\t\t\t__pm_relax(ep_wakeup_source(epi));\n\t\t\tlist_del_init(&epi->rdllink);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);",
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&epi->rdllink"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "ep_wakeup_source(epi)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "628-631",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_item_poll",
          "args": [
            "epi",
            "&pt",
            "depth"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "884-901",
          "snippet": "static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "epi",
            "tmp",
            "head",
            "rdllink"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&pt",
            "NULL"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct epitem *epi, *tmp;\n\tpoll_table pt;\n\tint depth = *(int *)priv;\n\n\tinit_poll_funcptr(&pt, NULL);\n\tdepth++;\n\n\tlist_for_each_entry_safe(epi, tmp, head, rdllink) {\n\t\tif (ep_item_poll(epi, &pt, depth)) {\n\t\t\treturn EPOLLIN | EPOLLRDNORM;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Item has been dropped into the ready list by the poll\n\t\t\t * callback, but it's not actually ready, as far as\n\t\t\t * caller requested events goes. We can remove it here.\n\t\t\t */\n\t\t\t__pm_relax(ep_wakeup_source(epi));\n\t\t\tlist_del_init(&epi->rdllink);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_item_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "884-901",
    "snippet": "static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_scan_ready_list",
          "args": [
            "epi->ffd.file->private_data",
            "ep_read_events_proc",
            "&depth",
            "depth",
            "locked"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ep_scan_ready_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "672-762",
          "snippet": "static __poll_t ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      __poll_t (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\t__poll_t res;\n\tint pwake = 0;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\tres = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irq(&ep->wq.lock);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn res;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [
            "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic __poll_t ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      __poll_t (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\t__poll_t res;\n\tint pwake = 0;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\tres = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irq(&ep->wq.lock);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "epi->ffd.file",
            "&ep->poll_wait",
            "pt"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_poll",
          "args": [
            "epi->ffd.file",
            "pt"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_epoll",
          "args": [
            "epi->ffd.file"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "is_file_epoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "317-320",
          "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventpoll_fops;",
            "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt,\n\t\t\t\t int depth)\n{\n\tstruct eventpoll *ep;\n\tbool locked;\n\n\tpt->_key = epi->event.events;\n\tif (!is_file_epoll(epi->ffd.file))\n\t\treturn vfs_poll(epi->ffd.file, pt) & epi->event.events;\n\n\tep = epi->ffd.file->private_data;\n\tpoll_wait(epi->ffd.file, &ep->poll_wait, pt);\n\tlocked = pt && (pt->_qproc == ep_ptable_queue_proc);\n\n\treturn ep_scan_ready_list(epi->ffd.file->private_data,\n\t\t\t\t  ep_read_events_proc, &depth, depth,\n\t\t\t\t  locked) & epi->event.events;\n}"
  },
  {
    "function_name": "ep_eventpoll_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "864-872",
    "snippet": "static int ep_eventpoll_release(struct inode *inode, struct file *file)\n{\n\tstruct eventpoll *ep = file->private_data;\n\n\tif (ep)\n\t\tep_free(ep);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_free",
          "args": [
            "ep"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "ep_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "812-862",
          "snippet": "static void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->wq.lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first_cached(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(epmutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(epmutex);\n\nstatic void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->wq.lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first_cached(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_eventpoll_release(struct inode *inode, struct file *file)\n{\n\tstruct eventpoll *ep = file->private_data;\n\n\tif (ep)\n\t\tep_free(ep);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "812-862",
    "snippet": "static void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->wq.lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first_cached(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(epmutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ep"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "ep->ws"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "ep->user"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&ep->mtx"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&epmutex"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_remove",
          "args": [
            "ep",
            "epi"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "ep_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "774-810",
          "snippet": "static int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct file *file = epi->ffd.file;\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * Removes poll wait queue hooks.\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase_cached(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irq(&ep->wq.lock);\n\tif (ep_is_linked(epi))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irq(&ep->wq.lock);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct file *file = epi->ffd.file;\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * Removes poll wait queue hooks.\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase_cached(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irq(&ep->wq.lock);\n\tif (ep_is_linked(epi))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irq(&ep->wq.lock);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first_cached",
          "args": [
            "&ep->rbr"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ep->mtx"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_unregister_pollwait",
          "args": [
            "ep",
            "epi"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ep_unregister_pollwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "613-625",
          "snippet": "static void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rbp"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first_cached",
          "args": [
            "&ep->rbr"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&epmutex"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "584-587",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(epmutex);\n\nstatic void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->wq.lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first_cached(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}"
  },
  {
    "function_name": "ep_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "774-810",
    "snippet": "static int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct file *file = epi->ffd.file;\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * Removes poll wait queue hooks.\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase_cached(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irq(&ep->wq.lock);\n\tif (ep_is_linked(epi))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irq(&ep->wq.lock);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&ep->user->epoll_watches"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&epi->rcu",
            "epi_rcu_free"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "ep_wakeup_source(epi)"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "628-631",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&epi->rdllink"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "epi"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "339-342",
          "snippet": "static inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase_cached",
          "args": [
            "&epi->rbn",
            "&ep->rbr"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&file->f_lock"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&epi->fllink"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&file->f_lock"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_unregister_pollwait",
          "args": [
            "ep",
            "epi"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "ep_unregister_pollwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "613-625",
          "snippet": "static void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct file *file = epi->ffd.file;\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * Removes poll wait queue hooks.\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase_cached(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irq(&ep->wq.lock);\n\tif (ep_is_linked(epi))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irq(&ep->wq.lock);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "epi_rcu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "764-768",
    "snippet": "static void epi_rcu_free(struct rcu_head *head)\n{\n\tstruct epitem *epi = container_of(head, struct epitem, rcu);\n\tkmem_cache_free(epi_cache, epi);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "epi_cache",
            "epi"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structepitem",
            "rcu"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void epi_rcu_free(struct rcu_head *head)\n{\n\tstruct epitem *epi = container_of(head, struct epitem, rcu);\n\tkmem_cache_free(epi_cache, epi);\n}"
  },
  {
    "function_name": "ep_scan_ready_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "672-762",
    "snippet": "static __poll_t ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      __poll_t (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\t__poll_t res;\n\tint pwake = 0;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\tres = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irq(&ep->wq.lock);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)"
    ],
    "globals_used": [
      "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "584-587",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ep->wq"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->wq"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ep->rdllist"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "ep->ws"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&txlist",
            "&ep->rdllist"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pm_stay_awake",
          "args": [
            "epi"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "648-657",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "epi"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "339-342",
          "snippet": "static inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ep",
            "&txlist",
            "priv"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&ep->rdllist",
            "&txlist"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->wq.lock"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&ep->mtx",
            "depth"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_enabled",
          "args": [],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "txlist"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic __poll_t ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      __poll_t (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\t__poll_t res;\n\tint pwake = 0;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\tlockdep_assert_irqs_enabled();\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irq(&ep->wq.lock);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irq(&ep->wq.lock);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\tres = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irq(&ep->wq.lock);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(epi)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irq(&ep->wq.lock);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn res;\n}"
  },
  {
    "function_name": "ep_pm_stay_awake_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "648-657",
    "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "ws"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "epi->ws"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "ep_has_wakeup_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "642-645",
    "snippet": "static inline bool ep_has_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_access_pointer(epi->ws) ? true : false;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "epi->ws"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline bool ep_has_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_access_pointer(epi->ws) ? true : false;\n}"
  },
  {
    "function_name": "ep_pm_stay_awake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "634-640",
    "snippet": "static inline void ep_pm_stay_awake(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "ws"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "628-631",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n}"
  },
  {
    "function_name": "ep_wakeup_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "628-631",
    "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "epi->ws",
            "lockdep_is_held(&epi->ep->mtx)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&epi->ep->mtx"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
  },
  {
    "function_name": "ep_unregister_pollwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "613-625",
    "snippet": "static void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "pwq_cache",
            "pwq"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_remove_wait_queue",
          "args": [
            "pwq"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "ep_remove_wait_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "591-606",
          "snippet": "static void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/*\n\t * If it is cleared by POLLFREE, it should be rcu-safe.\n\t * If we read NULL we need a barrier paired with\n\t * smp_store_release() in ep_poll_callback(), otherwise\n\t * we rely on whead->lock.\n\t */\n\twhead = smp_load_acquire(&pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/*\n\t * If it is cleared by POLLFREE, it should be rcu-safe.\n\t * If we read NULL we need a barrier paired with\n\t * smp_store_release() in ep_poll_callback(), otherwise\n\t * we rely on whead->lock.\n\t */\n\twhead = smp_load_acquire(&pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pwq->llink"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "lsthead",
            "structeppoll_entry",
            "llink"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "lsthead"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}"
  },
  {
    "function_name": "ep_remove_wait_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "591-606",
    "snippet": "static void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/*\n\t * If it is cleared by POLLFREE, it should be rcu-safe.\n\t * If we read NULL we need a barrier paired with\n\t * smp_store_release() in ep_poll_callback(), otherwise\n\t * we rely on whead->lock.\n\t */\n\twhead = smp_load_acquire(&pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "whead",
            "&pwq->wait"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&pwq->whead"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/*\n\t * If it is cleared by POLLFREE, it should be rcu-safe.\n\t * If we read NULL we need a barrier paired with\n\t * smp_store_release() in ep_poll_callback(), otherwise\n\t * we rely on whead->lock.\n\t */\n\twhead = smp_load_acquire(&pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "ep_poll_safewake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "584-587",
    "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "wq",
            "EPOLLIN"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\twake_up_poll(wq, EPOLLIN);\n}"
  },
  {
    "function_name": "ep_poll_safewake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "572-580",
    "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_safewake_ncalls",
            "EP_MAX_NESTS",
            "ep_poll_wakeup_proc",
            "NULL",
            "wq",
            "(void *) (long) this_cpu"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "483-529",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}"
  },
  {
    "function_name": "ep_poll_wakeup_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "560-570",
    "snippet": "static int ep_poll_wakeup_proc(void *priv, void *cookie, int call_nests)\n{\n\tunsigned long flags;\n\twait_queue_head_t *wqueue = (wait_queue_head_t *)cookie;\n\n\tspin_lock_irqsave_nested(&wqueue->lock, flags, call_nests + 1);\n\twake_up_locked_poll(wqueue, EPOLLIN);\n\tspin_unlock_irqrestore(&wqueue->lock, flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wqueue->lock",
            "flags"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "wqueue",
            "EPOLLIN"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_nested",
          "args": [
            "&wqueue->lock",
            "flags",
            "call_nests + 1"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int ep_poll_wakeup_proc(void *priv, void *cookie, int call_nests)\n{\n\tunsigned long flags;\n\twait_queue_head_t *wqueue = (wait_queue_head_t *)cookie;\n\n\tspin_lock_irqsave_nested(&wqueue->lock, flags, call_nests + 1);\n\twake_up_locked_poll(wqueue, EPOLLIN);\n\tspin_unlock_irqrestore(&wqueue->lock, flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_call_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "483-529",
    "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ncalls->lock",
            "flags"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tnode.llink"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "449-456",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode->i_sb->s_inode_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode->i_sb->s_inode_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ncalls->lock",
            "flags"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "priv",
            "cookie",
            "call_nests"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ncalls->lock",
            "flags"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tnode.llink",
            "lsthead"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/xattr.c",
          "lines": "985-991",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tncur",
            "lsthead",
            "llink"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ncalls->lock",
            "flags"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic __poll_t ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv);\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ep_set_busy_poll_napi_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "461-463",
    "snippet": "static inline void ep_set_busy_poll_napi_id(struct epitem *epi)\n{\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_busy_poll_napi_id(struct epitem *epi)\n{\n}"
  },
  {
    "function_name": "ep_reset_busy_poll_napi_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "457-459",
    "snippet": "static inline void ep_reset_busy_poll_napi_id(struct eventpoll *ep)\n{\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_reset_busy_poll_napi_id(struct eventpoll *ep)\n{\n}"
  },
  {
    "function_name": "ep_busy_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "453-455",
    "snippet": "static inline void ep_busy_loop(struct eventpoll *ep, int nonblock)\n{\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_busy_loop(struct eventpoll *ep, int nonblock)\n{\n}"
  },
  {
    "function_name": "ep_set_busy_poll_napi_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "418-449",
    "snippet": "static inline void ep_set_busy_poll_napi_id(struct epitem *epi)\n{\n\tstruct eventpoll *ep;\n\tunsigned int napi_id;\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tint err;\n\n\tif (!net_busy_loop_on())\n\t\treturn;\n\n\tsock = sock_from_file(epi->ffd.file, &err);\n\tif (!sock)\n\t\treturn;\n\n\tsk = sock->sk;\n\tif (!sk)\n\t\treturn;\n\n\tnapi_id = READ_ONCE(sk->sk_napi_id);\n\tep = epi->ep;\n\n\t/* Non-NAPI IDs can be rejected\n\t *\tor\n\t * Nothing to do if we already have this ID\n\t */\n\tif (napi_id < MIN_NAPI_ID || napi_id == ep->napi_id)\n\t\treturn;\n\n\t/* record NAPI ID for use in next busy poll */\n\tep->napi_id = napi_id;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "sk->sk_napi_id"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_from_file",
          "args": [
            "epi->ffd.file",
            "&err"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_busy_loop_on",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_busy_poll_napi_id(struct epitem *epi)\n{\n\tstruct eventpoll *ep;\n\tunsigned int napi_id;\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tint err;\n\n\tif (!net_busy_loop_on())\n\t\treturn;\n\n\tsock = sock_from_file(epi->ffd.file, &err);\n\tif (!sock)\n\t\treturn;\n\n\tsk = sock->sk;\n\tif (!sk)\n\t\treturn;\n\n\tnapi_id = READ_ONCE(sk->sk_napi_id);\n\tep = epi->ep;\n\n\t/* Non-NAPI IDs can be rejected\n\t *\tor\n\t * Nothing to do if we already have this ID\n\t */\n\tif (napi_id < MIN_NAPI_ID || napi_id == ep->napi_id)\n\t\treturn;\n\n\t/* record NAPI ID for use in next busy poll */\n\tep->napi_id = napi_id;\n}"
  },
  {
    "function_name": "ep_reset_busy_poll_napi_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "409-413",
    "snippet": "static inline void ep_reset_busy_poll_napi_id(struct eventpoll *ep)\n{\n\tif (ep->napi_id)\n\t\tep->napi_id = 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_reset_busy_poll_napi_id(struct eventpoll *ep)\n{\n\tif (ep->napi_id)\n\t\tep->napi_id = 0;\n}"
  },
  {
    "function_name": "ep_busy_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "401-407",
    "snippet": "static void ep_busy_loop(struct eventpoll *ep, int nonblock)\n{\n\tunsigned int napi_id = READ_ONCE(ep->napi_id);\n\n\tif ((napi_id >= MIN_NAPI_ID) && net_busy_loop_on())\n\t\tnapi_busy_loop(napi_id, nonblock ? NULL : ep_busy_loop_end, ep);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "napi_busy_loop",
          "args": [
            "napi_id",
            "nonblock ? NULL : ep_busy_loop_end",
            "ep"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_busy_loop_on",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "ep->napi_id"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_busy_loop(struct eventpoll *ep, int nonblock)\n{\n\tunsigned int napi_id = READ_ONCE(ep->napi_id);\n\n\tif ((napi_id >= MIN_NAPI_ID) && net_busy_loop_on())\n\t\tnapi_busy_loop(napi_id, nonblock ? NULL : ep_busy_loop_end, ep);\n}"
  },
  {
    "function_name": "ep_busy_loop_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "388-393",
    "snippet": "static bool ep_busy_loop_end(void *p, unsigned long start_time)\n{\n\tstruct eventpoll *ep = p;\n\n\treturn ep_events_available(ep) || busy_loop_timeout(start_time);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "busy_loop_timeout",
          "args": [
            "start_time"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_events_available",
          "args": [
            "ep"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "ep_events_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
          "lines": "382-385",
          "snippet": "static inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic bool ep_busy_loop_end(void *p, unsigned long start_time)\n{\n\tstruct eventpoll *ep = p;\n\n\treturn ep_events_available(ep) || busy_loop_timeout(start_time);\n}"
  },
  {
    "function_name": "ep_events_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "382-385",
    "snippet": "static inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ep->rdllist"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}"
  },
  {
    "function_name": "ep_nested_calls_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "368-372",
    "snippet": "static void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ncalls->lock"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ncalls->tasks_call_list"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}"
  },
  {
    "function_name": "ep_op_has_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "362-365",
    "snippet": "static inline int ep_op_has_event(int op)\n{\n\treturn op != EPOLL_CTL_DEL;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_op_has_event(int op)\n{\n\treturn op != EPOLL_CTL_DEL;\n}"
  },
  {
    "function_name": "ep_item_from_epqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "356-359",
    "snippet": "static inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structep_pqueue",
            "pt"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}"
  },
  {
    "function_name": "ep_item_from_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "350-353",
    "snippet": "static inline struct epitem *ep_item_from_wait(wait_queue_entry_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structeppoll_entry",
            "wait"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct epitem *ep_item_from_wait(wait_queue_entry_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}"
  },
  {
    "function_name": "ep_pwq_from_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "344-347",
    "snippet": "static inline struct eppoll_entry *ep_pwq_from_wait(wait_queue_entry_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structeppoll_entry",
            "wait"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct eppoll_entry *ep_pwq_from_wait(wait_queue_entry_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait);\n}"
  },
  {
    "function_name": "ep_is_linked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "339-342",
    "snippet": "static inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&epi->rdllink"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct epitem *epi)\n{\n\treturn !list_empty(&epi->rdllink);\n}"
  },
  {
    "function_name": "ep_cmp_ffd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "331-336",
    "snippet": "static inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}"
  },
  {
    "function_name": "ep_set_ffd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "323-328",
    "snippet": "static inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}"
  },
  {
    "function_name": "is_file_epoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "317-320",
    "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventpoll_fops;",
      "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
  },
  {
    "function_name": "epoll_create1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1989-1992",
    "snippet": "SYSCALL_DEFINE1(epoll_create1, int, flags)\n{\n\treturn do_epoll_create(flags);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nSYSCALL_DEFINE1(epoll_create1, int, flags)\n{\n\treturn do_epoll_create(flags);\n}"
  },
  {
    "function_name": "epoll_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "1994-2000",
    "snippet": "SYSCALL_DEFINE1(epoll_create, int, size)\n{\n\tif (size <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_epoll_create(0);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nSYSCALL_DEFINE1(epoll_create, int, size)\n{\n\tif (size <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_epoll_create(0);\n}"
  },
  {
    "function_name": "epoll_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "2007-2157",
    "snippet": "SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n\tint error;\n\tint full_check = 0;\n\tstruct fd f, tf;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\tstruct eventpoll *tep = NULL;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\terror = -EBADF;\n\tf = fdget(epfd);\n\tif (!f.file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttf = fdget(fd);\n\tif (!tf.file)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!file_can_poll(tf.file))\n\t\tgoto error_tgt_fput;\n\n\t/* Check if EPOLLWAKEUP is allowed */\n\tif (ep_op_has_event(op))\n\t\tep_take_care_of_epollwakeup(&epds);\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (f.file == tf.file || !is_file_epoll(f.file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,\n\t * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.\n\t * Also, we do not currently supported nested exclusive wakeups.\n\t */\n\tif (ep_op_has_event(op) && (epds.events & EPOLLEXCLUSIVE)) {\n\t\tif (op == EPOLL_CTL_MOD)\n\t\t\tgoto error_tgt_fput;\n\t\tif (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||\n\t\t\t\t(epds.events & ~EPOLLEXCLUSIVE_OK_BITS)))\n\t\t\tgoto error_tgt_fput;\n\t}\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = f.file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven't created too many possible wakeup paths.\n\t *\n\t * We do not need to take the global 'epumutex' on EPOLL_CTL_ADD when\n\t * the epoll file descriptor is attaching directly to a wakeup source,\n\t * unless the epoll file descriptor is nested. The purpose of taking the\n\t * 'epmutex' on add is to prevent complex toplogies such as loops and\n\t * deep wakeup paths from forming in parallel through multiple\n\t * EPOLL_CTL_ADD operations.\n\t */\n\tmutex_lock_nested(&ep->mtx, 0);\n\tif (op == EPOLL_CTL_ADD) {\n\t\tif (!list_empty(&f.file->f_ep_links) ||\n\t\t\t\t\t\tis_file_epoll(tf.file)) {\n\t\t\tfull_check = 1;\n\t\t\tmutex_unlock(&ep->mtx);\n\t\t\tmutex_lock(&epmutex);\n\t\t\tif (is_file_epoll(tf.file)) {\n\t\t\t\terror = -ELOOP;\n\t\t\t\tif (ep_loop_check(ep, tf.file) != 0) {\n\t\t\t\t\tclear_tfile_check_list();\n\t\t\t\t\tgoto error_tgt_fput;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlist_add(&tf.file->f_tfile_llink,\n\t\t\t\t\t\t\t&tfile_check_list);\n\t\t\tmutex_lock_nested(&ep->mtx, 0);\n\t\t\tif (is_file_epoll(tf.file)) {\n\t\t\t\ttep = tf.file->private_data;\n\t\t\t\tmutex_lock_nested(&tep->mtx, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tf.file, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds.events |= EPOLLERR | EPOLLHUP;\n\t\t\terror = ep_insert(ep, &epds, tf.file, fd, full_check);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tif (full_check)\n\t\t\tclear_tfile_check_list();\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tif (!(epi->event.events & EPOLLEXCLUSIVE)) {\n\t\t\t\tepds.events |= EPOLLERR | EPOLLHUP;\n\t\t\t\terror = ep_modify(ep, epi, &epds);\n\t\t\t}\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tif (tep != NULL)\n\t\tmutex_unlock(&tep->mtx);\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (full_check)\n\t\tmutex_unlock(&epmutex);\n\n\tfdput(tf);\nerror_fput:\n\tfdput(f);\nerror_return:\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EPOLLEXCLUSIVE_OK_BITS (EPOLLINOUT_BITS | EPOLLERR | EPOLLHUP | \\\n\t\t\t\tEPOLLWAKEUP | EPOLLET | EPOLLEXCLUSIVE)"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(epmutex);",
      "static LIST_HEAD(tfile_check_list);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EPOLLEXCLUSIVE_OK_BITS (EPOLLINOUT_BITS | EPOLLERR | EPOLLHUP | \\\n\t\t\t\tEPOLLWAKEUP | EPOLLET | EPOLLEXCLUSIVE)\n\nstatic DEFINE_MUTEX(epmutex);\nstatic LIST_HEAD(tfile_check_list);\n\nSYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,\n\t\tstruct epoll_event __user *, event)\n{\n\tint error;\n\tint full_check = 0;\n\tstruct fd f, tf;\n\tstruct eventpoll *ep;\n\tstruct epitem *epi;\n\tstruct epoll_event epds;\n\tstruct eventpoll *tep = NULL;\n\n\terror = -EFAULT;\n\tif (ep_op_has_event(op) &&\n\t    copy_from_user(&epds, event, sizeof(struct epoll_event)))\n\t\tgoto error_return;\n\n\terror = -EBADF;\n\tf = fdget(epfd);\n\tif (!f.file)\n\t\tgoto error_return;\n\n\t/* Get the \"struct file *\" for the target file */\n\ttf = fdget(fd);\n\tif (!tf.file)\n\t\tgoto error_fput;\n\n\t/* The target file descriptor must support poll */\n\terror = -EPERM;\n\tif (!file_can_poll(tf.file))\n\t\tgoto error_tgt_fput;\n\n\t/* Check if EPOLLWAKEUP is allowed */\n\tif (ep_op_has_event(op))\n\t\tep_take_care_of_epollwakeup(&epds);\n\n\t/*\n\t * We have to check that the file structure underneath the file descriptor\n\t * the user passed to us _is_ an eventpoll file. And also we do not permit\n\t * adding an epoll file descriptor inside itself.\n\t */\n\terror = -EINVAL;\n\tif (f.file == tf.file || !is_file_epoll(f.file))\n\t\tgoto error_tgt_fput;\n\n\t/*\n\t * epoll adds to the wakeup queue at EPOLL_CTL_ADD time only,\n\t * so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation.\n\t * Also, we do not currently supported nested exclusive wakeups.\n\t */\n\tif (ep_op_has_event(op) && (epds.events & EPOLLEXCLUSIVE)) {\n\t\tif (op == EPOLL_CTL_MOD)\n\t\t\tgoto error_tgt_fput;\n\t\tif (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||\n\t\t\t\t(epds.events & ~EPOLLEXCLUSIVE_OK_BITS)))\n\t\t\tgoto error_tgt_fput;\n\t}\n\n\t/*\n\t * At this point it is safe to assume that the \"private_data\" contains\n\t * our own data structure.\n\t */\n\tep = f.file->private_data;\n\n\t/*\n\t * When we insert an epoll file descriptor, inside another epoll file\n\t * descriptor, there is the change of creating closed loops, which are\n\t * better be handled here, than in more critical paths. While we are\n\t * checking for loops we also determine the list of files reachable\n\t * and hang them on the tfile_check_list, so we can check that we\n\t * haven't created too many possible wakeup paths.\n\t *\n\t * We do not need to take the global 'epumutex' on EPOLL_CTL_ADD when\n\t * the epoll file descriptor is attaching directly to a wakeup source,\n\t * unless the epoll file descriptor is nested. The purpose of taking the\n\t * 'epmutex' on add is to prevent complex toplogies such as loops and\n\t * deep wakeup paths from forming in parallel through multiple\n\t * EPOLL_CTL_ADD operations.\n\t */\n\tmutex_lock_nested(&ep->mtx, 0);\n\tif (op == EPOLL_CTL_ADD) {\n\t\tif (!list_empty(&f.file->f_ep_links) ||\n\t\t\t\t\t\tis_file_epoll(tf.file)) {\n\t\t\tfull_check = 1;\n\t\t\tmutex_unlock(&ep->mtx);\n\t\t\tmutex_lock(&epmutex);\n\t\t\tif (is_file_epoll(tf.file)) {\n\t\t\t\terror = -ELOOP;\n\t\t\t\tif (ep_loop_check(ep, tf.file) != 0) {\n\t\t\t\t\tclear_tfile_check_list();\n\t\t\t\t\tgoto error_tgt_fput;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tlist_add(&tf.file->f_tfile_llink,\n\t\t\t\t\t\t\t&tfile_check_list);\n\t\t\tmutex_lock_nested(&ep->mtx, 0);\n\t\t\tif (is_file_epoll(tf.file)) {\n\t\t\t\ttep = tf.file->private_data;\n\t\t\t\tmutex_lock_nested(&tep->mtx, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Try to lookup the file inside our RB tree, Since we grabbed \"mtx\"\n\t * above, we can be sure to be able to use the item looked up by\n\t * ep_find() till we release the mutex.\n\t */\n\tepi = ep_find(ep, tf.file, fd);\n\n\terror = -EINVAL;\n\tswitch (op) {\n\tcase EPOLL_CTL_ADD:\n\t\tif (!epi) {\n\t\t\tepds.events |= EPOLLERR | EPOLLHUP;\n\t\t\terror = ep_insert(ep, &epds, tf.file, fd, full_check);\n\t\t} else\n\t\t\terror = -EEXIST;\n\t\tif (full_check)\n\t\t\tclear_tfile_check_list();\n\t\tbreak;\n\tcase EPOLL_CTL_DEL:\n\t\tif (epi)\n\t\t\terror = ep_remove(ep, epi);\n\t\telse\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\tcase EPOLL_CTL_MOD:\n\t\tif (epi) {\n\t\t\tif (!(epi->event.events & EPOLLEXCLUSIVE)) {\n\t\t\t\tepds.events |= EPOLLERR | EPOLLHUP;\n\t\t\t\terror = ep_modify(ep, epi, &epds);\n\t\t\t}\n\t\t} else\n\t\t\terror = -ENOENT;\n\t\tbreak;\n\t}\n\tif (tep != NULL)\n\t\tmutex_unlock(&tep->mtx);\n\tmutex_unlock(&ep->mtx);\n\nerror_tgt_fput:\n\tif (full_check)\n\t\tmutex_unlock(&epmutex);\n\n\tfdput(tf);\nerror_fput:\n\tfdput(f);\nerror_return:\n\n\treturn error;\n}"
  },
  {
    "function_name": "epoll_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "2205-2209",
    "snippet": "SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,\n\t\tint, maxevents, int, timeout)\n{\n\treturn do_epoll_wait(epfd, events, maxevents, timeout);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nSYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,\n\t\tint, maxevents, int, timeout)\n{\n\treturn do_epoll_wait(epfd, events, maxevents, timeout);\n}"
  },
  {
    "function_name": "epoll_pwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "2215-2253",
    "snippet": "SYSCALL_DEFINE6(epoll_pwait, int, epfd, struct epoll_event __user *, events,\n\t\tint, maxevents, int, timeout, const sigset_t __user *, sigmask,\n\t\tsize_t, sigsetsize)\n{\n\tint error;\n\tsigset_t ksigmask, sigsaved;\n\n\t/*\n\t * If the caller wants a certain signal mask to be set during the wait,\n\t * we apply it here.\n\t */\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigsaved = current->blocked;\n\t\tset_current_blocked(&ksigmask);\n\t}\n\n\terror = do_epoll_wait(epfd, events, maxevents, timeout);\n\n\t/*\n\t * If we changed the signal mask, we need to restore the original one.\n\t * In case we've got a signal while waiting, we do not restore the\n\t * signal mask yet, and we allow do_signal() to deliver the signal on\n\t * the way back to userspace, before the signal mask is restored.\n\t */\n\tif (sigmask) {\n\t\tif (error == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t} else\n\t\t\tset_current_blocked(&sigsaved);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nSYSCALL_DEFINE6(epoll_pwait, int, epfd, struct epoll_event __user *, events,\n\t\tint, maxevents, int, timeout, const sigset_t __user *, sigmask,\n\t\tsize_t, sigsetsize)\n{\n\tint error;\n\tsigset_t ksigmask, sigsaved;\n\n\t/*\n\t * If the caller wants a certain signal mask to be set during the wait,\n\t * we apply it here.\n\t */\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ksigmask, sigmask, sizeof(ksigmask)))\n\t\t\treturn -EFAULT;\n\t\tsigsaved = current->blocked;\n\t\tset_current_blocked(&ksigmask);\n\t}\n\n\terror = do_epoll_wait(epfd, events, maxevents, timeout);\n\n\t/*\n\t * If we changed the signal mask, we need to restore the original one.\n\t * In case we've got a signal while waiting, we do not restore the\n\t * signal mask yet, and we allow do_signal() to deliver the signal on\n\t * the way back to userspace, before the signal mask is restored.\n\t */\n\tif (sigmask) {\n\t\tif (error == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t} else\n\t\t\tset_current_blocked(&sigsaved);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "epoll_pwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/eventpoll.c",
    "lines": "2256-2296",
    "snippet": "SYSCALL_DEFINE6(epoll_pwait, int, epfd,\n\t\t\tstruct epoll_event __user *, events,\n\t\t\tint, maxevents, int, timeout,\n\t\t\tconst compat_sigset_t __user *, sigmask,\n\t\t\tcompat_size_t, sigsetsize)\n{\n\tlong err;\n\tsigset_t ksigmask, sigsaved;\n\n\t/*\n\t * If the caller wants a certain signal mask to be set during the wait,\n\t * we apply it here.\n\t */\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (get_compat_sigset(&ksigmask, sigmask))\n\t\t\treturn -EFAULT;\n\t\tsigsaved = current->blocked;\n\t\tset_current_blocked(&ksigmask);\n\t}\n\n\terr = do_epoll_wait(epfd, events, maxevents, timeout);\n\n\t/*\n\t * If we changed the signal mask, we need to restore the original one.\n\t * In case we've got a signal while waiting, we do not restore the\n\t * signal mask yet, and we allow do_signal() to deliver the signal on\n\t * the way back to userspace, before the signal mask is restored.\n\t */\n\tif (sigmask) {\n\t\tif (err == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t} else\n\t\t\tset_current_blocked(&sigsaved);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <net/busy_poll.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <net/busy_poll.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nSYSCALL_DEFINE6(epoll_pwait, int, epfd,\n\t\t\tstruct epoll_event __user *, events,\n\t\t\tint, maxevents, int, timeout,\n\t\t\tconst compat_sigset_t __user *, sigmask,\n\t\t\tcompat_size_t, sigsetsize)\n{\n\tlong err;\n\tsigset_t ksigmask, sigsaved;\n\n\t/*\n\t * If the caller wants a certain signal mask to be set during the wait,\n\t * we apply it here.\n\t */\n\tif (sigmask) {\n\t\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\t\treturn -EINVAL;\n\t\tif (get_compat_sigset(&ksigmask, sigmask))\n\t\t\treturn -EFAULT;\n\t\tsigsaved = current->blocked;\n\t\tset_current_blocked(&ksigmask);\n\t}\n\n\terr = do_epoll_wait(epfd, events, maxevents, timeout);\n\n\t/*\n\t * If we changed the signal mask, we need to restore the original one.\n\t * In case we've got a signal while waiting, we do not restore the\n\t * signal mask yet, and we allow do_signal() to deliver the signal on\n\t * the way back to userspace, before the signal mask is restored.\n\t */\n\tif (sigmask) {\n\t\tif (err == -EINTR) {\n\t\t\tmemcpy(&current->saved_sigmask, &sigsaved,\n\t\t\t       sizeof(sigsaved));\n\t\t\tset_restore_sigmask();\n\t\t} else\n\t\t\tset_current_blocked(&sigsaved);\n\t}\n\n\treturn err;\n}"
  }
]