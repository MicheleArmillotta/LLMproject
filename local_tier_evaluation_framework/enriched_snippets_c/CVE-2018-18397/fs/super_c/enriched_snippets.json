[
  {
    "function_name": "thaw_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1577-1581",
    "snippet": "int thaw_super(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\treturn thaw_super_locked(sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thaw_super_locked",
          "args": [
            "sb"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_super_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1542-1575",
          "snippet": "static int thaw_super_locked(struct super_block *sb)\n{\n\tint error;\n\n\tif (sb->s_writers.frozen != SB_FREEZE_COMPLETE) {\n\t\tup_write(&sb->s_umount);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\tgoto out;\n\t}\n\n\tlockdep_sb_freeze_acquire(sb);\n\n\tif (sb->s_op->unfreeze_fs) {\n\t\terror = sb->s_op->unfreeze_fs(sb);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\");\n\t\t\tlockdep_sb_freeze_release(sb);\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tsb->s_writers.frozen = SB_UNFROZEN;\n\tsb_freeze_unlock(sb);\nout:\n\twake_up(&sb->s_writers.wait_unfrozen);\n\tdeactivate_locked_super(sb);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic int thaw_super_locked(struct super_block *sb)\n{\n\tint error;\n\n\tif (sb->s_writers.frozen != SB_FREEZE_COMPLETE) {\n\t\tup_write(&sb->s_umount);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\tgoto out;\n\t}\n\n\tlockdep_sb_freeze_acquire(sb);\n\n\tif (sb->s_op->unfreeze_fs) {\n\t\terror = sb->s_op->unfreeze_fs(sb);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\");\n\t\t\tlockdep_sb_freeze_release(sb);\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tsb->s_writers.frozen = SB_UNFROZEN;\n\tsb_freeze_unlock(sb);\nout:\n\twake_up(&sb->s_writers.wait_unfrozen);\n\tdeactivate_locked_super(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint thaw_super(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\treturn thaw_super_locked(sb);\n}"
  },
  {
    "function_name": "thaw_super_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1542-1575",
    "snippet": "static int thaw_super_locked(struct super_block *sb)\n{\n\tint error;\n\n\tif (sb->s_writers.frozen != SB_FREEZE_COMPLETE) {\n\t\tup_write(&sb->s_umount);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\tgoto out;\n\t}\n\n\tlockdep_sb_freeze_acquire(sb);\n\n\tif (sb->s_op->unfreeze_fs) {\n\t\terror = sb->s_op->unfreeze_fs(sb);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\");\n\t\t\tlockdep_sb_freeze_release(sb);\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tsb->s_writers.frozen = SB_UNFROZEN;\n\tsb_freeze_unlock(sb);\nout:\n\twake_up(&sb->s_writers.wait_unfrozen);\n\tdeactivate_locked_super(sb);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sb->s_writers.wait_unfrozen"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "714-739",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_freeze_unlock",
          "args": [
            "sb"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "sb_freeze_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1432-1438",
          "snippet": "static void sb_freeze_unlock(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_up_write(sb->s_writers.rw_sem + level);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void sb_freeze_unlock(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_up_write(sb->s_writers.rw_sem + level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_sb_freeze_release",
          "args": [
            "sb"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_sb_freeze_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1413-1419",
          "snippet": "static void lockdep_sb_freeze_release(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_rwsem_release(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void lockdep_sb_freeze_release(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_rwsem_release(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\""
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->unfreeze_fs",
          "args": [
            "sb"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_sb_freeze_acquire",
          "args": [
            "sb"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_sb_freeze_acquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1424-1430",
          "snippet": "static void lockdep_sb_freeze_acquire(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = 0; level < SB_FREEZE_LEVELS; ++level)\n\t\tpercpu_rwsem_acquire(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void lockdep_sb_freeze_acquire(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = 0; level < SB_FREEZE_LEVELS; ++level)\n\t\tpercpu_rwsem_acquire(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic int thaw_super_locked(struct super_block *sb)\n{\n\tint error;\n\n\tif (sb->s_writers.frozen != SB_FREEZE_COMPLETE) {\n\t\tup_write(&sb->s_umount);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\tgoto out;\n\t}\n\n\tlockdep_sb_freeze_acquire(sb);\n\n\tif (sb->s_op->unfreeze_fs) {\n\t\terror = sb->s_op->unfreeze_fs(sb);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\");\n\t\t\tlockdep_sb_freeze_release(sb);\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tsb->s_writers.frozen = SB_UNFROZEN;\n\tsb_freeze_unlock(sb);\nout:\n\twake_up(&sb->s_writers.wait_unfrozen);\n\tdeactivate_locked_super(sb);\n\treturn 0;\n}"
  },
  {
    "function_name": "freeze_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1473-1533",
    "snippet": "int freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & SB_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\tdown_write(&sb->s_umount);\n\n\t/* Now we go and block page faults... */\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsb_freeze_unlock(sb);\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * For debugging purposes so that fs can warn if it sees write activity\n\t * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tlockdep_sb_freeze_release(sb);\n\tup_write(&sb->s_umount);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_sb_freeze_release",
          "args": [
            "sb"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_sb_freeze_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1413-1419",
          "snippet": "static void lockdep_sb_freeze_release(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_rwsem_release(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void lockdep_sb_freeze_release(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_rwsem_release(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&sb->s_writers.wait_unfrozen"
          ],
          "line": 1520
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/locks.c",
          "lines": "714-739",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_freeze_unlock",
          "args": [
            "sb"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "sb_freeze_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1432-1438",
          "snippet": "static void sb_freeze_unlock(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_up_write(sb->s_writers.rw_sem + level);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void sb_freeze_unlock(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_up_write(sb->s_writers.rw_sem + level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\""
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->freeze_fs",
          "args": [
            "sb"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_wait_write",
          "args": [
            "sb",
            "SB_FREEZE_FS"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "sb_wait_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1404-1407",
          "snippet": "static void sb_wait_write(struct super_block *sb, int level)\n{\n\tpercpu_down_write(sb->s_writers.rw_sem + level-1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void sb_wait_write(struct super_block *sb, int level)\n{\n\tpercpu_down_write(sb->s_writers.rw_sem + level-1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "48-68",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sb->s_active"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & SB_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\tdown_write(&sb->s_umount);\n\n\t/* Now we go and block page faults... */\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsb_freeze_unlock(sb);\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * For debugging purposes so that fs can warn if it sees write activity\n\t * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tlockdep_sb_freeze_release(sb);\n\tup_write(&sb->s_umount);\n\treturn 0;\n}"
  },
  {
    "function_name": "sb_freeze_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1432-1438",
    "snippet": "static void sb_freeze_unlock(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_up_write(sb->s_writers.rw_sem + level);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_write",
          "args": [
            "sb->s_writers.rw_sem + level"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void sb_freeze_unlock(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_up_write(sb->s_writers.rw_sem + level);\n}"
  },
  {
    "function_name": "lockdep_sb_freeze_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1424-1430",
    "snippet": "static void lockdep_sb_freeze_acquire(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = 0; level < SB_FREEZE_LEVELS; ++level)\n\t\tpercpu_rwsem_acquire(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_rwsem_acquire",
          "args": [
            "sb->s_writers.rw_sem + level",
            "0",
            "_THIS_IP_"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void lockdep_sb_freeze_acquire(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = 0; level < SB_FREEZE_LEVELS; ++level)\n\t\tpercpu_rwsem_acquire(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}"
  },
  {
    "function_name": "lockdep_sb_freeze_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1413-1419",
    "snippet": "static void lockdep_sb_freeze_release(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_rwsem_release(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_rwsem_release",
          "args": [
            "sb->s_writers.rw_sem + level",
            "0",
            "_THIS_IP_"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void lockdep_sb_freeze_release(struct super_block *sb)\n{\n\tint level;\n\n\tfor (level = SB_FREEZE_LEVELS - 1; level >= 0; level--)\n\t\tpercpu_rwsem_release(sb->s_writers.rw_sem + level, 0, _THIS_IP_);\n}"
  },
  {
    "function_name": "sb_wait_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1404-1407",
    "snippet": "static void sb_wait_write(struct super_block *sb, int level)\n{\n\tpercpu_down_write(sb->s_writers.rw_sem + level-1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_down_write",
          "args": [
            "sb->s_writers.rw_sem + level-1"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void sb_wait_write(struct super_block *sb, int level)\n{\n\tpercpu_down_write(sb->s_writers.rw_sem + level-1);\n}"
  },
  {
    "function_name": "__sb_start_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1361-1393",
    "snippet": "int __sb_start_write(struct super_block *sb, int level, bool wait)\n{\n\tbool force_trylock = false;\n\tint ret = 1;\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * We want lockdep to tell us about possible deadlocks with freezing\n\t * but it's it bit tricky to properly instrument it. Getting a freeze\n\t * protection works as getting a read lock but there are subtle\n\t * problems. XFS for example gets freeze protection on internal level\n\t * twice in some cases, which is OK only because we already hold a\n\t * freeze protection also on higher level. Due to these cases we have\n\t * to use wait == F (trylock mode) which must not fail.\n\t */\n\tif (wait) {\n\t\tint i;\n\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tif (percpu_rwsem_is_held(sb->s_writers.rw_sem + i)) {\n\t\t\t\tforce_trylock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n#endif\n\tif (wait && !force_trylock)\n\t\tpercpu_down_read(sb->s_writers.rw_sem + level-1);\n\telse\n\t\tret = percpu_down_read_trylock(sb->s_writers.rw_sem + level-1);\n\n\tWARN_ON(force_trylock && !ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "force_trylock && !ret"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_down_read_trylock",
          "args": [
            "sb->s_writers.rw_sem + level-1"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_down_read",
          "args": [
            "sb->s_writers.rw_sem + level-1"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_rwsem_is_held",
          "args": [
            "sb->s_writers.rw_sem + i"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint __sb_start_write(struct super_block *sb, int level, bool wait)\n{\n\tbool force_trylock = false;\n\tint ret = 1;\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * We want lockdep to tell us about possible deadlocks with freezing\n\t * but it's it bit tricky to properly instrument it. Getting a freeze\n\t * protection works as getting a read lock but there are subtle\n\t * problems. XFS for example gets freeze protection on internal level\n\t * twice in some cases, which is OK only because we already hold a\n\t * freeze protection also on higher level. Due to these cases we have\n\t * to use wait == F (trylock mode) which must not fail.\n\t */\n\tif (wait) {\n\t\tint i;\n\n\t\tfor (i = 0; i < level - 1; i++)\n\t\t\tif (percpu_rwsem_is_held(sb->s_writers.rw_sem + i)) {\n\t\t\t\tforce_trylock = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n#endif\n\tif (wait && !force_trylock)\n\t\tpercpu_down_read(sb->s_writers.rw_sem + level-1);\n\telse\n\t\tret = percpu_down_read_trylock(sb->s_writers.rw_sem + level-1);\n\n\tWARN_ON(force_trylock && !ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "__sb_end_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1351-1354",
    "snippet": "void __sb_end_write(struct super_block *sb, int level)\n{\n\tpercpu_up_read(sb->s_writers.rw_sem + level-1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_up_read",
          "args": [
            "sb->s_writers.rw_sem + level-1"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid __sb_end_write(struct super_block *sb, int level)\n{\n\tpercpu_up_read(sb->s_writers.rw_sem + level-1);\n}"
  },
  {
    "function_name": "super_setup_bdi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1338-1344",
    "snippet": "int super_setup_bdi(struct super_block *sb)\n{\n\tstatic atomic_long_t bdi_seq = ATOMIC_LONG_INIT(0);\n\n\treturn super_setup_bdi_name(sb, \"%.28s-%ld\", sb->s_type->name,\n\t\t\t\t    atomic_long_inc_return(&bdi_seq));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "super_setup_bdi_name",
          "args": [
            "sb",
            "\"%.28s-%ld\"",
            "sb->s_type->name",
            "atomic_long_inc_return(&bdi_seq)"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "super_setup_bdi_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1308-1331",
          "snippet": "int super_setup_bdi_name(struct super_block *sb, char *fmt, ...)\n{\n\tstruct backing_dev_info *bdi;\n\tint err;\n\tva_list args;\n\n\tbdi = bdi_alloc(GFP_KERNEL);\n\tif (!bdi)\n\t\treturn -ENOMEM;\n\n\tbdi->name = sb->s_type->name;\n\n\tva_start(args, fmt);\n\terr = bdi_register_va(bdi, fmt, args);\n\tva_end(args);\n\tif (err) {\n\t\tbdi_put(bdi);\n\t\treturn err;\n\t}\n\tWARN_ON(sb->s_bdi != &noop_backing_dev_info);\n\tsb->s_bdi = bdi;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint super_setup_bdi_name(struct super_block *sb, char *fmt, ...)\n{\n\tstruct backing_dev_info *bdi;\n\tint err;\n\tva_list args;\n\n\tbdi = bdi_alloc(GFP_KERNEL);\n\tif (!bdi)\n\t\treturn -ENOMEM;\n\n\tbdi->name = sb->s_type->name;\n\n\tva_start(args, fmt);\n\terr = bdi_register_va(bdi, fmt, args);\n\tva_end(args);\n\tif (err) {\n\t\tbdi_put(bdi);\n\t\treturn err;\n\t}\n\tWARN_ON(sb->s_bdi != &noop_backing_dev_info);\n\tsb->s_bdi = bdi;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc_return",
          "args": [
            "&bdi_seq"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_LONG_INIT",
          "args": [
            "0"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint super_setup_bdi(struct super_block *sb)\n{\n\tstatic atomic_long_t bdi_seq = ATOMIC_LONG_INIT(0);\n\n\treturn super_setup_bdi_name(sb, \"%.28s-%ld\", sb->s_type->name,\n\t\t\t\t    atomic_long_inc_return(&bdi_seq));\n}"
  },
  {
    "function_name": "super_setup_bdi_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1308-1331",
    "snippet": "int super_setup_bdi_name(struct super_block *sb, char *fmt, ...)\n{\n\tstruct backing_dev_info *bdi;\n\tint err;\n\tva_list args;\n\n\tbdi = bdi_alloc(GFP_KERNEL);\n\tif (!bdi)\n\t\treturn -ENOMEM;\n\n\tbdi->name = sb->s_type->name;\n\n\tva_start(args, fmt);\n\terr = bdi_register_va(bdi, fmt, args);\n\tva_end(args);\n\tif (err) {\n\t\tbdi_put(bdi);\n\t\treturn err;\n\t}\n\tWARN_ON(sb->s_bdi != &noop_backing_dev_info);\n\tsb->s_bdi = bdi;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sb->s_bdi != &noop_backing_dev_info"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_put",
          "args": [
            "bdi"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_register_va",
          "args": [
            "bdi",
            "fmt",
            "args"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_alloc",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint super_setup_bdi_name(struct super_block *sb, char *fmt, ...)\n{\n\tstruct backing_dev_info *bdi;\n\tint err;\n\tva_list args;\n\n\tbdi = bdi_alloc(GFP_KERNEL);\n\tif (!bdi)\n\t\treturn -ENOMEM;\n\n\tbdi->name = sb->s_type->name;\n\n\tva_start(args, fmt);\n\terr = bdi_register_va(bdi, fmt, args);\n\tva_end(args);\n\tif (err) {\n\t\tbdi_put(bdi);\n\t\treturn err;\n\t}\n\tWARN_ON(sb->s_bdi != &noop_backing_dev_info);\n\tsb->s_bdi = bdi;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mount_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1243-1302",
    "snippet": "struct dentry *\nmount_fs(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct dentry *root;\n\tstruct super_block *sb;\n\tchar *secdata = NULL;\n\tint error = -ENOMEM;\n\n\tif (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {\n\t\tsecdata = alloc_secdata();\n\t\tif (!secdata)\n\t\t\tgoto out;\n\n\t\terror = security_sb_copy_data(data, secdata);\n\t\tif (error)\n\t\t\tgoto out_free_secdata;\n\t}\n\n\troot = type->mount(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\terror = PTR_ERR(root);\n\t\tgoto out_free_secdata;\n\t}\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\tWARN_ON(!sb->s_bdi);\n\n\t/*\n\t * Write barrier is for super_cache_count(). We place it before setting\n\t * SB_BORN as the data dependency between the two functions is the\n\t * superblock structure contents that we just set up, not the SB_BORN\n\t * flag.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= SB_BORN;\n\n\terror = security_sb_kern_mount(sb, flags, secdata);\n\tif (error)\n\t\tgoto out_sb;\n\n\t/*\n\t * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE\n\t * but s_maxbytes was an unsigned long long for many releases. Throw\n\t * this warning for a little while to try and catch filesystems that\n\t * violate this rule.\n\t */\n\tWARN((sb->s_maxbytes < 0), \"%s set sb->s_maxbytes to \"\n\t\t\"negative value (%lld)\\n\", type->name, sb->s_maxbytes);\n\n\tup_write(&sb->s_umount);\n\tfree_secdata(secdata);\n\treturn root;\nout_sb:\n\tdput(root);\n\tdeactivate_locked_super(sb);\nout_free_secdata:\n\tfree_secdata(secdata);\nout:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_secdata",
          "args": [
            "secdata"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "root"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "813-834",
          "snippet": "void dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid dput(struct dentry *dentry)\n{\n\twhile (dentry) {\n\t\tmight_sleep();\n\n\t\trcu_read_lock();\n\t\tif (likely(fast_dput(dentry))) {\n\t\t\trcu_read_unlock();\n\t\t\treturn;\n\t\t}\n\n\t\t/* Slow case: now with the dentry lock held */\n\t\trcu_read_unlock();\n\n\t\tif (likely(retain_dentry(dentry))) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tdentry = dentry_kill(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_secdata",
          "args": [
            "secdata"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "(sb->s_maxbytes < 0)",
            "\"%s set sb->s_maxbytes to \"\n\t\t\"negative value (%lld)\\n\"",
            "type->name",
            "sb->s_maxbytes"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_kern_mount",
          "args": [
            "sb",
            "flags",
            "secdata"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sb->s_bdi"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!sb"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->mount",
          "args": [
            "type",
            "flags",
            "name",
            "data"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_copy_data",
          "args": [
            "data",
            "secdata"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_secdata",
          "args": [],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstruct dentry *\nmount_fs(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct dentry *root;\n\tstruct super_block *sb;\n\tchar *secdata = NULL;\n\tint error = -ENOMEM;\n\n\tif (data && !(type->fs_flags & FS_BINARY_MOUNTDATA)) {\n\t\tsecdata = alloc_secdata();\n\t\tif (!secdata)\n\t\t\tgoto out;\n\n\t\terror = security_sb_copy_data(data, secdata);\n\t\tif (error)\n\t\t\tgoto out_free_secdata;\n\t}\n\n\troot = type->mount(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\terror = PTR_ERR(root);\n\t\tgoto out_free_secdata;\n\t}\n\tsb = root->d_sb;\n\tBUG_ON(!sb);\n\tWARN_ON(!sb->s_bdi);\n\n\t/*\n\t * Write barrier is for super_cache_count(). We place it before setting\n\t * SB_BORN as the data dependency between the two functions is the\n\t * superblock structure contents that we just set up, not the SB_BORN\n\t * flag.\n\t */\n\tsmp_wmb();\n\tsb->s_flags |= SB_BORN;\n\n\terror = security_sb_kern_mount(sb, flags, secdata);\n\tif (error)\n\t\tgoto out_sb;\n\n\t/*\n\t * filesystems should never set s_maxbytes larger than MAX_LFS_FILESIZE\n\t * but s_maxbytes was an unsigned long long for many releases. Throw\n\t * this warning for a little while to try and catch filesystems that\n\t * violate this rule.\n\t */\n\tWARN((sb->s_maxbytes < 0), \"%s set sb->s_maxbytes to \"\n\t\t\"negative value (%lld)\\n\", type->name, sb->s_maxbytes);\n\n\tup_write(&sb->s_umount);\n\tfree_secdata(secdata);\n\treturn root;\nout_sb:\n\tdput(root);\n\tdeactivate_locked_super(sb);\nout_free_secdata:\n\tfree_secdata(secdata);\nout:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "mount_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1219-1240",
    "snippet": "struct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *s;\n\tint error;\n\n\ts = sget(fs_type, compare_single, set_anon_super, flags, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\tif (!s->s_root) {\n\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\ts->s_flags |= SB_ACTIVE;\n\t} else {\n\t\tdo_remount_sb(s, flags, data, 0);\n\t}\n\treturn dget(s->s_root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "s->s_root"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_remount_sb",
          "args": [
            "s",
            "flags",
            "data",
            "0"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "do_remount_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "845-917",
          "snippet": "int do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(sb_flags & SB_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &sb_flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (sb_flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(sb_flags & SB_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &sb_flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (sb_flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_super",
          "args": [
            "s",
            "data",
            "flags & SB_SILENT ? 1 : 0"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "1002-1234",
          "snippet": "static int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ocfs2_debugfs_root;",
            "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_sync_fs(struct super_block *sb, int wait);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
            "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
            "static const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *ocfs2_debugfs_root;\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "s"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "compare_single",
            "set_anon_super",
            "flags",
            "NULL"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "sget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "551-571",
          "snippet": "struct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\t/* We don't yet pass the user namespace of the parent\n\t * mount through to here so always use &init_user_ns\n\t * until that changes.\n\t */\n\tif (flags & SB_SUBMOUNT)\n\t\tuser_ns = &init_user_ns;\n\n\t/* Ensure the requestor has permissions over the target filesystem */\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn sget_userns(type, test, set, flags, user_ns, data);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\t/* We don't yet pass the user namespace of the parent\n\t * mount through to here so always use &init_user_ns\n\t * until that changes.\n\t */\n\tif (flags & SB_SUBMOUNT)\n\t\tuser_ns = &init_user_ns;\n\n\t/* Ensure the requestor has permissions over the target filesystem */\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn sget_userns(type, test, set, flags, user_ns, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *s;\n\tint error;\n\n\ts = sget(fs_type, compare_single, set_anon_super, flags, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\tif (!s->s_root) {\n\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\ts->s_flags |= SB_ACTIVE;\n\t} else {\n\t\tdo_remount_sb(s, flags, data, 0);\n\t}\n\treturn dget(s->s_root);\n}"
  },
  {
    "function_name": "compare_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1214-1217",
    "snippet": "static int compare_single(struct super_block *s, void *p)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int compare_single(struct super_block *s, void *p)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "mount_nodev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1194-1211",
    "snippet": "struct dentry *mount_nodev(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tint error;\n\tstruct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);\n\tif (error) {\n\t\tdeactivate_locked_super(s);\n\t\treturn ERR_PTR(error);\n\t}\n\ts->s_flags |= SB_ACTIVE;\n\treturn dget(s->s_root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "s->s_root"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_super",
          "args": [
            "s",
            "data",
            "flags & SB_SILENT ? 1 : 0"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "1002-1234",
          "snippet": "static int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ocfs2_debugfs_root;",
            "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_sync_fs(struct super_block *sb, int wait);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
            "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
            "static const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *ocfs2_debugfs_root;\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "s"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "NULL",
            "set_anon_super",
            "flags",
            "NULL"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "sget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "551-571",
          "snippet": "struct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\t/* We don't yet pass the user namespace of the parent\n\t * mount through to here so always use &init_user_ns\n\t * until that changes.\n\t */\n\tif (flags & SB_SUBMOUNT)\n\t\tuser_ns = &init_user_ns;\n\n\t/* Ensure the requestor has permissions over the target filesystem */\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn sget_userns(type, test, set, flags, user_ns, data);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\t/* We don't yet pass the user namespace of the parent\n\t * mount through to here so always use &init_user_ns\n\t * until that changes.\n\t */\n\tif (flags & SB_SUBMOUNT)\n\t\tuser_ns = &init_user_ns;\n\n\t/* Ensure the requestor has permissions over the target filesystem */\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn sget_userns(type, test, set, flags, user_ns, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct dentry *mount_nodev(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tint error;\n\tstruct super_block *s = sget(fs_type, NULL, set_anon_super, flags, NULL);\n\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\n\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);\n\tif (error) {\n\t\tdeactivate_locked_super(s);\n\t\treturn ERR_PTR(error);\n\t}\n\ts->s_flags |= SB_ACTIVE;\n\treturn dget(s->s_root);\n}"
  },
  {
    "function_name": "kill_block_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1179-1189",
    "snippet": "void kill_block_super(struct super_block *sb)\n{\n\tstruct block_device *bdev = sb->s_bdev;\n\tfmode_t mode = sb->s_mode;\n\n\tbdev->bd_super = NULL;\n\tgeneric_shutdown_super(sb);\n\tsync_blockdev(bdev);\n\tWARN_ON_ONCE(!(mode & FMODE_EXCL));\n\tblkdev_put(bdev, mode | FMODE_EXCL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "mode | FMODE_EXCL"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1814-1859",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(mode & FMODE_EXCL)"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "bdev"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "456-459",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_shutdown_super",
          "args": [
            "sb"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "generic_shutdown_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "436-473",
          "snippet": "void generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~SB_ACTIVE;\n\n\t\tfsnotify_sb_delete(sb);\n\t\tcgroup_writeback_umount();\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n\tif (sb->s_bdi != &noop_backing_dev_info) {\n\t\tbdi_put(sb->s_bdi);\n\t\tsb->s_bdi = &noop_backing_dev_info;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~SB_ACTIVE;\n\n\t\tfsnotify_sb_delete(sb);\n\t\tcgroup_writeback_umount();\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n\tif (sb->s_bdi != &noop_backing_dev_info) {\n\t\tbdi_put(sb->s_bdi);\n\t\tsb->s_bdi = &noop_backing_dev_info;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid kill_block_super(struct super_block *sb)\n{\n\tstruct block_device *bdev = sb->s_bdev;\n\tfmode_t mode = sb->s_mode;\n\n\tbdev->bd_super = NULL;\n\tgeneric_shutdown_super(sb);\n\tsync_blockdev(bdev);\n\tWARN_ON_ONCE(!(mode & FMODE_EXCL));\n\tblkdev_put(bdev, mode | FMODE_EXCL);\n}"
  },
  {
    "function_name": "mount_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1104-1176",
    "snippet": "struct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error = 0;\n\n\tif (!(flags & SB_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | SB_NOSEC,\n\t\t bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s))\n\t\tgoto error_s;\n\n\tif (s->s_root) {\n\t\tif ((flags ^ s->s_flags) & SB_RDONLY) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\terror = -EBUSY;\n\t\t\tgoto error_bdev;\n\t\t}\n\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t} else {\n\t\ts->s_mode = mode;\n\t\tsnprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\tgoto error;\n\t\t}\n\n\t\ts->s_flags |= SB_ACTIVE;\n\t\tbdev->bd_super = s;\n\t}\n\n\treturn dget(s->s_root);\n\nerror_s:\n\terror = PTR_ERR(s);\nerror_bdev:\n\tblkdev_put(bdev, mode);\nerror:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "bdev",
            "mode"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1814-1859",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "s"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "s->s_root"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_super",
          "args": [
            "s",
            "data",
            "flags & SB_SILENT ? 1 : 0"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "1002-1234",
          "snippet": "static int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ocfs2_debugfs_root;",
            "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_sync_fs(struct super_block *sb, int wait);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
            "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
            "static const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *ocfs2_debugfs_root;\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "block_size(bdev)"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "129-138",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_size",
          "args": [
            "bdev"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "block_size_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "1623-1626",
          "snippet": "static inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nstatic inline int block_size_bits(unsigned int blocksize)\n{\n\treturn ilog2(blocksize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "s->s_id",
            "sizeof(s->s_id)",
            "\"%pg\"",
            "bdev"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "dbg_snprintf_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ubifs/debug.c",
          "lines": "102-139",
          "snippet": "const char *dbg_snprintf_key(const struct ubifs_info *c,\n\t\t\t     const union ubifs_key *key, char *buffer, int len)\n{\n\tchar *p = buffer;\n\tint type = key_type(c, key);\n\n\tif (c->key_fmt == UBIFS_SIMPLE_KEY_FMT) {\n\t\tswitch (type) {\n\t\tcase UBIFS_INO_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tcase UBIFS_DENT_KEY:\n\t\tcase UBIFS_XENT_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %#08x)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_hash(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_DATA_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %u)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_block(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_TRUN_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen -= snprintf(p, len, \"(bad key type: %#08x, %#08x)\",\n\t\t\t\t\tkey->u32[0], key->u32[1]);\n\t\t}\n\t} else\n\t\tlen -= snprintf(p, len, \"bad key format %d\", c->key_fmt);\n\tubifs_assert(c, len > 0);\n\treturn p;\n}",
          "includes": [
            "#include \"ubifs.h\"",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ubifs.h\"\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n\nconst char *dbg_snprintf_key(const struct ubifs_info *c,\n\t\t\t     const union ubifs_key *key, char *buffer, int len)\n{\n\tchar *p = buffer;\n\tint type = key_type(c, key);\n\n\tif (c->key_fmt == UBIFS_SIMPLE_KEY_FMT) {\n\t\tswitch (type) {\n\t\tcase UBIFS_INO_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tcase UBIFS_DENT_KEY:\n\t\tcase UBIFS_XENT_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %#08x)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_hash(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_DATA_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s, %u)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type), key_block(c, key));\n\t\t\tbreak;\n\t\tcase UBIFS_TRUN_KEY:\n\t\t\tlen -= snprintf(p, len, \"(%lu, %s)\",\n\t\t\t\t\t(unsigned long)key_inum(c, key),\n\t\t\t\t\tget_key_type(type));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen -= snprintf(p, len, \"(bad key type: %#08x, %#08x)\",\n\t\t\t\t\tkey->u32[0], key->u32[1]);\n\t\t}\n\t} else\n\t\tlen -= snprintf(p, len, \"bad key format %d\", c->key_fmt);\n\tubifs_assert(c, len > 0);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "test_bdev_super",
            "set_bdev_super",
            "flags | SB_NOSEC",
            "bdev"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "sget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "551-571",
          "snippet": "struct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\t/* We don't yet pass the user namespace of the parent\n\t * mount through to here so always use &init_user_ns\n\t * until that changes.\n\t */\n\tif (flags & SB_SUBMOUNT)\n\t\tuser_ns = &init_user_ns;\n\n\t/* Ensure the requestor has permissions over the target filesystem */\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn sget_userns(type, test, set, flags, user_ns, data);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\t/* We don't yet pass the user namespace of the parent\n\t * mount through to here so always use &init_user_ns\n\t * until that changes.\n\t */\n\tif (flags & SB_SUBMOUNT)\n\t\tuser_ns = &init_user_ns;\n\n\t/* Ensure the requestor has permissions over the target filesystem */\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn sget_userns(type, test, set, flags, user_ns, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&bdev->bd_fsfreeze_mutex"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "bdev"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bdev"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_path",
          "args": [
            "dev_name",
            "mode",
            "fs_type"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "1685-1705",
          "snippet": "struct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_path(const char *path, fmode_t mode,\n\t\t\t\t\tvoid *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = lookup_bdev(path);\n\tif (IS_ERR(bdev))\n\t\treturn bdev;\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tif ((mode & FMODE_WRITE) && bdev_read_only(bdev)) {\n\t\tblkdev_put(bdev, mode);\n\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\treturn bdev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct dentry *mount_bdev(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct block_device *bdev;\n\tstruct super_block *s;\n\tfmode_t mode = FMODE_READ | FMODE_EXCL;\n\tint error = 0;\n\n\tif (!(flags & SB_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\tbdev = blkdev_get_by_path(dev_name, mode, fs_type);\n\tif (IS_ERR(bdev))\n\t\treturn ERR_CAST(bdev);\n\n\t/*\n\t * once the super is inserted into the list by sget, s_umount\n\t * will protect the lockfs code from trying to start a snapshot\n\t * while we are mounting\n\t */\n\tmutex_lock(&bdev->bd_fsfreeze_mutex);\n\tif (bdev->bd_fsfreeze_count > 0) {\n\t\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\t\terror = -EBUSY;\n\t\tgoto error_bdev;\n\t}\n\ts = sget(fs_type, test_bdev_super, set_bdev_super, flags | SB_NOSEC,\n\t\t bdev);\n\tmutex_unlock(&bdev->bd_fsfreeze_mutex);\n\tif (IS_ERR(s))\n\t\tgoto error_s;\n\n\tif (s->s_root) {\n\t\tif ((flags ^ s->s_flags) & SB_RDONLY) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\terror = -EBUSY;\n\t\t\tgoto error_bdev;\n\t\t}\n\n\t\t/*\n\t\t * s_umount nests inside bd_mutex during\n\t\t * __invalidate_device().  blkdev_put() acquires\n\t\t * bd_mutex and can't be called under s_umount.  Drop\n\t\t * s_umount temporarily.  This is safe as we're\n\t\t * holding an active reference.\n\t\t */\n\t\tup_write(&s->s_umount);\n\t\tblkdev_put(bdev, mode);\n\t\tdown_write(&s->s_umount);\n\t} else {\n\t\ts->s_mode = mode;\n\t\tsnprintf(s->s_id, sizeof(s->s_id), \"%pg\", bdev);\n\t\tsb_set_blocksize(s, block_size(bdev));\n\t\terror = fill_super(s, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\tgoto error;\n\t\t}\n\n\t\ts->s_flags |= SB_ACTIVE;\n\t\tbdev->bd_super = s;\n\t}\n\n\treturn dget(s->s_root);\n\nerror_s:\n\terror = PTR_ERR(s);\nerror_bdev:\n\tblkdev_put(bdev, mode);\nerror:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "test_bdev_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1099-1102",
    "snippet": "static int test_bdev_super(struct super_block *s, void *data)\n{\n\treturn (void *)s->s_bdev == data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int test_bdev_super(struct super_block *s, void *data)\n{\n\treturn (void *)s->s_bdev == data;\n}"
  },
  {
    "function_name": "set_bdev_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1090-1097",
    "snippet": "static int set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\ts->s_bdi = bdi_get(s->s_bdev->bd_bdi);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_get",
          "args": [
            "s->s_bdev->bd_bdi"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\ts->s_bdi = bdi_get(s->s_bdev->bd_bdi);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mount_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1056-1085",
    "snippet": "struct dentry *mount_ns(struct file_system_type *fs_type,\n\tint flags, void *data, void *ns, struct user_namespace *user_ns,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *sb;\n\n\t/* Don't allow mounting unless the caller has CAP_SYS_ADMIN\n\t * over the namespace.\n\t */\n\tif (!(flags & SB_KERNMOUNT) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = sget_userns(fs_type, ns_test_super, ns_set_super, flags,\n\t\t\t user_ns, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tint err;\n\t\terr = fill_super(sb, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= SB_ACTIVE;\n\t}\n\n\treturn dget(sb->s_root);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "849-886",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = READ_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == READ_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "sb"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_super",
          "args": [
            "sb",
            "data",
            "flags & SB_SILENT ? 1 : 0"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "1002-1234",
          "snippet": "static int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ocfs2_debugfs_root;",
            "static int ocfs2_show_options(struct seq_file *s, struct dentry *root);",
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_sync_fs(struct super_block *sb, int wait);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);",
            "static int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static void ocfs2_destroy_inode(struct inode *inode);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);",
            "static const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct dentry *ocfs2_debugfs_root;\nstatic int ocfs2_show_options(struct seq_file *s, struct dentry *root);\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic int ocfs2_verify_volume(struct ocfs2_dinode *di,\n\t\t\t       struct buffer_head *bh,\n\t\t\t       u32 sectsize,\n\t\t\t       struct ocfs2_blockcheck_stats *stats);\nstatic int ocfs2_initialize_super(struct super_block *sb,\n\t\t\t\t  struct buffer_head *bh,\n\t\t\t\t  int sector_size,\n\t\t\t\t  struct ocfs2_blockcheck_stats *stats);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic void ocfs2_destroy_inode(struct inode *inode);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\nstatic const struct file_operations ocfs2_osb_debug_fops = {\n\t.open =\t\tocfs2_osb_debug_open,\n\t.release =\tocfs2_debug_release,\n\t.read =\t\tocfs2_debug_read,\n\t.llseek =\tgeneric_file_llseek,\n};\n\nstatic int ocfs2_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct dentry *root;\n\tint status, sector_size;\n\tstruct mount_options parsed_options;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_super *osb = NULL;\n\tstruct buffer_head *bh = NULL;\n\tchar nodestr[12];\n\tstruct ocfs2_blockcheck_stats stats;\n\n\ttrace_ocfs2_fill_super(sb, data, silent);\n\n\tif (!ocfs2_parse_options(sb, data, &parsed_options, 0)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\n\t/* probe for superblock */\n\tstatus = ocfs2_sb_probe(sb, &bh, &sector_size, &stats);\n\tif (status < 0) {\n\t\tmlog(ML_ERROR, \"superblock probe failed!\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tstatus = ocfs2_initialize_super(sb, bh, sector_size, &stats);\n\tosb = OCFS2_SB(sb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\tif (!ocfs2_check_set_options(sb, &parsed_options)) {\n\t\tstatus = -EINVAL;\n\t\tgoto read_super_error;\n\t}\n\tosb->s_mount_opt = parsed_options.mount_opt;\n\tosb->s_atime_quantum = parsed_options.atime_quantum;\n\tosb->preferred_slot = parsed_options.slot;\n\tosb->osb_commit_interval = parsed_options.commit_interval;\n\n\tocfs2_la_set_sizes(osb, parsed_options.localalloc_opt);\n\tosb->osb_resv_level = parsed_options.resv_level;\n\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\tif (parsed_options.dir_resv_level == -1)\n\t\tosb->osb_dir_resv_level = parsed_options.resv_level;\n\telse\n\t\tosb->osb_dir_resv_level = parsed_options.dir_resv_level;\n\n\tstatus = ocfs2_verify_userspace_stack(osb, &parsed_options);\n\tif (status)\n\t\tgoto read_super_error;\n\n\tsb->s_magic = OCFS2_SUPER_MAGIC;\n\n\tsb->s_flags = (sb->s_flags & ~(SB_POSIXACL | SB_NOSEC)) |\n\t\t((osb->s_mount_opt & OCFS2_MOUNT_POSIX_ACL) ? SB_POSIXACL : 0);\n\n\t/* Hard readonly mode only if: bdev_read_only, SB_RDONLY,\n\t * heartbeat=none */\n\tif (bdev_read_only(sb->s_bdev)) {\n\t\tif (!sb_rdonly(sb)) {\n\t\t\tstatus = -EACCES;\n\t\t\tmlog(ML_ERROR, \"Readonly device detected but readonly \"\n\t\t\t     \"mount was not specified.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\t/* You should not be able to start a local heartbeat\n\t\t * on a readonly device. */\n\t\tif (osb->s_mount_opt & OCFS2_MOUNT_HB_LOCAL) {\n\t\t\tstatus = -EROFS;\n\t\t\tmlog(ML_ERROR, \"Local heartbeat specified on readonly \"\n\t\t\t     \"device.\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tstatus = ocfs2_check_journals_nolocks(osb);\n\t\tif (status < 0) {\n\t\t\tif (status == -EROFS)\n\t\t\t\tmlog(ML_ERROR, \"Recovery required on readonly \"\n\t\t\t\t     \"file system, but write access is \"\n\t\t\t\t     \"unavailable.\\n\");\n\t\t\telse\n\t\t\t\tmlog_errno(status);\n\t\t\tgoto read_super_error;\n\t\t}\n\n\t\tocfs2_set_ro_flag(osb, 1);\n\n\t\tprintk(KERN_NOTICE \"ocfs2: Readonly device (%s) detected. \"\n\t\t       \"Cluster services will not be used for this mount. \"\n\t\t       \"Recovery will be skipped.\\n\", osb->dev_str);\n\t}\n\n\tif (!ocfs2_is_hard_readonly(osb)) {\n\t\tif (sb_rdonly(sb))\n\t\t\tocfs2_set_ro_flag(osb, 0);\n\t}\n\n\tstatus = ocfs2_verify_heartbeat(osb);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_debug_root = debugfs_create_dir(osb->uuid_str,\n\t\t\t\t\t\t ocfs2_debugfs_root);\n\tif (!osb->osb_debug_root) {\n\t\tstatus = -EINVAL;\n\t\tmlog(ML_ERROR, \"Unable to create per-mount debugfs root.\\n\");\n\t\tgoto read_super_error;\n\t}\n\n\tosb->osb_ctxt = debugfs_create_file(\"fs_state\", S_IFREG|S_IRUSR,\n\t\t\t\t\t    osb->osb_debug_root,\n\t\t\t\t\t    osb,\n\t\t\t\t\t    &ocfs2_osb_debug_fops);\n\tif (!osb->osb_ctxt) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_meta_ecc(osb)) {\n\t\tstatus = ocfs2_blockcheck_stats_debugfs_install(\n\t\t\t\t\t\t&osb->osb_ecc_stats,\n\t\t\t\t\t\tosb->osb_debug_root);\n\t\tif (status) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"Unable to create blockcheck statistics \"\n\t\t\t     \"files\\n\");\n\t\t\tgoto read_super_error;\n\t\t}\n\t}\n\n\tstatus = ocfs2_mount_volume(sb);\n\tif (status < 0)\n\t\tgoto read_super_error;\n\n\tif (osb->root_inode)\n\t\tinode = igrab(osb->root_inode);\n\n\tif (!inode) {\n\t\tstatus = -EIO;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\troot = d_make_root(inode);\n\tif (!root) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto read_super_error;\n\t}\n\n\tsb->s_root = root;\n\n\tocfs2_complete_mount_recovery(osb);\n\n\tosb->osb_dev_kset = kset_create_and_add(sb->s_id, NULL,\n\t\t\t\t\t\t&ocfs2_kset->kobj);\n\tif (!osb->osb_dev_kset) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create device kset %s.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\t/* Create filecheck sysfs related directories/files at\n\t * /sys/fs/ocfs2/<devname>/filecheck */\n\tif (ocfs2_filecheck_create_sysfs(osb)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog(ML_ERROR, \"Unable to create filecheck sysfs directory at \"\n\t\t\t\"/sys/fs/ocfs2/%s/filecheck.\\n\", sb->s_id);\n\t\tgoto read_super_error;\n\t}\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Mounting device (%s) on (node %s, slot %d) \"\n\t       \"with %s data mode.\\n\",\n\t       osb->dev_str, nodestr, osb->slot_num,\n\t       osb->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK ? \"writeback\" :\n\t       \"ordered\");\n\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Now we can initialize quotas because we can afford to wait\n\t * for cluster locks recovery now. That also means that truncation\n\t * log recovery can happen but that waits for proper quota setup */\n\tif (!sb_rdonly(sb)) {\n\t\tstatus = ocfs2_enable_quotas(osb);\n\t\tif (status < 0) {\n\t\t\t/* We have to err-out specially here because\n\t\t\t * s_root is already set */\n\t\t\tmlog_errno(status);\n\t\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\t\twake_up(&osb->osb_mount_event);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tocfs2_complete_quota_recovery(osb);\n\n\t/* Now we wake up again for processes waiting for quotas */\n\tatomic_set(&osb->vol_state, VOLUME_MOUNTED_QUOTAS);\n\twake_up(&osb->osb_mount_event);\n\n\t/* Start this when the mount is almost sure of being successful */\n\tocfs2_orphan_scan_start(osb);\n\n\treturn status;\n\nread_super_error:\n\tbrelse(bh);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\tif (osb) {\n\t\tatomic_set(&osb->vol_state, VOLUME_DISABLED);\n\t\twake_up(&osb->osb_mount_event);\n\t\tocfs2_dismount_volume(sb, 1);\n\t}\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "sb"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sb"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget_userns",
          "args": [
            "fs_type",
            "ns_test_super",
            "ns_set_super",
            "flags",
            "user_ns",
            "ns"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "sget_userns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "486-539",
          "snippet": "struct super_block *sget_userns(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, struct user_namespace *user_ns,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&\n\t    !(type->fs_flags & FS_USERNS_MOUNT) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (user_ns != old->s_user_ns) {\n\t\t\t\tspin_unlock(&sb_lock);\n\t\t\t\tdestroy_unused_super(s);\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tdestroy_unused_super(s);\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, (flags & ~SB_SUBMOUNT), user_ns);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tdestroy_unused_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker_prepared(&s->s_shrink);\n\treturn s;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *sget_userns(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, struct user_namespace *user_ns,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&\n\t    !(type->fs_flags & FS_USERNS_MOUNT) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (user_ns != old->s_user_ns) {\n\t\t\t\tspin_unlock(&sb_lock);\n\t\t\t\tdestroy_unused_super(s);\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tdestroy_unused_super(s);\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, (flags & ~SB_SUBMOUNT), user_ns);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tdestroy_unused_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker_prepared(&s->s_shrink);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstruct dentry *mount_ns(struct file_system_type *fs_type,\n\tint flags, void *data, void *ns, struct user_namespace *user_ns,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *sb;\n\n\t/* Don't allow mounting unless the caller has CAP_SYS_ADMIN\n\t * over the namespace.\n\t */\n\tif (!(flags & SB_KERNMOUNT) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\tsb = sget_userns(fs_type, ns_test_super, ns_set_super, flags,\n\t\t\t user_ns, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!sb->s_root) {\n\t\tint err;\n\t\terr = fill_super(sb, data, flags & SB_SILENT ? 1 : 0);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= SB_ACTIVE;\n\t}\n\n\treturn dget(sb->s_root);\n}"
  },
  {
    "function_name": "ns_set_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1050-1054",
    "snippet": "static int ns_set_super(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_anon_super",
          "args": [
            "sb",
            "NULL"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "set_anon_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1023-1026",
          "snippet": "int set_anon_super(struct super_block *s, void *data)\n{\n\treturn get_anon_bdev(&s->s_dev);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nint set_anon_super(struct super_block *s, void *data)\n{\n\treturn get_anon_bdev(&s->s_dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic int ns_set_super(struct super_block *sb, void *data)\n{\n\tsb->s_fs_info = data;\n\treturn set_anon_super(sb, NULL);\n}"
  },
  {
    "function_name": "ns_test_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1045-1048",
    "snippet": "static int ns_test_super(struct super_block *sb, void *data)\n{\n\treturn sb->s_fs_info == data;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic int ns_test_super(struct super_block *sb, void *data)\n{\n\treturn sb->s_fs_info == data;\n}"
  },
  {
    "function_name": "kill_litter_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1037-1042",
    "snippet": "void kill_litter_super(struct super_block *sb)\n{\n\tif (sb->s_root)\n\t\td_genocide(sb->s_root);\n\tkill_anon_super(sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "sb"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "kill_anon_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1029-1034",
          "snippet": "void kill_anon_super(struct super_block *sb)\n{\n\tdev_t dev = sb->s_dev;\n\tgeneric_shutdown_super(sb);\n\tfree_anon_bdev(dev);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid kill_anon_super(struct super_block *sb)\n{\n\tdev_t dev = sb->s_dev;\n\tgeneric_shutdown_super(sb);\n\tfree_anon_bdev(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_genocide",
          "args": [
            "sb->s_root"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "d_genocide",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "3010-3013",
          "snippet": "void d_genocide(struct dentry *parent)\n{\n\td_walk(parent, parent, d_genocide_kill);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid d_genocide(struct dentry *parent)\n{\n\td_walk(parent, parent, d_genocide_kill);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid kill_litter_super(struct super_block *sb)\n{\n\tif (sb->s_root)\n\t\td_genocide(sb->s_root);\n\tkill_anon_super(sb);\n}"
  },
  {
    "function_name": "kill_anon_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1029-1034",
    "snippet": "void kill_anon_super(struct super_block *sb)\n{\n\tdev_t dev = sb->s_dev;\n\tgeneric_shutdown_super(sb);\n\tfree_anon_bdev(dev);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_anon_bdev",
          "args": [
            "dev"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "free_anon_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1017-1020",
          "snippet": "void free_anon_bdev(dev_t dev)\n{\n\tida_free(&unnamed_dev_ida, MINOR(dev));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(unnamed_dev_ida);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_IDA(unnamed_dev_ida);\n\nvoid free_anon_bdev(dev_t dev)\n{\n\tida_free(&unnamed_dev_ida, MINOR(dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_shutdown_super",
          "args": [
            "sb"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "generic_shutdown_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "436-473",
          "snippet": "void generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~SB_ACTIVE;\n\n\t\tfsnotify_sb_delete(sb);\n\t\tcgroup_writeback_umount();\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n\tif (sb->s_bdi != &noop_backing_dev_info) {\n\t\tbdi_put(sb->s_bdi);\n\t\tsb->s_bdi = &noop_backing_dev_info;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~SB_ACTIVE;\n\n\t\tfsnotify_sb_delete(sb);\n\t\tcgroup_writeback_umount();\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n\tif (sb->s_bdi != &noop_backing_dev_info) {\n\t\tbdi_put(sb->s_bdi);\n\t\tsb->s_bdi = &noop_backing_dev_info;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid kill_anon_super(struct super_block *sb)\n{\n\tdev_t dev = sb->s_dev;\n\tgeneric_shutdown_super(sb);\n\tfree_anon_bdev(dev);\n}"
  },
  {
    "function_name": "set_anon_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1023-1026",
    "snippet": "int set_anon_super(struct super_block *s, void *data)\n{\n\treturn get_anon_bdev(&s->s_dev);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_anon_bdev",
          "args": [
            "&s->s_dev"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "get_anon_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "997-1014",
          "snippet": "int get_anon_bdev(dev_t *p)\n{\n\tint dev;\n\n\t/*\n\t * Many userspace utilities consider an FSID of 0 invalid.\n\t * Always return at least 1 from get_anon_bdev.\n\t */\n\tdev = ida_alloc_range(&unnamed_dev_ida, 1, (1 << MINORBITS) - 1,\n\t\t\tGFP_ATOMIC);\n\tif (dev == -ENOSPC)\n\t\tdev = -EMFILE;\n\tif (dev < 0)\n\t\treturn dev;\n\n\t*p = MKDEV(0, dev);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDA(unnamed_dev_ida);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_IDA(unnamed_dev_ida);\n\nint get_anon_bdev(dev_t *p)\n{\n\tint dev;\n\n\t/*\n\t * Many userspace utilities consider an FSID of 0 invalid.\n\t * Always return at least 1 from get_anon_bdev.\n\t */\n\tdev = ida_alloc_range(&unnamed_dev_ida, 1, (1 << MINORBITS) - 1,\n\t\t\tGFP_ATOMIC);\n\tif (dev == -ENOSPC)\n\t\tdev = -EMFILE;\n\tif (dev < 0)\n\t\treturn dev;\n\n\t*p = MKDEV(0, dev);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nint set_anon_super(struct super_block *s, void *data)\n{\n\treturn get_anon_bdev(&s->s_dev);\n}"
  },
  {
    "function_name": "free_anon_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "1017-1020",
    "snippet": "void free_anon_bdev(dev_t dev)\n{\n\tida_free(&unnamed_dev_ida, MINOR(dev));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDA(unnamed_dev_ida);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ida_free",
          "args": [
            "&unnamed_dev_ida",
            "MINOR(dev)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_IDA(unnamed_dev_ida);\n\nvoid free_anon_bdev(dev_t dev)\n{\n\tida_free(&unnamed_dev_ida, MINOR(dev));\n}"
  },
  {
    "function_name": "get_anon_bdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "997-1014",
    "snippet": "int get_anon_bdev(dev_t *p)\n{\n\tint dev;\n\n\t/*\n\t * Many userspace utilities consider an FSID of 0 invalid.\n\t * Always return at least 1 from get_anon_bdev.\n\t */\n\tdev = ida_alloc_range(&unnamed_dev_ida, 1, (1 << MINORBITS) - 1,\n\t\t\tGFP_ATOMIC);\n\tif (dev == -ENOSPC)\n\t\tdev = -EMFILE;\n\tif (dev < 0)\n\t\treturn dev;\n\n\t*p = MKDEV(0, dev);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDA(unnamed_dev_ida);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "0",
            "dev"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ida_alloc_range",
          "args": [
            "&unnamed_dev_ida",
            "1",
            "(1 << MINORBITS) - 1",
            "GFP_ATOMIC"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_IDA(unnamed_dev_ida);\n\nint get_anon_bdev(dev_t *p)\n{\n\tint dev;\n\n\t/*\n\t * Many userspace utilities consider an FSID of 0 invalid.\n\t * Always return at least 1 from get_anon_bdev.\n\t */\n\tdev = ida_alloc_range(&unnamed_dev_ida, 1, (1 << MINORBITS) - 1,\n\t\t\tGFP_ATOMIC);\n\tif (dev == -ENOSPC)\n\t\tdev = -EMFILE;\n\tif (dev < 0)\n\t\treturn dev;\n\n\t*p = MKDEV(0, dev);\n\treturn 0;\n}"
  },
  {
    "function_name": "emergency_thaw_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "973-982",
    "snippet": "void emergency_thaw_all(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_thaw_all);\n\t\tschedule_work(work);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "work"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/direct.c",
          "lines": "740-757",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq);",
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq);\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "work",
            "do_thaw_all"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*work)",
            "GFP_ATOMIC"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nvoid emergency_thaw_all(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_thaw_all);\n\t\tschedule_work(work);\n\t}\n}"
  },
  {
    "function_name": "do_thaw_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "961-966",
    "snippet": "static void do_thaw_all(struct work_struct *work)\n{\n\t__iterate_supers(do_thaw_all_callback);\n\tkfree(work);\n\tprintk(KERN_WARNING \"Emergency Thaw complete\\n\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Emergency Thaw complete\\n\""
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "work"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iterate_supers",
          "args": [
            "do_thaw_all_callback"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "__iterate_supers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "590-611",
          "snippet": "static void __iterate_supers(void (*f)(struct super_block *))\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tf(sb);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void __iterate_supers(void (*f)(struct super_block *))\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tf(sb);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void do_thaw_all(struct work_struct *work)\n{\n\t__iterate_supers(do_thaw_all_callback);\n\tkfree(work);\n\tprintk(KERN_WARNING \"Emergency Thaw complete\\n\");\n}"
  },
  {
    "function_name": "do_thaw_all_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "950-959",
    "snippet": "static void do_thaw_all_callback(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\tif (sb->s_root && sb->s_flags & SB_BORN) {\n\t\temergency_thaw_bdev(sb);\n\t\tthaw_super_locked(sb);\n\t} else {\n\t\tup_write(&sb->s_umount);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thaw_super_locked",
          "args": [
            "sb"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "thaw_super_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1542-1575",
          "snippet": "static int thaw_super_locked(struct super_block *sb)\n{\n\tint error;\n\n\tif (sb->s_writers.frozen != SB_FREEZE_COMPLETE) {\n\t\tup_write(&sb->s_umount);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\tgoto out;\n\t}\n\n\tlockdep_sb_freeze_acquire(sb);\n\n\tif (sb->s_op->unfreeze_fs) {\n\t\terror = sb->s_op->unfreeze_fs(sb);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\");\n\t\t\tlockdep_sb_freeze_release(sb);\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tsb->s_writers.frozen = SB_UNFROZEN;\n\tsb_freeze_unlock(sb);\nout:\n\twake_up(&sb->s_writers.wait_unfrozen);\n\tdeactivate_locked_super(sb);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic int thaw_super_locked(struct super_block *sb)\n{\n\tint error;\n\n\tif (sb->s_writers.frozen != SB_FREEZE_COMPLETE) {\n\t\tup_write(&sb->s_umount);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\tgoto out;\n\t}\n\n\tlockdep_sb_freeze_acquire(sb);\n\n\tif (sb->s_op->unfreeze_fs) {\n\t\terror = sb->s_op->unfreeze_fs(sb);\n\t\tif (error) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem thaw failed\\n\");\n\t\t\tlockdep_sb_freeze_release(sb);\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\tsb->s_writers.frozen = SB_UNFROZEN;\n\tsb_freeze_unlock(sb);\nout:\n\twake_up(&sb->s_writers.wait_unfrozen);\n\tdeactivate_locked_super(sb);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emergency_thaw_bdev",
          "args": [
            "sb"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "emergency_thaw_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/buffer.c",
          "lines": "497-501",
          "snippet": "void emergency_thaw_bdev(struct super_block *sb)\n{\n\twhile (sb->s_bdev && !thaw_bdev(sb->s_bdev, sb))\n\t\tprintk(KERN_WARNING \"Emergency Thaw on %pg\\n\", sb->s_bdev);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/iomap.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/sched/mm.h>\n#include <linux/pagevec.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/backing-dev.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/iomap.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid emergency_thaw_bdev(struct super_block *sb)\n{\n\twhile (sb->s_bdev && !thaw_bdev(sb->s_bdev, sb))\n\t\tprintk(KERN_WARNING \"Emergency Thaw on %pg\\n\", sb->s_bdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void do_thaw_all_callback(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\tif (sb->s_root && sb->s_flags & SB_BORN) {\n\t\temergency_thaw_bdev(sb);\n\t\tthaw_super_locked(sb);\n\t} else {\n\t\tup_write(&sb->s_umount);\n\t}\n}"
  },
  {
    "function_name": "emergency_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "939-948",
    "snippet": "void emergency_remount(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_emergency_remount);\n\t\tschedule_work(work);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "work"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/direct.c",
          "lines": "740-757",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq);",
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq);\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "work",
            "do_emergency_remount"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*work)",
            "GFP_ATOMIC"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dir.c",
          "lines": "2521-2533",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/iversion.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/iversion.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nvoid emergency_remount(void)\n{\n\tstruct work_struct *work;\n\n\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\tif (work) {\n\t\tINIT_WORK(work, do_emergency_remount);\n\t\tschedule_work(work);\n\t}\n}"
  },
  {
    "function_name": "do_emergency_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "932-937",
    "snippet": "static void do_emergency_remount(struct work_struct *work)\n{\n\t__iterate_supers(do_emergency_remount_callback);\n\tkfree(work);\n\tprintk(\"Emergency Remount complete\\n\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Emergency Remount complete\\n\""
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/reiserfs/prints.c",
          "lines": "310-314",
          "snippet": "static void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nstatic void reiserfs_printk(const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tprintk(error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "work"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__iterate_supers",
          "args": [
            "do_emergency_remount_callback"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "__iterate_supers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "590-611",
          "snippet": "static void __iterate_supers(void (*f)(struct super_block *))\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tf(sb);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void __iterate_supers(void (*f)(struct super_block *))\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tf(sb);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void do_emergency_remount(struct work_struct *work)\n{\n\t__iterate_supers(do_emergency_remount_callback);\n\tkfree(work);\n\tprintk(\"Emergency Remount complete\\n\");\n}"
  },
  {
    "function_name": "do_emergency_remount_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "919-930",
    "snippet": "static void do_emergency_remount_callback(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\tif (sb->s_root && sb->s_bdev && (sb->s_flags & SB_BORN) &&\n\t    !sb_rdonly(sb)) {\n\t\t/*\n\t\t * What lock protects sb->s_flags??\n\t\t */\n\t\tdo_remount_sb(sb, SB_RDONLY, NULL, 1);\n\t}\n\tup_write(&sb->s_umount);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_remount_sb",
          "args": [
            "sb",
            "SB_RDONLY",
            "NULL",
            "1"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "do_remount_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "845-917",
          "snippet": "int do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(sb_flags & SB_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &sb_flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (sb_flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(sb_flags & SB_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &sb_flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (sb_flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic void do_emergency_remount_callback(struct super_block *sb)\n{\n\tdown_write(&sb->s_umount);\n\tif (sb->s_root && sb->s_bdev && (sb->s_flags & SB_BORN) &&\n\t    !sb_rdonly(sb)) {\n\t\t/*\n\t\t * What lock protects sb->s_flags??\n\t\t */\n\t\tdo_remount_sb(sb, SB_RDONLY, NULL, 1);\n\t}\n\tup_write(&sb->s_umount);\n}"
  },
  {
    "function_name": "do_remount_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "845-917",
    "snippet": "int do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(sb_flags & SB_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &sb_flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (sb_flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invalidate_bdev",
          "args": [
            "sb->s_bdev"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_bdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/block_dev.c",
          "lines": "91-104",
          "snippet": "void invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_bh_lrus();\n\t\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\t\tinvalidate_mapping_pages(mapping, 0, -1);\n\t}\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/falloc.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/badblocks.h>",
            "#include <linux/dax.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dax.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/falloc.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/badblocks.h>\n#include <linux/dax.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/dax.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nvoid invalidate_bdev(struct block_device *bdev)\n{\n\tstruct address_space *mapping = bdev->bd_inode->i_mapping;\n\n\tif (mapping->nrpages) {\n\t\tinvalidate_bh_lrus();\n\t\tlru_add_drain_all();\t/* make sure all lru add caches are flushed */\n\t\tinvalidate_mapping_pages(mapping, 0, -1);\n\t}\n\t/* 99% of the time, we don't need to flush the cleancache on the bdev.\n\t * But, for the strange corners, lets be cautious\n\t */\n\tcleancache_invalidate_inode(mapping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"forced remount of a %s fs returned %i\\n\"",
            "sb->s_type->name",
            "retval"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->remount_fs",
          "args": [
            "sb",
            "&sb_flags",
            "data"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_prepare_remount_readonly",
          "args": [
            "sb"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "sb_prepare_remount_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/namespace.c",
          "lines": "517-551",
          "snippet": "int sb_prepare_remount_readonly(struct super_block *sb)\n{\n\tstruct mount *mnt;\n\tint err = 0;\n\n\t/* Racy optimization.  Recheck the counter under MNT_WRITE_HOLD */\n\tif (atomic_long_read(&sb->s_remove_count))\n\t\treturn -EBUSY;\n\n\tlock_mount_hash();\n\tlist_for_each_entry(mnt, &sb->s_mounts, mnt_instance) {\n\t\tif (!(mnt->mnt.mnt_flags & MNT_READONLY)) {\n\t\t\tmnt->mnt.mnt_flags |= MNT_WRITE_HOLD;\n\t\t\tsmp_mb();\n\t\t\tif (mnt_get_writers(mnt) > 0) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!err && atomic_long_read(&sb->s_remove_count))\n\t\terr = -EBUSY;\n\n\tif (!err) {\n\t\tsb->s_readonly_remount = 1;\n\t\tsmp_wmb();\n\t}\n\tlist_for_each_entry(mnt, &sb->s_mounts, mnt_instance) {\n\t\tif (mnt->mnt.mnt_flags & MNT_WRITE_HOLD)\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_WRITE_HOLD;\n\t}\n\tunlock_mount_hash();\n\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/sched/task.h>",
            "#include <linux/task_work.h>",
            "#include <linux/memblock.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/cred.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);",
            "__latent_entropy\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/sched/task.h>\n#include <linux/task_work.h>\n#include <linux/memblock.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/cred.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n__latent_entropy\nstruct;\n\nint sb_prepare_remount_readonly(struct super_block *sb)\n{\n\tstruct mount *mnt;\n\tint err = 0;\n\n\t/* Racy optimization.  Recheck the counter under MNT_WRITE_HOLD */\n\tif (atomic_long_read(&sb->s_remove_count))\n\t\treturn -EBUSY;\n\n\tlock_mount_hash();\n\tlist_for_each_entry(mnt, &sb->s_mounts, mnt_instance) {\n\t\tif (!(mnt->mnt.mnt_flags & MNT_READONLY)) {\n\t\t\tmnt->mnt.mnt_flags |= MNT_WRITE_HOLD;\n\t\t\tsmp_mb();\n\t\t\tif (mnt_get_writers(mnt) > 0) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!err && atomic_long_read(&sb->s_remove_count))\n\t\terr = -EBUSY;\n\n\tif (!err) {\n\t\tsb->s_readonly_remount = 1;\n\t\tsmp_wmb();\n\t}\n\tlist_for_each_entry(mnt, &sb->s_mounts, mnt_instance) {\n\t\tif (mnt->mnt.mnt_flags & MNT_WRITE_HOLD)\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_WRITE_HOLD;\n\t}\n\tunlock_mount_hash();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shrink_dcache_sb",
          "args": [
            "sb"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1189-1202",
          "snippet": "void shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, 1024);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (list_lru_count(&sb->s_dentry_lru) > 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(long, nr_dentry_unused);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nstatic DEFINE_PER_CPU(long, nr_dentry_unused);\n\nvoid shrink_dcache_sb(struct super_block *sb)\n{\n\tlong freed;\n\n\tdo {\n\t\tLIST_HEAD(dispose);\n\n\t\tfreed = list_lru_walk(&sb->s_dentry_lru,\n\t\t\tdentry_lru_isolate_shrink, &dispose, 1024);\n\n\t\tthis_cpu_sub(nr_dentry_unused, freed);\n\t\tshrink_dentry_list(&dispose);\n\t} while (list_lru_count(&sb->s_dentry_lru) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_pin_kill",
          "args": [
            "&sb->s_pins"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "group_pin_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs_pin.c",
          "lines": "91-103",
          "snippet": "void group_pin_kill(struct hlist_head *p)\n{\n\twhile (1) {\n\t\tstruct hlist_node *q;\n\t\trcu_read_lock();\n\t\tq = READ_ONCE(p->first);\n\t\tif (!q) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tpin_kill(hlist_entry(q, struct fs_pin, s_list));\n\t}\n}",
          "includes": [
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n\nvoid group_pin_kill(struct hlist_head *p)\n{\n\twhile (1) {\n\t\tstruct hlist_node *q;\n\t\trcu_read_lock();\n\t\tq = READ_ONCE(p->first);\n\t\tif (!q) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tpin_kill(hlist_entry(q, struct fs_pin, s_list));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&sb->s_pins"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_rdonly",
          "args": [
            "sb"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "sb->s_bdev"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint do_remount_sb(struct super_block *sb, int sb_flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n\n#ifdef CONFIG_BLOCK\n\tif (!(sb_flags & SB_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\n\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\n\tif (remount_ro) {\n\t\tif (!hlist_empty(&sb->s_pins)) {\n\t\t\tup_write(&sb->s_umount);\n\t\t\tgroup_pin_kill(&sb->s_pins);\n\t\t\tdown_write(&sb->s_umount);\n\t\t\tif (!sb->s_root)\n\t\t\t\treturn 0;\n\t\t\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\t\t\treturn -EBUSY;\n\t\t\tremount_ro = (sb_flags & SB_RDONLY) && !sb_rdonly(sb);\n\t\t}\n\t}\n\tshrink_dcache_sb(sb);\n\n\t/* If we are remounting RDONLY and current sb is read/write,\n\t   make sure there are no rw files opened */\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tsb->s_readonly_remount = 1;\n\t\t\tsmp_wmb();\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &sb_flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\t/* If forced remount, go ahead despite any errors */\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (sb_flags & MS_RMT_MASK);\n\t/* Needs to be ordered wrt mnt_is_readonly() */\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\n\t/*\n\t * Some filesystems modify their metadata via some other path than the\n\t * bdev buffer cache (eg. use a private mapping, or directories in\n\t * pagecache, etc). Also file data modifications go via their own\n\t * mappings. So If we try to mount readonly then copy the filesystem\n\t * from bdev, we could get stale data, so invalidate it to give a best\n\t * effort at coherency.\n\t */\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\n\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}"
  },
  {
    "function_name": "user_get_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "809-834",
    "snippet": "struct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static LIST_HEAD(super_blocks);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_super",
          "args": [
            "sb"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "__put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "283-295",
          "snippet": "static void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&sb->s_instances"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sb",
            "&super_blocks",
            "s_list"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *user_get_super(dev_t dev)\n{\n\tstruct super_block *sb;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_dev ==  dev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tdown_read(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tup_read(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_active_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "786-807",
    "snippet": "struct super_block *get_active_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\nrestart:\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tif (!grab_super(sb))\n\t\t\t\tgoto restart;\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn sb;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static LIST_HEAD(super_blocks);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_super",
          "args": [
            "sb"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "grab_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "379-391",
          "snippet": "static int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & SB_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & SB_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&sb->s_instances"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sb",
            "&super_blocks",
            "s_list"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *get_active_super(struct block_device *bdev)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\nrestart:\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tif (!grab_super(sb))\n\t\t\t\tgoto restart;\n\t\t\tup_write(&sb->s_umount);\n\t\t\treturn sb;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_super_exclusive_thawed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "772-775",
    "snippet": "struct super_block *get_super_exclusive_thawed(struct block_device *bdev)\n{\n\treturn __get_super_thawed(bdev, true);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_super_thawed",
          "args": [
            "bdev",
            "true"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "__get_super_thawed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "731-746",
          "snippet": "static struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct super_block *get_super_exclusive_thawed(struct block_device *bdev)\n{\n\treturn __get_super_thawed(bdev, true);\n}"
  },
  {
    "function_name": "get_super_thawed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "757-760",
    "snippet": "struct super_block *get_super_thawed(struct block_device *bdev)\n{\n\treturn __get_super_thawed(bdev, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_super_thawed",
          "args": [
            "bdev",
            "false"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__get_super_thawed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "731-746",
          "snippet": "static struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct super_block *get_super_thawed(struct block_device *bdev)\n{\n\treturn __get_super_thawed(bdev, false);\n}"
  },
  {
    "function_name": "__get_super_thawed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "731-746",
    "snippet": "static struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_super",
          "args": [
            "s"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "304-309",
          "snippet": "static void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "s->s_writers.wait_unfrozen",
            "s->s_writers.frozen == SB_UNFROZEN"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&s->s_umount"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_super",
          "args": [
            "bdev",
            "excl"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__get_super_thawed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "731-746",
          "snippet": "static struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}"
  },
  {
    "function_name": "get_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "725-728",
    "snippet": "struct super_block *get_super(struct block_device *bdev)\n{\n\treturn __get_super(bdev, false);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_super",
          "args": [
            "bdev",
            "false"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "__get_super_thawed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "731-746",
          "snippet": "static struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic struct super_block *__get_super_thawed(struct block_device *bdev,\n\t\t\t\t\t      bool excl)\n{\n\twhile (1) {\n\t\tstruct super_block *s = __get_super(bdev, excl);\n\t\tif (!s || s->s_writers.frozen == SB_UNFROZEN)\n\t\t\treturn s;\n\t\tif (!excl)\n\t\t\tup_read(&s->s_umount);\n\t\telse\n\t\t\tup_write(&s->s_umount);\n\t\twait_event(s->s_writers.wait_unfrozen,\n\t\t\t   s->s_writers.frozen == SB_UNFROZEN);\n\t\tput_super(s);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct super_block *get_super(struct block_device *bdev)\n{\n\treturn __get_super(bdev, false);\n}"
  },
  {
    "function_name": "__get_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "682-716",
    "snippet": "static struct super_block *__get_super(struct block_device *bdev, bool excl)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tif (!excl)\n\t\t\t\tdown_read(&sb->s_umount);\n\t\t\telse\n\t\t\t\tdown_write(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tif (!excl)\n\t\t\t\tup_read(&sb->s_umount);\n\t\t\telse\n\t\t\t\tup_write(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static LIST_HEAD(super_blocks);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_super",
          "args": [
            "sb"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "283-295",
          "snippet": "static void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&sb->s_instances"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sb",
            "&super_blocks",
            "s_list"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic struct super_block *__get_super(struct block_device *bdev, bool excl)\n{\n\tstruct super_block *sb;\n\n\tif (!bdev)\n\t\treturn NULL;\n\n\tspin_lock(&sb_lock);\nrescan:\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tif (sb->s_bdev == bdev) {\n\t\t\tsb->s_count++;\n\t\t\tspin_unlock(&sb_lock);\n\t\t\tif (!excl)\n\t\t\t\tdown_read(&sb->s_umount);\n\t\t\telse\n\t\t\t\tdown_write(&sb->s_umount);\n\t\t\t/* still alive? */\n\t\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\t\treturn sb;\n\t\t\tif (!excl)\n\t\t\t\tup_read(&sb->s_umount);\n\t\t\telse\n\t\t\t\tup_write(&sb->s_umount);\n\t\t\t/* nope, got unmounted */\n\t\t\tspin_lock(&sb_lock);\n\t\t\t__put_super(sb);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n\tspin_unlock(&sb_lock);\n\treturn NULL;\n}"
  },
  {
    "function_name": "iterate_supers_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "655-678",
    "snippet": "void iterate_supers_type(struct file_system_type *type,\n\tvoid (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\thlist_for_each_entry(sb, &type->fs_supers, s_instances) {\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_super",
          "args": [
            "p"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "__put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "283-295",
          "snippet": "static void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "sb",
            "arg"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dismount_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "1897-1991",
          "snippet": "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\t/* Remove file check sysfs related directores/files,\n\t * and wait for the pending file check operations */\n\tocfs2_filecheck_remove_sysfs(osb);\n\n\tkset_unregister(osb->osb_dev_kset);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_sync_fs(struct super_block *sb, int wait);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\t/* Remove file check sysfs related directores/files,\n\t * and wait for the pending file check operations */\n\tocfs2_filecheck_remove_sysfs(osb);\n\n\tkset_unregister(osb->osb_dev_kset);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "sb",
            "&type->fs_supers",
            "s_instances"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid iterate_supers_type(struct file_system_type *type,\n\tvoid (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\thlist_for_each_entry(sb, &type->fs_supers, s_instances) {\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
  },
  {
    "function_name": "iterate_supers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "620-644",
    "snippet": "void iterate_supers(void (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static LIST_HEAD(super_blocks);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_super",
          "args": [
            "p"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "__put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "283-295",
          "snippet": "static void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "sb",
            "arg"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dismount_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/super.c",
          "lines": "1897-1991",
          "snippet": "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\t/* Remove file check sysfs related directores/files,\n\t * and wait for the pending file check operations */\n\tocfs2_filecheck_remove_sysfs(osb);\n\n\tkset_unregister(osb->osb_dev_kset);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}",
          "includes": [
            "#include \"filecheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/signal.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);",
            "static void ocfs2_delete_osb(struct ocfs2_super *osb);",
            "static int ocfs2_sync_fs(struct super_block *sb, int wait);",
            "static int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);",
            "static void ocfs2_release_system_inodes(struct ocfs2_super *osb);",
            "static int ocfs2_check_volume(struct ocfs2_super *osb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static int ocfs2_enable_quotas(struct ocfs2_super *osb);",
            "static void ocfs2_disable_quotas(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"filecheck.h\"\n#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/signal.h>\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err);\nstatic void ocfs2_delete_osb(struct ocfs2_super *osb);\nstatic int ocfs2_sync_fs(struct super_block *sb, int wait);\nstatic int ocfs2_init_global_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_init_local_system_inodes(struct ocfs2_super *osb);\nstatic void ocfs2_release_system_inodes(struct ocfs2_super *osb);\nstatic int ocfs2_check_volume(struct ocfs2_super *osb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic int ocfs2_enable_quotas(struct ocfs2_super *osb);\nstatic void ocfs2_disable_quotas(struct ocfs2_super *osb);\n\nstatic void ocfs2_dismount_volume(struct super_block *sb, int mnt_err)\n{\n\tint tmp, hangup_needed = 0;\n\tstruct ocfs2_super *osb = NULL;\n\tchar nodestr[12];\n\n\ttrace_ocfs2_dismount_volume(sb);\n\n\tBUG_ON(!sb);\n\tosb = OCFS2_SB(sb);\n\tBUG_ON(!osb);\n\n\t/* Remove file check sysfs related directores/files,\n\t * and wait for the pending file check operations */\n\tocfs2_filecheck_remove_sysfs(osb);\n\n\tkset_unregister(osb->osb_dev_kset);\n\n\tdebugfs_remove(osb->osb_ctxt);\n\n\t/* Orphan scan should be stopped as early as possible */\n\tocfs2_orphan_scan_stop(osb);\n\n\tocfs2_disable_quotas(osb);\n\n\t/* All dquots should be freed by now */\n\tWARN_ON(!llist_empty(&osb->dquot_drop_list));\n\t/* Wait for worker to be done with the work structure in osb */\n\tcancel_work_sync(&osb->dquot_drop_work);\n\n\tocfs2_shutdown_local_alloc(osb);\n\n\tocfs2_truncate_log_shutdown(osb);\n\n\t/* This will disable recovery and flush any recovery work. */\n\tocfs2_recovery_exit(osb);\n\n\tocfs2_journal_shutdown(osb);\n\n\tocfs2_sync_blockdev(sb);\n\n\tocfs2_purge_refcount_trees(osb);\n\n\t/* No cluster connection means we've failed during mount, so skip\n\t * all the steps which depended on that to complete. */\n\tif (osb->cconn) {\n\t\ttmp = ocfs2_super_lock(osb, 1);\n\t\tif (tmp < 0) {\n\t\t\tmlog_errno(tmp);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (osb->slot_num != OCFS2_INVALID_SLOT)\n\t\tocfs2_put_slot(osb);\n\n\tif (osb->cconn)\n\t\tocfs2_super_unlock(osb, 1);\n\n\tocfs2_release_system_inodes(osb);\n\n\t/*\n\t * If we're dismounting due to mount error, mount.ocfs2 will clean\n\t * up heartbeat.  If we're a local mount, there is no heartbeat.\n\t * If we failed before we got a uuid_str yet, we can't stop\n\t * heartbeat.  Otherwise, do it.\n\t */\n\tif (!mnt_err && !ocfs2_mount_local(osb) && osb->uuid_str &&\n\t    !ocfs2_is_hard_readonly(osb))\n\t\thangup_needed = 1;\n\n\tif (osb->cconn)\n\t\tocfs2_dlm_shutdown(osb, hangup_needed);\n\n\tocfs2_blockcheck_stats_debugfs_remove(&osb->osb_ecc_stats);\n\tdebugfs_remove(osb->osb_debug_root);\n\n\tif (hangup_needed)\n\t\tocfs2_cluster_hangup(osb->uuid_str, strlen(osb->uuid_str));\n\n\tatomic_set(&osb->vol_state, VOLUME_DISMOUNTED);\n\n\tif (ocfs2_mount_local(osb))\n\t\tsnprintf(nodestr, sizeof(nodestr), \"local\");\n\telse\n\t\tsnprintf(nodestr, sizeof(nodestr), \"%u\", osb->node_num);\n\n\tprintk(KERN_INFO \"ocfs2: Unmounting device (%s) on (node %s)\\n\",\n\t       osb->dev_str, nodestr);\n\n\tocfs2_delete_osb(osb);\n\tkfree(osb);\n\tsb->s_dev = 0;\n\tsb->s_fs_info = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&sb->s_instances"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sb",
            "&super_blocks",
            "s_list"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid iterate_supers(void (*f)(struct super_block *, void *), void *arg)\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tdown_read(&sb->s_umount);\n\t\tif (sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\tf(sb, arg);\n\t\tup_read(&sb->s_umount);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
  },
  {
    "function_name": "__iterate_supers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "590-611",
    "snippet": "static void __iterate_supers(void (*f)(struct super_block *))\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tf(sb);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static LIST_HEAD(super_blocks);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_super",
          "args": [
            "p"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "__put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "283-295",
          "snippet": "static void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "sb"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "freeze_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1473-1533",
          "snippet": "int freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & SB_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\tdown_write(&sb->s_umount);\n\n\t/* Now we go and block page faults... */\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsb_freeze_unlock(sb);\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * For debugging purposes so that fs can warn if it sees write activity\n\t * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tlockdep_sb_freeze_release(sb);\n\tup_write(&sb->s_umount);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint freeze_super(struct super_block *sb)\n{\n\tint ret;\n\n\tatomic_inc(&sb->s_active);\n\tdown_write(&sb->s_umount);\n\tif (sb->s_writers.frozen != SB_UNFROZEN) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!(sb->s_flags & SB_BORN)) {\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\t/* sic - it's \"nothing to do\" */\n\t}\n\n\tif (sb_rdonly(sb)) {\n\t\t/* Nothing to do really... */\n\t\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\t\tup_write(&sb->s_umount);\n\t\treturn 0;\n\t}\n\n\tsb->s_writers.frozen = SB_FREEZE_WRITE;\n\t/* Release s_umount to preserve sb_start_write -> s_umount ordering */\n\tup_write(&sb->s_umount);\n\tsb_wait_write(sb, SB_FREEZE_WRITE);\n\tdown_write(&sb->s_umount);\n\n\t/* Now we go and block page faults... */\n\tsb->s_writers.frozen = SB_FREEZE_PAGEFAULT;\n\tsb_wait_write(sb, SB_FREEZE_PAGEFAULT);\n\n\t/* All writers are done so after syncing there won't be dirty data */\n\tsync_filesystem(sb);\n\n\t/* Now wait for internal filesystem counter */\n\tsb->s_writers.frozen = SB_FREEZE_FS;\n\tsb_wait_write(sb, SB_FREEZE_FS);\n\n\tif (sb->s_op->freeze_fs) {\n\t\tret = sb->s_op->freeze_fs(sb);\n\t\tif (ret) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"VFS:Filesystem freeze failed\\n\");\n\t\t\tsb->s_writers.frozen = SB_UNFROZEN;\n\t\t\tsb_freeze_unlock(sb);\n\t\t\twake_up(&sb->s_writers.wait_unfrozen);\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\t/*\n\t * For debugging purposes so that fs can warn if it sees write activity\n\t * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().\n\t */\n\tsb->s_writers.frozen = SB_FREEZE_COMPLETE;\n\tlockdep_sb_freeze_release(sb);\n\tup_write(&sb->s_umount);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&sb->s_instances"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sb",
            "&super_blocks",
            "s_list"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void __iterate_supers(void (*f)(struct super_block *))\n{\n\tstruct super_block *sb, *p = NULL;\n\n\tspin_lock(&sb_lock);\n\tlist_for_each_entry(sb, &super_blocks, s_list) {\n\t\tif (hlist_unhashed(&sb->s_instances))\n\t\t\tcontinue;\n\t\tsb->s_count++;\n\t\tspin_unlock(&sb_lock);\n\n\t\tf(sb);\n\n\t\tspin_lock(&sb_lock);\n\t\tif (p)\n\t\t\t__put_super(p);\n\t\tp = sb;\n\t}\n\tif (p)\n\t\t__put_super(p);\n\tspin_unlock(&sb_lock);\n}"
  },
  {
    "function_name": "drop_super_exclusive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "583-587",
    "snippet": "void drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_super",
          "args": [
            "sb"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "304-309",
          "snippet": "static void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid drop_super_exclusive(struct super_block *sb)\n{\n\tup_write(&sb->s_umount);\n\tput_super(sb);\n}"
  },
  {
    "function_name": "drop_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "575-579",
    "snippet": "void drop_super(struct super_block *sb)\n{\n\tup_read(&sb->s_umount);\n\tput_super(sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_super",
          "args": [
            "sb"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "304-309",
          "snippet": "static void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nvoid drop_super(struct super_block *sb)\n{\n\tup_read(&sb->s_umount);\n\tput_super(sb);\n}"
  },
  {
    "function_name": "sget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "551-571",
    "snippet": "struct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\t/* We don't yet pass the user namespace of the parent\n\t * mount through to here so always use &init_user_ns\n\t * until that changes.\n\t */\n\tif (flags & SB_SUBMOUNT)\n\t\tuser_ns = &init_user_ns;\n\n\t/* Ensure the requestor has permissions over the target filesystem */\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn sget_userns(type, test, set, flags, user_ns, data);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sget_userns",
          "args": [
            "type",
            "test",
            "set",
            "flags",
            "user_ns",
            "data"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "sget_userns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "486-539",
          "snippet": "struct super_block *sget_userns(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, struct user_namespace *user_ns,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&\n\t    !(type->fs_flags & FS_USERNS_MOUNT) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (user_ns != old->s_user_ns) {\n\t\t\t\tspin_unlock(&sb_lock);\n\t\t\t\tdestroy_unused_super(s);\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tdestroy_unused_super(s);\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, (flags & ~SB_SUBMOUNT), user_ns);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tdestroy_unused_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker_prepared(&s->s_shrink);\n\treturn s;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(super_blocks);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *sget_userns(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, struct user_namespace *user_ns,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&\n\t    !(type->fs_flags & FS_USERNS_MOUNT) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (user_ns != old->s_user_ns) {\n\t\t\t\tspin_unlock(&sb_lock);\n\t\t\t\tdestroy_unused_super(s);\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tdestroy_unused_super(s);\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, (flags & ~SB_SUBMOUNT), user_ns);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tdestroy_unused_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker_prepared(&s->s_shrink);\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstruct super_block *sget(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags,\n\t\t\tvoid *data)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\t/* We don't yet pass the user namespace of the parent\n\t * mount through to here so always use &init_user_ns\n\t * until that changes.\n\t */\n\tif (flags & SB_SUBMOUNT)\n\t\tuser_ns = &init_user_ns;\n\n\t/* Ensure the requestor has permissions over the target filesystem */\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) && !ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\n\n\treturn sget_userns(type, test, set, flags, user_ns, data);\n}"
  },
  {
    "function_name": "sget_userns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "486-539",
    "snippet": "struct super_block *sget_userns(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, struct user_namespace *user_ns,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&\n\t    !(type->fs_flags & FS_USERNS_MOUNT) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (user_ns != old->s_user_ns) {\n\t\t\t\tspin_unlock(&sb_lock);\n\t\t\t\tdestroy_unused_super(s);\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tdestroy_unused_super(s);\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, (flags & ~SB_SUBMOUNT), user_ns);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tdestroy_unused_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker_prepared(&s->s_shrink);\n\treturn s;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(super_blocks);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_shrinker_prepared",
          "args": [
            "&s->s_shrink"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_filesystem",
          "args": [
            "type"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "get_filesystem_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/filesystems.c",
          "lines": "207-222",
          "snippet": "int __init get_filesystem_list(char *buf)\n{\n\tint len = 0;\n\tstruct file_system_type * tmp;\n\n\tread_lock(&file_systems_lock);\n\ttmp = file_systems;\n\twhile (tmp && len < PAGE_SIZE - 80) {\n\t\tlen += sprintf(buf+len, \"%s\\t%s\\n\",\n\t\t\t(tmp->fs_flags & FS_REQUIRES_DEV) ? \"\" : \"nodev\",\n\t\t\ttmp->name);\n\t\ttmp = tmp->next;\n\t}\n\tread_unlock(&file_systems_lock);\n\treturn len;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint __init get_filesystem_list(char *buf)\n{\n\tint len = 0;\n\tstruct file_system_type * tmp;\n\n\tread_lock(&file_systems_lock);\n\ttmp = file_systems;\n\twhile (tmp && len < PAGE_SIZE - 80) {\n\t\tlen += sprintf(buf+len, \"%s\\t%s\\n\",\n\t\t\t(tmp->fs_flags & FS_REQUIRES_DEV) ? \"\" : \"nodev\",\n\t\t\ttmp->name);\n\t\ttmp = tmp->next;\n\t}\n\tread_unlock(&file_systems_lock);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&s->s_instances",
            "&type->fs_supers"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&s->s_list",
            "&super_blocks"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "s->s_id",
            "type->name",
            "sizeof(s->s_id)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_unused_super",
          "args": [
            "s"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_unused_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "173-186",
          "snippet": "static void destroy_unused_super(struct super_block *s)\n{\n\tif (!s)\n\t\treturn;\n\tup_write(&s->s_umount);\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tsecurity_sb_free(s);\n\tput_user_ns(s->s_user_ns);\n\tkfree(s->s_subtype);\n\tfree_prealloced_shrinker(&s->s_shrink);\n\t/* no delays needed */\n\tdestroy_super_work(&s->destroy_work);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void destroy_unused_super(struct super_block *s)\n{\n\tif (!s)\n\t\treturn;\n\tup_write(&s->s_umount);\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tsecurity_sb_free(s);\n\tput_user_ns(s->s_user_ns);\n\tkfree(s->s_subtype);\n\tfree_prealloced_shrinker(&s->s_shrink);\n\t/* no delays needed */\n\tdestroy_super_work(&s->destroy_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set",
          "args": [
            "s",
            "data"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "super_setup_bdi_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1308-1331",
          "snippet": "int super_setup_bdi_name(struct super_block *sb, char *fmt, ...)\n{\n\tstruct backing_dev_info *bdi;\n\tint err;\n\tva_list args;\n\n\tbdi = bdi_alloc(GFP_KERNEL);\n\tif (!bdi)\n\t\treturn -ENOMEM;\n\n\tbdi->name = sb->s_type->name;\n\n\tva_start(args, fmt);\n\terr = bdi_register_va(bdi, fmt, args);\n\tva_end(args);\n\tif (err) {\n\t\tbdi_put(bdi);\n\t\treturn err;\n\t}\n\tWARN_ON(sb->s_bdi != &noop_backing_dev_info);\n\tsb->s_bdi = bdi;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nint super_setup_bdi_name(struct super_block *sb, char *fmt, ...)\n{\n\tstruct backing_dev_info *bdi;\n\tint err;\n\tva_list args;\n\n\tbdi = bdi_alloc(GFP_KERNEL);\n\tif (!bdi)\n\t\treturn -ENOMEM;\n\n\tbdi->name = sb->s_type->name;\n\n\tva_start(args, fmt);\n\terr = bdi_register_va(bdi, fmt, args);\n\tva_end(args);\n\tif (err) {\n\t\tbdi_put(bdi);\n\t\treturn err;\n\t}\n\tWARN_ON(sb->s_bdi != &noop_backing_dev_info);\n\tsb->s_bdi = bdi;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_super",
          "args": [
            "type",
            "(flags & ~SB_SUBMOUNT)",
            "user_ns"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "197-276",
          "snippet": "static struct super_block *alloc_super(struct file_system_type *type, int flags,\n\t\t\t\t       struct user_namespace *user_ns)\n{\n\tstruct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);\n\tstatic const struct super_operations default_op;\n\tint i;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s->s_mounts);\n\ts->s_user_ns = get_user_ns(user_ns);\n\tinit_rwsem(&s->s_umount);\n\tlockdep_set_class(&s->s_umount, &type->s_umount_key);\n\t/*\n\t * sget() can have s_umount recursion.\n\t *\n\t * When it cannot find a suitable sb, it allocates a new\n\t * one (this one), and tries again to find a suitable old\n\t * one.\n\t *\n\t * In case that succeeds, it will acquire the s_umount\n\t * lock of the old one. Since these are clearly distrinct\n\t * locks, and this object isn't exposed yet, there's no\n\t * risk of deadlocks.\n\t *\n\t * Annotate this by putting this lock in a different\n\t * subclass.\n\t */\n\tdown_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);\n\n\tif (security_sb_alloc(s))\n\t\tgoto fail;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n\t\tif (__percpu_init_rwsem(&s->s_writers.rw_sem[i],\n\t\t\t\t\tsb_writers_name[i],\n\t\t\t\t\t&type->s_writers_key[i]))\n\t\t\tgoto fail;\n\t}\n\tinit_waitqueue_head(&s->s_writers.wait_unfrozen);\n\ts->s_bdi = &noop_backing_dev_info;\n\ts->s_flags = flags;\n\tif (s->s_user_ns != &init_user_ns)\n\t\ts->s_iflags |= SB_I_NODEV;\n\tINIT_HLIST_NODE(&s->s_instances);\n\tINIT_HLIST_BL_HEAD(&s->s_roots);\n\tmutex_init(&s->s_sync_lock);\n\tINIT_LIST_HEAD(&s->s_inodes);\n\tspin_lock_init(&s->s_inode_list_lock);\n\tINIT_LIST_HEAD(&s->s_inodes_wb);\n\tspin_lock_init(&s->s_inode_wblist_lock);\n\n\ts->s_count = 1;\n\tatomic_set(&s->s_active, 1);\n\tmutex_init(&s->s_vfs_rename_mutex);\n\tlockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);\n\tinit_rwsem(&s->s_dquot.dqio_sem);\n\ts->s_maxbytes = MAX_NON_LFS;\n\ts->s_op = &default_op;\n\ts->s_time_gran = 1000000000;\n\ts->cleancache_poolid = CLEANCACHE_NO_POOL;\n\n\ts->s_shrink.seeks = DEFAULT_SEEKS;\n\ts->s_shrink.scan_objects = super_cache_scan;\n\ts->s_shrink.count_objects = super_cache_count;\n\ts->s_shrink.batch = 1024;\n\ts->s_shrink.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE;\n\tif (prealloc_shrinker(&s->s_shrink))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_dentry_lru, &s->s_shrink))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_inode_lru, &s->s_shrink))\n\t\tgoto fail;\n\treturn s;\n\nfail:\n\tdestroy_unused_super(s);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static char *sb_writers_name[SB_FREEZE_LEVELS] = {\n\t\"sb_writers\",\n\t\"sb_pagefaults\",\n\t\"sb_internal\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic char *sb_writers_name[SB_FREEZE_LEVELS] = {\n\t\"sb_writers\",\n\t\"sb_pagefaults\",\n\t\"sb_internal\",\n};\n\nstatic struct super_block *alloc_super(struct file_system_type *type, int flags,\n\t\t\t\t       struct user_namespace *user_ns)\n{\n\tstruct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);\n\tstatic const struct super_operations default_op;\n\tint i;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s->s_mounts);\n\ts->s_user_ns = get_user_ns(user_ns);\n\tinit_rwsem(&s->s_umount);\n\tlockdep_set_class(&s->s_umount, &type->s_umount_key);\n\t/*\n\t * sget() can have s_umount recursion.\n\t *\n\t * When it cannot find a suitable sb, it allocates a new\n\t * one (this one), and tries again to find a suitable old\n\t * one.\n\t *\n\t * In case that succeeds, it will acquire the s_umount\n\t * lock of the old one. Since these are clearly distrinct\n\t * locks, and this object isn't exposed yet, there's no\n\t * risk of deadlocks.\n\t *\n\t * Annotate this by putting this lock in a different\n\t * subclass.\n\t */\n\tdown_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);\n\n\tif (security_sb_alloc(s))\n\t\tgoto fail;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n\t\tif (__percpu_init_rwsem(&s->s_writers.rw_sem[i],\n\t\t\t\t\tsb_writers_name[i],\n\t\t\t\t\t&type->s_writers_key[i]))\n\t\t\tgoto fail;\n\t}\n\tinit_waitqueue_head(&s->s_writers.wait_unfrozen);\n\ts->s_bdi = &noop_backing_dev_info;\n\ts->s_flags = flags;\n\tif (s->s_user_ns != &init_user_ns)\n\t\ts->s_iflags |= SB_I_NODEV;\n\tINIT_HLIST_NODE(&s->s_instances);\n\tINIT_HLIST_BL_HEAD(&s->s_roots);\n\tmutex_init(&s->s_sync_lock);\n\tINIT_LIST_HEAD(&s->s_inodes);\n\tspin_lock_init(&s->s_inode_list_lock);\n\tINIT_LIST_HEAD(&s->s_inodes_wb);\n\tspin_lock_init(&s->s_inode_wblist_lock);\n\n\ts->s_count = 1;\n\tatomic_set(&s->s_active, 1);\n\tmutex_init(&s->s_vfs_rename_mutex);\n\tlockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);\n\tinit_rwsem(&s->s_dquot.dqio_sem);\n\ts->s_maxbytes = MAX_NON_LFS;\n\ts->s_op = &default_op;\n\ts->s_time_gran = 1000000000;\n\ts->cleancache_poolid = CLEANCACHE_NO_POOL;\n\n\ts->s_shrink.seeks = DEFAULT_SEEKS;\n\ts->s_shrink.scan_objects = super_cache_scan;\n\ts->s_shrink.count_objects = super_cache_count;\n\ts->s_shrink.batch = 1024;\n\ts->s_shrink.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE;\n\tif (prealloc_shrinker(&s->s_shrink))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_dentry_lru, &s->s_shrink))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_inode_lru, &s->s_shrink))\n\t\tgoto fail;\n\treturn s;\n\nfail:\n\tdestroy_unused_super(s);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_super",
          "args": [
            "old"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "grab_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "379-391",
          "snippet": "static int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & SB_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & SB_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test",
          "args": [
            "old",
            "data"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "test_bdev_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "1099-1102",
          "snippet": "static int test_bdev_super(struct super_block *s, void *data)\n{\n\treturn (void *)s->s_bdev == data;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int test_bdev_super(struct super_block *s, void *data)\n{\n\treturn (void *)s->s_bdev == data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "old",
            "&type->fs_supers",
            "s_instances"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "2033-2044",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (kuid_has_mapping(ns, inode->i_uid) && ns_capable(ns, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(super_blocks);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstruct super_block *sget_userns(struct file_system_type *type,\n\t\t\tint (*test)(struct super_block *,void *),\n\t\t\tint (*set)(struct super_block *,void *),\n\t\t\tint flags, struct user_namespace *user_ns,\n\t\t\tvoid *data)\n{\n\tstruct super_block *s = NULL;\n\tstruct super_block *old;\n\tint err;\n\n\tif (!(flags & (SB_KERNMOUNT|SB_SUBMOUNT)) &&\n\t    !(type->fs_flags & FS_USERNS_MOUNT) &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn ERR_PTR(-EPERM);\nretry:\n\tspin_lock(&sb_lock);\n\tif (test) {\n\t\thlist_for_each_entry(old, &type->fs_supers, s_instances) {\n\t\t\tif (!test(old, data))\n\t\t\t\tcontinue;\n\t\t\tif (user_ns != old->s_user_ns) {\n\t\t\t\tspin_unlock(&sb_lock);\n\t\t\t\tdestroy_unused_super(s);\n\t\t\t\treturn ERR_PTR(-EBUSY);\n\t\t\t}\n\t\t\tif (!grab_super(old))\n\t\t\t\tgoto retry;\n\t\t\tdestroy_unused_super(s);\n\t\t\treturn old;\n\t\t}\n\t}\n\tif (!s) {\n\t\tspin_unlock(&sb_lock);\n\t\ts = alloc_super(type, (flags & ~SB_SUBMOUNT), user_ns);\n\t\tif (!s)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tgoto retry;\n\t}\n\n\terr = set(s, data);\n\tif (err) {\n\t\tspin_unlock(&sb_lock);\n\t\tdestroy_unused_super(s);\n\t\treturn ERR_PTR(err);\n\t}\n\ts->s_type = type;\n\tstrlcpy(s->s_id, type->name, sizeof(s->s_id));\n\tlist_add_tail(&s->s_list, &super_blocks);\n\thlist_add_head(&s->s_instances, &type->fs_supers);\n\tspin_unlock(&sb_lock);\n\tget_filesystem(type);\n\tregister_shrinker_prepared(&s->s_shrink);\n\treturn s;\n}"
  },
  {
    "function_name": "generic_shutdown_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "436-473",
    "snippet": "void generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~SB_ACTIVE;\n\n\t\tfsnotify_sb_delete(sb);\n\t\tcgroup_writeback_umount();\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n\tif (sb->s_bdi != &noop_backing_dev_info) {\n\t\tbdi_put(sb->s_bdi);\n\t\tsb->s_bdi = &noop_backing_dev_info;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdi_put",
          "args": [
            "sb->s_bdi"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sb->s_umount"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_del_init",
          "args": [
            "&sb->s_instances"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\"",
            "sb->s_id"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/super.c",
          "lines": "187-218",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tchar lvl[PRINTK_MAX_SINGLE_HEADER_LEN + 1] = \"\\0\";\n\tstruct va_format vaf;\n\tva_list args;\n\tint kern_level;\n\tconst char *type = logtypes[4];\n\tstruct ratelimit_state *ratelimit = &printk_limits[4];\n\n\tva_start(args, fmt);\n\n\twhile ((kern_level = printk_get_level(fmt)) != 0) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\n\t\tif (kern_level >= '0' && kern_level <= '7') {\n\t\t\tmemcpy(lvl, fmt,  size);\n\t\t\tlvl[size] = '\\0';\n\t\t\ttype = logtypes[kern_level - '0'];\n\t\t\tratelimit = &printk_limits[kern_level - '0'];\n\t\t}\n\t\tfmt += size;\n\t}\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (__ratelimit(ratelimit))\n\t\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type,\n\t\t\tfs_info ? fs_info->sb->s_id : \"<unknown>\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/crc32c.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tchar lvl[PRINTK_MAX_SINGLE_HEADER_LEN + 1] = \"\\0\";\n\tstruct va_format vaf;\n\tva_list args;\n\tint kern_level;\n\tconst char *type = logtypes[4];\n\tstruct ratelimit_state *ratelimit = &printk_limits[4];\n\n\tva_start(args, fmt);\n\n\twhile ((kern_level = printk_get_level(fmt)) != 0) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\n\t\tif (kern_level >= '0' && kern_level <= '7') {\n\t\t\tmemcpy(lvl, fmt,  size);\n\t\t\tlvl[size] = '\\0';\n\t\t\ttype = logtypes[kern_level - '0'];\n\t\t\tratelimit = &printk_limits[kern_level - '0'];\n\t\t}\n\t\tfmt += size;\n\t}\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (__ratelimit(ratelimit))\n\t\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type,\n\t\t\tfs_info ? fs_info->sb->s_id : \"<unknown>\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&sb->s_inodes"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sop->put_super",
          "args": [
            "sb"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "304-309",
          "snippet": "static void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "sb->s_dio_done_wq"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/btrfs/async-thread.c",
          "lines": "382-390",
          "snippet": "void btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_destroy_workqueue(struct btrfs_workqueue *wq)\n{\n\tif (!wq)\n\t\treturn;\n\tif (wq->high)\n\t\t__btrfs_destroy_workqueue(wq->high);\n\t__btrfs_destroy_workqueue(wq->normal);\n\tkfree(wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "evict_inodes",
          "args": [
            "sb"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "evict_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "607-644",
          "snippet": "void evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid evict_inodes(struct super_block *sb)\n{\n\tstruct inode *inode, *next;\n\tLIST_HEAD(dispose);\n\nagain:\n\tspin_lock(&sb->s_inode_list_lock);\n\tlist_for_each_entry_safe(inode, next, &sb->s_inodes, i_sb_list) {\n\t\tif (atomic_read(&inode->i_count))\n\t\t\tcontinue;\n\n\t\tspin_lock(&inode->i_lock);\n\t\tif (inode->i_state & (I_NEW | I_FREEING | I_WILL_FREE)) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode->i_state |= I_FREEING;\n\t\tinode_lru_list_del(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t\tlist_add(&inode->i_lru, &dispose);\n\n\t\t/*\n\t\t * We can have a ton of inodes to evict at unmount time given\n\t\t * enough memory, check to see if we need to go to sleep for a\n\t\t * bit so we don't livelock.\n\t\t */\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&sb->s_inode_list_lock);\n\t\t\tcond_resched();\n\t\t\tdispose_list(&dispose);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock(&sb->s_inode_list_lock);\n\n\tdispose_list(&dispose);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_writeback_umount",
          "args": [],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_writeback_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/fs-writeback.c",
          "lines": "871-877",
          "snippet": "void cgroup_writeback_umount(void)\n{\n\tif (atomic_read(&isw_nr_in_flight)) {\n\t\tsynchronize_rcu();\n\t\tflush_workqueue(isw_wq);\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/memcontrol.h>",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/memcontrol.h>\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid cgroup_writeback_umount(void)\n{\n\tif (atomic_read(&isw_nr_in_flight)) {\n\t\tsynchronize_rcu();\n\t\tflush_workqueue(isw_wq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_sb_delete",
          "args": [
            "sb"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_sb_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/notify/fsnotify.c",
          "lines": "104-108",
          "snippet": "void fsnotify_sb_delete(struct super_block *sb)\n{\n\tfsnotify_unmount_inodes(sb);\n\tfsnotify_clear_marks_by_sb(sb);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid fsnotify_sb_delete(struct super_block *sb)\n{\n\tfsnotify_unmount_inodes(sb);\n\tfsnotify_clear_marks_by_sb(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/sync.c",
          "lines": "48-68",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb_rdonly(sb))\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_for_umount",
          "args": [
            "sb"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_for_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1521-1535",
          "snippet": "void shrink_dcache_for_umount(struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\n\tWARN(down_read_trylock(&sb->s_umount), \"s_umount should've been locked\");\n\n\tdentry = sb->s_root;\n\tsb->s_root = NULL;\n\tdo_one_tree(dentry);\n\n\twhile (!hlist_bl_empty(&sb->s_roots)) {\n\t\tdentry = dget(hlist_bl_entry(hlist_bl_first(&sb->s_roots), struct dentry, d_hash));\n\t\tdo_one_tree(dentry);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nvoid shrink_dcache_for_umount(struct super_block *sb)\n{\n\tstruct dentry *dentry;\n\n\tWARN(down_read_trylock(&sb->s_umount), \"s_umount should've been locked\");\n\n\tdentry = sb->s_root;\n\tsb->s_root = NULL;\n\tdo_one_tree(dentry);\n\n\twhile (!hlist_bl_empty(&sb->s_roots)) {\n\t\tdentry = dget(hlist_bl_entry(hlist_bl_first(&sb->s_roots), struct dentry, d_hash));\n\t\tdo_one_tree(dentry);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~SB_ACTIVE;\n\n\t\tfsnotify_sb_delete(sb);\n\t\tcgroup_writeback_umount();\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n\tif (sb->s_bdi != &noop_backing_dev_info) {\n\t\tbdi_put(sb->s_bdi);\n\t\tsb->s_bdi = &noop_backing_dev_info;\n\t}\n}"
  },
  {
    "function_name": "trylock_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "410-420",
    "snippet": "bool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_unhashed",
          "args": [
            "&sb->s_instances"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read_trylock",
          "args": [
            "&sb->s_umount"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nbool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "grab_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "379-391",
    "snippet": "static int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & SB_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_super",
          "args": [
            "s"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "304-309",
          "snippet": "static void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&s->s_active"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "sb_lock"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic int grab_super(struct super_block *s) __releases(sb_lock)\n{\n\ts->s_count++;\n\tspin_unlock(&sb_lock);\n\tdown_write(&s->s_umount);\n\tif ((s->s_flags & SB_BORN) && atomic_inc_not_zero(&s->s_active)) {\n\t\tput_super(s);\n\t\treturn 1;\n\t}\n\tup_write(&s->s_umount);\n\tput_super(s);\n\treturn 0;\n}"
  },
  {
    "function_name": "deactivate_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "356-362",
    "snippet": "void deactivate_super(struct super_block *s)\n{\n        if (!atomic_add_unless(&s->s_active, -1, 1)) {\n\t\tdown_write(&s->s_umount);\n\t\tdeactivate_locked_super(s);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_locked_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "323-344",
          "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&s->s_active",
            "-1",
            "1"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nvoid deactivate_super(struct super_block *s)\n{\n        if (!atomic_add_unless(&s->s_active, -1, 1)) {\n\t\tdown_write(&s->s_umount);\n\t\tdeactivate_locked_super(s);\n\t}\n}"
  },
  {
    "function_name": "deactivate_locked_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "323-344",
    "snippet": "void deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_super",
          "args": [
            "s"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "304-309",
          "snippet": "static void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);",
            "static DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_filesystem",
          "args": [
            "fs"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "put_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/filesystems.c",
          "lines": "43-46",
          "snippet": "void put_filesystem(struct file_system_type *fs)\n{\n\tmodule_put(fs->owner);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nvoid put_filesystem(struct file_system_type *fs)\n{\n\tmodule_put(fs->owner);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_destroy",
          "args": [
            "&s->s_inode_lru"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_destroy",
          "args": [
            "&s->s_dentry_lru"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs->kill_sb",
          "args": [
            "s"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&s->s_shrink"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_es_unregister_shrinker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ext4/extents_status.c",
          "lines": "1294-1299",
          "snippet": "void ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}",
          "includes": [
            "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */",
            "#include <trace/events/ext4.h>",
            "#include \"ext4.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list_sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4_extents.h\"\t/* Needed when ES_AGGRESSIVE_TEST is defined */\n#include <trace/events/ext4.h>\n#include \"ext4.h\"\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/list_sort.h>\n\nvoid ext4_es_unregister_shrinker(struct ext4_sb_info *sbi)\n{\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_all_cnt);\n\tpercpu_counter_destroy(&sbi->s_es_stats.es_stats_shk_cnt);\n\tunregister_shrinker(&sbi->s_es_shrinker);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleancache_invalidate_fs",
          "args": [
            "s"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&s->s_active"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic DEFINE_SPINLOCK(sb_lock);\n\nvoid deactivate_locked_super(struct super_block *s)\n{\n\tstruct file_system_type *fs = s->s_type;\n\tif (atomic_dec_and_test(&s->s_active)) {\n\t\tcleancache_invalidate_fs(s);\n\t\tunregister_shrinker(&s->s_shrink);\n\t\tfs->kill_sb(s);\n\n\t\t/*\n\t\t * Since list_lru_destroy() may sleep, we cannot call it from\n\t\t * put_super(), where we hold the sb_lock. Therefore we destroy\n\t\t * the lru lists right now.\n\t\t */\n\t\tlist_lru_destroy(&s->s_dentry_lru);\n\t\tlist_lru_destroy(&s->s_inode_lru);\n\n\t\tput_filesystem(fs);\n\t\tput_super(s);\n\t} else {\n\t\tup_write(&s->s_umount);\n\t}\n}"
  },
  {
    "function_name": "put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "304-309",
    "snippet": "static void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static DEFINE_SPINLOCK(sb_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&sb_lock"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_super",
          "args": [
            "sb"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "__put_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "283-295",
          "snippet": "static void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&sb_lock"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic DEFINE_SPINLOCK(sb_lock);\n\nstatic void put_super(struct super_block *sb)\n{\n\tspin_lock(&sb_lock);\n\t__put_super(sb);\n\tspin_unlock(&sb_lock);\n}"
  },
  {
    "function_name": "__put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "283-295",
    "snippet": "static void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&s->rcu",
            "destroy_super_rcu"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->s_subtype"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "s->s_user_ns"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_free",
          "args": [
            "s"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&s->s_mounts)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&s->s_mounts"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "577-586",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "s->s_inode_lru.node"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "s->s_dentry_lru.node"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&s->s_list"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void __put_super(struct super_block *s)\n{\n\tif (!--s->s_count) {\n\t\tlist_del_init(&s->s_list);\n\t\tWARN_ON(s->s_dentry_lru.node);\n\t\tWARN_ON(s->s_inode_lru.node);\n\t\tWARN_ON(!list_empty(&s->s_mounts));\n\t\tsecurity_sb_free(s);\n\t\tput_user_ns(s->s_user_ns);\n\t\tkfree(s->s_subtype);\n\t\tcall_rcu(&s->rcu, destroy_super_rcu);\n\t}\n}"
  },
  {
    "function_name": "alloc_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "197-276",
    "snippet": "static struct super_block *alloc_super(struct file_system_type *type, int flags,\n\t\t\t\t       struct user_namespace *user_ns)\n{\n\tstruct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);\n\tstatic const struct super_operations default_op;\n\tint i;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s->s_mounts);\n\ts->s_user_ns = get_user_ns(user_ns);\n\tinit_rwsem(&s->s_umount);\n\tlockdep_set_class(&s->s_umount, &type->s_umount_key);\n\t/*\n\t * sget() can have s_umount recursion.\n\t *\n\t * When it cannot find a suitable sb, it allocates a new\n\t * one (this one), and tries again to find a suitable old\n\t * one.\n\t *\n\t * In case that succeeds, it will acquire the s_umount\n\t * lock of the old one. Since these are clearly distrinct\n\t * locks, and this object isn't exposed yet, there's no\n\t * risk of deadlocks.\n\t *\n\t * Annotate this by putting this lock in a different\n\t * subclass.\n\t */\n\tdown_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);\n\n\tif (security_sb_alloc(s))\n\t\tgoto fail;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n\t\tif (__percpu_init_rwsem(&s->s_writers.rw_sem[i],\n\t\t\t\t\tsb_writers_name[i],\n\t\t\t\t\t&type->s_writers_key[i]))\n\t\t\tgoto fail;\n\t}\n\tinit_waitqueue_head(&s->s_writers.wait_unfrozen);\n\ts->s_bdi = &noop_backing_dev_info;\n\ts->s_flags = flags;\n\tif (s->s_user_ns != &init_user_ns)\n\t\ts->s_iflags |= SB_I_NODEV;\n\tINIT_HLIST_NODE(&s->s_instances);\n\tINIT_HLIST_BL_HEAD(&s->s_roots);\n\tmutex_init(&s->s_sync_lock);\n\tINIT_LIST_HEAD(&s->s_inodes);\n\tspin_lock_init(&s->s_inode_list_lock);\n\tINIT_LIST_HEAD(&s->s_inodes_wb);\n\tspin_lock_init(&s->s_inode_wblist_lock);\n\n\ts->s_count = 1;\n\tatomic_set(&s->s_active, 1);\n\tmutex_init(&s->s_vfs_rename_mutex);\n\tlockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);\n\tinit_rwsem(&s->s_dquot.dqio_sem);\n\ts->s_maxbytes = MAX_NON_LFS;\n\ts->s_op = &default_op;\n\ts->s_time_gran = 1000000000;\n\ts->cleancache_poolid = CLEANCACHE_NO_POOL;\n\n\ts->s_shrink.seeks = DEFAULT_SEEKS;\n\ts->s_shrink.scan_objects = super_cache_scan;\n\ts->s_shrink.count_objects = super_cache_count;\n\ts->s_shrink.batch = 1024;\n\ts->s_shrink.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE;\n\tif (prealloc_shrinker(&s->s_shrink))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_dentry_lru, &s->s_shrink))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_inode_lru, &s->s_shrink))\n\t\tgoto fail;\n\treturn s;\n\nfail:\n\tdestroy_unused_super(s);\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);",
      "static char *sb_writers_name[SB_FREEZE_LEVELS] = {\n\t\"sb_writers\",\n\t\"sb_pagefaults\",\n\t\"sb_internal\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_unused_super",
          "args": [
            "s"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_unused_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "173-186",
          "snippet": "static void destroy_unused_super(struct super_block *s)\n{\n\tif (!s)\n\t\treturn;\n\tup_write(&s->s_umount);\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tsecurity_sb_free(s);\n\tput_user_ns(s->s_user_ns);\n\tkfree(s->s_subtype);\n\tfree_prealloced_shrinker(&s->s_shrink);\n\t/* no delays needed */\n\tdestroy_super_work(&s->destroy_work);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void destroy_unused_super(struct super_block *s)\n{\n\tif (!s)\n\t\treturn;\n\tup_write(&s->s_umount);\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tsecurity_sb_free(s);\n\tput_user_ns(s->s_user_ns);\n\tkfree(s->s_subtype);\n\tfree_prealloced_shrinker(&s->s_shrink);\n\t/* no delays needed */\n\tdestroy_super_work(&s->destroy_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_lru_init_memcg",
          "args": [
            "&s->s_inode_lru",
            "&s->s_shrink"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_init_memcg",
          "args": [
            "&s->s_dentry_lru",
            "&s->s_shrink"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prealloc_shrinker",
          "args": [
            "&s->s_shrink"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&s->s_dquot.dqio_sem"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&s->s_vfs_rename_mutex",
            "&type->s_vfs_rename_key"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&s->s_vfs_rename_mutex"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&s->s_active",
            "1"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&s->s_inode_wblist_lock"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_inodes_wb"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&s->s_inode_list_lock"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_inodes"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&s->s_sync_lock"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_BL_HEAD",
          "args": [
            "&s->s_roots"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_NODE",
          "args": [
            "&s->s_instances"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&s->s_writers.wait_unfrozen"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__percpu_init_rwsem",
          "args": [
            "&s->s_writers.rw_sem[i]",
            "sb_writers_name[i]",
            "&type->s_writers_key[i]"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_alloc",
          "args": [
            "s"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write_nested",
          "args": [
            "&s->s_umount",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_set_class",
          "args": [
            "&s->s_umount",
            "&type->s_umount_key"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&s->s_umount"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&s->s_mounts"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct super_block)",
            "GFP_USER"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\nstatic char *sb_writers_name[SB_FREEZE_LEVELS] = {\n\t\"sb_writers\",\n\t\"sb_pagefaults\",\n\t\"sb_internal\",\n};\n\nstatic struct super_block *alloc_super(struct file_system_type *type, int flags,\n\t\t\t\t       struct user_namespace *user_ns)\n{\n\tstruct super_block *s = kzalloc(sizeof(struct super_block),  GFP_USER);\n\tstatic const struct super_operations default_op;\n\tint i;\n\n\tif (!s)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&s->s_mounts);\n\ts->s_user_ns = get_user_ns(user_ns);\n\tinit_rwsem(&s->s_umount);\n\tlockdep_set_class(&s->s_umount, &type->s_umount_key);\n\t/*\n\t * sget() can have s_umount recursion.\n\t *\n\t * When it cannot find a suitable sb, it allocates a new\n\t * one (this one), and tries again to find a suitable old\n\t * one.\n\t *\n\t * In case that succeeds, it will acquire the s_umount\n\t * lock of the old one. Since these are clearly distrinct\n\t * locks, and this object isn't exposed yet, there's no\n\t * risk of deadlocks.\n\t *\n\t * Annotate this by putting this lock in a different\n\t * subclass.\n\t */\n\tdown_write_nested(&s->s_umount, SINGLE_DEPTH_NESTING);\n\n\tif (security_sb_alloc(s))\n\t\tgoto fail;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++) {\n\t\tif (__percpu_init_rwsem(&s->s_writers.rw_sem[i],\n\t\t\t\t\tsb_writers_name[i],\n\t\t\t\t\t&type->s_writers_key[i]))\n\t\t\tgoto fail;\n\t}\n\tinit_waitqueue_head(&s->s_writers.wait_unfrozen);\n\ts->s_bdi = &noop_backing_dev_info;\n\ts->s_flags = flags;\n\tif (s->s_user_ns != &init_user_ns)\n\t\ts->s_iflags |= SB_I_NODEV;\n\tINIT_HLIST_NODE(&s->s_instances);\n\tINIT_HLIST_BL_HEAD(&s->s_roots);\n\tmutex_init(&s->s_sync_lock);\n\tINIT_LIST_HEAD(&s->s_inodes);\n\tspin_lock_init(&s->s_inode_list_lock);\n\tINIT_LIST_HEAD(&s->s_inodes_wb);\n\tspin_lock_init(&s->s_inode_wblist_lock);\n\n\ts->s_count = 1;\n\tatomic_set(&s->s_active, 1);\n\tmutex_init(&s->s_vfs_rename_mutex);\n\tlockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);\n\tinit_rwsem(&s->s_dquot.dqio_sem);\n\ts->s_maxbytes = MAX_NON_LFS;\n\ts->s_op = &default_op;\n\ts->s_time_gran = 1000000000;\n\ts->cleancache_poolid = CLEANCACHE_NO_POOL;\n\n\ts->s_shrink.seeks = DEFAULT_SEEKS;\n\ts->s_shrink.scan_objects = super_cache_scan;\n\ts->s_shrink.count_objects = super_cache_count;\n\ts->s_shrink.batch = 1024;\n\ts->s_shrink.flags = SHRINKER_NUMA_AWARE | SHRINKER_MEMCG_AWARE;\n\tif (prealloc_shrinker(&s->s_shrink))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_dentry_lru, &s->s_shrink))\n\t\tgoto fail;\n\tif (list_lru_init_memcg(&s->s_inode_lru, &s->s_shrink))\n\t\tgoto fail;\n\treturn s;\n\nfail:\n\tdestroy_unused_super(s);\n\treturn NULL;\n}"
  },
  {
    "function_name": "destroy_unused_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "173-186",
    "snippet": "static void destroy_unused_super(struct super_block *s)\n{\n\tif (!s)\n\t\treturn;\n\tup_write(&s->s_umount);\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tsecurity_sb_free(s);\n\tput_user_ns(s->s_user_ns);\n\tkfree(s->s_subtype);\n\tfree_prealloced_shrinker(&s->s_shrink);\n\t/* no delays needed */\n\tdestroy_super_work(&s->destroy_work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_super_work",
          "args": [
            "&s->destroy_work"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_super_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "154-163",
          "snippet": "static void destroy_super_work(struct work_struct *work)\n{\n\tstruct super_block *s = container_of(work, struct super_block,\n\t\t\t\t\t\t\tdestroy_work);\n\tint i;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_free_rwsem(&s->s_writers.rw_sem[i]);\n\tkfree(s);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void destroy_super_work(struct work_struct *work)\n{\n\tstruct super_block *s = container_of(work, struct super_block,\n\t\t\t\t\t\t\tdestroy_work);\n\tint i;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_free_rwsem(&s->s_writers.rw_sem[i]);\n\tkfree(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_prealloced_shrinker",
          "args": [
            "&s->s_shrink"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->s_subtype"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "s->s_user_ns"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_free",
          "args": [
            "s"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_destroy",
          "args": [
            "&s->s_inode_lru"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_destroy",
          "args": [
            "&s->s_dentry_lru"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&s->s_umount"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void destroy_unused_super(struct super_block *s)\n{\n\tif (!s)\n\t\treturn;\n\tup_write(&s->s_umount);\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n\tsecurity_sb_free(s);\n\tput_user_ns(s->s_user_ns);\n\tkfree(s->s_subtype);\n\tfree_prealloced_shrinker(&s->s_shrink);\n\t/* no delays needed */\n\tdestroy_super_work(&s->destroy_work);\n}"
  },
  {
    "function_name": "destroy_super_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "165-170",
    "snippet": "static void destroy_super_rcu(struct rcu_head *head)\n{\n\tstruct super_block *s = container_of(head, struct super_block, rcu);\n\tINIT_WORK(&s->destroy_work, destroy_super_work);\n\tschedule_work(&s->destroy_work);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&s->destroy_work"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_write_schedule_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/nfs/direct.c",
          "lines": "740-757",
          "snippet": "static void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */",
            "#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */"
          ],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq);",
            "static void nfs_direct_write_schedule_work(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define NFS_ODIRECT_RESCHED_WRITES\t(2)\t/* write verification failed */\n#define NFS_ODIRECT_DO_COMMIT\t\t(1)\t/* an unstable reply was received */\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq);\nstatic void nfs_direct_write_schedule_work(struct work_struct *work);\n\nstatic void nfs_direct_write_schedule_work(struct work_struct *work)\n{\n\tstruct nfs_direct_req *dreq = container_of(work, struct nfs_direct_req, work);\n\tint flags = dreq->flags;\n\n\tdreq->flags = 0;\n\tswitch (flags) {\n\t\tcase NFS_ODIRECT_DO_COMMIT:\n\t\t\tnfs_direct_commit_schedule(dreq);\n\t\t\tbreak;\n\t\tcase NFS_ODIRECT_RESCHED_WRITES:\n\t\t\tnfs_direct_write_reschedule(dreq);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnfs_zap_mapping(dreq->inode, dreq->inode->i_mapping);\n\t\t\tnfs_direct_complete(dreq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&s->destroy_work",
            "destroy_super_work"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structsuper_block",
            "rcu"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void destroy_super_rcu(struct rcu_head *head)\n{\n\tstruct super_block *s = container_of(head, struct super_block, rcu);\n\tINIT_WORK(&s->destroy_work, destroy_super_work);\n\tschedule_work(&s->destroy_work);\n}"
  },
  {
    "function_name": "destroy_super_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "154-163",
    "snippet": "static void destroy_super_work(struct work_struct *work)\n{\n\tstruct super_block *s = container_of(work, struct super_block,\n\t\t\t\t\t\t\tdestroy_work);\n\tint i;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_free_rwsem(&s->s_writers.rw_sem[i]);\n\tkfree(s);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "kfree_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/libfs.c",
          "lines": "1103-1106",
          "snippet": "void kfree_link(void *p)\n{\n\tkfree(p);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nvoid kfree_link(void *p)\n{\n\tkfree(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_free_rwsem",
          "args": [
            "&s->s_writers.rw_sem[i]"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsuper_block",
            "destroy_work"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic void destroy_super_work(struct work_struct *work)\n{\n\tstruct super_block *s = container_of(work, struct super_block,\n\t\t\t\t\t\t\tdestroy_work);\n\tint i;\n\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_free_rwsem(&s->s_writers.rw_sem[i]);\n\tkfree(s);\n}"
  },
  {
    "function_name": "super_cache_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "115-152",
    "snippet": "static unsigned long super_cache_count(struct shrinker *shrink,\n\t\t\t\t       struct shrink_control *sc)\n{\n\tstruct super_block *sb;\n\tlong\ttotal_objects = 0;\n\n\tsb = container_of(shrink, struct super_block, s_shrink);\n\n\t/*\n\t * We don't call trylock_super() here as it is a scalability bottleneck,\n\t * so we're exposed to partial setup state. The shrinker rwsem does not\n\t * protect filesystem operations backing list_lru_shrink_count() or\n\t * s_op->nr_cached_objects(). Counts can change between\n\t * super_cache_count and super_cache_scan, so we really don't need locks\n\t * here.\n\t *\n\t * However, if we are currently mounting the superblock, the underlying\n\t * filesystem might be in a state of partial construction and hence it\n\t * is dangerous to access it.  trylock_super() uses a SB_BORN check to\n\t * avoid this situation, so do the same here. The memory barrier is\n\t * matched with the one in mount_fs() as we don't hold locks here.\n\t */\n\tif (!(sb->s_flags & SB_BORN))\n\t\treturn 0;\n\tsmp_rmb();\n\n\tif (sb->s_op && sb->s_op->nr_cached_objects)\n\t\ttotal_objects = sb->s_op->nr_cached_objects(sb, sc);\n\n\ttotal_objects += list_lru_shrink_count(&sb->s_dentry_lru, sc);\n\ttotal_objects += list_lru_shrink_count(&sb->s_inode_lru, sc);\n\n\tif (!total_objects)\n\t\treturn SHRINK_EMPTY;\n\n\ttotal_objects = vfs_pressure_ratio(total_objects);\n\treturn total_objects;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_pressure_ratio",
          "args": [
            "total_objects"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_count",
          "args": [
            "&sb->s_inode_lru",
            "sc"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_count",
          "args": [
            "&sb->s_dentry_lru",
            "sc"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->nr_cached_objects",
          "args": [
            "sb",
            "sc"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "shrink",
            "structsuper_block",
            "s_shrink"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic unsigned long super_cache_count(struct shrinker *shrink,\n\t\t\t\t       struct shrink_control *sc)\n{\n\tstruct super_block *sb;\n\tlong\ttotal_objects = 0;\n\n\tsb = container_of(shrink, struct super_block, s_shrink);\n\n\t/*\n\t * We don't call trylock_super() here as it is a scalability bottleneck,\n\t * so we're exposed to partial setup state. The shrinker rwsem does not\n\t * protect filesystem operations backing list_lru_shrink_count() or\n\t * s_op->nr_cached_objects(). Counts can change between\n\t * super_cache_count and super_cache_scan, so we really don't need locks\n\t * here.\n\t *\n\t * However, if we are currently mounting the superblock, the underlying\n\t * filesystem might be in a state of partial construction and hence it\n\t * is dangerous to access it.  trylock_super() uses a SB_BORN check to\n\t * avoid this situation, so do the same here. The memory barrier is\n\t * matched with the one in mount_fs() as we don't hold locks here.\n\t */\n\tif (!(sb->s_flags & SB_BORN))\n\t\treturn 0;\n\tsmp_rmb();\n\n\tif (sb->s_op && sb->s_op->nr_cached_objects)\n\t\ttotal_objects = sb->s_op->nr_cached_objects(sb, sc);\n\n\ttotal_objects += list_lru_shrink_count(&sb->s_dentry_lru, sc);\n\ttotal_objects += list_lru_shrink_count(&sb->s_inode_lru, sc);\n\n\tif (!total_objects)\n\t\treturn SHRINK_EMPTY;\n\n\ttotal_objects = vfs_pressure_ratio(total_objects);\n\treturn total_objects;\n}"
  },
  {
    "function_name": "super_cache_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
    "lines": "58-113",
    "snippet": "static unsigned long super_cache_scan(struct shrinker *shrink,\n\t\t\t\t      struct shrink_control *sc)\n{\n\tstruct super_block *sb;\n\tlong\tfs_objects = 0;\n\tlong\ttotal_objects;\n\tlong\tfreed = 0;\n\tlong\tdentries;\n\tlong\tinodes;\n\n\tsb = container_of(shrink, struct super_block, s_shrink);\n\n\t/*\n\t * Deadlock avoidance.  We may hold various FS locks, and we don't want\n\t * to recurse into the FS that called us in clear_inode() and friends..\n\t */\n\tif (!(sc->gfp_mask & __GFP_FS))\n\t\treturn SHRINK_STOP;\n\n\tif (!trylock_super(sb))\n\t\treturn SHRINK_STOP;\n\n\tif (sb->s_op->nr_cached_objects)\n\t\tfs_objects = sb->s_op->nr_cached_objects(sb, sc);\n\n\tinodes = list_lru_shrink_count(&sb->s_inode_lru, sc);\n\tdentries = list_lru_shrink_count(&sb->s_dentry_lru, sc);\n\ttotal_objects = dentries + inodes + fs_objects + 1;\n\tif (!total_objects)\n\t\ttotal_objects = 1;\n\n\t/* proportion the scan between the caches */\n\tdentries = mult_frac(sc->nr_to_scan, dentries, total_objects);\n\tinodes = mult_frac(sc->nr_to_scan, inodes, total_objects);\n\tfs_objects = mult_frac(sc->nr_to_scan, fs_objects, total_objects);\n\n\t/*\n\t * prune the dcache first as the icache is pinned by it, then\n\t * prune the icache, followed by the filesystem specific caches\n\t *\n\t * Ensure that we always scan at least one object - memcg kmem\n\t * accounting uses this to fully empty the caches.\n\t */\n\tsc->nr_to_scan = dentries + 1;\n\tfreed = prune_dcache_sb(sb, sc);\n\tsc->nr_to_scan = inodes + 1;\n\tfreed += prune_icache_sb(sb, sc);\n\n\tif (fs_objects) {\n\t\tsc->nr_to_scan = fs_objects + 1;\n\t\tfreed += sb->s_op->free_cached_objects(sb, sc);\n\t}\n\n\tup_read(&sb->s_umount);\n\treturn freed;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/user_namespace.h>",
      "#include <linux/lockdep.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/rculist_bl.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/mutex.h>",
      "#include <linux/idr.h>",
      "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int thaw_super_locked(struct super_block *sb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sb->s_umount"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->free_cached_objects",
          "args": [
            "sb",
            "sc"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prune_icache_sb",
          "args": [
            "sb",
            "sc"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "prune_icache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/inode.c",
          "lines": "777-786",
          "snippet": "long prune_icache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_inode_lru, sc,\n\t\t\t\t     inode_lru_isolate, &freeable);\n\tdispose_list(&freeable);\n\treturn freed;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/iversion.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/iversion.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/memblock.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nlong prune_icache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(freeable);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_inode_lru, sc,\n\t\t\t\t     inode_lru_isolate, &freeable);\n\tdispose_list(&freeable);\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prune_dcache_sb",
          "args": [
            "sb",
            "sc"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "prune_dcache_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/dcache.c",
          "lines": "1150-1159",
          "snippet": "long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_dentry_lru, sc,\n\t\t\t\t     dentry_lru_isolate, &dispose);\n\tshrink_dentry_list(&dispose);\n\treturn freed;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/list_lru.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/memblock.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/list_lru.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/memblock.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n\nlong prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)\n{\n\tLIST_HEAD(dispose);\n\tlong freed;\n\n\tfreed = list_lru_shrink_walk(&sb->s_dentry_lru, sc,\n\t\t\t\t     dentry_lru_isolate, &dispose);\n\tshrink_dentry_list(&dispose);\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mult_frac",
          "args": [
            "sc->nr_to_scan",
            "fs_objects",
            "total_objects"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mult_frac",
          "args": [
            "sc->nr_to_scan",
            "inodes",
            "total_objects"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mult_frac",
          "args": [
            "sc->nr_to_scan",
            "dentries",
            "total_objects"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_count",
          "args": [
            "&sb->s_dentry_lru",
            "sc"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_lru_shrink_count",
          "args": [
            "&sb->s_inode_lru",
            "sc"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb->s_op->nr_cached_objects",
          "args": [
            "sb",
            "sc"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trylock_super",
          "args": [
            "sb"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "trylock_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18397/repo/fs/super.c",
          "lines": "410-420",
          "snippet": "bool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/idr.h>",
            "#include <linux/writeback.h>\t\t/* for the emergency remount stuff */",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int thaw_super_locked(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nbool trylock_super(struct super_block *sb)\n{\n\tif (down_read_trylock(&sb->s_umount)) {\n\t\tif (!hlist_unhashed(&sb->s_instances) &&\n\t\t    sb->s_root && (sb->s_flags & SB_BORN))\n\t\t\treturn true;\n\t\tup_read(&sb->s_umount);\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "shrink",
            "structsuper_block",
            "s_shrink"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/user_namespace.h>\n#include <linux/lockdep.h>\n#include <linux/fsnotify.h>\n#include <linux/cleancache.h>\n#include <linux/rculist_bl.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/idr.h>\n#include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\nstatic int thaw_super_locked(struct super_block *sb);\n\nstatic unsigned long super_cache_scan(struct shrinker *shrink,\n\t\t\t\t      struct shrink_control *sc)\n{\n\tstruct super_block *sb;\n\tlong\tfs_objects = 0;\n\tlong\ttotal_objects;\n\tlong\tfreed = 0;\n\tlong\tdentries;\n\tlong\tinodes;\n\n\tsb = container_of(shrink, struct super_block, s_shrink);\n\n\t/*\n\t * Deadlock avoidance.  We may hold various FS locks, and we don't want\n\t * to recurse into the FS that called us in clear_inode() and friends..\n\t */\n\tif (!(sc->gfp_mask & __GFP_FS))\n\t\treturn SHRINK_STOP;\n\n\tif (!trylock_super(sb))\n\t\treturn SHRINK_STOP;\n\n\tif (sb->s_op->nr_cached_objects)\n\t\tfs_objects = sb->s_op->nr_cached_objects(sb, sc);\n\n\tinodes = list_lru_shrink_count(&sb->s_inode_lru, sc);\n\tdentries = list_lru_shrink_count(&sb->s_dentry_lru, sc);\n\ttotal_objects = dentries + inodes + fs_objects + 1;\n\tif (!total_objects)\n\t\ttotal_objects = 1;\n\n\t/* proportion the scan between the caches */\n\tdentries = mult_frac(sc->nr_to_scan, dentries, total_objects);\n\tinodes = mult_frac(sc->nr_to_scan, inodes, total_objects);\n\tfs_objects = mult_frac(sc->nr_to_scan, fs_objects, total_objects);\n\n\t/*\n\t * prune the dcache first as the icache is pinned by it, then\n\t * prune the icache, followed by the filesystem specific caches\n\t *\n\t * Ensure that we always scan at least one object - memcg kmem\n\t * accounting uses this to fully empty the caches.\n\t */\n\tsc->nr_to_scan = dentries + 1;\n\tfreed = prune_dcache_sb(sb, sc);\n\tsc->nr_to_scan = inodes + 1;\n\tfreed += prune_icache_sb(sb, sc);\n\n\tif (fs_objects) {\n\t\tsc->nr_to_scan = fs_objects + 1;\n\t\tfreed += sb->s_op->free_cached_objects(sb, sc);\n\t}\n\n\tup_read(&sb->s_umount);\n\treturn freed;\n}"
  }
]