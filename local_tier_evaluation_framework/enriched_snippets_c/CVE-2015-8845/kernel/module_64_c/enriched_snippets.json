[
  {
    "function_name": "apply_relocate_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "487-671",
    "snippet": "int apply_relocate_add(Elf64_Shdr *sechdrs,\n\t\t       const char *strtab,\n\t\t       unsigned int symindex,\n\t\t       unsigned int relsec,\n\t\t       struct module *me)\n{\n\tunsigned int i;\n\tElf64_Rela *rela = (void *)sechdrs[relsec].sh_addr;\n\tElf64_Sym *sym;\n\tunsigned long *location;\n\tunsigned long value;\n\n\tpr_debug(\"Applying ADD relocate section %u to %u\\n\", relsec,\n\t       sechdrs[relsec].sh_info);\n\n\t/* First time we're called, we can fix up .TOC. */\n\tif (!me->arch.toc_fixed) {\n\t\tsym = find_dot_toc(sechdrs, strtab, symindex);\n\t\t/* It's theoretically possible that a module doesn't want a\n\t\t * .TOC. so don't fail it just for that. */\n\t\tif (sym)\n\t\t\tsym->st_value = my_r2(sechdrs, me);\n\t\tme->arch.toc_fixed = true;\n\t}\n\n\tfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\n\t\t/* This is where to make the change */\n\t\tlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\n\t\t\t+ rela[i].r_offset;\n\t\t/* This is the symbol it is referring to */\n\t\tsym = (Elf64_Sym *)sechdrs[symindex].sh_addr\n\t\t\t+ ELF64_R_SYM(rela[i].r_info);\n\n\t\tpr_debug(\"RELOC at %p: %li-type as %s (0x%lx) + %li\\n\",\n\t\t       location, (long)ELF64_R_TYPE(rela[i].r_info),\n\t\t       strtab + sym->st_name, (unsigned long)sym->st_value,\n\t\t       (long)rela[i].r_addend);\n\n\t\t/* `Everything is relative'. */\n\t\tvalue = sym->st_value + rela[i].r_addend;\n\n\t\tswitch (ELF64_R_TYPE(rela[i].r_info)) {\n\t\tcase R_PPC64_ADDR32:\n\t\t\t/* Simply set it */\n\t\t\t*(u32 *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_ADDR64:\n\t\t\t/* Simply set it */\n\t\t\t*(unsigned long *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC:\n\t\t\t*(unsigned long *)location = my_r2(sechdrs, me);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif (value + 0x8000 > 0xffff) {\n\t\t\t\tpr_err(\"%s: bad TOC16 relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_LO:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_DS:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif ((value & 3) != 0 || value + 0x8000 > 0xffff) {\n\t\t\t\tpr_err(\"%s: bad TOC16_DS relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xfffc)\n\t\t\t\t| (value & 0xfffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_LO_DS:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif ((value & 3) != 0) {\n\t\t\t\tpr_err(\"%s: bad TOC16_LO_DS relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xfffc)\n\t\t\t\t| (value & 0xfffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_HA:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tvalue = ((value + 0x8000) >> 16);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC_REL24:\n\t\t\t/* FIXME: Handle weak symbols here --RR */\n\t\t\tif (sym->st_shndx == SHN_UNDEF) {\n\t\t\t\t/* External: go via stub */\n\t\t\t\tvalue = stub_for_addr(sechdrs, value, me);\n\t\t\t\tif (!value)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\tif (!restore_r2((u32 *)location + 1, me))\n\t\t\t\t\treturn -ENOEXEC;\n\t\t\t} else\n\t\t\t\tvalue += local_entry_offset(sym);\n\n\t\t\t/* Convert value to relative */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tif (value + 0x2000000 > 0x3ffffff || (value & 3) != 0){\n\t\t\t\tpr_err(\"%s: REL24 %li out of range!\\n\",\n\t\t\t\t       me->name, (long int)value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\n\t\t\t/* Only replace bits 2 through 26 */\n\t\t\t*(uint32_t *)location\n\t\t\t\t= (*(uint32_t *)location & ~0x03fffffc)\n\t\t\t\t| (value & 0x03fffffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL64:\n\t\t\t/* 64 bits relative (used by features fixups) */\n\t\t\t*location = value - (unsigned long)location;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOCSAVE:\n\t\t\t/*\n\t\t\t * Marker reloc indicates we don't have to save r2.\n\t\t\t * That would only save us one instruction, so ignore\n\t\t\t * it.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL16_HA:\n\t\t\t/* Subtract location pointer */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tvalue = ((value + 0x8000) >> 16);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL16_LO:\n\t\t\t/* Subtract location pointer */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: Unknown ADD relocation: %lu\\n\",\n\t\t\t       me->name,\n\t\t\t       (unsigned long)ELF64_R_TYPE(rela[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tme->arch.toc = my_r2(sechdrs, me);\n\tme->arch.tramp = stub_for_addr(sechdrs,\n\t\t\t\t       (unsigned long)ftrace_caller,\n\t\t\t\t       me);\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stub_for_addr",
          "args": [
            "sechdrs",
            "(unsigned long)ftrace_caller",
            "me"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "stub_for_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "449-471",
          "snippet": "static unsigned long stub_for_addr(Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tBUG_ON(i >= num_stubs);\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_for_addr(Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tBUG_ON(i >= num_stubs);\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "my_r2",
          "args": [
            "sechdrs",
            "me"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "my_r2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "410-413",
          "snippet": "static inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn sechdrs[me->arch.toc_section].sh_addr + 0x8000;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn sechdrs[me->arch.toc_section].sh_addr + 0x8000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Unknown ADD relocation: %lu\\n\"",
            "me->name",
            "(unsigned long)ELF64_R_TYPE(rela[i].r_info)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: REL24 %li out of range!\\n\"",
            "me->name",
            "(long int)value"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_entry_offset",
          "args": [
            "sym"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "local_entry_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "93-96",
          "snippet": "static unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_r2",
          "args": [
            "(u32 *)location + 1",
            "me"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "restore_r2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "475-485",
          "snippet": "static int restore_r2(u32 *instruction, struct module *me)\n{\n\tif (*instruction != PPC_INST_NOP) {\n\t\tpr_err(\"%s: Expect noop after relocate, got %08x\\n\",\n\t\t       me->name, *instruction);\n\t\treturn 0;\n\t}\n\t/* ld r2,R2_STACK_OFFSET(r1) */\n\t*instruction = 0xe8410000 | R2_STACK_OFFSET;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define R2_STACK_OFFSET 40",
            "#define R2_STACK_OFFSET 24"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\n#define R2_STACK_OFFSET 40\n#define R2_STACK_OFFSET 24\n\nstatic int restore_r2(u32 *instruction, struct module *me)\n{\n\tif (*instruction != PPC_INST_NOP) {\n\t\tpr_err(\"%s: Expect noop after relocate, got %08x\\n\",\n\t\t       me->name, *instruction);\n\t\treturn 0;\n\t}\n\t/* ld r2,R2_STACK_OFFSET(r1) */\n\t*instruction = 0xe8410000 | R2_STACK_OFFSET;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: bad TOC16_LO_DS relocation (0x%lx)\\n\"",
            "me->name",
            "value"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: bad TOC16_DS relocation (0x%lx)\\n\"",
            "me->name",
            "value"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: bad TOC16 relocation (0x%lx)\\n\"",
            "me->name",
            "value"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"RELOC at %p: %li-type as %s (0x%lx) + %li\\n\"",
            "location",
            "(long)ELF64_R_TYPE(rela[i].r_info)",
            "strtab + sym->st_name",
            "(unsigned long)sym->st_value",
            "(long)rela[i].r_addend"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_dot_toc",
          "args": [
            "sechdrs",
            "strtab",
            "symindex"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "find_dot_toc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "343-359",
          "snippet": "static Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\n\t\t\t       const char *strtab,\n\t\t\t       unsigned int symindex)\n{\n\tunsigned int i, numsyms;\n\tElf64_Sym *syms;\n\n\tsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\n\tnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF\n\t\t    && strcmp(strtab + syms[i].st_name, \"TOC.\") == 0)\n\t\t\treturn &syms[i];\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\n\t\t\t       const char *strtab,\n\t\t\t       unsigned int symindex)\n{\n\tunsigned int i, numsyms;\n\tElf64_Sym *syms;\n\n\tsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\n\tnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF\n\t\t    && strcmp(strtab + syms[i].st_name, \"TOC.\") == 0)\n\t\t\treturn &syms[i];\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Applying ADD relocate section %u to %u\\n\"",
            "relsec",
            "sechdrs[relsec].sh_info"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nint apply_relocate_add(Elf64_Shdr *sechdrs,\n\t\t       const char *strtab,\n\t\t       unsigned int symindex,\n\t\t       unsigned int relsec,\n\t\t       struct module *me)\n{\n\tunsigned int i;\n\tElf64_Rela *rela = (void *)sechdrs[relsec].sh_addr;\n\tElf64_Sym *sym;\n\tunsigned long *location;\n\tunsigned long value;\n\n\tpr_debug(\"Applying ADD relocate section %u to %u\\n\", relsec,\n\t       sechdrs[relsec].sh_info);\n\n\t/* First time we're called, we can fix up .TOC. */\n\tif (!me->arch.toc_fixed) {\n\t\tsym = find_dot_toc(sechdrs, strtab, symindex);\n\t\t/* It's theoretically possible that a module doesn't want a\n\t\t * .TOC. so don't fail it just for that. */\n\t\tif (sym)\n\t\t\tsym->st_value = my_r2(sechdrs, me);\n\t\tme->arch.toc_fixed = true;\n\t}\n\n\tfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\n\t\t/* This is where to make the change */\n\t\tlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\n\t\t\t+ rela[i].r_offset;\n\t\t/* This is the symbol it is referring to */\n\t\tsym = (Elf64_Sym *)sechdrs[symindex].sh_addr\n\t\t\t+ ELF64_R_SYM(rela[i].r_info);\n\n\t\tpr_debug(\"RELOC at %p: %li-type as %s (0x%lx) + %li\\n\",\n\t\t       location, (long)ELF64_R_TYPE(rela[i].r_info),\n\t\t       strtab + sym->st_name, (unsigned long)sym->st_value,\n\t\t       (long)rela[i].r_addend);\n\n\t\t/* `Everything is relative'. */\n\t\tvalue = sym->st_value + rela[i].r_addend;\n\n\t\tswitch (ELF64_R_TYPE(rela[i].r_info)) {\n\t\tcase R_PPC64_ADDR32:\n\t\t\t/* Simply set it */\n\t\t\t*(u32 *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_ADDR64:\n\t\t\t/* Simply set it */\n\t\t\t*(unsigned long *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC:\n\t\t\t*(unsigned long *)location = my_r2(sechdrs, me);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif (value + 0x8000 > 0xffff) {\n\t\t\t\tpr_err(\"%s: bad TOC16 relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_LO:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_DS:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif ((value & 3) != 0 || value + 0x8000 > 0xffff) {\n\t\t\t\tpr_err(\"%s: bad TOC16_DS relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xfffc)\n\t\t\t\t| (value & 0xfffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_LO_DS:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tif ((value & 3) != 0) {\n\t\t\t\tpr_err(\"%s: bad TOC16_LO_DS relocation (0x%lx)\\n\",\n\t\t\t\t       me->name, value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xfffc)\n\t\t\t\t| (value & 0xfffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOC16_HA:\n\t\t\t/* Subtract TOC pointer */\n\t\t\tvalue -= my_r2(sechdrs, me);\n\t\t\tvalue = ((value + 0x8000) >> 16);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC_REL24:\n\t\t\t/* FIXME: Handle weak symbols here --RR */\n\t\t\tif (sym->st_shndx == SHN_UNDEF) {\n\t\t\t\t/* External: go via stub */\n\t\t\t\tvalue = stub_for_addr(sechdrs, value, me);\n\t\t\t\tif (!value)\n\t\t\t\t\treturn -ENOENT;\n\t\t\t\tif (!restore_r2((u32 *)location + 1, me))\n\t\t\t\t\treturn -ENOEXEC;\n\t\t\t} else\n\t\t\t\tvalue += local_entry_offset(sym);\n\n\t\t\t/* Convert value to relative */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tif (value + 0x2000000 > 0x3ffffff || (value & 3) != 0){\n\t\t\t\tpr_err(\"%s: REL24 %li out of range!\\n\",\n\t\t\t\t       me->name, (long int)value);\n\t\t\t\treturn -ENOEXEC;\n\t\t\t}\n\n\t\t\t/* Only replace bits 2 through 26 */\n\t\t\t*(uint32_t *)location\n\t\t\t\t= (*(uint32_t *)location & ~0x03fffffc)\n\t\t\t\t| (value & 0x03fffffc);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL64:\n\t\t\t/* 64 bits relative (used by features fixups) */\n\t\t\t*location = value - (unsigned long)location;\n\t\t\tbreak;\n\n\t\tcase R_PPC64_TOCSAVE:\n\t\t\t/*\n\t\t\t * Marker reloc indicates we don't have to save r2.\n\t\t\t * That would only save us one instruction, so ignore\n\t\t\t * it.\n\t\t\t */\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL16_HA:\n\t\t\t/* Subtract location pointer */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\tvalue = ((value + 0x8000) >> 16);\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tcase R_PPC64_REL16_LO:\n\t\t\t/* Subtract location pointer */\n\t\t\tvalue -= (unsigned long)location;\n\t\t\t*((uint16_t *) location)\n\t\t\t\t= (*((uint16_t *) location) & ~0xffff)\n\t\t\t\t| (value & 0xffff);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: Unknown ADD relocation: %lu\\n\",\n\t\t\t       me->name,\n\t\t\t       (unsigned long)ELF64_R_TYPE(rela[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tme->arch.toc = my_r2(sechdrs, me);\n\tme->arch.tramp = stub_for_addr(sechdrs,\n\t\t\t\t       (unsigned long)ftrace_caller,\n\t\t\t\t       me);\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_r2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "475-485",
    "snippet": "static int restore_r2(u32 *instruction, struct module *me)\n{\n\tif (*instruction != PPC_INST_NOP) {\n\t\tpr_err(\"%s: Expect noop after relocate, got %08x\\n\",\n\t\t       me->name, *instruction);\n\t\treturn 0;\n\t}\n\t/* ld r2,R2_STACK_OFFSET(r1) */\n\t*instruction = 0xe8410000 | R2_STACK_OFFSET;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define R2_STACK_OFFSET 40",
      "#define R2_STACK_OFFSET 24"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Expect noop after relocate, got %08x\\n\"",
            "me->name",
            "*instruction"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\n#define R2_STACK_OFFSET 40\n#define R2_STACK_OFFSET 24\n\nstatic int restore_r2(u32 *instruction, struct module *me)\n{\n\tif (*instruction != PPC_INST_NOP) {\n\t\tpr_err(\"%s: Expect noop after relocate, got %08x\\n\",\n\t\t       me->name, *instruction);\n\t\treturn 0;\n\t}\n\t/* ld r2,R2_STACK_OFFSET(r1) */\n\t*instruction = 0xe8410000 | R2_STACK_OFFSET;\n\treturn 1;\n}"
  },
  {
    "function_name": "stub_for_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "449-471",
    "snippet": "static unsigned long stub_for_addr(Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tBUG_ON(i >= num_stubs);\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_stub",
          "args": [
            "sechdrs",
            "&stubs[i]",
            "addr",
            "me"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "create_stub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "423-445",
          "snippet": "static inline int create_stub(Elf64_Shdr *sechdrs,\n\t\t\t      struct ppc64_stub_entry *entry,\n\t\t\t      unsigned long addr,\n\t\t\t      struct module *me)\n{\n\tlong reladdr;\n\n\tmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\n\n\t/* Stub uses address relative to r2. */\n\treladdr = (unsigned long)entry - my_r2(sechdrs, me);\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address %p of stub out of range of %p.\\n\",\n\t\t       me->name, (void *)reladdr, (void *)my_r2);\n\t\treturn 0;\n\t}\n\tpr_debug(\"Stub %p get data from reladdr %li\\n\", entry, reladdr);\n\n\tentry->jump[0] |= PPC_HA(reladdr);\n\tentry->jump[1] |= PPC_LO(reladdr);\n\tentry->funcdata = func_desc(addr);\n\treturn 1;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 ppc64_stub_insns[] = {\n\t0x3d620000,\t\t\t/* addis   r11,r2, <high> */\n\t0x396b0000,\t\t\t/* addi    r11,r11, <low> */\n\t/* Save current r2 value in magic place on the stack. */\n\t0xf8410000|R2_STACK_OFFSET,\t/* std     r2,R2_STACK_OFFSET(r1) */\n\t0xe98b0020,\t\t\t/* ld      r12,32(r11) */\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t/* Set up new r2 from function descriptor */\n\t0xe84b0028,\t\t\t/* ld      r2,40(r11) */\n#endif\n\t0x7d8903a6,\t\t\t/* mtctr   r12 */\n\t0x4e800420\t\t\t/* bctr */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic u32 ppc64_stub_insns[] = {\n\t0x3d620000,\t\t\t/* addis   r11,r2, <high> */\n\t0x396b0000,\t\t\t/* addi    r11,r11, <low> */\n\t/* Save current r2 value in magic place on the stack. */\n\t0xf8410000|R2_STACK_OFFSET,\t/* std     r2,R2_STACK_OFFSET(r1) */\n\t0xe98b0020,\t\t\t/* ld      r12,32(r11) */\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t/* Set up new r2 from function descriptor */\n\t0xe84b0028,\t\t\t/* ld      r2,40(r11) */\n#endif\n\t0x7d8903a6,\t\t\t/* mtctr   r12 */\n\t0x4e800420\t\t\t/* bctr */\n};\n\nstatic inline int create_stub(Elf64_Shdr *sechdrs,\n\t\t\t      struct ppc64_stub_entry *entry,\n\t\t\t      unsigned long addr,\n\t\t\t      struct module *me)\n{\n\tlong reladdr;\n\n\tmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\n\n\t/* Stub uses address relative to r2. */\n\treladdr = (unsigned long)entry - my_r2(sechdrs, me);\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address %p of stub out of range of %p.\\n\",\n\t\t       me->name, (void *)reladdr, (void *)my_r2);\n\t\treturn 0;\n\t}\n\tpr_debug(\"Stub %p get data from reladdr %li\\n\", entry, reladdr);\n\n\tentry->jump[0] |= PPC_HA(reladdr);\n\tentry->jump[1] |= PPC_LO(reladdr);\n\tentry->funcdata = func_desc(addr);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "func_addr",
          "args": [
            "addr"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "stub_func_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "89-92",
          "snippet": "static unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i >= num_stubs"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_for_addr(Elf64_Shdr *sechdrs,\n\t\t\t\t   unsigned long addr,\n\t\t\t\t   struct module *me)\n{\n\tstruct ppc64_stub_entry *stubs;\n\tunsigned int i, num_stubs;\n\n\tnum_stubs = sechdrs[me->arch.stubs_section].sh_size / sizeof(*stubs);\n\n\t/* Find this stub, or if that fails, the next avail. entry */\n\tstubs = (void *)sechdrs[me->arch.stubs_section].sh_addr;\n\tfor (i = 0; stub_func_addr(stubs[i].funcdata); i++) {\n\t\tBUG_ON(i >= num_stubs);\n\n\t\tif (stub_func_addr(stubs[i].funcdata) == func_addr(addr))\n\t\t\treturn (unsigned long)&stubs[i];\n\t}\n\n\tif (!create_stub(sechdrs, &stubs[i], addr, me))\n\t\treturn 0;\n\n\treturn (unsigned long)&stubs[i];\n}"
  },
  {
    "function_name": "create_stub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "423-445",
    "snippet": "static inline int create_stub(Elf64_Shdr *sechdrs,\n\t\t\t      struct ppc64_stub_entry *entry,\n\t\t\t      unsigned long addr,\n\t\t\t      struct module *me)\n{\n\tlong reladdr;\n\n\tmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\n\n\t/* Stub uses address relative to r2. */\n\treladdr = (unsigned long)entry - my_r2(sechdrs, me);\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address %p of stub out of range of %p.\\n\",\n\t\t       me->name, (void *)reladdr, (void *)my_r2);\n\t\treturn 0;\n\t}\n\tpr_debug(\"Stub %p get data from reladdr %li\\n\", entry, reladdr);\n\n\tentry->jump[0] |= PPC_HA(reladdr);\n\tentry->jump[1] |= PPC_LO(reladdr);\n\tentry->funcdata = func_desc(addr);\n\treturn 1;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ppc64_stub_insns[] = {\n\t0x3d620000,\t\t\t/* addis   r11,r2, <high> */\n\t0x396b0000,\t\t\t/* addi    r11,r11, <low> */\n\t/* Save current r2 value in magic place on the stack. */\n\t0xf8410000|R2_STACK_OFFSET,\t/* std     r2,R2_STACK_OFFSET(r1) */\n\t0xe98b0020,\t\t\t/* ld      r12,32(r11) */\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t/* Set up new r2 from function descriptor */\n\t0xe84b0028,\t\t\t/* ld      r2,40(r11) */\n#endif\n\t0x7d8903a6,\t\t\t/* mtctr   r12 */\n\t0x4e800420\t\t\t/* bctr */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "func_desc",
          "args": [
            "addr"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "func_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "81-84",
          "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_LO",
          "args": [
            "reladdr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_HA",
          "args": [
            "reladdr"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Stub %p get data from reladdr %li\\n\"",
            "entry",
            "reladdr"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Address %p of stub out of range of %p.\\n\"",
            "me->name",
            "(void *)reladdr",
            "(void *)my_r2"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "my_r2",
          "args": [
            "sechdrs",
            "me"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "my_r2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "410-413",
          "snippet": "static inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn sechdrs[me->arch.toc_section].sh_addr + 0x8000;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn sechdrs[me->arch.toc_section].sh_addr + 0x8000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->jump",
            "ppc64_stub_insns",
            "sizeof(ppc64_stub_insns)"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic u32 ppc64_stub_insns[] = {\n\t0x3d620000,\t\t\t/* addis   r11,r2, <high> */\n\t0x396b0000,\t\t\t/* addi    r11,r11, <low> */\n\t/* Save current r2 value in magic place on the stack. */\n\t0xf8410000|R2_STACK_OFFSET,\t/* std     r2,R2_STACK_OFFSET(r1) */\n\t0xe98b0020,\t\t\t/* ld      r12,32(r11) */\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t/* Set up new r2 from function descriptor */\n\t0xe84b0028,\t\t\t/* ld      r2,40(r11) */\n#endif\n\t0x7d8903a6,\t\t\t/* mtctr   r12 */\n\t0x4e800420\t\t\t/* bctr */\n};\n\nstatic inline int create_stub(Elf64_Shdr *sechdrs,\n\t\t\t      struct ppc64_stub_entry *entry,\n\t\t\t      unsigned long addr,\n\t\t\t      struct module *me)\n{\n\tlong reladdr;\n\n\tmemcpy(entry->jump, ppc64_stub_insns, sizeof(ppc64_stub_insns));\n\n\t/* Stub uses address relative to r2. */\n\treladdr = (unsigned long)entry - my_r2(sechdrs, me);\n\tif (reladdr > 0x7FFFFFFF || reladdr < -(0x80000000L)) {\n\t\tpr_err(\"%s: Address %p of stub out of range of %p.\\n\",\n\t\t       me->name, (void *)reladdr, (void *)my_r2);\n\t\treturn 0;\n\t}\n\tpr_debug(\"Stub %p get data from reladdr %li\\n\", entry, reladdr);\n\n\tentry->jump[0] |= PPC_HA(reladdr);\n\tentry->jump[1] |= PPC_LO(reladdr);\n\tentry->funcdata = func_desc(addr);\n\treturn 1;\n}"
  },
  {
    "function_name": "my_r2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "410-413",
    "snippet": "static inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn sechdrs[me->arch.toc_section].sh_addr + 0x8000;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic inline unsigned long my_r2(Elf64_Shdr *sechdrs, struct module *me)\n{\n\treturn sechdrs[me->arch.toc_section].sh_addr + 0x8000;\n}"
  },
  {
    "function_name": "module_frob_arch_sections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "361-405",
    "snippet": "int module_frob_arch_sections(Elf64_Ehdr *hdr,\n\t\t\t      Elf64_Shdr *sechdrs,\n\t\t\t      char *secstrings,\n\t\t\t      struct module *me)\n{\n\tunsigned int i;\n\n\t/* Find .toc and .stubs sections, symtab and strtab */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tchar *p;\n\t\tif (strcmp(secstrings + sechdrs[i].sh_name, \".stubs\") == 0)\n\t\t\tme->arch.stubs_section = i;\n\t\telse if (strcmp(secstrings + sechdrs[i].sh_name, \".toc\") == 0)\n\t\t\tme->arch.toc_section = i;\n\t\telse if (strcmp(secstrings+sechdrs[i].sh_name,\"__versions\")==0)\n\t\t\tdedotify_versions((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t\t\t  sechdrs[i].sh_size);\n\n\t\t/* We don't handle .init for the moment: rename to _init */\n\t\twhile ((p = strstr(secstrings + sechdrs[i].sh_name, \".init\")))\n\t\t\tp[0] = '_';\n\n\t\tif (sechdrs[i].sh_type == SHT_SYMTAB)\n\t\t\tdedotify((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t\t sechdrs[i].sh_size / sizeof(Elf64_Sym),\n\t\t\t\t (void *)hdr\n\t\t\t\t + sechdrs[sechdrs[i].sh_link].sh_offset);\n\t}\n\n\tif (!me->arch.stubs_section) {\n\t\tpr_err(\"%s: doesn't contain .stubs.\\n\", me->name);\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* If we don't have a .toc, just use .stubs.  We need to set r2\n\t   to some reasonable value in case the module calls out to\n\t   other functions via a stub, or if a function pointer escapes\n\t   the module by some means.  */\n\tif (!me->arch.toc_section)\n\t\tme->arch.toc_section = me->arch.stubs_section;\n\n\t/* Override the stubs size */\n\tsechdrs[me->arch.stubs_section].sh_size = get_stubs_size(hdr, sechdrs);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_stubs_size",
          "args": [
            "hdr",
            "sechdrs"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "get_stubs_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "270-307",
          "snippet": "static unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\n\t\t\t\t    const Elf64_Shdr *sechdrs)\n{\n\t/* One extra reloc so it's always 0-funcaddr terminated */\n\tunsigned long relocs = 1;\n\tunsigned i;\n\n\t/* Every relocated section... */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %Lu\\n\",\n\t\t\t       (void *)sechdrs[i].sh_addr,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf64_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)sechdrs[i].sh_addr,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf64_Rela),\n\t\t\t     sizeof(Elf64_Rela), relacmp, relaswap);\n\n\t\t\trelocs += count_relocs((void *)sechdrs[i].sh_addr,\n\t\t\t\t\t       sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela));\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/* make the trampoline to the ftrace_caller */\n\trelocs++;\n#endif\n\n\tpr_debug(\"Looks like a total of %lu stubs, max\\n\", relocs);\n\treturn relocs * sizeof(struct ppc64_stub_entry);\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\n\t\t\t\t    const Elf64_Shdr *sechdrs)\n{\n\t/* One extra reloc so it's always 0-funcaddr terminated */\n\tunsigned long relocs = 1;\n\tunsigned i;\n\n\t/* Every relocated section... */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %Lu\\n\",\n\t\t\t       (void *)sechdrs[i].sh_addr,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf64_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)sechdrs[i].sh_addr,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf64_Rela),\n\t\t\t     sizeof(Elf64_Rela), relacmp, relaswap);\n\n\t\t\trelocs += count_relocs((void *)sechdrs[i].sh_addr,\n\t\t\t\t\t       sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela));\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/* make the trampoline to the ftrace_caller */\n\trelocs++;\n#endif\n\n\tpr_debug(\"Looks like a total of %lu stubs, max\\n\", relocs);\n\treturn relocs * sizeof(struct ppc64_stub_entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: doesn't contain .stubs.\\n\"",
            "me->name"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dedotify",
          "args": [
            "(void *)hdr + sechdrs[i].sh_offset",
            "sechdrs[i].sh_size / sizeof(Elf64_Sym)",
            "(void *)hdr\n\t\t\t\t + sechdrs[sechdrs[i].sh_link].sh_offset"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "dedotify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "330-341",
          "snippet": "static void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF) {\n\t\t\tchar *name = strtab + syms[i].st_name;\n\t\t\tif (name[0] == '.')\n\t\t\t\tmemmove(name, name+1, strlen(name));\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF) {\n\t\t\tchar *name = strtab + syms[i].st_name;\n\t\t\tif (name[0] == '.')\n\t\t\t\tmemmove(name, name+1, strlen(name));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "secstrings + sechdrs[i].sh_name",
            "\".init\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dedotify_versions",
          "args": [
            "(void *)hdr + sechdrs[i].sh_offset",
            "sechdrs[i].sh_size"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "dedotify_versions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "310-327",
          "snippet": "static void dedotify_versions(struct modversion_info *vers,\n\t\t\t      unsigned long size)\n{\n\tstruct modversion_info *end;\n\n\tfor (end = (void *)vers + size; vers < end; vers++)\n\t\tif (vers->name[0] == '.') {\n\t\t\tmemmove(vers->name, vers->name+1, strlen(vers->name));\n#ifdef ARCH_RELOCATES_KCRCTAB\n\t\t\t/* The TOC symbol has no CRC computed. To avoid CRC\n\t\t\t * check failing, we must force it to the expected\n\t\t\t * value (see CRC check in module.c).\n\t\t\t */\n\t\t\tif (!strcmp(vers->name, \"TOC.\"))\n\t\t\t\tvers->crc = -(unsigned long)reloc_start;\n#endif\n\t\t}\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void dedotify_versions(struct modversion_info *vers,\n\t\t\t      unsigned long size)\n{\n\tstruct modversion_info *end;\n\n\tfor (end = (void *)vers + size; vers < end; vers++)\n\t\tif (vers->name[0] == '.') {\n\t\t\tmemmove(vers->name, vers->name+1, strlen(vers->name));\n#ifdef ARCH_RELOCATES_KCRCTAB\n\t\t\t/* The TOC symbol has no CRC computed. To avoid CRC\n\t\t\t * check failing, we must force it to the expected\n\t\t\t * value (see CRC check in module.c).\n\t\t\t */\n\t\t\tif (!strcmp(vers->name, \"TOC.\"))\n\t\t\t\tvers->crc = -(unsigned long)reloc_start;\n#endif\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "secstrings+sechdrs[i].sh_name",
            "\"__versions\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "secstrings + sechdrs[i].sh_name",
            "\".toc\""
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "secstrings + sechdrs[i].sh_name",
            "\".stubs\""
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nint module_frob_arch_sections(Elf64_Ehdr *hdr,\n\t\t\t      Elf64_Shdr *sechdrs,\n\t\t\t      char *secstrings,\n\t\t\t      struct module *me)\n{\n\tunsigned int i;\n\n\t/* Find .toc and .stubs sections, symtab and strtab */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tchar *p;\n\t\tif (strcmp(secstrings + sechdrs[i].sh_name, \".stubs\") == 0)\n\t\t\tme->arch.stubs_section = i;\n\t\telse if (strcmp(secstrings + sechdrs[i].sh_name, \".toc\") == 0)\n\t\t\tme->arch.toc_section = i;\n\t\telse if (strcmp(secstrings+sechdrs[i].sh_name,\"__versions\")==0)\n\t\t\tdedotify_versions((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t\t\t  sechdrs[i].sh_size);\n\n\t\t/* We don't handle .init for the moment: rename to _init */\n\t\twhile ((p = strstr(secstrings + sechdrs[i].sh_name, \".init\")))\n\t\t\tp[0] = '_';\n\n\t\tif (sechdrs[i].sh_type == SHT_SYMTAB)\n\t\t\tdedotify((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t\t sechdrs[i].sh_size / sizeof(Elf64_Sym),\n\t\t\t\t (void *)hdr\n\t\t\t\t + sechdrs[sechdrs[i].sh_link].sh_offset);\n\t}\n\n\tif (!me->arch.stubs_section) {\n\t\tpr_err(\"%s: doesn't contain .stubs.\\n\", me->name);\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* If we don't have a .toc, just use .stubs.  We need to set r2\n\t   to some reasonable value in case the module calls out to\n\t   other functions via a stub, or if a function pointer escapes\n\t   the module by some means.  */\n\tif (!me->arch.toc_section)\n\t\tme->arch.toc_section = me->arch.stubs_section;\n\n\t/* Override the stubs size */\n\tsechdrs[me->arch.stubs_section].sh_size = get_stubs_size(hdr, sechdrs);\n\treturn 0;\n}"
  },
  {
    "function_name": "find_dot_toc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "343-359",
    "snippet": "static Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\n\t\t\t       const char *strtab,\n\t\t\t       unsigned int symindex)\n{\n\tunsigned int i, numsyms;\n\tElf64_Sym *syms;\n\n\tsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\n\tnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF\n\t\t    && strcmp(strtab + syms[i].st_name, \"TOC.\") == 0)\n\t\t\treturn &syms[i];\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "strtab + syms[i].st_name",
            "\"TOC.\""
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic Elf64_Sym *find_dot_toc(Elf64_Shdr *sechdrs,\n\t\t\t       const char *strtab,\n\t\t\t       unsigned int symindex)\n{\n\tunsigned int i, numsyms;\n\tElf64_Sym *syms;\n\n\tsyms = (Elf64_Sym *)sechdrs[symindex].sh_addr;\n\tnumsyms = sechdrs[symindex].sh_size / sizeof(Elf64_Sym);\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF\n\t\t    && strcmp(strtab + syms[i].st_name, \"TOC.\") == 0)\n\t\t\treturn &syms[i];\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "dedotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "330-341",
    "snippet": "static void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF) {\n\t\t\tchar *name = strtab + syms[i].st_name;\n\t\t\tif (name[0] == '.')\n\t\t\t\tmemmove(name, name+1, strlen(name));\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "name",
            "name+1",
            "strlen(name)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void dedotify(Elf64_Sym *syms, unsigned int numsyms, char *strtab)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < numsyms; i++) {\n\t\tif (syms[i].st_shndx == SHN_UNDEF) {\n\t\t\tchar *name = strtab + syms[i].st_name;\n\t\t\tif (name[0] == '.')\n\t\t\t\tmemmove(name, name+1, strlen(name));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "dedotify_versions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "310-327",
    "snippet": "static void dedotify_versions(struct modversion_info *vers,\n\t\t\t      unsigned long size)\n{\n\tstruct modversion_info *end;\n\n\tfor (end = (void *)vers + size; vers < end; vers++)\n\t\tif (vers->name[0] == '.') {\n\t\t\tmemmove(vers->name, vers->name+1, strlen(vers->name));\n#ifdef ARCH_RELOCATES_KCRCTAB\n\t\t\t/* The TOC symbol has no CRC computed. To avoid CRC\n\t\t\t * check failing, we must force it to the expected\n\t\t\t * value (see CRC check in module.c).\n\t\t\t */\n\t\t\tif (!strcmp(vers->name, \"TOC.\"))\n\t\t\t\tvers->crc = -(unsigned long)reloc_start;\n#endif\n\t\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "vers->name",
            "\"TOC.\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "vers->name",
            "vers->name+1",
            "strlen(vers->name)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "vers->name"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void dedotify_versions(struct modversion_info *vers,\n\t\t\t      unsigned long size)\n{\n\tstruct modversion_info *end;\n\n\tfor (end = (void *)vers + size; vers < end; vers++)\n\t\tif (vers->name[0] == '.') {\n\t\t\tmemmove(vers->name, vers->name+1, strlen(vers->name));\n#ifdef ARCH_RELOCATES_KCRCTAB\n\t\t\t/* The TOC symbol has no CRC computed. To avoid CRC\n\t\t\t * check failing, we must force it to the expected\n\t\t\t * value (see CRC check in module.c).\n\t\t\t */\n\t\t\tif (!strcmp(vers->name, \"TOC.\"))\n\t\t\t\tvers->crc = -(unsigned long)reloc_start;\n#endif\n\t\t}\n}"
  },
  {
    "function_name": "get_stubs_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "270-307",
    "snippet": "static unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\n\t\t\t\t    const Elf64_Shdr *sechdrs)\n{\n\t/* One extra reloc so it's always 0-funcaddr terminated */\n\tunsigned long relocs = 1;\n\tunsigned i;\n\n\t/* Every relocated section... */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %Lu\\n\",\n\t\t\t       (void *)sechdrs[i].sh_addr,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf64_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)sechdrs[i].sh_addr,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf64_Rela),\n\t\t\t     sizeof(Elf64_Rela), relacmp, relaswap);\n\n\t\t\trelocs += count_relocs((void *)sechdrs[i].sh_addr,\n\t\t\t\t\t       sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela));\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/* make the trampoline to the ftrace_caller */\n\trelocs++;\n#endif\n\n\tpr_debug(\"Looks like a total of %lu stubs, max\\n\", relocs);\n\treturn relocs * sizeof(struct ppc64_stub_entry);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Looks like a total of %lu stubs, max\\n\"",
            "relocs"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_relocs",
          "args": [
            "(void *)sechdrs[i].sh_addr",
            "sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela)"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "count_relocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "210-229",
          "snippet": "static unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t/* FIXME: Only count external ones --RR */\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF64_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF64_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n\treturn _count_relocs;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t/* FIXME: Only count external ones --RR */\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF64_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF64_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n\treturn _count_relocs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "(void *)sechdrs[i].sh_addr",
            "sechdrs[i].sh_size / sizeof(Elf64_Rela)",
            "sizeof(Elf64_Rela)",
            "relacmp",
            "relaswap"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Ptr: %p.  Number: %Lu\\n\"",
            "(void *)sechdrs[i].sh_addr",
            "sechdrs[i].sh_size / sizeof(Elf64_Rela)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Found relocations in section %u\\n\"",
            "i"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long get_stubs_size(const Elf64_Ehdr *hdr,\n\t\t\t\t    const Elf64_Shdr *sechdrs)\n{\n\t/* One extra reloc so it's always 0-funcaddr terminated */\n\tunsigned long relocs = 1;\n\tunsigned i;\n\n\t/* Every relocated section... */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %Lu\\n\",\n\t\t\t       (void *)sechdrs[i].sh_addr,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf64_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)sechdrs[i].sh_addr,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf64_Rela),\n\t\t\t     sizeof(Elf64_Rela), relacmp, relaswap);\n\n\t\t\trelocs += count_relocs((void *)sechdrs[i].sh_addr,\n\t\t\t\t\t       sechdrs[i].sh_size\n\t\t\t\t\t       / sizeof(Elf64_Rela));\n\t\t}\n\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t/* make the trampoline to the ftrace_caller */\n\trelocs++;\n#endif\n\n\tpr_debug(\"Looks like a total of %lu stubs, max\\n\", relocs);\n\treturn relocs * sizeof(struct ppc64_stub_entry);\n}"
  },
  {
    "function_name": "relaswap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "254-267",
    "snippet": "static void relaswap(void *_x, void *_y, int size)\n{\n\tuint64_t *x, *y, tmp;\n\tint i;\n\n\ty = (uint64_t *)_x;\n\tx = (uint64_t *)_y;\n\n\tfor (i = 0; i < sizeof(Elf64_Rela) / sizeof(uint64_t); i++) {\n\t\ttmp = x[i];\n\t\tx[i] = y[i];\n\t\ty[i] = tmp;\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic void relaswap(void *_x, void *_y, int size)\n{\n\tuint64_t *x, *y, tmp;\n\tint i;\n\n\ty = (uint64_t *)_x;\n\tx = (uint64_t *)_y;\n\n\tfor (i = 0; i < sizeof(Elf64_Rela) / sizeof(uint64_t); i++) {\n\t\ttmp = x[i];\n\t\tx[i] = y[i];\n\t\ty[i] = tmp;\n\t}\n}"
  },
  {
    "function_name": "relacmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "231-252",
    "snippet": "static int relacmp(const void *_x, const void *_y)\n{\n\tconst Elf64_Rela *x, *y;\n\n\ty = (Elf64_Rela *)_x;\n\tx = (Elf64_Rela *)_y;\n\n\t/* Compare the entire r_info (as opposed to ELF64_R_SYM(r_info) only) to\n\t * make the comparison cheaper/faster. It won't affect the sorting or\n\t * the counting algorithms' performance\n\t */\n\tif (x->r_info < y->r_info)\n\t\treturn -1;\n\telse if (x->r_info > y->r_info)\n\t\treturn 1;\n\telse if (x->r_addend < y->r_addend)\n\t\treturn -1;\n\telse if (x->r_addend > y->r_addend)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic int relacmp(const void *_x, const void *_y)\n{\n\tconst Elf64_Rela *x, *y;\n\n\ty = (Elf64_Rela *)_x;\n\tx = (Elf64_Rela *)_y;\n\n\t/* Compare the entire r_info (as opposed to ELF64_R_SYM(r_info) only) to\n\t * make the comparison cheaper/faster. It won't affect the sorting or\n\t * the counting algorithms' performance\n\t */\n\tif (x->r_info < y->r_info)\n\t\treturn -1;\n\telse if (x->r_info > y->r_info)\n\t\treturn 1;\n\telse if (x->r_addend < y->r_addend)\n\t\treturn -1;\n\telse if (x->r_addend > y->r_addend)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "count_relocs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "210-229",
    "snippet": "static unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t/* FIXME: Only count external ones --RR */\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF64_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF64_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n\treturn _count_relocs;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ELF64_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF64_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int count_relocs(const Elf64_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t/* FIXME: Only count external ones --RR */\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF64_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF64_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF64_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n\treturn _count_relocs;\n}"
  },
  {
    "function_name": "module_trampoline_target",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "177-204",
    "snippet": "int module_trampoline_target(struct module *mod, u32 *trampoline,\n\t\t\t     unsigned long *target)\n{\n\tu32 buf[2];\n\tu16 upper, lower;\n\tlong offset;\n\tvoid *toc_entry;\n\n\tif (probe_kernel_read(buf, trampoline, sizeof(buf)))\n\t\treturn -EFAULT;\n\n\tupper = buf[0] & 0xffff;\n\tlower = buf[1] & 0xffff;\n\n\t/* perform the addis/addi, both signed */\n\toffset = ((short)upper << 16) + (short)lower;\n\n\t/*\n\t * Now get the address this trampoline jumps to. This\n\t * is always 32 bytes into our trampoline stub.\n\t */\n\ttoc_entry = (void *)mod->arch.toc + offset + 32;\n\n\tif (probe_kernel_read(target, toc_entry, sizeof(*target)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "target",
            "toc_entry",
            "sizeof(*target)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "buf",
            "trampoline",
            "sizeof(buf)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nint module_trampoline_target(struct module *mod, u32 *trampoline,\n\t\t\t     unsigned long *target)\n{\n\tu32 buf[2];\n\tu16 upper, lower;\n\tlong offset;\n\tvoid *toc_entry;\n\n\tif (probe_kernel_read(buf, trampoline, sizeof(buf)))\n\t\treturn -EFAULT;\n\n\tupper = buf[0] & 0xffff;\n\tlower = buf[1] & 0xffff;\n\n\t/* perform the addis/addi, both signed */\n\toffset = ((short)upper << 16) + (short)lower;\n\n\t/*\n\t * Now get the address this trampoline jumps to. This\n\t * is always 32 bytes into our trampoline stub.\n\t */\n\ttoc_entry = (void *)mod->arch.toc + offset + 32;\n\n\tif (probe_kernel_read(target, toc_entry, sizeof(*target)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_module_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "155-175",
    "snippet": "bool is_module_trampoline(u32 *p)\n{\n\tunsigned int i;\n\tu32 insns[ARRAY_SIZE(ppc64_stub_insns)];\n\n\tBUILD_BUG_ON(sizeof(ppc64_stub_insns) != sizeof(ppc64_stub_mask));\n\n\tif (probe_kernel_read(insns, p, sizeof(insns)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < ARRAY_SIZE(ppc64_stub_insns); i++) {\n\t\tu32 insna = insns[i];\n\t\tu32 insnb = ppc64_stub_insns[i];\n\t\tu32 mask = ppc64_stub_mask[i];\n\n\t\tif ((insna & mask) != (insnb & mask))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 ppc64_stub_insns[] = {\n\t0x3d620000,\t\t\t/* addis   r11,r2, <high> */\n\t0x396b0000,\t\t\t/* addi    r11,r11, <low> */\n\t/* Save current r2 value in magic place on the stack. */\n\t0xf8410000|R2_STACK_OFFSET,\t/* std     r2,R2_STACK_OFFSET(r1) */\n\t0xe98b0020,\t\t\t/* ld      r12,32(r11) */\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t/* Set up new r2 from function descriptor */\n\t0xe84b0028,\t\t\t/* ld      r2,40(r11) */\n#endif\n\t0x7d8903a6,\t\t\t/* mtctr   r12 */\n\t0x4e800420\t\t\t/* bctr */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ppc64_stub_insns"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "insns",
            "p",
            "sizeof(insns)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(ppc64_stub_insns) != sizeof(ppc64_stub_mask)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ppc64_stub_insns"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic u32 ppc64_stub_insns[] = {\n\t0x3d620000,\t\t\t/* addis   r11,r2, <high> */\n\t0x396b0000,\t\t\t/* addi    r11,r11, <low> */\n\t/* Save current r2 value in magic place on the stack. */\n\t0xf8410000|R2_STACK_OFFSET,\t/* std     r2,R2_STACK_OFFSET(r1) */\n\t0xe98b0020,\t\t\t/* ld      r12,32(r11) */\n#if !defined(_CALL_ELF) || _CALL_ELF != 2\n\t/* Set up new r2 from function descriptor */\n\t0xe84b0028,\t\t\t/* ld      r2,40(r11) */\n#endif\n\t0x7d8903a6,\t\t\t/* mtctr   r12 */\n\t0x4e800420\t\t\t/* bctr */\n};\n\nbool is_module_trampoline(u32 *p)\n{\n\tunsigned int i;\n\tu32 insns[ARRAY_SIZE(ppc64_stub_insns)];\n\n\tBUILD_BUG_ON(sizeof(ppc64_stub_insns) != sizeof(ppc64_stub_mask));\n\n\tif (probe_kernel_read(insns, p, sizeof(insns)))\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < ARRAY_SIZE(ppc64_stub_insns); i++) {\n\t\tu32 insna = insns[i];\n\t\tu32 insnb = ppc64_stub_insns[i];\n\t\tu32 mask = ppc64_stub_mask[i];\n\n\t\tif ((insna & mask) != (insnb & mask))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "local_entry_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "93-96",
    "snippet": "static unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "stub_func_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "89-92",
    "snippet": "static unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func.funcaddr;\n}"
  },
  {
    "function_name": "func_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "85-88",
    "snippet": "static unsigned long func_addr(unsigned long addr)\n{\n\treturn func_desc(addr).funcaddr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "func_desc",
          "args": [
            "addr"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "func_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
          "lines": "81-84",
          "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/bug.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/elf.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long func_addr(unsigned long addr)\n{\n\treturn func_desc(addr).funcaddr;\n}"
  },
  {
    "function_name": "func_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "81-84",
    "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn *(struct ppc64_opd_entry *)addr;\n}"
  },
  {
    "function_name": "local_entry_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "68-74",
    "snippet": "static unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\t/* sym->st_other indicates offset to local entry point\n\t * (otherwise it will assume r12 is the address of the start\n\t * of function and try to derive r2 from it). */\n\treturn PPC64_LOCAL_ENTRY_OFFSET(sym->st_other);\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PPC64_LOCAL_ENTRY_OFFSET",
          "args": [
            "sym->st_other"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned int local_entry_offset(const Elf64_Sym *sym)\n{\n\t/* sym->st_other indicates offset to local entry point\n\t * (otherwise it will assume r12 is the address of the start\n\t * of function and try to derive r2 from it). */\n\treturn PPC64_LOCAL_ENTRY_OFFSET(sym->st_other);\n}"
  },
  {
    "function_name": "stub_func_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "57-60",
    "snippet": "static unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long stub_func_addr(func_desc_t func)\n{\n\treturn func;\n}"
  },
  {
    "function_name": "func_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "53-56",
    "snippet": "static unsigned long func_addr(unsigned long addr)\n{\n\treturn addr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic unsigned long func_addr(unsigned long addr)\n{\n\treturn addr;\n}"
  },
  {
    "function_name": "func_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_64.c",
    "lines": "49-52",
    "snippet": "static func_desc_t func_desc(unsigned long addr)\n{\n\treturn addr;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/bug.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/elf.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/module.h>\n#include <linux/uaccess.h>\n#include <linux/bug.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/moduleloader.h>\n#include <linux/elf.h>\n#include <linux/module.h>\n\nstatic func_desc_t func_desc(unsigned long addr)\n{\n\treturn addr;\n}"
  }
]