[
  {
    "function_name": "nvram_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "1248-1251",
    "snippet": "static void __exit nvram_cleanup(void)\n{\n        misc_deregister( &nvram_dev );\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice nvram_dev = {\n\tNVRAM_MINOR,\n\t\"nvram\",\n\t&nvram_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&nvram_dev"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic struct miscdevice nvram_dev = {\n\tNVRAM_MINOR,\n\t\"nvram\",\n\t&nvram_fops\n};\n\nstatic void __exit nvram_cleanup(void)\n{\n        misc_deregister( &nvram_dev );\n}"
  },
  {
    "function_name": "nvram_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "1230-1246",
    "snippet": "static int __init nvram_init(void)\n{\n\tint rc;\n\t\n\tBUILD_BUG_ON(NVRAM_BLOCK_LEN != 16);\n\n\tif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\n\t\treturn  -ENODEV;\n\n  \trc = misc_register(&nvram_dev);\n\tif (rc != 0) {\n\t\tprintk(KERN_ERR \"nvram_init: failed to register device\\n\");\n\t\treturn rc;\n\t}\n  \t\n  \treturn rc;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN"
    ],
    "globals_used": [
      "static struct miscdevice nvram_dev = {\n\tNVRAM_MINOR,\n\t\"nvram\",\n\t&nvram_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_init: failed to register device\\n\""
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&nvram_dev"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "NVRAM_BLOCK_LEN != 16"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n\nstatic struct miscdevice nvram_dev = {\n\tNVRAM_MINOR,\n\t\"nvram\",\n\t&nvram_fops\n};\n\nstatic int __init nvram_init(void)\n{\n\tint rc;\n\t\n\tBUILD_BUG_ON(NVRAM_BLOCK_LEN != 16);\n\n\tif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\n\t\treturn  -ENODEV;\n\n  \trc = misc_register(&nvram_dev);\n\tif (rc != 0) {\n\t\tprintk(KERN_ERR \"nvram_init: failed to register device\\n\");\n\t\treturn rc;\n\t}\n  \t\n  \treturn rc;\n}"
  },
  {
    "function_name": "nvram_scan_partitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "1157-1228",
    "snippet": "int __init nvram_scan_partitions(void)\n{\n\tloff_t cur_index = 0;\n\tstruct nvram_header phead;\n\tstruct nvram_partition * tmp_part;\n\tunsigned char c_sum;\n\tchar * header;\n\tint total_size;\n\tint err;\n\n\tif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\n\t\treturn -ENODEV;\n\ttotal_size = ppc_md.nvram_size();\n\t\n\theader = kmalloc(NVRAM_HEADER_LEN, GFP_KERNEL);\n\tif (!header) {\n\t\tprintk(KERN_ERR \"nvram_scan_partitions: Failed kmalloc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (cur_index < total_size) {\n\n\t\terr = ppc_md.nvram_read(header, NVRAM_HEADER_LEN, &cur_index);\n\t\tif (err != NVRAM_HEADER_LEN) {\n\t\t\tprintk(KERN_ERR \"nvram_scan_partitions: Error parsing \"\n\t\t\t       \"nvram partitions\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tcur_index -= NVRAM_HEADER_LEN; /* nvram_read will advance us */\n\n\t\tmemcpy(&phead, header, NVRAM_HEADER_LEN);\n\n\t\tphead.length = be16_to_cpu(phead.length);\n\n\t\terr = 0;\n\t\tc_sum = nvram_checksum(&phead);\n\t\tif (c_sum != phead.checksum) {\n\t\t\tprintk(KERN_WARNING \"WARNING: nvram partition checksum\"\n\t\t\t       \" was %02x, should be %02x!\\n\",\n\t\t\t       phead.checksum, c_sum);\n\t\t\tprintk(KERN_WARNING \"Terminating nvram partition scan\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!phead.length) {\n\t\t\tprintk(KERN_WARNING \"WARNING: nvram corruption \"\n\t\t\t       \"detected: 0-length partition\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttmp_part = kmalloc(sizeof(struct nvram_partition), GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (!tmp_part) {\n\t\t\tprintk(KERN_ERR \"nvram_scan_partitions: kmalloc failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\tmemcpy(&tmp_part->header, &phead, NVRAM_HEADER_LEN);\n\t\ttmp_part->index = cur_index;\n\t\tlist_add_tail(&tmp_part->partition, &nvram_partitions);\n\t\t\n\t\tcur_index += phead.length * NVRAM_BLOCK_LEN;\n\t}\n\terr = 0;\n\n#ifdef DEBUG_NVRAM\n\tnvram_print_partitions(\"NVRAM Partitions\");\n#endif\n\n out:\n\tkfree(header);\n\treturn err;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "header"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_print_partitions",
          "args": [
            "\"NVRAM Partitions\""
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_print_partitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "883-895",
          "snippet": "static void __init nvram_print_partitions(char * label)\n{\n\tstruct nvram_partition * tmp_part;\n\t\n\tprintk(KERN_WARNING \"--------%s---------\\n\", label);\n\tprintk(KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\");\n\tlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\n\t\tprintk(KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\",\n\t\t       tmp_part->index, tmp_part->header.signature,\n\t\t       tmp_part->header.checksum, tmp_part->header.length,\n\t\t       tmp_part->header.name);\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nvram_partitions);\n\nstatic void __init nvram_print_partitions(char * label)\n{\n\tstruct nvram_partition * tmp_part;\n\t\n\tprintk(KERN_WARNING \"--------%s---------\\n\", label);\n\tprintk(KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\");\n\tlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\n\t\tprintk(KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\",\n\t\t       tmp_part->index, tmp_part->header.signature,\n\t\t       tmp_part->header.checksum, tmp_part->header.length,\n\t\t       tmp_part->header.name);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tmp_part->partition",
            "&nvram_partitions"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp_part->header",
            "&phead",
            "NVRAM_HEADER_LEN"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_scan_partitions: kmalloc failed\\n\""
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct nvram_partition)",
            "GFP_KERNEL"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"WARNING: nvram corruption \"\n\t\t\t       \"detected: 0-length partition\\n\""
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Terminating nvram partition scan\\n\""
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"WARNING: nvram partition checksum\"\n\t\t\t       \" was %02x, should be %02x!\\n\"",
            "phead.checksum",
            "c_sum"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_checksum",
          "args": [
            "&phead"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "915-927",
          "snippet": "static unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "phead.length"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_scan_partitions: Error parsing \"\n\t\t\t       \"nvram partitions\\n\""
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_read",
          "args": [
            "header",
            "NVRAM_HEADER_LEN",
            "&cur_index"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_scan_partitions: Failed kmalloc\\n\""
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "NVRAM_HEADER_LEN",
            "GFP_KERNEL"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nint __init nvram_scan_partitions(void)\n{\n\tloff_t cur_index = 0;\n\tstruct nvram_header phead;\n\tstruct nvram_partition * tmp_part;\n\tunsigned char c_sum;\n\tchar * header;\n\tint total_size;\n\tint err;\n\n\tif (ppc_md.nvram_size == NULL || ppc_md.nvram_size() <= 0)\n\t\treturn -ENODEV;\n\ttotal_size = ppc_md.nvram_size();\n\t\n\theader = kmalloc(NVRAM_HEADER_LEN, GFP_KERNEL);\n\tif (!header) {\n\t\tprintk(KERN_ERR \"nvram_scan_partitions: Failed kmalloc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (cur_index < total_size) {\n\n\t\terr = ppc_md.nvram_read(header, NVRAM_HEADER_LEN, &cur_index);\n\t\tif (err != NVRAM_HEADER_LEN) {\n\t\t\tprintk(KERN_ERR \"nvram_scan_partitions: Error parsing \"\n\t\t\t       \"nvram partitions\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tcur_index -= NVRAM_HEADER_LEN; /* nvram_read will advance us */\n\n\t\tmemcpy(&phead, header, NVRAM_HEADER_LEN);\n\n\t\tphead.length = be16_to_cpu(phead.length);\n\n\t\terr = 0;\n\t\tc_sum = nvram_checksum(&phead);\n\t\tif (c_sum != phead.checksum) {\n\t\t\tprintk(KERN_WARNING \"WARNING: nvram partition checksum\"\n\t\t\t       \" was %02x, should be %02x!\\n\",\n\t\t\t       phead.checksum, c_sum);\n\t\t\tprintk(KERN_WARNING \"Terminating nvram partition scan\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!phead.length) {\n\t\t\tprintk(KERN_WARNING \"WARNING: nvram corruption \"\n\t\t\t       \"detected: 0-length partition\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\ttmp_part = kmalloc(sizeof(struct nvram_partition), GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (!tmp_part) {\n\t\t\tprintk(KERN_ERR \"nvram_scan_partitions: kmalloc failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\t\n\t\tmemcpy(&tmp_part->header, &phead, NVRAM_HEADER_LEN);\n\t\ttmp_part->index = cur_index;\n\t\tlist_add_tail(&tmp_part->partition, &nvram_partitions);\n\t\t\n\t\tcur_index += phead.length * NVRAM_BLOCK_LEN;\n\t}\n\terr = 0;\n\n#ifdef DEBUG_NVRAM\n\tnvram_print_partitions(\"NVRAM Partitions\");\n#endif\n\n out:\n\tkfree(header);\n\treturn err;\n}"
  },
  {
    "function_name": "nvram_find_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "1141-1155",
    "snippet": "loff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "p->header.name",
            "name",
            "12"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "p",
            "&nvram_partitions",
            "partition"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_get_partition_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "1123-1132",
    "snippet": "int nvram_get_partition_size(loff_t data_index)\n{\n\tstruct nvram_partition *part;\n\t\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->index + NVRAM_HEADER_LEN == data_index)\n\t\t\treturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "part",
            "&nvram_partitions",
            "partition"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nint nvram_get_partition_size(loff_t data_index)\n{\n\tstruct nvram_partition *part;\n\t\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->index + NVRAM_HEADER_LEN == data_index)\n\t\t\treturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "nvram_create_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "1018-1115",
    "snippet": "loff_t __init nvram_create_partition(const char *name, int sig,\n\t\t\t\t     int req_size, int min_size)\n{\n\tstruct nvram_partition *part;\n\tstruct nvram_partition *new_part;\n\tstruct nvram_partition *free_part = NULL;\n\tstatic char nv_init_vals[16];\n\tloff_t tmp_index;\n\tlong size = 0;\n\tint rc;\n\n\t/* Convert sizes from bytes to blocks */\n\treq_size = _ALIGN_UP(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\tmin_size = _ALIGN_UP(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\n\t/* If no minimum size specified, make it the same as the\n\t * requested size\n\t */\n\tif (min_size == 0)\n\t\tmin_size = req_size;\n\tif (min_size > req_size)\n\t\treturn -EINVAL;\n\n\t/* Now add one block to each for the header */\n\treq_size += 1;\n\tmin_size += 1;\n\n\t/* Find a free partition that will give us the maximum needed size \n\t   If can't find one that will give us the minimum size needed */\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE)\n\t\t\tcontinue;\n\n\t\tif (part->header.length >= req_size) {\n\t\t\tsize = req_size;\n\t\t\tfree_part = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (part->header.length > size &&\n\t\t    part->header.length >= min_size) {\n\t\t\tsize = part->header.length;\n\t\t\tfree_part = part;\n\t\t}\n\t}\n\tif (!size)\n\t\treturn -ENOSPC;\n\t\n\t/* Create our OS partition */\n\tnew_part = kmalloc(sizeof(*new_part), GFP_KERNEL);\n\tif (!new_part) {\n\t\tpr_err(\"%s: kmalloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_part->index = free_part->index;\n\tnew_part->header.signature = sig;\n\tnew_part->header.length = size;\n\tstrncpy(new_part->header.name, name, 12);\n\tnew_part->header.checksum = nvram_checksum(&new_part->header);\n\n\trc = nvram_write_header(new_part);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\", __func__, rc);\n\t\tkfree(new_part);\n\t\treturn rc;\n\t}\n\tlist_add_tail(&new_part->partition, &free_part->partition);\n\n\t/* Adjust or remove the partition we stole the space from */\n\tif (free_part->header.length > size) {\n\t\tfree_part->index += size * NVRAM_BLOCK_LEN;\n\t\tfree_part->header.length -= size;\n\t\tfree_part->header.checksum = nvram_checksum(&free_part->header);\n\t\trc = nvram_write_header(free_part);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tlist_del(&free_part->partition);\n\t\tkfree(free_part);\n\t} \n\n\t/* Clear the new partition */\n\tfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\n\t     tmp_index <  ((size - 1) * NVRAM_BLOCK_LEN);\n\t     tmp_index += NVRAM_BLOCK_LEN) {\n\t\trc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn new_part->index + NVRAM_HEADER_LEN;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: nvram_write failed (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "nv_init_vals",
            "NVRAM_BLOCK_LEN",
            "&tmp_index"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "free_part"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&free_part->partition"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: nvram_write_header failed (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_write_header",
          "args": [
            "free_part"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_write_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "899-912",
          "snippet": "static int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_checksum",
          "args": [
            "&free_part->header"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "915-927",
          "snippet": "static unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&new_part->partition",
            "&free_part->partition"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_part"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: nvram_write_header failed (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "new_part->header.name",
            "name",
            "12"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: kmalloc failed\\n\"",
            "__func__"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*new_part)",
            "GFP_KERNEL"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "part",
            "&nvram_partitions",
            "partition"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ALIGN_UP",
          "args": [
            "min_size",
            "NVRAM_BLOCK_LEN"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ALIGN_UP",
          "args": [
            "req_size",
            "NVRAM_BLOCK_LEN"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t __init nvram_create_partition(const char *name, int sig,\n\t\t\t\t     int req_size, int min_size)\n{\n\tstruct nvram_partition *part;\n\tstruct nvram_partition *new_part;\n\tstruct nvram_partition *free_part = NULL;\n\tstatic char nv_init_vals[16];\n\tloff_t tmp_index;\n\tlong size = 0;\n\tint rc;\n\n\t/* Convert sizes from bytes to blocks */\n\treq_size = _ALIGN_UP(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\tmin_size = _ALIGN_UP(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\n\t/* If no minimum size specified, make it the same as the\n\t * requested size\n\t */\n\tif (min_size == 0)\n\t\tmin_size = req_size;\n\tif (min_size > req_size)\n\t\treturn -EINVAL;\n\n\t/* Now add one block to each for the header */\n\treq_size += 1;\n\tmin_size += 1;\n\n\t/* Find a free partition that will give us the maximum needed size \n\t   If can't find one that will give us the minimum size needed */\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE)\n\t\t\tcontinue;\n\n\t\tif (part->header.length >= req_size) {\n\t\t\tsize = req_size;\n\t\t\tfree_part = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (part->header.length > size &&\n\t\t    part->header.length >= min_size) {\n\t\t\tsize = part->header.length;\n\t\t\tfree_part = part;\n\t\t}\n\t}\n\tif (!size)\n\t\treturn -ENOSPC;\n\t\n\t/* Create our OS partition */\n\tnew_part = kmalloc(sizeof(*new_part), GFP_KERNEL);\n\tif (!new_part) {\n\t\tpr_err(\"%s: kmalloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_part->index = free_part->index;\n\tnew_part->header.signature = sig;\n\tnew_part->header.length = size;\n\tstrncpy(new_part->header.name, name, 12);\n\tnew_part->header.checksum = nvram_checksum(&new_part->header);\n\n\trc = nvram_write_header(new_part);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\", __func__, rc);\n\t\tkfree(new_part);\n\t\treturn rc;\n\t}\n\tlist_add_tail(&new_part->partition, &free_part->partition);\n\n\t/* Adjust or remove the partition we stole the space from */\n\tif (free_part->header.length > size) {\n\t\tfree_part->index += size * NVRAM_BLOCK_LEN;\n\t\tfree_part->header.length -= size;\n\t\tfree_part->header.checksum = nvram_checksum(&free_part->header);\n\t\trc = nvram_write_header(free_part);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tlist_del(&free_part->partition);\n\t\tkfree(free_part);\n\t} \n\n\t/* Clear the new partition */\n\tfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\n\t     tmp_index <  ((size - 1) * NVRAM_BLOCK_LEN);\n\t     tmp_index += NVRAM_BLOCK_LEN) {\n\t\trc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn new_part->index + NVRAM_HEADER_LEN;\n}"
  },
  {
    "function_name": "nvram_remove_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "960-1003",
    "snippet": "int __init nvram_remove_partition(const char *name, int sig,\n\t\t\t\t\t\tconst char *exceptions[])\n{\n\tstruct nvram_partition *part, *prev, *tmp;\n\tint rc;\n\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (!nvram_can_remove_partition(part, name, sig, exceptions))\n\t\t\tcontinue;\n\n\t\t/* Make partition a free partition */\n\t\tpart->header.signature = NVRAM_SIG_FREE;\n\t\tstrncpy(part->header.name, \"wwwwwwwwwwww\", 12);\n\t\tpart->header.checksum = nvram_checksum(&part->header);\n\t\trc = nvram_write_header(part);\n\t\tif (rc <= 0) {\n\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Merge contiguous ones */\n\tprev = NULL;\n\tlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE) {\n\t\t\tprev = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (prev) {\n\t\t\tprev->header.length += part->header.length;\n\t\t\tprev->header.checksum = nvram_checksum(&part->header);\n\t\t\trc = nvram_write_header(part);\n\t\t\tif (rc <= 0) {\n\t\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&part->partition);\n\t\t\tkfree(part);\n\t\t} else\n\t\t\tprev = part;\n\t}\n\t\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "part"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&part->partition"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\"",
            "rc"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_write_header",
          "args": [
            "part"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_write_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "899-912",
          "snippet": "static int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_checksum",
          "args": [
            "&part->header"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_checksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "915-927",
          "snippet": "static unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "part",
            "tmp",
            "&nvram_partitions",
            "partition"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "part->header.name",
            "\"wwwwwwwwwwww\"",
            "12"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_can_remove_partition",
          "args": [
            "part",
            "name",
            "sig",
            "exceptions"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_can_remove_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "933-949",
          "snippet": "static int nvram_can_remove_partition(struct nvram_partition *part,\n\t\tconst char *name, int sig, const char *exceptions[])\n{\n\tif (part->header.signature != sig)\n\t\treturn 0;\n\tif (name) {\n\t\tif (strncmp(name, part->header.name, 12))\n\t\t\treturn 0;\n\t} else if (exceptions) {\n\t\tconst char **except;\n\t\tfor (except = exceptions; *except; except++) {\n\t\t\tif (!strncmp(*except, part->header.name, 12))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int nvram_can_remove_partition(struct nvram_partition *part,\n\t\tconst char *name, int sig, const char *exceptions[])\n{\n\tif (part->header.signature != sig)\n\t\treturn 0;\n\tif (name) {\n\t\tif (strncmp(name, part->header.name, 12))\n\t\t\treturn 0;\n\t} else if (exceptions) {\n\t\tconst char **except;\n\t\tfor (except = exceptions; *except; except++) {\n\t\t\tif (!strncmp(*except, part->header.name, 12))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "part",
            "&nvram_partitions",
            "partition"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nvram_partitions);\n\nint __init nvram_remove_partition(const char *name, int sig,\n\t\t\t\t\t\tconst char *exceptions[])\n{\n\tstruct nvram_partition *part, *prev, *tmp;\n\tint rc;\n\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (!nvram_can_remove_partition(part, name, sig, exceptions))\n\t\t\tcontinue;\n\n\t\t/* Make partition a free partition */\n\t\tpart->header.signature = NVRAM_SIG_FREE;\n\t\tstrncpy(part->header.name, \"wwwwwwwwwwww\", 12);\n\t\tpart->header.checksum = nvram_checksum(&part->header);\n\t\trc = nvram_write_header(part);\n\t\tif (rc <= 0) {\n\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Merge contiguous ones */\n\tprev = NULL;\n\tlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE) {\n\t\t\tprev = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (prev) {\n\t\t\tprev->header.length += part->header.length;\n\t\t\tprev->header.checksum = nvram_checksum(&part->header);\n\t\t\trc = nvram_write_header(part);\n\t\t\tif (rc <= 0) {\n\t\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&part->partition);\n\t\t\tkfree(part);\n\t\t} else\n\t\t\tprev = part;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_can_remove_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "933-949",
    "snippet": "static int nvram_can_remove_partition(struct nvram_partition *part,\n\t\tconst char *name, int sig, const char *exceptions[])\n{\n\tif (part->header.signature != sig)\n\t\treturn 0;\n\tif (name) {\n\t\tif (strncmp(name, part->header.name, 12))\n\t\t\treturn 0;\n\t} else if (exceptions) {\n\t\tconst char **except;\n\t\tfor (except = exceptions; *except; except++) {\n\t\t\tif (!strncmp(*except, part->header.name, 12))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "*except",
            "part->header.name",
            "12"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "part->header.name",
            "12"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int nvram_can_remove_partition(struct nvram_partition *part,\n\t\tconst char *name, int sig, const char *exceptions[])\n{\n\tif (part->header.signature != sig)\n\t\treturn 0;\n\tif (name) {\n\t\tif (strncmp(name, part->header.name, 12))\n\t\t\treturn 0;\n\t} else if (exceptions) {\n\t\tconst char **except;\n\t\tfor (except = exceptions; *except; except++) {\n\t\t\tif (!strncmp(*except, part->header.name, 12))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "nvram_checksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "915-927",
    "snippet": "static unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic unsigned char __init nvram_checksum(struct nvram_header *p)\n{\n\tunsigned int c_sum, c_sum2;\n\tunsigned short *sp = (unsigned short *)p->name; /* assume 6 shorts */\n\tc_sum = p->signature + p->length + sp[0] + sp[1] + sp[2] + sp[3] + sp[4] + sp[5];\n\n\t/* The sum may have spilled into the 3rd byte.  Fold it back. */\n\tc_sum = ((c_sum & 0xffff) + (c_sum >> 16)) & 0xffff;\n\t/* The sum cannot exceed 2 bytes.  Fold it into a checksum */\n\tc_sum2 = (c_sum >> 8) + (c_sum << 8);\n\tc_sum = ((c_sum + c_sum2) >> 8) & 0xff;\n\treturn c_sum;\n}"
  },
  {
    "function_name": "nvram_write_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "899-912",
    "snippet": "static int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "(char *)&phead",
            "NVRAM_HEADER_LEN",
            "&tmp_index"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "phead.length"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&phead",
            "&part->header",
            "NVRAM_HEADER_LEN"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic int __init nvram_write_header(struct nvram_partition * part)\n{\n\tloff_t tmp_index;\n\tint rc;\n\tstruct nvram_header phead;\n\n\tmemcpy(&phead, &part->header, NVRAM_HEADER_LEN);\n\tphead.length = cpu_to_be16(phead.length);\n\n\ttmp_index = part->index;\n\trc = ppc_md.nvram_write((char *)&phead, NVRAM_HEADER_LEN, &tmp_index);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "nvram_print_partitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "883-895",
    "snippet": "static void __init nvram_print_partitions(char * label)\n{\n\tstruct nvram_partition * tmp_part;\n\t\n\tprintk(KERN_WARNING \"--------%s---------\\n\", label);\n\tprintk(KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\");\n\tlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\n\t\tprintk(KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\",\n\t\t       tmp_part->index, tmp_part->header.signature,\n\t\t       tmp_part->header.checksum, tmp_part->header.length,\n\t\t       tmp_part->header.name);\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(nvram_partitions);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\"",
            "tmp_part->index",
            "tmp_part->header.signature",
            "tmp_part->header.checksum",
            "tmp_part->header.length",
            "tmp_part->header.name"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp_part",
            "&nvram_partitions",
            "partition"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\""
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"--------%s---------\\n\"",
            "label"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nvram_partitions);\n\nstatic void __init nvram_print_partitions(char * label)\n{\n\tstruct nvram_partition * tmp_part;\n\t\n\tprintk(KERN_WARNING \"--------%s---------\\n\", label);\n\tprintk(KERN_WARNING \"indx\\t\\tsig\\tchks\\tlen\\tname\\n\");\n\tlist_for_each_entry(tmp_part, &nvram_partitions, partition) {\n\t\tprintk(KERN_WARNING \"%4d    \\t%02x\\t%02x\\t%d\\t%12.12s\\n\",\n\t\t       tmp_part->index, tmp_part->header.signature,\n\t\t       tmp_part->header.checksum, tmp_part->header.length,\n\t\t       tmp_part->header.name);\n\t}\n}"
  },
  {
    "function_name": "dev_nvram_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "838-865",
    "snippet": "static long dev_nvram_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tswitch(cmd) {\n#ifdef CONFIG_PPC_PMAC\n\tcase OBSOLETE_PMAC_NVRAM_GET_OFFSET:\n\t\tprintk(KERN_WARNING \"nvram: Using obsolete PMAC_NVRAM_GET_OFFSET ioctl\\n\");\n\tcase IOC_NVRAM_GET_OFFSET: {\n\t\tint part, offset;\n\n\t\tif (!machine_is(powermac))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&part, (void __user*)arg, sizeof(part)) != 0)\n\t\t\treturn -EFAULT;\n\t\tif (part < pmac_nvram_OF || part > pmac_nvram_NR)\n\t\t\treturn -EINVAL;\n\t\toffset = pmac_get_partition(part);\n\t\tif (offset < 0)\n\t\t\treturn offset;\n\t\tif (copy_to_user((void __user*)arg, &offset, sizeof(offset)) != 0)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n#endif /* CONFIG_PPC_PMAC */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user*)arg",
            "&offset",
            "sizeof(offset)"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmac_get_partition",
          "args": [
            "part"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&part",
            "(void __user*)arg",
            "sizeof(part)"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "powermac"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"nvram: Using obsolete PMAC_NVRAM_GET_OFFSET ioctl\\n\""
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic long dev_nvram_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tswitch(cmd) {\n#ifdef CONFIG_PPC_PMAC\n\tcase OBSOLETE_PMAC_NVRAM_GET_OFFSET:\n\t\tprintk(KERN_WARNING \"nvram: Using obsolete PMAC_NVRAM_GET_OFFSET ioctl\\n\");\n\tcase IOC_NVRAM_GET_OFFSET: {\n\t\tint part, offset;\n\n\t\tif (!machine_is(powermac))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&part, (void __user*)arg, sizeof(part)) != 0)\n\t\t\treturn -EFAULT;\n\t\tif (part < pmac_nvram_OF || part > pmac_nvram_NR)\n\t\t\treturn -EINVAL;\n\t\toffset = pmac_get_partition(part);\n\t\tif (offset < 0)\n\t\t\treturn offset;\n\t\tif (copy_to_user((void __user*)arg, &offset, sizeof(offset)) != 0)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n#endif /* CONFIG_PPC_PMAC */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}"
  },
  {
    "function_name": "dev_nvram_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "802-836",
    "snippet": "static ssize_t dev_nvram_write(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tchar *tmp = NULL;\n\tssize_t size;\n\n\tret = -ENODEV;\n\tif (!ppc_md.nvram_size)\n\t\tgoto out;\n\n\tret = 0;\n\tsize = ppc_md.nvram_size();\n\tif (*ppos >= size || size < 0)\n\t\tgoto out;\n\n\tcount = min_t(size_t, count, size - *ppos);\n\tcount = min(count, PAGE_SIZE);\n\n\tret = -ENOMEM;\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(tmp, buf, count))\n\t\tgoto out;\n\n\tret = ppc_md.nvram_write(tmp, count, ppos);\n\nout:\n\tkfree(tmp);\n\treturn ret;\n\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "tmp",
            "count",
            "ppos"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "tmp",
            "buf",
            "count"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count",
            "GFP_KERNEL"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "PAGE_SIZE"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "count",
            "size - *ppos"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic ssize_t dev_nvram_write(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tchar *tmp = NULL;\n\tssize_t size;\n\n\tret = -ENODEV;\n\tif (!ppc_md.nvram_size)\n\t\tgoto out;\n\n\tret = 0;\n\tsize = ppc_md.nvram_size();\n\tif (*ppos >= size || size < 0)\n\t\tgoto out;\n\n\tcount = min_t(size_t, count, size - *ppos);\n\tcount = min(count, PAGE_SIZE);\n\n\tret = -ENOMEM;\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp)\n\t\tgoto out;\n\n\tret = -EFAULT;\n\tif (copy_from_user(tmp, buf, count))\n\t\tgoto out;\n\n\tret = ppc_md.nvram_write(tmp, count, ppos);\n\nout:\n\tkfree(tmp);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "dev_nvram_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "757-800",
    "snippet": "static ssize_t dev_nvram_read(struct file *file, char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tchar *tmp = NULL;\n\tssize_t size;\n\n\tif (!ppc_md.nvram_size) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tsize = ppc_md.nvram_size();\n\tif (size < 0) {\n\t\tret = size;\n\t\tgoto out;\n\t}\n\n\tif (*ppos >= size) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tcount = min_t(size_t, count, size - *ppos);\n\tcount = min(count, PAGE_SIZE);\n\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ppc_md.nvram_read(tmp, count, ppos);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tif (copy_to_user(buf, tmp, ret))\n\t\tret = -EFAULT;\n\nout:\n\tkfree(tmp);\n\treturn ret;\n\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "tmp",
            "ret"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_read",
          "args": [
            "tmp",
            "count",
            "ppos"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count",
            "GFP_KERNEL"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "count",
            "PAGE_SIZE"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "count",
            "size - *ppos"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic ssize_t dev_nvram_read(struct file *file, char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tssize_t ret;\n\tchar *tmp = NULL;\n\tssize_t size;\n\n\tif (!ppc_md.nvram_size) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tsize = ppc_md.nvram_size();\n\tif (size < 0) {\n\t\tret = size;\n\t\tgoto out;\n\t}\n\n\tif (*ppos >= size) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tcount = min_t(size_t, count, size - *ppos);\n\tcount = min(count, PAGE_SIZE);\n\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = ppc_md.nvram_read(tmp, count, ppos);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tif (copy_to_user(buf, tmp, ret))\n\t\tret = -EFAULT;\n\nout:\n\tkfree(tmp);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "dev_nvram_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "734-754",
    "snippet": "static loff_t dev_nvram_llseek(struct file *file, loff_t offset, int origin)\n{\n\tint size;\n\n\tif (ppc_md.nvram_size == NULL)\n\t\treturn -ENODEV;\n\tsize = ppc_md.nvram_size();\n\n\tswitch (origin) {\n\tcase 1:\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase 2:\n\t\toffset += size;\n\t\tbreak;\n\t}\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\tfile->f_pos = offset;\n\treturn file->f_pos;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.nvram_size",
          "args": [],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic loff_t dev_nvram_llseek(struct file *file, loff_t offset, int origin)\n{\n\tint size;\n\n\tif (ppc_md.nvram_size == NULL)\n\t\treturn -ENODEV;\n\tsize = ppc_md.nvram_size();\n\n\tswitch (origin) {\n\tcase 1:\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase 2:\n\t\toffset += size;\n\t\tbreak;\n\t}\n\tif (offset < 0)\n\t\treturn -EINVAL;\n\tfile->f_pos = offset;\n\treturn file->f_pos;\n}"
  },
  {
    "function_name": "oops_to_nvram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "672-732",
    "snippet": "static void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tstatic unsigned int oops_count = 0;\n\tstatic bool panicking = false;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tsize_t text_len;\n\tunsigned int err_type = ERR_TYPE_KERNEL_PANIC_GZ;\n\tint rc = -1;\n\n\tswitch (reason) {\n\tcase KMSG_DUMP_RESTART:\n\tcase KMSG_DUMP_HALT:\n\tcase KMSG_DUMP_POWEROFF:\n\t\t/* These are almost always orderly shutdowns. */\n\t\treturn;\n\tcase KMSG_DUMP_OOPS:\n\t\tbreak;\n\tcase KMSG_DUMP_PANIC:\n\t\tpanicking = true;\n\t\tbreak;\n\tcase KMSG_DUMP_EMERG:\n\t\tif (panicking)\n\t\t\t/* Panic report already captured. */\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: ignoring unrecognized KMSG_DUMP_* reason %d\\n\",\n\t\t       __func__, (int) reason);\n\t\treturn;\n\t}\n\n\tif (clobbering_unread_rtas_event())\n\t\treturn;\n\n\tif (!spin_trylock_irqsave(&lock, flags))\n\t\treturn;\n\n\tif (big_oops_buf) {\n\t\tkmsg_dump_get_buffer(dumper, false,\n\t\t\t\t     big_oops_buf, big_oops_buf_sz, &text_len);\n\t\trc = zip_oops(text_len);\n\t}\n\tif (rc != 0) {\n\t\tkmsg_dump_rewind(dumper);\n\t\tkmsg_dump_get_buffer(dumper, false,\n\t\t\t\t     oops_data, oops_data_sz, &text_len);\n\t\terr_type = ERR_TYPE_KERNEL_PANIC;\n\t\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\t\toops_hdr->report_length = cpu_to_be16(text_len);\n\t\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\t}\n\n\t(void) nvram_write_os_partition(&oops_log_partition, oops_buf,\n\t\t(int) (sizeof(*oops_hdr) + text_len), err_type,\n\t\t++oops_count);\n\n\tspin_unlock_irqrestore(&lock, flags);\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};",
      "static void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason);",
      "static size_t big_oops_buf_sz;",
      "static char *big_oops_buf, *oops_buf;",
      "static char *oops_data;",
      "static size_t oops_data_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_write_os_partition",
          "args": [
            "&oops_log_partition",
            "oops_buf",
            "(int) (sizeof(*oops_hdr) + text_len)",
            "err_type",
            "++oops_count"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_write_os_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "191-225",
          "snippet": "int nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info),\n\t\t\t\t&tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info),\n\t\t\t\t&tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ktime_get_real_seconds()"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "text_len"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "OOPS_HDR_VERSION"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_buffer",
          "args": [
            "dumper",
            "false",
            "oops_data",
            "oops_data_sz",
            "&text_len"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_rewind",
          "args": [
            "dumper"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zip_oops",
          "args": [
            "text_len"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "zip_oops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "367-381",
          "snippet": "static int zip_oops(size_t text_len)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\n\t\t\t\t\t\t\t\toops_data_sz);\n\tif (zipped_len < 0) {\n\t\tpr_err(\"nvram: compression failed; returned %d\\n\", zipped_len);\n\t\tpr_err(\"nvram: logging uncompressed oops/panic report\\n\");\n\t\treturn -1;\n\t}\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(zipped_len);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *big_oops_buf, *oops_buf;",
            "static char *oops_data;",
            "static size_t oops_data_sz;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic char *big_oops_buf, *oops_buf;\nstatic char *oops_data;\nstatic size_t oops_data_sz;\n\nstatic int zip_oops(size_t text_len)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\n\t\t\t\t\t\t\t\toops_data_sz);\n\tif (zipped_len < 0) {\n\t\tpr_err(\"nvram: compression failed; returned %d\\n\", zipped_len);\n\t\tpr_err(\"nvram: logging uncompressed oops/panic report\\n\");\n\t\treturn -1;\n\t}\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(zipped_len);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_buffer",
          "args": [
            "dumper",
            "false",
            "big_oops_buf",
            "big_oops_buf_sz",
            "&text_len"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock_irqsave",
          "args": [
            "&lock",
            "flags"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clobbering_unread_rtas_event",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: ignoring unrecognized KMSG_DUMP_* reason %d\\n\"",
            "__func__",
            "(int) reason"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstruct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason);\nstatic size_t big_oops_buf_sz;\nstatic char *big_oops_buf, *oops_buf;\nstatic char *oops_data;\nstatic size_t oops_data_sz;\n\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tstatic unsigned int oops_count = 0;\n\tstatic bool panicking = false;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tsize_t text_len;\n\tunsigned int err_type = ERR_TYPE_KERNEL_PANIC_GZ;\n\tint rc = -1;\n\n\tswitch (reason) {\n\tcase KMSG_DUMP_RESTART:\n\tcase KMSG_DUMP_HALT:\n\tcase KMSG_DUMP_POWEROFF:\n\t\t/* These are almost always orderly shutdowns. */\n\t\treturn;\n\tcase KMSG_DUMP_OOPS:\n\t\tbreak;\n\tcase KMSG_DUMP_PANIC:\n\t\tpanicking = true;\n\t\tbreak;\n\tcase KMSG_DUMP_EMERG:\n\t\tif (panicking)\n\t\t\t/* Panic report already captured. */\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: ignoring unrecognized KMSG_DUMP_* reason %d\\n\",\n\t\t       __func__, (int) reason);\n\t\treturn;\n\t}\n\n\tif (clobbering_unread_rtas_event())\n\t\treturn;\n\n\tif (!spin_trylock_irqsave(&lock, flags))\n\t\treturn;\n\n\tif (big_oops_buf) {\n\t\tkmsg_dump_get_buffer(dumper, false,\n\t\t\t\t     big_oops_buf, big_oops_buf_sz, &text_len);\n\t\trc = zip_oops(text_len);\n\t}\n\tif (rc != 0) {\n\t\tkmsg_dump_rewind(dumper);\n\t\tkmsg_dump_get_buffer(dumper, false,\n\t\t\t\t     oops_data, oops_data_sz, &text_len);\n\t\terr_type = ERR_TYPE_KERNEL_PANIC;\n\t\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\t\toops_hdr->report_length = cpu_to_be16(text_len);\n\t\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\t}\n\n\t(void) nvram_write_os_partition(&oops_log_partition, oops_buf,\n\t\t(int) (sizeof(*oops_hdr) + text_len), err_type,\n\t\t++oops_count);\n\n\tspin_unlock_irqrestore(&lock, flags);\n}"
  },
  {
    "function_name": "nvram_init_oops_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "598-663",
    "snippet": "void __init nvram_init_oops_partition(int rtas_partition_exists)\n{\n\tint rc;\n\n\trc = nvram_init_os_partition(&oops_log_partition);\n\tif (rc != 0) {\n#ifdef CONFIG_PPC_PSERIES\n\t\tif (!rtas_partition_exists) {\n\t\t\tpr_err(\"nvram: Failed to initialize oops partition!\");\n\t\t\treturn;\n\t\t}\n\t\tpr_notice(\"nvram: Using %s partition to log both\"\n\t\t\t\" RTAS errors and oops/panic reports\\n\",\n\t\t\trtas_log_partition.name);\n\t\tmemcpy(&oops_log_partition, &rtas_log_partition,\n\t\t\t\t\t\tsizeof(rtas_log_partition));\n#else\n\t\tpr_err(\"nvram: Failed to initialize oops partition!\");\n\t\treturn;\n#endif\n\t}\n\toops_buf = kmalloc(oops_log_partition.size, GFP_KERNEL);\n\tif (!oops_buf) {\n\t\tpr_err(\"nvram: No memory for %s partition\\n\",\n\t\t\t\t\t\toops_log_partition.name);\n\t\treturn;\n\t}\n\toops_data = oops_buf + sizeof(struct oops_log_info);\n\toops_data_sz = oops_log_partition.size - sizeof(struct oops_log_info);\n\n\trc = nvram_pstore_init();\n\n\tif (!rc)\n\t\treturn;\n\n\t/*\n\t * Figure compression (preceded by elimination of each line's <n>\n\t * severity prefix) will reduce the oops/panic report to at most\n\t * 45% of its original size.\n\t */\n\tbig_oops_buf_sz = (oops_data_sz * 100) / 45;\n\tbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\n\tif (big_oops_buf) {\n\t\tstream.workspace =  kmalloc(zlib_deflate_workspacesize(\n\t\t\t\t\tWINDOW_BITS, MEM_LEVEL), GFP_KERNEL);\n\t\tif (!stream.workspace) {\n\t\t\tpr_err(\"nvram: No memory for compression workspace; \"\n\t\t\t\t\"skipping compression of %s partition data\\n\",\n\t\t\t\toops_log_partition.name);\n\t\t\tkfree(big_oops_buf);\n\t\t\tbig_oops_buf = NULL;\n\t\t}\n\t} else {\n\t\tpr_err(\"No memory for uncompressed %s data; \"\n\t\t\t\"skipping compression\\n\", oops_log_partition.name);\n\t\tstream.workspace = NULL;\n\t}\n\n\trc = kmsg_dump_register(&nvram_kmsg_dumper);\n\tif (rc != 0) {\n\t\tpr_err(\"nvram: kmsg_dump_register() failed; returned %d\\n\", rc);\n\t\tkfree(oops_buf);\n\t\tkfree(big_oops_buf);\n\t\tkfree(stream.workspace);\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MEM_LEVEL 4",
      "#define WINDOW_BITS 12"
    ],
    "globals_used": [
      "struct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};",
      "static struct kmsg_dumper nvram_kmsg_dumper = {\n\t.dump = oops_to_nvram\n};",
      "static size_t big_oops_buf_sz;",
      "static char *big_oops_buf, *oops_buf;",
      "static char *oops_data;",
      "static size_t oops_data_sz;",
      "static struct z_stream_s stream;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stream.workspace"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "big_oops_buf"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "oops_buf"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: kmsg_dump_register() failed; returned %d\\n\"",
            "rc"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_register",
          "args": [
            "&nvram_kmsg_dumper"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"No memory for uncompressed %s data; \"\n\t\t\t\"skipping compression\\n\"",
            "oops_log_partition.name"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "big_oops_buf"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: No memory for compression workspace; \"\n\t\t\t\t\"skipping compression of %s partition data\\n\"",
            "oops_log_partition.name"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "zlib_deflate_workspacesize(\n\t\t\t\t\tWINDOW_BITS, MEM_LEVEL)",
            "GFP_KERNEL"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflate_workspacesize",
          "args": [
            "WINDOW_BITS",
            "MEM_LEVEL"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "big_oops_buf_sz",
            "GFP_KERNEL"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_pstore_init",
          "args": [],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_pstore_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "592-595",
          "snippet": "static int nvram_pstore_init(void)\n{\n\treturn -1;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int nvram_pstore_init(void)\n{\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: No memory for %s partition\\n\"",
            "oops_log_partition.name"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "oops_log_partition.size",
            "GFP_KERNEL"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: Failed to initialize oops partition!\""
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&oops_log_partition",
            "&rtas_log_partition",
            "sizeof(rtas_log_partition)"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"nvram: Using %s partition to log both\"\n\t\t\t\" RTAS errors and oops/panic reports\\n\"",
            "rtas_log_partition.name"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: Failed to initialize oops partition!\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_init_os_partition",
          "args": [
            "&oops_log_partition"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_init_os_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "288-329",
          "snippet": "int __init nvram_init_os_partition(struct nvram_os_partition *part)\n{\n\tloff_t p;\n\tint size;\n\n\t/* Look for ours */\n\tp = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\n\n\t/* Found one but too small, remove it */\n\tif (p && size < part->min_size) {\n\t\tpr_info(\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\", part->name);\n\t\tnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\n\t\tp = 0;\n\t}\n\n\t/* Create one if we didn't find */\n\tif (!p) {\n\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\tif (p == -ENOSPC) {\n\t\t\tpr_info(\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\",\n\t\t\t\tpart->name);\n\t\t\tnvram_remove_partition(NULL, NVRAM_SIG_OS,\n\t\t\t\t\tnvram_os_partitions);\n\t\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\t}\n\t}\n\n\tif (p <= 0) {\n\t\tpr_err(\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\", part->name, (int)p);\n\t\treturn -1;\n\t}\n\n\tpart->index = p;\n\tpart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *nvram_os_partitions[] = {\n#ifdef CONFIG_PPC_PSERIES\n\t\"ibm,rtas-log\",\n#endif\n\t\"lnx,oops-log\",\n\tNULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic const char *nvram_os_partitions[] = {\n#ifdef CONFIG_PPC_PSERIES\n\t\"ibm,rtas-log\",\n#endif\n\t\"lnx,oops-log\",\n\tNULL\n};\n\nint __init nvram_init_os_partition(struct nvram_os_partition *part)\n{\n\tloff_t p;\n\tint size;\n\n\t/* Look for ours */\n\tp = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\n\n\t/* Found one but too small, remove it */\n\tif (p && size < part->min_size) {\n\t\tpr_info(\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\", part->name);\n\t\tnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\n\t\tp = 0;\n\t}\n\n\t/* Create one if we didn't find */\n\tif (!p) {\n\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\tif (p == -ENOSPC) {\n\t\t\tpr_info(\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\",\n\t\t\t\tpart->name);\n\t\t\tnvram_remove_partition(NULL, NVRAM_SIG_OS,\n\t\t\t\t\tnvram_os_partitions);\n\t\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\t}\n\t}\n\n\tif (p <= 0) {\n\t\tpr_err(\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\", part->name, (int)p);\n\t\treturn -1;\n\t}\n\n\tpart->index = p;\n\tpart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n\nstruct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};\nstatic struct kmsg_dumper nvram_kmsg_dumper = {\n\t.dump = oops_to_nvram\n};\nstatic size_t big_oops_buf_sz;\nstatic char *big_oops_buf, *oops_buf;\nstatic char *oops_data;\nstatic size_t oops_data_sz;\nstatic struct z_stream_s stream;\n\nvoid __init nvram_init_oops_partition(int rtas_partition_exists)\n{\n\tint rc;\n\n\trc = nvram_init_os_partition(&oops_log_partition);\n\tif (rc != 0) {\n#ifdef CONFIG_PPC_PSERIES\n\t\tif (!rtas_partition_exists) {\n\t\t\tpr_err(\"nvram: Failed to initialize oops partition!\");\n\t\t\treturn;\n\t\t}\n\t\tpr_notice(\"nvram: Using %s partition to log both\"\n\t\t\t\" RTAS errors and oops/panic reports\\n\",\n\t\t\trtas_log_partition.name);\n\t\tmemcpy(&oops_log_partition, &rtas_log_partition,\n\t\t\t\t\t\tsizeof(rtas_log_partition));\n#else\n\t\tpr_err(\"nvram: Failed to initialize oops partition!\");\n\t\treturn;\n#endif\n\t}\n\toops_buf = kmalloc(oops_log_partition.size, GFP_KERNEL);\n\tif (!oops_buf) {\n\t\tpr_err(\"nvram: No memory for %s partition\\n\",\n\t\t\t\t\t\toops_log_partition.name);\n\t\treturn;\n\t}\n\toops_data = oops_buf + sizeof(struct oops_log_info);\n\toops_data_sz = oops_log_partition.size - sizeof(struct oops_log_info);\n\n\trc = nvram_pstore_init();\n\n\tif (!rc)\n\t\treturn;\n\n\t/*\n\t * Figure compression (preceded by elimination of each line's <n>\n\t * severity prefix) will reduce the oops/panic report to at most\n\t * 45% of its original size.\n\t */\n\tbig_oops_buf_sz = (oops_data_sz * 100) / 45;\n\tbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\n\tif (big_oops_buf) {\n\t\tstream.workspace =  kmalloc(zlib_deflate_workspacesize(\n\t\t\t\t\tWINDOW_BITS, MEM_LEVEL), GFP_KERNEL);\n\t\tif (!stream.workspace) {\n\t\t\tpr_err(\"nvram: No memory for compression workspace; \"\n\t\t\t\t\"skipping compression of %s partition data\\n\",\n\t\t\t\toops_log_partition.name);\n\t\t\tkfree(big_oops_buf);\n\t\t\tbig_oops_buf = NULL;\n\t\t}\n\t} else {\n\t\tpr_err(\"No memory for uncompressed %s data; \"\n\t\t\t\"skipping compression\\n\", oops_log_partition.name);\n\t\tstream.workspace = NULL;\n\t}\n\n\trc = kmsg_dump_register(&nvram_kmsg_dumper);\n\tif (rc != 0) {\n\t\tpr_err(\"nvram: kmsg_dump_register() failed; returned %d\\n\", rc);\n\t\tkfree(oops_buf);\n\t\tkfree(big_oops_buf);\n\t\tkfree(stream.workspace);\n\t}\n}"
  },
  {
    "function_name": "nvram_pstore_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "592-595",
    "snippet": "static int nvram_pstore_init(void)\n{\n\treturn -1;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int nvram_pstore_init(void)\n{\n\treturn -1;\n}"
  },
  {
    "function_name": "nvram_pstore_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "568-590",
    "snippet": "static int nvram_pstore_init(void)\n{\n\tint rc = 0;\n\n\tif (machine_is(pseries)) {\n\t\tnvram_type_ids[2] = PSTORE_TYPE_PPC_RTAS;\n\t\tnvram_type_ids[3] = PSTORE_TYPE_PPC_OF;\n\t} else\n\t\tnvram_type_ids[2] = PSTORE_TYPE_PPC_OPAL;\n\n\tnvram_pstore_info.buf = oops_data;\n\tnvram_pstore_info.bufsize = oops_data_sz;\n\n\tspin_lock_init(&nvram_pstore_info.buf_lock);\n\n\trc = pstore_register(&nvram_pstore_info);\n\tif (rc && (rc != -EPERM))\n\t\t/* Print error only when pstore.backend == nvram */\n\t\tpr_err(\"nvram: pstore_register() failed, returned %d. \"\n\t\t\t\t\"Defaults to kmsg_dump\\n\", rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *oops_data;",
      "static size_t oops_data_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: pstore_register() failed, returned %d. \"\n\t\t\t\t\"Defaults to kmsg_dump\\n\"",
            "rc"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pstore_register",
          "args": [
            "&nvram_pstore_info"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&nvram_pstore_info.buf_lock"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic char *oops_data;\nstatic size_t oops_data_sz;\n\nstatic int nvram_pstore_init(void)\n{\n\tint rc = 0;\n\n\tif (machine_is(pseries)) {\n\t\tnvram_type_ids[2] = PSTORE_TYPE_PPC_RTAS;\n\t\tnvram_type_ids[3] = PSTORE_TYPE_PPC_OF;\n\t} else\n\t\tnvram_type_ids[2] = PSTORE_TYPE_PPC_OPAL;\n\n\tnvram_pstore_info.buf = oops_data;\n\tnvram_pstore_info.bufsize = oops_data_sz;\n\n\tspin_lock_init(&nvram_pstore_info.buf_lock);\n\n\trc = pstore_register(&nvram_pstore_info);\n\tif (rc && (rc != -EPERM))\n\t\t/* Print error only when pstore.backend == nvram */\n\t\tpr_err(\"nvram: pstore_register() failed, returned %d. \"\n\t\t\t\t\"Defaults to kmsg_dump\\n\", rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "nvram_pstore_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "446-558",
    "snippet": "static ssize_t nvram_pstore_read(u64 *id, enum pstore_type_id *type,\n\t\t\t\tint *count, struct timespec *time, char **buf,\n\t\t\t\tbool *compressed, struct pstore_info *psi)\n{\n\tstruct oops_log_info *oops_hdr;\n\tunsigned int err_type, id_no, size = 0;\n\tstruct nvram_os_partition *part = NULL;\n\tchar *buff = NULL;\n\tint sig = 0;\n\tloff_t p;\n\n\tread_type++;\n\n\tswitch (nvram_type_ids[read_type]) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tpart = &oops_log_partition;\n\t\t*type = PSTORE_TYPE_DMESG;\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_COMMON:\n\t\tsig = NVRAM_SIG_SYS;\n\t\tpart = &common_partition;\n\t\t*type = PSTORE_TYPE_PPC_COMMON;\n\t\t*id = PSTORE_TYPE_PPC_COMMON;\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\tbreak;\n#ifdef CONFIG_PPC_PSERIES\n\tcase PSTORE_TYPE_PPC_RTAS:\n\t\tpart = &rtas_log_partition;\n\t\t*type = PSTORE_TYPE_PPC_RTAS;\n\t\ttime->tv_sec = last_rtas_event;\n\t\ttime->tv_nsec = 0;\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_OF:\n\t\tsig = NVRAM_SIG_OF;\n\t\tpart = &of_config_partition;\n\t\t*type = PSTORE_TYPE_PPC_OF;\n\t\t*id = PSTORE_TYPE_PPC_OF;\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\tbreak;\n#endif\n#ifdef CONFIG_PPC_POWERNV\n\tcase PSTORE_TYPE_PPC_OPAL:\n\t\tsig = NVRAM_SIG_FW;\n\t\tpart = &skiboot_partition;\n\t\t*type = PSTORE_TYPE_PPC_OPAL;\n\t\t*id = PSTORE_TYPE_PPC_OPAL;\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!part->os_partition) {\n\t\tp = nvram_find_partition(part->name, sig, &size);\n\t\tif (p <= 0) {\n\t\t\tpr_err(\"nvram: Failed to find partition %s, \"\n\t\t\t\t\"err %d\\n\", part->name, (int)p);\n\t\t\treturn 0;\n\t\t}\n\t\tpart->index = p;\n\t\tpart->size = size;\n\t}\n\n\tbuff = kmalloc(part->size, GFP_KERNEL);\n\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tif (nvram_read_partition(part, buff, part->size, &err_type, &id_no)) {\n\t\tkfree(buff);\n\t\treturn 0;\n\t}\n\n\t*count = 0;\n\n\tif (part->os_partition)\n\t\t*id = id_no;\n\n\tif (nvram_type_ids[read_type] == PSTORE_TYPE_DMESG) {\n\t\tsize_t length, hdr_size;\n\n\t\toops_hdr = (struct oops_log_info *)buff;\n\t\tif (be16_to_cpu(oops_hdr->version) < OOPS_HDR_VERSION) {\n\t\t\t/* Old format oops header had 2-byte record size */\n\t\t\thdr_size = sizeof(u16);\n\t\t\tlength = be16_to_cpu(oops_hdr->version);\n\t\t\ttime->tv_sec = 0;\n\t\t\ttime->tv_nsec = 0;\n\t\t} else {\n\t\t\thdr_size = sizeof(*oops_hdr);\n\t\t\tlength = be16_to_cpu(oops_hdr->report_length);\n\t\t\ttime->tv_sec = be64_to_cpu(oops_hdr->timestamp);\n\t\t\ttime->tv_nsec = 0;\n\t\t}\n\t\t*buf = kmemdup(buff + hdr_size, length, GFP_KERNEL);\n\t\tif (*buf == NULL)\n\t\t\treturn -ENOMEM;\n\t\tkfree(buff);\n\n\t\tif (err_type == ERR_TYPE_KERNEL_PANIC_GZ)\n\t\t\t*compressed = true;\n\t\telse\n\t\t\t*compressed = false;\n\t\treturn length;\n\t}\n\n\t*buf = buff;\n\treturn part->size;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buff"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "buff + hdr_size",
            "length",
            "GFP_KERNEL"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oops_hdr->timestamp"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oops_hdr->report_length"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oops_hdr->version"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "oops_hdr->version"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buff"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_read_partition",
          "args": [
            "part",
            "buff",
            "part->size",
            "&err_type",
            "&id_no"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_read_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "231-269",
          "snippet": "int nvram_read_partition(struct nvram_os_partition *part, char *buff,\n\t\t\t int length, unsigned int *err_type,\n\t\t\t unsigned int *error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -1;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\ttmp_index = part->index;\n\n\tif (part->os_partition) {\n\t\trc = ppc_md.nvram_read((char *)&info,\n\t\t\t\t\tsizeof(struct err_log_info),\n\t\t\t\t\t&tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ppc_md.nvram_read(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (part->os_partition) {\n\t\t*error_log_cnt = be32_to_cpu(info.seq_num);\n\t\t*err_type = be32_to_cpu(info.error_type);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint nvram_read_partition(struct nvram_os_partition *part, char *buff,\n\t\t\t int length, unsigned int *err_type,\n\t\t\t unsigned int *error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -1;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\ttmp_index = part->index;\n\n\tif (part->os_partition) {\n\t\trc = ppc_md.nvram_read((char *)&info,\n\t\t\t\t\tsizeof(struct err_log_info),\n\t\t\t\t\t&tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ppc_md.nvram_read(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (part->os_partition) {\n\t\t*error_log_cnt = be32_to_cpu(info.seq_num);\n\t\t*err_type = be32_to_cpu(info.error_type);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "part->size",
            "GFP_KERNEL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: Failed to find partition %s, \"\n\t\t\t\t\"err %d\\n\"",
            "part->name",
            "(int)p"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_find_partition",
          "args": [
            "part->name",
            "sig",
            "&size"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_find_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "1141-1155",
          "snippet": "loff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstruct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};\n\nstatic ssize_t nvram_pstore_read(u64 *id, enum pstore_type_id *type,\n\t\t\t\tint *count, struct timespec *time, char **buf,\n\t\t\t\tbool *compressed, struct pstore_info *psi)\n{\n\tstruct oops_log_info *oops_hdr;\n\tunsigned int err_type, id_no, size = 0;\n\tstruct nvram_os_partition *part = NULL;\n\tchar *buff = NULL;\n\tint sig = 0;\n\tloff_t p;\n\n\tread_type++;\n\n\tswitch (nvram_type_ids[read_type]) {\n\tcase PSTORE_TYPE_DMESG:\n\t\tpart = &oops_log_partition;\n\t\t*type = PSTORE_TYPE_DMESG;\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_COMMON:\n\t\tsig = NVRAM_SIG_SYS;\n\t\tpart = &common_partition;\n\t\t*type = PSTORE_TYPE_PPC_COMMON;\n\t\t*id = PSTORE_TYPE_PPC_COMMON;\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\tbreak;\n#ifdef CONFIG_PPC_PSERIES\n\tcase PSTORE_TYPE_PPC_RTAS:\n\t\tpart = &rtas_log_partition;\n\t\t*type = PSTORE_TYPE_PPC_RTAS;\n\t\ttime->tv_sec = last_rtas_event;\n\t\ttime->tv_nsec = 0;\n\t\tbreak;\n\tcase PSTORE_TYPE_PPC_OF:\n\t\tsig = NVRAM_SIG_OF;\n\t\tpart = &of_config_partition;\n\t\t*type = PSTORE_TYPE_PPC_OF;\n\t\t*id = PSTORE_TYPE_PPC_OF;\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\tbreak;\n#endif\n#ifdef CONFIG_PPC_POWERNV\n\tcase PSTORE_TYPE_PPC_OPAL:\n\t\tsig = NVRAM_SIG_FW;\n\t\tpart = &skiboot_partition;\n\t\t*type = PSTORE_TYPE_PPC_OPAL;\n\t\t*id = PSTORE_TYPE_PPC_OPAL;\n\t\ttime->tv_sec = 0;\n\t\ttime->tv_nsec = 0;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (!part->os_partition) {\n\t\tp = nvram_find_partition(part->name, sig, &size);\n\t\tif (p <= 0) {\n\t\t\tpr_err(\"nvram: Failed to find partition %s, \"\n\t\t\t\t\"err %d\\n\", part->name, (int)p);\n\t\t\treturn 0;\n\t\t}\n\t\tpart->index = p;\n\t\tpart->size = size;\n\t}\n\n\tbuff = kmalloc(part->size, GFP_KERNEL);\n\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tif (nvram_read_partition(part, buff, part->size, &err_type, &id_no)) {\n\t\tkfree(buff);\n\t\treturn 0;\n\t}\n\n\t*count = 0;\n\n\tif (part->os_partition)\n\t\t*id = id_no;\n\n\tif (nvram_type_ids[read_type] == PSTORE_TYPE_DMESG) {\n\t\tsize_t length, hdr_size;\n\n\t\toops_hdr = (struct oops_log_info *)buff;\n\t\tif (be16_to_cpu(oops_hdr->version) < OOPS_HDR_VERSION) {\n\t\t\t/* Old format oops header had 2-byte record size */\n\t\t\thdr_size = sizeof(u16);\n\t\t\tlength = be16_to_cpu(oops_hdr->version);\n\t\t\ttime->tv_sec = 0;\n\t\t\ttime->tv_nsec = 0;\n\t\t} else {\n\t\t\thdr_size = sizeof(*oops_hdr);\n\t\t\tlength = be16_to_cpu(oops_hdr->report_length);\n\t\t\ttime->tv_sec = be64_to_cpu(oops_hdr->timestamp);\n\t\t\ttime->tv_nsec = 0;\n\t\t}\n\t\t*buf = kmemdup(buff + hdr_size, length, GFP_KERNEL);\n\t\tif (*buf == NULL)\n\t\t\treturn -ENOMEM;\n\t\tkfree(buff);\n\n\t\tif (err_type == ERR_TYPE_KERNEL_PANIC_GZ)\n\t\t\t*compressed = true;\n\t\telse\n\t\t\t*compressed = false;\n\t\treturn length;\n\t}\n\n\t*buf = buff;\n\treturn part->size;\n}"
  },
  {
    "function_name": "nvram_pstore_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "407-439",
    "snippet": "static int nvram_pstore_write(enum pstore_type_id type,\n\t\t\t\tenum kmsg_dump_reason reason,\n\t\t\t\tu64 *id, unsigned int part, int count,\n\t\t\t\tbool compressed, size_t size,\n\t\t\t\tstruct pstore_info *psi)\n{\n\tint rc;\n\tunsigned int err_type = ERR_TYPE_KERNEL_PANIC;\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *) oops_buf;\n\n\t/* part 1 has the recent messages from printk buffer */\n\tif (part > 1 || (type != PSTORE_TYPE_DMESG))\n\t\treturn -1;\n\n\tif (clobbering_unread_rtas_event())\n\t\treturn -1;\n\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(size);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\n\tif (compressed)\n\t\terr_type = ERR_TYPE_KERNEL_PANIC_GZ;\n\n\trc = nvram_write_os_partition(&oops_log_partition, oops_buf,\n\t\t(int) (sizeof(*oops_hdr) + size), err_type, count);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\t*id = part;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};",
      "static void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason);",
      "static char *big_oops_buf, *oops_buf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nvram_write_os_partition",
          "args": [
            "&oops_log_partition",
            "oops_buf",
            "(int) (sizeof(*oops_hdr) + size)",
            "err_type",
            "count"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_write_os_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "191-225",
          "snippet": "int nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info),\n\t\t\t\t&tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info),\n\t\t\t\t&tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ktime_get_real_seconds()"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "size"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "OOPS_HDR_VERSION"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clobbering_unread_rtas_event",
          "args": [],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstruct nvram_os_partition oops_log_partition = {\n\t.name = \"lnx,oops-log\",\n\t.req_size = 4000,\n\t.min_size = 2000,\n\t.index = -1,\n\t.os_partition = true\n};\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\n\t\t\t  enum kmsg_dump_reason reason);\nstatic char *big_oops_buf, *oops_buf;\n\nstatic int nvram_pstore_write(enum pstore_type_id type,\n\t\t\t\tenum kmsg_dump_reason reason,\n\t\t\t\tu64 *id, unsigned int part, int count,\n\t\t\t\tbool compressed, size_t size,\n\t\t\t\tstruct pstore_info *psi)\n{\n\tint rc;\n\tunsigned int err_type = ERR_TYPE_KERNEL_PANIC;\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *) oops_buf;\n\n\t/* part 1 has the recent messages from printk buffer */\n\tif (part > 1 || (type != PSTORE_TYPE_DMESG))\n\t\treturn -1;\n\n\tif (clobbering_unread_rtas_event())\n\t\treturn -1;\n\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(size);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\n\tif (compressed)\n\t\terr_type = ERR_TYPE_KERNEL_PANIC_GZ;\n\n\trc = nvram_write_os_partition(&oops_log_partition, oops_buf,\n\t\t(int) (sizeof(*oops_hdr) + size), err_type, count);\n\n\tif (rc != 0)\n\t\treturn rc;\n\n\t*id = part;\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_pstore_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "384-389",
    "snippet": "static int nvram_pstore_open(struct pstore_info *psi)\n{\n\t/* Reset the iterator to start reading partitions again */\n\tread_type = -1;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic int nvram_pstore_open(struct pstore_info *psi)\n{\n\t/* Reset the iterator to start reading partitions again */\n\tread_type = -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "zip_oops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "367-381",
    "snippet": "static int zip_oops(size_t text_len)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\n\t\t\t\t\t\t\t\toops_data_sz);\n\tif (zipped_len < 0) {\n\t\tpr_err(\"nvram: compression failed; returned %d\\n\", zipped_len);\n\t\tpr_err(\"nvram: logging uncompressed oops/panic report\\n\");\n\t\treturn -1;\n\t}\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(zipped_len);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *big_oops_buf, *oops_buf;",
      "static char *oops_data;",
      "static size_t oops_data_sz;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ktime_get_real_seconds()"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "zipped_len"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "OOPS_HDR_VERSION"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: logging uncompressed oops/panic report\\n\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: compression failed; returned %d\\n\"",
            "zipped_len"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_compress",
          "args": [
            "big_oops_buf",
            "oops_data",
            "text_len",
            "oops_data_sz"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "332-364",
          "snippet": "static int nvram_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MEM_LEVEL 4",
            "#define WINDOW_BITS 12",
            "#define COMPR_LEVEL 6"
          ],
          "globals_used": [
            "static struct z_stream_s stream;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n#define COMPR_LEVEL 6\n\nstatic struct z_stream_s stream;\n\nstatic int nvram_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic char *big_oops_buf, *oops_buf;\nstatic char *oops_data;\nstatic size_t oops_data_sz;\n\nstatic int zip_oops(size_t text_len)\n{\n\tstruct oops_log_info *oops_hdr = (struct oops_log_info *)oops_buf;\n\tint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\n\t\t\t\t\t\t\t\toops_data_sz);\n\tif (zipped_len < 0) {\n\t\tpr_err(\"nvram: compression failed; returned %d\\n\", zipped_len);\n\t\tpr_err(\"nvram: logging uncompressed oops/panic report\\n\");\n\t\treturn -1;\n\t}\n\toops_hdr->version = cpu_to_be16(OOPS_HDR_VERSION);\n\toops_hdr->report_length = cpu_to_be16(zipped_len);\n\toops_hdr->timestamp = cpu_to_be64(ktime_get_real_seconds());\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "332-364",
    "snippet": "static int nvram_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MEM_LEVEL 4",
      "#define WINDOW_BITS 12",
      "#define COMPR_LEVEL 6"
    ],
    "globals_used": [
      "static struct z_stream_s stream;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "zlib_deflateEnd",
          "args": [
            "&stream"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflate",
          "args": [
            "&stream",
            "Z_FINISH"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zlib_deflateInit2",
          "args": [
            "&stream",
            "COMPR_LEVEL",
            "Z_DEFLATED",
            "WINDOW_BITS",
            "MEM_LEVEL",
            "Z_DEFAULT_STRATEGY"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define MEM_LEVEL 4\n#define WINDOW_BITS 12\n#define COMPR_LEVEL 6\n\nstatic struct z_stream_s stream;\n\nstatic int nvram_compress(const void *in, void *out, size_t inlen,\n\t\t\t\t\t\t\tsize_t outlen)\n{\n\tint err, ret;\n\n\tret = -EIO;\n\terr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\n\t\t\t\t\t\tMEM_LEVEL, Z_DEFAULT_STRATEGY);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tstream.next_in = in;\n\tstream.avail_in = inlen;\n\tstream.total_in = 0;\n\tstream.next_out = out;\n\tstream.avail_out = outlen;\n\tstream.total_out = 0;\n\n\terr = zlib_deflate(&stream, Z_FINISH);\n\tif (err != Z_STREAM_END)\n\t\tgoto error;\n\n\terr = zlib_deflateEnd(&stream);\n\tif (err != Z_OK)\n\t\tgoto error;\n\n\tif (stream.total_out >= stream.total_in)\n\t\tgoto error;\n\n\tret = stream.total_out;\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "nvram_init_os_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "288-329",
    "snippet": "int __init nvram_init_os_partition(struct nvram_os_partition *part)\n{\n\tloff_t p;\n\tint size;\n\n\t/* Look for ours */\n\tp = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\n\n\t/* Found one but too small, remove it */\n\tif (p && size < part->min_size) {\n\t\tpr_info(\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\", part->name);\n\t\tnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\n\t\tp = 0;\n\t}\n\n\t/* Create one if we didn't find */\n\tif (!p) {\n\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\tif (p == -ENOSPC) {\n\t\t\tpr_info(\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\",\n\t\t\t\tpart->name);\n\t\t\tnvram_remove_partition(NULL, NVRAM_SIG_OS,\n\t\t\t\t\tnvram_os_partitions);\n\t\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\t}\n\t}\n\n\tif (p <= 0) {\n\t\tpr_err(\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\", part->name, (int)p);\n\t\treturn -1;\n\t}\n\n\tpart->index = p;\n\tpart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *nvram_os_partitions[] = {\n#ifdef CONFIG_PPC_PSERIES\n\t\"ibm,rtas-log\",\n#endif\n\t\"lnx,oops-log\",\n\tNULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nvram_get_partition_size",
          "args": [
            "p"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_get_partition_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "1123-1132",
          "snippet": "int nvram_get_partition_size(loff_t data_index)\n{\n\tstruct nvram_partition *part;\n\t\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->index + NVRAM_HEADER_LEN == data_index)\n\t\t\treturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nint nvram_get_partition_size(loff_t data_index)\n{\n\tstruct nvram_partition *part;\n\t\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->index + NVRAM_HEADER_LEN == data_index)\n\t\t\treturn (part->header.length - 1) * NVRAM_BLOCK_LEN;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\"",
            "part->name",
            "(int)p"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_create_partition",
          "args": [
            "part->name",
            "NVRAM_SIG_OS",
            "part->req_size",
            "part->min_size"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_create_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "1018-1115",
          "snippet": "loff_t __init nvram_create_partition(const char *name, int sig,\n\t\t\t\t     int req_size, int min_size)\n{\n\tstruct nvram_partition *part;\n\tstruct nvram_partition *new_part;\n\tstruct nvram_partition *free_part = NULL;\n\tstatic char nv_init_vals[16];\n\tloff_t tmp_index;\n\tlong size = 0;\n\tint rc;\n\n\t/* Convert sizes from bytes to blocks */\n\treq_size = _ALIGN_UP(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\tmin_size = _ALIGN_UP(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\n\t/* If no minimum size specified, make it the same as the\n\t * requested size\n\t */\n\tif (min_size == 0)\n\t\tmin_size = req_size;\n\tif (min_size > req_size)\n\t\treturn -EINVAL;\n\n\t/* Now add one block to each for the header */\n\treq_size += 1;\n\tmin_size += 1;\n\n\t/* Find a free partition that will give us the maximum needed size \n\t   If can't find one that will give us the minimum size needed */\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE)\n\t\t\tcontinue;\n\n\t\tif (part->header.length >= req_size) {\n\t\t\tsize = req_size;\n\t\t\tfree_part = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (part->header.length > size &&\n\t\t    part->header.length >= min_size) {\n\t\t\tsize = part->header.length;\n\t\t\tfree_part = part;\n\t\t}\n\t}\n\tif (!size)\n\t\treturn -ENOSPC;\n\t\n\t/* Create our OS partition */\n\tnew_part = kmalloc(sizeof(*new_part), GFP_KERNEL);\n\tif (!new_part) {\n\t\tpr_err(\"%s: kmalloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_part->index = free_part->index;\n\tnew_part->header.signature = sig;\n\tnew_part->header.length = size;\n\tstrncpy(new_part->header.name, name, 12);\n\tnew_part->header.checksum = nvram_checksum(&new_part->header);\n\n\trc = nvram_write_header(new_part);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\", __func__, rc);\n\t\tkfree(new_part);\n\t\treturn rc;\n\t}\n\tlist_add_tail(&new_part->partition, &free_part->partition);\n\n\t/* Adjust or remove the partition we stole the space from */\n\tif (free_part->header.length > size) {\n\t\tfree_part->index += size * NVRAM_BLOCK_LEN;\n\t\tfree_part->header.length -= size;\n\t\tfree_part->header.checksum = nvram_checksum(&free_part->header);\n\t\trc = nvram_write_header(free_part);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tlist_del(&free_part->partition);\n\t\tkfree(free_part);\n\t} \n\n\t/* Clear the new partition */\n\tfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\n\t     tmp_index <  ((size - 1) * NVRAM_BLOCK_LEN);\n\t     tmp_index += NVRAM_BLOCK_LEN) {\n\t\trc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn new_part->index + NVRAM_HEADER_LEN;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t __init nvram_create_partition(const char *name, int sig,\n\t\t\t\t     int req_size, int min_size)\n{\n\tstruct nvram_partition *part;\n\tstruct nvram_partition *new_part;\n\tstruct nvram_partition *free_part = NULL;\n\tstatic char nv_init_vals[16];\n\tloff_t tmp_index;\n\tlong size = 0;\n\tint rc;\n\n\t/* Convert sizes from bytes to blocks */\n\treq_size = _ALIGN_UP(req_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\tmin_size = _ALIGN_UP(min_size, NVRAM_BLOCK_LEN) / NVRAM_BLOCK_LEN;\n\n\t/* If no minimum size specified, make it the same as the\n\t * requested size\n\t */\n\tif (min_size == 0)\n\t\tmin_size = req_size;\n\tif (min_size > req_size)\n\t\treturn -EINVAL;\n\n\t/* Now add one block to each for the header */\n\treq_size += 1;\n\tmin_size += 1;\n\n\t/* Find a free partition that will give us the maximum needed size \n\t   If can't find one that will give us the minimum size needed */\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE)\n\t\t\tcontinue;\n\n\t\tif (part->header.length >= req_size) {\n\t\t\tsize = req_size;\n\t\t\tfree_part = part;\n\t\t\tbreak;\n\t\t}\n\t\tif (part->header.length > size &&\n\t\t    part->header.length >= min_size) {\n\t\t\tsize = part->header.length;\n\t\t\tfree_part = part;\n\t\t}\n\t}\n\tif (!size)\n\t\treturn -ENOSPC;\n\t\n\t/* Create our OS partition */\n\tnew_part = kmalloc(sizeof(*new_part), GFP_KERNEL);\n\tif (!new_part) {\n\t\tpr_err(\"%s: kmalloc failed\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_part->index = free_part->index;\n\tnew_part->header.signature = sig;\n\tnew_part->header.length = size;\n\tstrncpy(new_part->header.name, name, 12);\n\tnew_part->header.checksum = nvram_checksum(&new_part->header);\n\n\trc = nvram_write_header(new_part);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\", __func__, rc);\n\t\tkfree(new_part);\n\t\treturn rc;\n\t}\n\tlist_add_tail(&new_part->partition, &free_part->partition);\n\n\t/* Adjust or remove the partition we stole the space from */\n\tif (free_part->header.length > size) {\n\t\tfree_part->index += size * NVRAM_BLOCK_LEN;\n\t\tfree_part->header.length -= size;\n\t\tfree_part->header.checksum = nvram_checksum(&free_part->header);\n\t\trc = nvram_write_header(free_part);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write_header failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\tlist_del(&free_part->partition);\n\t\tkfree(free_part);\n\t} \n\n\t/* Clear the new partition */\n\tfor (tmp_index = new_part->index + NVRAM_HEADER_LEN;\n\t     tmp_index <  ((size - 1) * NVRAM_BLOCK_LEN);\n\t     tmp_index += NVRAM_BLOCK_LEN) {\n\t\trc = ppc_md.nvram_write(nv_init_vals, NVRAM_BLOCK_LEN, &tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: nvram_write failed (%d)\\n\",\n\t\t\t       __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn new_part->index + NVRAM_HEADER_LEN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nvram_remove_partition",
          "args": [
            "NULL",
            "NVRAM_SIG_OS",
            "nvram_os_partitions"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_remove_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "960-1003",
          "snippet": "int __init nvram_remove_partition(const char *name, int sig,\n\t\t\t\t\t\tconst char *exceptions[])\n{\n\tstruct nvram_partition *part, *prev, *tmp;\n\tint rc;\n\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (!nvram_can_remove_partition(part, name, sig, exceptions))\n\t\t\tcontinue;\n\n\t\t/* Make partition a free partition */\n\t\tpart->header.signature = NVRAM_SIG_FREE;\n\t\tstrncpy(part->header.name, \"wwwwwwwwwwww\", 12);\n\t\tpart->header.checksum = nvram_checksum(&part->header);\n\t\trc = nvram_write_header(part);\n\t\tif (rc <= 0) {\n\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Merge contiguous ones */\n\tprev = NULL;\n\tlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE) {\n\t\t\tprev = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (prev) {\n\t\t\tprev->header.length += part->header.length;\n\t\t\tprev->header.checksum = nvram_checksum(&part->header);\n\t\t\trc = nvram_write_header(part);\n\t\t\tif (rc <= 0) {\n\t\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&part->partition);\n\t\t\tkfree(part);\n\t\t} else\n\t\t\tprev = part;\n\t}\n\t\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(nvram_partitions);\n\nint __init nvram_remove_partition(const char *name, int sig,\n\t\t\t\t\t\tconst char *exceptions[])\n{\n\tstruct nvram_partition *part, *prev, *tmp;\n\tint rc;\n\n\tlist_for_each_entry(part, &nvram_partitions, partition) {\n\t\tif (!nvram_can_remove_partition(part, name, sig, exceptions))\n\t\t\tcontinue;\n\n\t\t/* Make partition a free partition */\n\t\tpart->header.signature = NVRAM_SIG_FREE;\n\t\tstrncpy(part->header.name, \"wwwwwwwwwwww\", 12);\n\t\tpart->header.checksum = nvram_checksum(&part->header);\n\t\trc = nvram_write_header(part);\n\t\tif (rc <= 0) {\n\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t/* Merge contiguous ones */\n\tprev = NULL;\n\tlist_for_each_entry_safe(part, tmp, &nvram_partitions, partition) {\n\t\tif (part->header.signature != NVRAM_SIG_FREE) {\n\t\t\tprev = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (prev) {\n\t\t\tprev->header.length += part->header.length;\n\t\t\tprev->header.checksum = nvram_checksum(&part->header);\n\t\t\trc = nvram_write_header(part);\n\t\t\tif (rc <= 0) {\n\t\t\t\tprintk(KERN_ERR \"nvram_remove_partition: nvram_write failed (%d)\\n\", rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tlist_del(&part->partition);\n\t\t\tkfree(part);\n\t\t} else\n\t\t\tprev = part;\n\t}\n\t\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\"",
            "part->name"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\"",
            "part->name"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nvram_find_partition",
          "args": [
            "part->name",
            "NVRAM_SIG_OS",
            "&size"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "nvram_find_partition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
          "lines": "1141-1155",
          "snippet": "loff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/nvram.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/zlib.h>",
            "#include <linux/pstore.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/nvram.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN",
            "#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)"
          ],
          "globals_used": [
            "static LIST_HEAD(nvram_partitions);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define NVRAM_BLOCK_LEN\t\tNVRAM_HEADER_LEN\n#define NVRAM_HEADER_LEN\tsizeof(struct nvram_header)\n\nstatic LIST_HEAD(nvram_partitions);\n\nloff_t nvram_find_partition(const char *name, int sig, int *out_size)\n{\n\tstruct nvram_partition *p;\n\n\tlist_for_each_entry(p, &nvram_partitions, partition) {\n\t\tif (p->header.signature == sig &&\n\t\t    (!name || !strncmp(p->header.name, name, 12))) {\n\t\t\tif (out_size)\n\t\t\t\t*out_size = (p->header.length - 1) *\n\t\t\t\t\tNVRAM_BLOCK_LEN;\n\t\t\treturn p->index + NVRAM_HEADER_LEN;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic const char *nvram_os_partitions[] = {\n#ifdef CONFIG_PPC_PSERIES\n\t\"ibm,rtas-log\",\n#endif\n\t\"lnx,oops-log\",\n\tNULL\n};\n\nint __init nvram_init_os_partition(struct nvram_os_partition *part)\n{\n\tloff_t p;\n\tint size;\n\n\t/* Look for ours */\n\tp = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\n\n\t/* Found one but too small, remove it */\n\tif (p && size < part->min_size) {\n\t\tpr_info(\"nvram: Found too small %s partition,\"\n\t\t\t\t\t\" removing it...\\n\", part->name);\n\t\tnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\n\t\tp = 0;\n\t}\n\n\t/* Create one if we didn't find */\n\tif (!p) {\n\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\tif (p == -ENOSPC) {\n\t\t\tpr_info(\"nvram: No room to create %s partition, \"\n\t\t\t\t\"deleting any obsolete OS partitions...\\n\",\n\t\t\t\tpart->name);\n\t\t\tnvram_remove_partition(NULL, NVRAM_SIG_OS,\n\t\t\t\t\tnvram_os_partitions);\n\t\t\tp = nvram_create_partition(part->name, NVRAM_SIG_OS,\n\t\t\t\t\tpart->req_size, part->min_size);\n\t\t}\n\t}\n\n\tif (p <= 0) {\n\t\tpr_err(\"nvram: Failed to find or create %s\"\n\t\t       \" partition, err %d\\n\", part->name, (int)p);\n\t\treturn -1;\n\t}\n\n\tpart->index = p;\n\tpart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_read_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "231-269",
    "snippet": "int nvram_read_partition(struct nvram_os_partition *part, char *buff,\n\t\t\t int length, unsigned int *err_type,\n\t\t\t unsigned int *error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -1;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\ttmp_index = part->index;\n\n\tif (part->os_partition) {\n\t\trc = ppc_md.nvram_read((char *)&info,\n\t\t\t\t\tsizeof(struct err_log_info),\n\t\t\t\t\t&tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ppc_md.nvram_read(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (part->os_partition) {\n\t\t*error_log_cnt = be32_to_cpu(info.seq_num);\n\t\t*err_type = be32_to_cpu(info.error_type);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "info.error_type"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "info.seq_num"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed nvram_read (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_read",
          "args": [
            "buff",
            "length",
            "&tmp_index"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed nvram_read (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_read",
          "args": [
            "(char *)&info",
            "sizeof(struct err_log_info)",
            "&tmp_index"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint nvram_read_partition(struct nvram_os_partition *part, char *buff,\n\t\t\t int length, unsigned int *err_type,\n\t\t\t unsigned int *error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -1;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\ttmp_index = part->index;\n\n\tif (part->os_partition) {\n\t\trc = ppc_md.nvram_read((char *)&info,\n\t\t\t\t\tsizeof(struct err_log_info),\n\t\t\t\t\t&tmp_index);\n\t\tif (rc <= 0) {\n\t\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = ppc_md.nvram_read(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_read (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\tif (part->os_partition) {\n\t\t*error_log_cnt = be32_to_cpu(info.seq_num);\n\t\t*err_type = be32_to_cpu(info.error_type);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nvram_write_os_partition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/nvram_64.c",
    "lines": "191-225",
    "snippet": "int nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info),\n\t\t\t\t&tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/rtas.h>",
      "#include <asm/nvram.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/zlib.h>",
      "#include <linux/pstore.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/nvram.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/types.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed nvram_write (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "buff",
            "length",
            "&tmp_index"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed nvram_write (%d)\\n\"",
            "__func__",
            "rc"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.nvram_write",
          "args": [
            "(char *)&info",
            "sizeof(struct err_log_info)",
            "&tmp_index"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "error_log_cnt"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "err_type"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/nvram.h>\n#include <asm/uaccess.h>\n#include <linux/zlib.h>\n#include <linux/pstore.h>\n#include <linux/kmsg_dump.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/nvram.h>\n#include <linux/fcntl.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint nvram_write_os_partition(struct nvram_os_partition *part,\n\t\t\t     char *buff, int length,\n\t\t\t     unsigned int err_type,\n\t\t\t     unsigned int error_log_cnt)\n{\n\tint rc;\n\tloff_t tmp_index;\n\tstruct err_log_info info;\n\n\tif (part->index == -1)\n\t\treturn -ESPIPE;\n\n\tif (length > part->size)\n\t\tlength = part->size;\n\n\tinfo.error_type = cpu_to_be32(err_type);\n\tinfo.seq_num = cpu_to_be32(error_log_cnt);\n\n\ttmp_index = part->index;\n\n\trc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info),\n\t\t\t\t&tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\trc = ppc_md.nvram_write(buff, length, &tmp_index);\n\tif (rc <= 0) {\n\t\tpr_err(\"%s: Failed nvram_write (%d)\\n\", __func__, rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}"
  }
]