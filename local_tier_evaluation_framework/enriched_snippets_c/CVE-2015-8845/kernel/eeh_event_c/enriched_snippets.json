[
  {
    "function_name": "eeh_remove_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "162-196",
    "snippet": "void eeh_remove_event(struct eeh_pe *pe, bool force)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event, *tmp;\n\n\t/*\n\t * If we have NULL PE passed in, we have dead IOC\n\t * or we're sure we can report all existing errors\n\t * by the caller.\n\t *\n\t * With \"force\", the event with associated PE that\n\t * have been isolated, the event won't be removed\n\t * to avoid event lost.\n\t */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\n\t\tif (!force && event->pe &&\n\t\t    (event->pe->state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tif (!pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t} else if (pe->type & EEH_PE_PHB) {\n\t\t\tif (event->pe && event->pe->phb == pe->phb) {\n\t\t\t\tlist_del(&event->list);\n\t\t\t\tkfree(event);\n\t\t\t}\n\t\t} else if (event->pe == pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(eeh_eventlist_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "event",
            "tmp",
            "&eeh_eventlist",
            "list"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\n\nvoid eeh_remove_event(struct eeh_pe *pe, bool force)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event, *tmp;\n\n\t/*\n\t * If we have NULL PE passed in, we have dead IOC\n\t * or we're sure we can report all existing errors\n\t * by the caller.\n\t *\n\t * With \"force\", the event with associated PE that\n\t * have been isolated, the event won't be removed\n\t * to avoid event lost.\n\t */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {\n\t\tif (!force && event->pe &&\n\t\t    (event->pe->state & EEH_PE_ISOLATED))\n\t\t\tcontinue;\n\n\t\tif (!pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t} else if (pe->type & EEH_PE_PHB) {\n\t\t\tif (event->pe && event->pe->phb == pe->phb) {\n\t\t\t\tlist_del(&event->list);\n\t\t\t\tkfree(event);\n\t\t\t}\n\t\t} else if (event->pe == pe) {\n\t\t\tlist_del(&event->list);\n\t\t\tkfree(event);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n}"
  },
  {
    "function_name": "eeh_send_failure_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "129-150",
    "snippet": "int eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tup(&eeh_eventlist_sem);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
      "static struct semaphore eeh_eventlist_sem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&eeh_eventlist_sem"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "kgdb_roundup_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kgdb.c",
          "lines": "126-129",
          "snippet": "void kgdb_roundup_cpus(unsigned long flags)\n{\n\tsmp_send_debugger_break();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <asm/debug.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/signal.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <asm/debug.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/kdebug.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kernel.h>\n\nvoid kgdb_roundup_cpus(unsigned long flags)\n{\n\tsmp_send_debugger_break();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&event->list",
            "&eeh_eventlist"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EEH: out of memory, event not handled\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*event)",
            "GFP_ATOMIC"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic struct semaphore eeh_eventlist_sem;\n\nint eeh_send_failure_event(struct eeh_pe *pe)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event) {\n\t\tpr_err(\"EEH: out of memory, event not handled\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tevent->pe = pe;\n\n\t/* We may or may not be called in an interrupt context */\n\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\tlist_add(&event->list, &eeh_eventlist);\n\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\n\t/* For EEH deamon to knick in */\n\tup(&eeh_eventlist_sem);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_event_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "102-119",
    "snippet": "int eeh_event_init(void)\n{\n\tstruct task_struct *t;\n\tint ret = 0;\n\n\t/* Initialize semaphore */\n\tsema_init(&eeh_eventlist_sem, 0);\n\n\tt = kthread_run(eeh_event_handler, NULL, \"eehd\");\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tpr_err(\"%s: Failed to start EEH daemon (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct semaphore eeh_eventlist_sem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Failed to start EEH daemon (%d)\\n\"",
            "__func__",
            "ret"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "t"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "eeh_event_handler",
            "NULL",
            "\"eehd\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sema_init",
          "args": [
            "&eeh_eventlist_sem",
            "0"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic struct semaphore eeh_eventlist_sem;\n\nint eeh_event_init(void)\n{\n\tstruct task_struct *t;\n\tint ret = 0;\n\n\t/* Initialize semaphore */\n\tsema_init(&eeh_eventlist_sem, 0);\n\n\tt = kthread_run(eeh_event_handler, NULL, \"eehd\");\n\tif (IS_ERR(t)) {\n\t\tret = PTR_ERR(t);\n\t\tpr_err(\"%s: Failed to start EEH daemon (%d)\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_event_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_event.c",
    "lines": "51-94",
    "snippet": "static int eeh_event_handler(void * dummy)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\tstruct eeh_pe *pe;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (down_interruptible(&eeh_eventlist_sem))\n\t\t\tbreak;\n\n\t\t/* Fetch EEH event from the queue */\n\t\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\t\tevent = NULL;\n\t\tif (!list_empty(&eeh_eventlist)) {\n\t\t\tevent = list_entry(eeh_eventlist.next,\n\t\t\t\t\t   struct eeh_event, list);\n\t\t\tlist_del(&event->list);\n\t\t}\n\t\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\t\tif (!event)\n\t\t\tcontinue;\n\n\t\t/* We might have event without binding PE */\n\t\tpe = event->pe;\n\t\tif (pe) {\n\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\tif (pe->type & EEH_PE_PHB)\n\t\t\t\tpr_info(\"EEH: Detected error on PHB#%d\\n\",\n\t\t\t\t\t pe->phb->global_number);\n\t\t\telse\n\t\t\t\tpr_info(\"EEH: Detected PCI bus error on \"\n\t\t\t\t\t\"PHB#%d-PE#%x\\n\",\n\t\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\teeh_handle_event(pe);\n\t\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\t} else {\n\t\t\teeh_handle_event(NULL);\n\t\t}\n\n\t\tkfree(event);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/eeh_event.h>",
      "#include <linux/kthread.h>",
      "#include <linux/slab.h>",
      "#include <linux/pci.h>",
      "#include <linux/semaphore.h>",
      "#include <linux/sched.h>",
      "#include <linux/list.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(eeh_eventlist_lock);",
      "static struct semaphore eeh_eventlist_sem;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_handle_event",
          "args": [
            "NULL"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_handle_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_driver.c",
          "lines": "929-935",
          "snippet": "void eeh_handle_event(struct eeh_pe *pe)\n{\n\tif (pe)\n\t\teeh_handle_normal_event(pe);\n\telse\n\t\teeh_handle_special_event();\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <linux/pci.h>",
            "#include <linux/module.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/pci-bridge.h>\n#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n\nvoid eeh_handle_event(struct eeh_pe *pe)\n{\n\tif (pe)\n\t\teeh_handle_normal_event(pe);\n\telse\n\t\teeh_handle_special_event();\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_clear",
          "args": [
            "pe",
            "EEH_PE_RECOVERING"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "655-658",
          "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Detected PCI bus error on \"\n\t\t\t\t\t\"PHB#%d-PE#%x\\n\"",
            "pe->phb->global_number",
            "pe->addr"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"EEH: Detected error on PHB#%d\\n\"",
            "pe->phb->global_number"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_state_mark",
          "args": [
            "pe",
            "EEH_PE_RECOVERING"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_state_mark_with_cfg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "671-680",
          "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "eeh_eventlist.next",
            "structeeh_event",
            "list"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&eeh_eventlist"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&eeh_eventlist_lock",
            "flags"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_interruptible",
          "args": [
            "&eeh_eventlist_sem"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/eeh_event.h>\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n\nstatic DEFINE_SPINLOCK(eeh_eventlist_lock);\nstatic struct semaphore eeh_eventlist_sem;\n\nstatic int eeh_event_handler(void * dummy)\n{\n\tunsigned long flags;\n\tstruct eeh_event *event;\n\tstruct eeh_pe *pe;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (down_interruptible(&eeh_eventlist_sem))\n\t\t\tbreak;\n\n\t\t/* Fetch EEH event from the queue */\n\t\tspin_lock_irqsave(&eeh_eventlist_lock, flags);\n\t\tevent = NULL;\n\t\tif (!list_empty(&eeh_eventlist)) {\n\t\t\tevent = list_entry(eeh_eventlist.next,\n\t\t\t\t\t   struct eeh_event, list);\n\t\t\tlist_del(&event->list);\n\t\t}\n\t\tspin_unlock_irqrestore(&eeh_eventlist_lock, flags);\n\t\tif (!event)\n\t\t\tcontinue;\n\n\t\t/* We might have event without binding PE */\n\t\tpe = event->pe;\n\t\tif (pe) {\n\t\t\teeh_pe_state_mark(pe, EEH_PE_RECOVERING);\n\t\t\tif (pe->type & EEH_PE_PHB)\n\t\t\t\tpr_info(\"EEH: Detected error on PHB#%d\\n\",\n\t\t\t\t\t pe->phb->global_number);\n\t\t\telse\n\t\t\t\tpr_info(\"EEH: Detected PCI bus error on \"\n\t\t\t\t\t\"PHB#%d-PE#%x\\n\",\n\t\t\t\t\tpe->phb->global_number, pe->addr);\n\t\t\teeh_handle_event(pe);\n\t\t\teeh_pe_state_clear(pe, EEH_PE_RECOVERING);\n\t\t} else {\n\t\t\teeh_handle_event(NULL);\n\t\t}\n\n\t\tkfree(event);\n\t}\n\n\treturn 0;\n}"
  }
]