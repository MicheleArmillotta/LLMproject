[
  {
    "function_name": "do_syscall_trace_leave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1869-1883",
    "snippet": "void do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tint step;\n\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->result);\n\n\tstep = test_thread_flag(TIF_SINGLESTEP);\n\tif (step || test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, step);\n\n\tuser_enter();\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_enter",
          "args": [],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracehook_report_syscall_exit",
          "args": [
            "regs",
            "step"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SYSCALL_TRACE"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SINGLESTEP"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sys_exit",
          "args": [
            "regs",
            "regs->result"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_thread_flag(TIF_SYSCALL_TRACEPOINT)"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SYSCALL_TRACEPOINT"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_syscall_exit",
          "args": [
            "regs"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tint step;\n\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->result);\n\n\tstep = test_thread_flag(TIF_SINGLESTEP);\n\tif (step || test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, step);\n\n\tuser_enter();\n}"
  },
  {
    "function_name": "do_syscall_trace_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1822-1867",
    "snippet": "long do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tbool abort = false;\n\n\tuser_exit();\n\n\tif (do_seccomp(regs))\n\t\treturn -1;\n\n\tif (test_thread_flag(TIF_SYSCALL_TRACE)) {\n\t\t/*\n\t\t * The tracer may decide to abort the syscall, if so tracehook\n\t\t * will return !0. Note that the tracer may also just change\n\t\t * regs->gpr[0] to an invalid syscall number, that is handled\n\t\t * below on the exit path.\n\t\t */\n\t\tabort = tracehook_report_syscall_entry(regs) != 0;\n\t}\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gpr[0]);\n\n#ifdef CONFIG_PPC64\n\tif (!is_32bit_task())\n\t\taudit_syscall_entry(regs->gpr[0], regs->gpr[3], regs->gpr[4],\n\t\t\t\t    regs->gpr[5], regs->gpr[6]);\n\telse\n#endif\n\t\taudit_syscall_entry(regs->gpr[0],\n\t\t\t\t    regs->gpr[3] & 0xffffffff,\n\t\t\t\t    regs->gpr[4] & 0xffffffff,\n\t\t\t\t    regs->gpr[5] & 0xffffffff,\n\t\t\t\t    regs->gpr[6] & 0xffffffff);\n\n\tif (abort || regs->gpr[0] >= NR_syscalls) {\n\t\t/*\n\t\t * If we are aborting explicitly, or if the syscall number is\n\t\t * now invalid, set the return value to -ENOSYS.\n\t\t */\n\t\tregs->gpr[3] = -ENOSYS;\n\t\treturn -1;\n\t}\n\n\t/* Return the possibly modified but valid syscall number */\n\treturn regs->gpr[0];\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_syscall_entry",
          "args": [
            "regs->gpr[0]",
            "regs->gpr[3] & 0xffffffff",
            "regs->gpr[4] & 0xffffffff",
            "regs->gpr[5] & 0xffffffff",
            "regs->gpr[6] & 0xffffffff"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_syscall_entry",
          "args": [
            "regs->gpr[0]",
            "regs->gpr[3]",
            "regs->gpr[4]",
            "regs->gpr[5]",
            "regs->gpr[6]"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sys_enter",
          "args": [
            "regs",
            "regs->gpr[0]"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "test_thread_flag(TIF_SYSCALL_TRACEPOINT)"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SYSCALL_TRACEPOINT"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracehook_report_syscall_entry",
          "args": [
            "regs"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SYSCALL_TRACE"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_seccomp",
          "args": [
            "regs"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "do_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "1800-1800",
          "snippet": "static inline int do_seccomp(struct pt_regs *regs) { return 0; }",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic inline int do_seccomp(struct pt_regs *regs) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "user_exit",
          "args": [],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nlong do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tbool abort = false;\n\n\tuser_exit();\n\n\tif (do_seccomp(regs))\n\t\treturn -1;\n\n\tif (test_thread_flag(TIF_SYSCALL_TRACE)) {\n\t\t/*\n\t\t * The tracer may decide to abort the syscall, if so tracehook\n\t\t * will return !0. Note that the tracer may also just change\n\t\t * regs->gpr[0] to an invalid syscall number, that is handled\n\t\t * below on the exit path.\n\t\t */\n\t\tabort = tracehook_report_syscall_entry(regs) != 0;\n\t}\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gpr[0]);\n\n#ifdef CONFIG_PPC64\n\tif (!is_32bit_task())\n\t\taudit_syscall_entry(regs->gpr[0], regs->gpr[3], regs->gpr[4],\n\t\t\t\t    regs->gpr[5], regs->gpr[6]);\n\telse\n#endif\n\t\taudit_syscall_entry(regs->gpr[0],\n\t\t\t\t    regs->gpr[3] & 0xffffffff,\n\t\t\t\t    regs->gpr[4] & 0xffffffff,\n\t\t\t\t    regs->gpr[5] & 0xffffffff,\n\t\t\t\t    regs->gpr[6] & 0xffffffff);\n\n\tif (abort || regs->gpr[0] >= NR_syscalls) {\n\t\t/*\n\t\t * If we are aborting explicitly, or if the syscall number is\n\t\t * now invalid, set the return value to -ENOSYS.\n\t\t */\n\t\tregs->gpr[3] = -ENOSYS;\n\t\treturn -1;\n\t}\n\n\t/* Return the possibly modified but valid syscall number */\n\treturn regs->gpr[0];\n}"
  },
  {
    "function_name": "do_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1800-1800",
    "snippet": "static inline int do_seccomp(struct pt_regs *regs) { return 0; }",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic inline int do_seccomp(struct pt_regs *regs) { return 0; }"
  },
  {
    "function_name": "do_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1766-1798",
    "snippet": "static int do_seccomp(struct pt_regs *regs)\n{\n\tif (!test_thread_flag(TIF_SECCOMP))\n\t\treturn 0;\n\n\t/*\n\t * The ABI we present to seccomp tracers is that r3 contains\n\t * the syscall return value and orig_gpr3 contains the first\n\t * syscall parameter. This is different to the ptrace ABI where\n\t * both r3 and orig_gpr3 contain the first syscall parameter.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\n\t/*\n\t * We use the __ version here because we have already checked\n\t * TIF_SECCOMP. If this fails, there is nothing left to do, we\n\t * have already loaded -ENOSYS into r3, or seccomp has put\n\t * something else in r3 (via SECCOMP_RET_ERRNO/TRACE).\n\t */\n\tif (__secure_computing())\n\t\treturn -1;\n\n\t/*\n\t * The syscall was allowed by seccomp, restore the register\n\t * state to what ptrace and audit expect.\n\t * Note that we use orig_gpr3, which means a seccomp tracer can\n\t * modify the first syscall parameter (in orig_gpr3) and also\n\t * allow the syscall to proceed.\n\t */\n\tregs->gpr[3] = regs->orig_gpr3;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__secure_computing",
          "args": [],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SECCOMP"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int do_seccomp(struct pt_regs *regs)\n{\n\tif (!test_thread_flag(TIF_SECCOMP))\n\t\treturn 0;\n\n\t/*\n\t * The ABI we present to seccomp tracers is that r3 contains\n\t * the syscall return value and orig_gpr3 contains the first\n\t * syscall parameter. This is different to the ptrace ABI where\n\t * both r3 and orig_gpr3 contain the first syscall parameter.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\n\t/*\n\t * We use the __ version here because we have already checked\n\t * TIF_SECCOMP. If this fails, there is nothing left to do, we\n\t * have already loaded -ENOSYS into r3, or seccomp has put\n\t * something else in r3 (via SECCOMP_RET_ERRNO/TRACE).\n\t */\n\tif (__secure_computing())\n\t\treturn -1;\n\n\t/*\n\t * The syscall was allowed by seccomp, restore the register\n\t * state to what ptrace and audit expect.\n\t * Note that we use orig_gpr3, which means a seccomp tracer can\n\t * modify the first syscall parameter (in orig_gpr3) and also\n\t * allow the syscall to proceed.\n\t */\n\tregs->gpr[3] = regs->orig_gpr3;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1524-1763",
    "snippet": "long arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret = -EPERM;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\n\tswitch (request) {\n\t/* read the word at location addr in the USER area. */\n\tcase PTRACE_PEEKUSR: {\n\t\tunsigned long index, tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, (int) index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&tmp, &child->thread.TS_FPR(fpidx),\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\ttmp = child->thread.fp_state.fpscr;\n\t\t}\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&child->thread.TS_FPR(fpidx), &data,\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\tchild->thread.fp_state.fpscr = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_GETHWDBGINFO: {\n\t\tstruct ppc_debug_info dbginfo;\n\n\t\tdbginfo.version = 1;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tdbginfo.num_instruction_bps = CONFIG_PPC_ADV_DEBUG_IACS;\n\t\tdbginfo.num_data_bps = CONFIG_PPC_ADV_DEBUG_DACS;\n\t\tdbginfo.num_condition_regs = CONFIG_PPC_ADV_DEBUG_DVCS;\n\t\tdbginfo.data_bp_alignment = 4;\n\t\tdbginfo.sizeof_condition = 4;\n\t\tdbginfo.features = PPC_DEBUG_FEATURE_INSN_BP_RANGE |\n\t\t\t\t   PPC_DEBUG_FEATURE_INSN_BP_MASK;\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tdbginfo.features |=\n\t\t\t\t   PPC_DEBUG_FEATURE_DATA_BP_RANGE |\n\t\t\t\t   PPC_DEBUG_FEATURE_DATA_BP_MASK;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_REGS */\n\t\tdbginfo.num_instruction_bps = 0;\n\t\tdbginfo.num_data_bps = 1;\n\t\tdbginfo.num_condition_regs = 0;\n#ifdef CONFIG_PPC64\n\t\tdbginfo.data_bp_alignment = 8;\n#else\n\t\tdbginfo.data_bp_alignment = 4;\n#endif\n\t\tdbginfo.sizeof_condition = 0;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t\tdbginfo.features = PPC_DEBUG_FEATURE_DATA_BP_RANGE;\n\t\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\t\tdbginfo.features |= PPC_DEBUG_FEATURE_DATA_BP_DAWR;\n#else\n\t\tdbginfo.features = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\n\t\tif (!access_ok(VERIFY_WRITE, datavp,\n\t\t\t       sizeof(struct ppc_debug_info)))\n\t\t\treturn -EFAULT;\n\t\tret = __copy_to_user(datavp, &dbginfo,\n\t\t\t\t     sizeof(struct ppc_debug_info)) ?\n\t\t      -EFAULT : 0;\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_SETHWDEBUG: {\n\t\tstruct ppc_hw_breakpoint bp_info;\n\n\t\tif (!access_ok(VERIFY_READ, datavp,\n\t\t\t       sizeof(struct ppc_hw_breakpoint)))\n\t\t\treturn -EFAULT;\n\t\tret = __copy_from_user(&bp_info, datavp,\n\t\t\t\t       sizeof(struct ppc_hw_breakpoint)) ?\n\t\t      -EFAULT : 0;\n\t\tif (!ret)\n\t\t\tret = ppc_set_hwdebug(child, &bp_info);\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_DELHWDEBUG: {\n\t\tret = ppc_del_hwdebug(child, data);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG: {\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tunsigned long dabr_fake;\n#endif\n\t\tret = -EINVAL;\n\t\t/* We only support one DABR and no IABRS at the moment */\n\t\tif (addr > 0)\n\t\t\tbreak;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tret = put_user(child->thread.debug.dac1, datalp);\n#else\n\t\tdabr_fake = ((child->thread.hw_brk.address & (~HW_BRK_TYPE_DABR)) |\n\t\t\t     (child->thread.hw_brk.type & HW_BRK_TYPE_DABR));\n\t\tret = put_user(dabr_fake, datalp);\n#endif\n\t\tbreak;\n\t}\n\n\tcase PTRACE_SET_DEBUGREG:\n\t\tret = ptrace_set_debugreg(child, addr, data);\n\t\tbreak;\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_GETREGS64:\n#endif\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_GPR,\n\t\t\t\t\t   0, sizeof(struct pt_regs),\n\t\t\t\t\t   datavp);\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_SETREGS64:\n#endif\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_GPR,\n\t\t\t\t\t     0, sizeof(struct pt_regs),\n\t\t\t\t\t     datavp);\n\n\tcase PTRACE_GETFPREGS: /* Get the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_FPR,\n\t\t\t\t\t   0, sizeof(elf_fpregset_t),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETFPREGS: /* Set the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_FPR,\n\t\t\t\t\t     0, sizeof(elf_fpregset_t),\n\t\t\t\t\t     datavp);\n\n#ifdef CONFIG_ALTIVEC\n\tcase PTRACE_GETVRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VMX,\n\t\t\t\t\t   0, (33 * sizeof(vector128) +\n\t\t\t\t\t       sizeof(u32)),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VMX,\n\t\t\t\t\t     0, (33 * sizeof(vector128) +\n\t\t\t\t\t\t sizeof(u32)),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_VSX\n\tcase PTRACE_GETVSRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VSX,\n\t\t\t\t\t   0, 32 * sizeof(double),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVSRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VSX,\n\t\t\t\t\t     0, 32 * sizeof(double),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_SPE\n\tcase PTRACE_GETEVRREGS:\n\t\t/* Get the child spe register state. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETEVRREGS:\n\t\t/* Set the child spe register state. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t     datavp);\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_request",
          "args": [
            "child",
            "request",
            "addr",
            "data"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_SPE",
            "0",
            "35 * sizeof(u32)",
            "datavp"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_SPE",
            "0",
            "35 * sizeof(u32)",
            "datavp"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_VSX",
            "0",
            "32 * sizeof(double)",
            "datavp"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_VSX",
            "0",
            "32 * sizeof(double)",
            "datavp"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_VMX",
            "0",
            "(33 * sizeof(vector128) +\n\t\t\t\t\t\t sizeof(u32))",
            "datavp"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_VMX",
            "0",
            "(33 * sizeof(vector128) +\n\t\t\t\t\t       sizeof(u32))",
            "datavp"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_FPR",
            "0",
            "sizeof(elf_fpregset_t)",
            "datavp"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_FPR",
            "0",
            "sizeof(elf_fpregset_t)",
            "datavp"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_GPR",
            "0",
            "sizeof(struct pt_regs)",
            "datavp"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "&user_ppc_native_view",
            "REGSET_GPR",
            "0",
            "sizeof(struct pt_regs)",
            "datavp"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_set_debugreg",
          "args": [
            "child",
            "addr",
            "data"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_set_debugreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "935-1057",
          "snippet": "static int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,\n\t\t\t       unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &(task->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint hw_brk;\n#endif\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.\n\t *  It was assumed, on previous implementations, that 3 bits were\n\t *  passed together with the data address, fitting the design of the\n\t *  DABR register, as follows:\n\t *\n\t *  bit 0: Read flag\n\t *  bit 1: Write flag\n\t *  bit 2: Breakpoint translation\n\t *\n\t *  Thus, we use them here as so.\n\t */\n\n\t/* Ensure breakpoint translation bit is set */\n\tif (data && !(data & HW_BRK_TYPE_TRANSLATE))\n\t\treturn -EIO;\n\thw_brk.address = data & (~HW_BRK_TYPE_DABR);\n\thw_brk.type = (data & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\n\thw_brk.len = 8;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif ((!data) || !(hw_brk.type & HW_BRK_TYPE_RDWR)) {\n\t\tif (bp) {\n\t\t\tunregister_hw_breakpoint(bp);\n\t\t\tthread->ptrace_bps[0] = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (bp) {\n\t\tattr = bp->attr;\n\t\tattr.bp_addr = hw_brk.address;\n\t\tarch_bp_generic_fields(hw_brk.type, &attr.bp_type);\n\n\t\t/* Enable breakpoint */\n\t\tattr.disabled = false;\n\n\t\tret =  modify_user_hw_breakpoint(bp, &attr);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tthread->ptrace_bps[0] = bp;\n\t\tthread->hw_brk = hw_brk;\n\t\treturn 0;\n\t}\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = hw_brk.address;\n\tarch_bp_generic_fields(hw_brk.type,\n\t\t\t       &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, task);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\ttask->thread.hw_brk = hw_brk;\n#else /* CONFIG_PPC_ADV_DEBUG_REGS */\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0\n\t   register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0\n\t   accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R|DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,\n\t\t\t       unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &(task->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint hw_brk;\n#endif\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.\n\t *  It was assumed, on previous implementations, that 3 bits were\n\t *  passed together with the data address, fitting the design of the\n\t *  DABR register, as follows:\n\t *\n\t *  bit 0: Read flag\n\t *  bit 1: Write flag\n\t *  bit 2: Breakpoint translation\n\t *\n\t *  Thus, we use them here as so.\n\t */\n\n\t/* Ensure breakpoint translation bit is set */\n\tif (data && !(data & HW_BRK_TYPE_TRANSLATE))\n\t\treturn -EIO;\n\thw_brk.address = data & (~HW_BRK_TYPE_DABR);\n\thw_brk.type = (data & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\n\thw_brk.len = 8;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif ((!data) || !(hw_brk.type & HW_BRK_TYPE_RDWR)) {\n\t\tif (bp) {\n\t\t\tunregister_hw_breakpoint(bp);\n\t\t\tthread->ptrace_bps[0] = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (bp) {\n\t\tattr = bp->attr;\n\t\tattr.bp_addr = hw_brk.address;\n\t\tarch_bp_generic_fields(hw_brk.type, &attr.bp_type);\n\n\t\t/* Enable breakpoint */\n\t\tattr.disabled = false;\n\n\t\tret =  modify_user_hw_breakpoint(bp, &attr);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tthread->ptrace_bps[0] = bp;\n\t\tthread->hw_brk = hw_brk;\n\t\treturn 0;\n\t}\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = hw_brk.address;\n\tarch_bp_generic_fields(hw_brk.type,\n\t\t\t       &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, task);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\ttask->thread.hw_brk = hw_brk;\n#else /* CONFIG_PPC_ADV_DEBUG_REGS */\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0\n\t   register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0\n\t   accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R|DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "dabr_fake",
            "datalp"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "child->thread.debug.dac1",
            "datalp"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_del_hwdebug",
          "args": [
            "child",
            "data"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_del_hwdebug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "1477-1522",
          "snippet": "static long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n#else\n\tif (data != 1)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif (bp) {\n\t\tunregister_hw_breakpoint(bp);\n\t\tthread->ptrace_bps[0] = NULL;\n\t} else\n\t\tret = -ENOENT;\n\treturn ret;\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (child->thread.hw_brk.address == 0)\n\t\treturn -ENOENT;\n\n\tchild->thread.hw_brk.address = 0;\n\tchild->thread.hw_brk.type = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n#else\n\tif (data != 1)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif (bp) {\n\t\tunregister_hw_breakpoint(bp);\n\t\tthread->ptrace_bps[0] = NULL;\n\t} else\n\t\tret = -ENOENT;\n\treturn ret;\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (child->thread.hw_brk.address == 0)\n\t\treturn -ENOENT;\n\n\tchild->thread.hw_brk.address = 0;\n\tchild->thread.hw_brk.type = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_set_hwdebug",
          "args": [
            "child",
            "&bp_info"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_set_hwdebug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "1369-1475",
          "snippet": "static long ppc_set_hwdebug(struct task_struct *child,\n\t\t     struct ppc_hw_breakpoint *bp_info)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint len = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint brk;\n#endif\n\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif ((bp_info->trigger_type == 0) ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif ((bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE) ||\n\t\t    (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE))\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n\t/*\n\t * We only support one data breakpoint\n\t */\n\tif ((bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_RW) == 0 ||\n\t    (bp_info->trigger_type & ~PPC_BREAKPOINT_TRIGGER_RW) != 0 ||\n\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tbrk.address = bp_info->addr & ~7UL;\n\tbrk.type = HW_BRK_TYPE_TRANSLATE;\n\tbrk.len = 8;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tbrk.type |= HW_BRK_TYPE_READ;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tbrk.type |= HW_BRK_TYPE_WRITE;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t/*\n\t * Check if the request is for 'range' breakpoints. We can\n\t * support it if range < 8 bytes.\n\t */\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tlen = bp_info->addr2 - bp_info->addr;\n\telse if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\tlen = 1;\n\telse\n\t\treturn -EINVAL;\n\tbp = thread->ptrace_bps[0];\n\tif (bp)\n\t\treturn -ENOSPC;\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)bp_info->addr & ~HW_BREAKPOINT_ALIGN;\n\tattr.bp_len = len;\n\tarch_bp_generic_fields(brk.type, &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, child);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n\treturn 1;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn -EINVAL;\n\n\tif (child->thread.hw_brk.address)\n\t\treturn -ENOSPC;\n\n\tchild->thread.hw_brk = brk;\n\n\treturn 1;\n#endif /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic long ppc_set_hwdebug(struct task_struct *child,\n\t\t     struct ppc_hw_breakpoint *bp_info)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint len = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint brk;\n#endif\n\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif ((bp_info->trigger_type == 0) ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif ((bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE) ||\n\t\t    (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE))\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n\t/*\n\t * We only support one data breakpoint\n\t */\n\tif ((bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_RW) == 0 ||\n\t    (bp_info->trigger_type & ~PPC_BREAKPOINT_TRIGGER_RW) != 0 ||\n\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tbrk.address = bp_info->addr & ~7UL;\n\tbrk.type = HW_BRK_TYPE_TRANSLATE;\n\tbrk.len = 8;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tbrk.type |= HW_BRK_TYPE_READ;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tbrk.type |= HW_BRK_TYPE_WRITE;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t/*\n\t * Check if the request is for 'range' breakpoints. We can\n\t * support it if range < 8 bytes.\n\t */\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tlen = bp_info->addr2 - bp_info->addr;\n\telse if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\tlen = 1;\n\telse\n\t\treturn -EINVAL;\n\tbp = thread->ptrace_bps[0];\n\tif (bp)\n\t\treturn -ENOSPC;\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)bp_info->addr & ~HW_BREAKPOINT_ALIGN;\n\tattr.bp_len = len;\n\tarch_bp_generic_fields(brk.type, &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, child);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n\treturn 1;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn -EINVAL;\n\n\tif (child->thread.hw_brk.address)\n\t\treturn -ENOSPC;\n\n\tchild->thread.hw_brk = brk;\n\n\treturn 1;\n#endif /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&bp_info",
            "datavp",
            "sizeof(struct ppc_hw_breakpoint)"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "datavp",
            "sizeof(struct ppc_hw_breakpoint)"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "datavp",
            "&dbginfo",
            "sizeof(struct ppc_debug_info)"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "datavp",
            "sizeof(struct ppc_debug_info)"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DAWR"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&child->thread.TS_FPR(fpidx)",
            "&data",
            "sizeof(long)"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "child->thread.TS_FPR",
          "args": [
            "fpidx"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "child"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_put_reg",
          "args": [
            "child",
            "index",
            "data"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_put_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "245-262",
          "snippet": "int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PT_MAX_PUT_REG\tPT_CCR",
            "#define PT_MAX_PUT_REG\tPT_MQ"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define PT_MAX_PUT_REG\tPT_CCR\n#define PT_MAX_PUT_REG\tPT_MQ\n\nint ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "child->thread.regs"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "tmp",
            "datalp"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "child->thread.TS_FPR",
          "args": [
            "fpidx"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_get_reg",
          "args": [
            "child",
            "(int) index",
            "&tmp"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "221-240",
          "snippet": "int ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "child->thread.regs"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret = -EPERM;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\n\tswitch (request) {\n\t/* read the word at location addr in the USER area. */\n\tcase PTRACE_PEEKUSR: {\n\t\tunsigned long index, tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, (int) index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&tmp, &child->thread.TS_FPR(fpidx),\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\ttmp = child->thread.fp_state.fpscr;\n\t\t}\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&child->thread.TS_FPR(fpidx), &data,\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\tchild->thread.fp_state.fpscr = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_GETHWDBGINFO: {\n\t\tstruct ppc_debug_info dbginfo;\n\n\t\tdbginfo.version = 1;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tdbginfo.num_instruction_bps = CONFIG_PPC_ADV_DEBUG_IACS;\n\t\tdbginfo.num_data_bps = CONFIG_PPC_ADV_DEBUG_DACS;\n\t\tdbginfo.num_condition_regs = CONFIG_PPC_ADV_DEBUG_DVCS;\n\t\tdbginfo.data_bp_alignment = 4;\n\t\tdbginfo.sizeof_condition = 4;\n\t\tdbginfo.features = PPC_DEBUG_FEATURE_INSN_BP_RANGE |\n\t\t\t\t   PPC_DEBUG_FEATURE_INSN_BP_MASK;\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tdbginfo.features |=\n\t\t\t\t   PPC_DEBUG_FEATURE_DATA_BP_RANGE |\n\t\t\t\t   PPC_DEBUG_FEATURE_DATA_BP_MASK;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_REGS */\n\t\tdbginfo.num_instruction_bps = 0;\n\t\tdbginfo.num_data_bps = 1;\n\t\tdbginfo.num_condition_regs = 0;\n#ifdef CONFIG_PPC64\n\t\tdbginfo.data_bp_alignment = 8;\n#else\n\t\tdbginfo.data_bp_alignment = 4;\n#endif\n\t\tdbginfo.sizeof_condition = 0;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t\tdbginfo.features = PPC_DEBUG_FEATURE_DATA_BP_RANGE;\n\t\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\t\tdbginfo.features |= PPC_DEBUG_FEATURE_DATA_BP_DAWR;\n#else\n\t\tdbginfo.features = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\n\t\tif (!access_ok(VERIFY_WRITE, datavp,\n\t\t\t       sizeof(struct ppc_debug_info)))\n\t\t\treturn -EFAULT;\n\t\tret = __copy_to_user(datavp, &dbginfo,\n\t\t\t\t     sizeof(struct ppc_debug_info)) ?\n\t\t      -EFAULT : 0;\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_SETHWDEBUG: {\n\t\tstruct ppc_hw_breakpoint bp_info;\n\n\t\tif (!access_ok(VERIFY_READ, datavp,\n\t\t\t       sizeof(struct ppc_hw_breakpoint)))\n\t\t\treturn -EFAULT;\n\t\tret = __copy_from_user(&bp_info, datavp,\n\t\t\t\t       sizeof(struct ppc_hw_breakpoint)) ?\n\t\t      -EFAULT : 0;\n\t\tif (!ret)\n\t\t\tret = ppc_set_hwdebug(child, &bp_info);\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_DELHWDEBUG: {\n\t\tret = ppc_del_hwdebug(child, data);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG: {\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tunsigned long dabr_fake;\n#endif\n\t\tret = -EINVAL;\n\t\t/* We only support one DABR and no IABRS at the moment */\n\t\tif (addr > 0)\n\t\t\tbreak;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tret = put_user(child->thread.debug.dac1, datalp);\n#else\n\t\tdabr_fake = ((child->thread.hw_brk.address & (~HW_BRK_TYPE_DABR)) |\n\t\t\t     (child->thread.hw_brk.type & HW_BRK_TYPE_DABR));\n\t\tret = put_user(dabr_fake, datalp);\n#endif\n\t\tbreak;\n\t}\n\n\tcase PTRACE_SET_DEBUGREG:\n\t\tret = ptrace_set_debugreg(child, addr, data);\n\t\tbreak;\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_GETREGS64:\n#endif\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_GPR,\n\t\t\t\t\t   0, sizeof(struct pt_regs),\n\t\t\t\t\t   datavp);\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_SETREGS64:\n#endif\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_GPR,\n\t\t\t\t\t     0, sizeof(struct pt_regs),\n\t\t\t\t\t     datavp);\n\n\tcase PTRACE_GETFPREGS: /* Get the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_FPR,\n\t\t\t\t\t   0, sizeof(elf_fpregset_t),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETFPREGS: /* Set the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_FPR,\n\t\t\t\t\t     0, sizeof(elf_fpregset_t),\n\t\t\t\t\t     datavp);\n\n#ifdef CONFIG_ALTIVEC\n\tcase PTRACE_GETVRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VMX,\n\t\t\t\t\t   0, (33 * sizeof(vector128) +\n\t\t\t\t\t       sizeof(u32)),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VMX,\n\t\t\t\t\t     0, (33 * sizeof(vector128) +\n\t\t\t\t\t\t sizeof(u32)),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_VSX\n\tcase PTRACE_GETVSRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VSX,\n\t\t\t\t\t   0, 32 * sizeof(double),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVSRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VSX,\n\t\t\t\t\t     0, 32 * sizeof(double),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_SPE\n\tcase PTRACE_GETEVRREGS:\n\t\t/* Get the child spe register state. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETEVRREGS:\n\t\t/* Set the child spe register state. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t     datavp);\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ppc_del_hwdebug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1477-1522",
    "snippet": "static long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n#else\n\tif (data != 1)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif (bp) {\n\t\tunregister_hw_breakpoint(bp);\n\t\tthread->ptrace_bps[0] = NULL;\n\t} else\n\t\tret = -ENOENT;\n\treturn ret;\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (child->thread.hw_brk.address == 0)\n\t\treturn -ENOENT;\n\n\tchild->thread.hw_brk.address = 0;\n\tchild->thread.hw_brk.type = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unregister_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "106-115",
          "snippet": "void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t */\n\tif (bp->ctx && bp->ctx->task)\n\t\tbp->ctx->task->thread.last_hit_ubp = NULL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t */\n\tif (bp->ctx && bp->ctx->task)\n\t\tbp->ctx->task->thread.last_hit_ubp = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "child->thread.debug.dbcr0",
            "child->thread.debug.dbcr1"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_dac",
          "args": [
            "child",
            "(int)data - 4"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "del_dac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "1274-1311",
          "snippet": "static int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_instruction_bp",
          "args": [
            "child",
            "(int)data"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "del_instruction_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "1159-1212",
          "snippet": "static int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n#else\n\tif (data != 1)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif (bp) {\n\t\tunregister_hw_breakpoint(bp);\n\t\tthread->ptrace_bps[0] = NULL;\n\t} else\n\t\tret = -ENOENT;\n\treturn ret;\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (child->thread.hw_brk.address == 0)\n\t\treturn -ENOENT;\n\n\tchild->thread.hw_brk.address = 0;\n\tchild->thread.hw_brk.type = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "ppc_set_hwdebug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1369-1475",
    "snippet": "static long ppc_set_hwdebug(struct task_struct *child,\n\t\t     struct ppc_hw_breakpoint *bp_info)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint len = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint brk;\n#endif\n\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif ((bp_info->trigger_type == 0) ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif ((bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE) ||\n\t\t    (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE))\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n\t/*\n\t * We only support one data breakpoint\n\t */\n\tif ((bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_RW) == 0 ||\n\t    (bp_info->trigger_type & ~PPC_BREAKPOINT_TRIGGER_RW) != 0 ||\n\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tbrk.address = bp_info->addr & ~7UL;\n\tbrk.type = HW_BRK_TYPE_TRANSLATE;\n\tbrk.len = 8;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tbrk.type |= HW_BRK_TYPE_READ;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tbrk.type |= HW_BRK_TYPE_WRITE;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t/*\n\t * Check if the request is for 'range' breakpoints. We can\n\t * support it if range < 8 bytes.\n\t */\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tlen = bp_info->addr2 - bp_info->addr;\n\telse if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\tlen = 1;\n\telse\n\t\treturn -EINVAL;\n\tbp = thread->ptrace_bps[0];\n\tif (bp)\n\t\treturn -ENOSPC;\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)bp_info->addr & ~HW_BREAKPOINT_ALIGN;\n\tattr.bp_len = len;\n\tarch_bp_generic_fields(brk.type, &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, child);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n\treturn 1;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn -EINVAL;\n\n\tif (child->thread.hw_brk.address)\n\t\treturn -ENOSPC;\n\n\tchild->thread.hw_brk = brk;\n\n\treturn 1;\n#endif /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bp"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bp"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_user_hw_breakpoint",
          "args": [
            "&attr",
            "ptrace_triggered",
            "NULL",
            "child"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_bp_generic_fields",
          "args": [
            "brk.type",
            "&attr.bp_type"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "arch_bp_generic_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "127-137",
          "snippet": "int arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_init",
          "args": [
            "&attr"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dac_range",
          "args": [
            "child",
            "bp_info"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "set_dac_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "1315-1366",
          "snippet": "static int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_instruction_bp",
          "args": [
            "child",
            "bp_info"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "set_instruction_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "1071-1157",
          "snippet": "static long set_instruction_bp(struct task_struct *child,\n\t\t\t      struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif ((!slot1_in_use) && (!slot2_in_use)) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || (slot3_in_use == slot4_in_use)) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic long set_instruction_bp(struct task_struct *child,\n\t\t\t      struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif ((!slot1_in_use) && (!slot2_in_use)) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || (slot3_in_use == slot4_in_use)) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic long ppc_set_hwdebug(struct task_struct *child,\n\t\t     struct ppc_hw_breakpoint *bp_info)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint len = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint brk;\n#endif\n\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif ((bp_info->trigger_type == 0) ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif ((bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE) ||\n\t\t    (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE))\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n\t/*\n\t * We only support one data breakpoint\n\t */\n\tif ((bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_RW) == 0 ||\n\t    (bp_info->trigger_type & ~PPC_BREAKPOINT_TRIGGER_RW) != 0 ||\n\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tbrk.address = bp_info->addr & ~7UL;\n\tbrk.type = HW_BRK_TYPE_TRANSLATE;\n\tbrk.len = 8;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tbrk.type |= HW_BRK_TYPE_READ;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tbrk.type |= HW_BRK_TYPE_WRITE;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t/*\n\t * Check if the request is for 'range' breakpoints. We can\n\t * support it if range < 8 bytes.\n\t */\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tlen = bp_info->addr2 - bp_info->addr;\n\telse if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\tlen = 1;\n\telse\n\t\treturn -EINVAL;\n\tbp = thread->ptrace_bps[0];\n\tif (bp)\n\t\treturn -ENOSPC;\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)bp_info->addr & ~HW_BREAKPOINT_ALIGN;\n\tattr.bp_len = len;\n\tarch_bp_generic_fields(brk.type, &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, child);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n\treturn 1;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn -EINVAL;\n\n\tif (child->thread.hw_brk.address)\n\t\treturn -ENOSPC;\n\n\tchild->thread.hw_brk = brk;\n\n\treturn 1;\n#endif /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n}"
  },
  {
    "function_name": "set_dac_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1315-1366",
    "snippet": "static int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}"
  },
  {
    "function_name": "del_dac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1274-1311",
    "snippet": "static int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "set_dac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1214-1272",
    "snippet": "static int set_dac(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tint byte_enable =\n\t\t(bp_info->condition_mode >> PPC_BREAKPOINT_CONDITION_BE_SHIFT)\n\t\t& 0xf;\n\tint condition_mode =\n\t\tbp_info->condition_mode & PPC_BREAKPOINT_CONDITION_MODE;\n\tint slot;\n\n\tif (byte_enable && (condition_mode == 0))\n\t\treturn -EINVAL;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0) {\n\t\tslot = 1;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1W;\n\t\tchild->thread.debug.dac1 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc1 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC1BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC1M_SHIFT));\n\t\t}\n#endif\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t} else if (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t/* Both dac1 and dac2 are part of a range */\n\t\treturn -ENOSPC;\n#endif\n\t} else if ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0) {\n\t\tslot = 2;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2W;\n\t\tchild->thread.debug.dac2 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc2 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC2BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC2M_SHIFT));\n\t\t}\n#endif\n\t} else\n\t\treturn -ENOSPC;\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot + 4;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "child"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_dac(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tint byte_enable =\n\t\t(bp_info->condition_mode >> PPC_BREAKPOINT_CONDITION_BE_SHIFT)\n\t\t& 0xf;\n\tint condition_mode =\n\t\tbp_info->condition_mode & PPC_BREAKPOINT_CONDITION_MODE;\n\tint slot;\n\n\tif (byte_enable && (condition_mode == 0))\n\t\treturn -EINVAL;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0) {\n\t\tslot = 1;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1W;\n\t\tchild->thread.debug.dac1 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc1 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC1BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC1M_SHIFT));\n\t\t}\n#endif\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t} else if (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t/* Both dac1 and dac2 are part of a range */\n\t\treturn -ENOSPC;\n#endif\n\t} else if ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0) {\n\t\tslot = 2;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2W;\n\t\tchild->thread.debug.dac2 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc2 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC2BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC2M_SHIFT));\n\t\t}\n#endif\n\t} else\n\t\treturn -ENOSPC;\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot + 4;\n}"
  },
  {
    "function_name": "del_instruction_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1159-1212",
    "snippet": "static int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "set_instruction_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1071-1157",
    "snippet": "static long set_instruction_bp(struct task_struct *child,\n\t\t\t      struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif ((!slot1_in_use) && (!slot2_in_use)) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || (slot3_in_use == slot4_in_use)) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_iac_range",
          "args": [
            "child"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic long set_instruction_bp(struct task_struct *child,\n\t\t\t      struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif ((!slot1_in_use) && (!slot2_in_use)) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || (slot3_in_use == slot4_in_use)) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}"
  },
  {
    "function_name": "ptrace_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "1064-1068",
    "snippet": "void ptrace_disable(struct task_struct *child)\n{\n\t/* make sure the single step bit is not set. */\n\tuser_disable_single_step(child);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_disable_single_step",
          "args": [
            "child"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "user_disable_single_step",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "886-915",
          "snippet": "void user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid ptrace_disable(struct task_struct *child)\n{\n\t/* make sure the single step bit is not set. */\n\tuser_disable_single_step(child);\n}"
  },
  {
    "function_name": "ptrace_set_debugreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "935-1057",
    "snippet": "static int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,\n\t\t\t       unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &(task->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint hw_brk;\n#endif\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.\n\t *  It was assumed, on previous implementations, that 3 bits were\n\t *  passed together with the data address, fitting the design of the\n\t *  DABR register, as follows:\n\t *\n\t *  bit 0: Read flag\n\t *  bit 1: Write flag\n\t *  bit 2: Breakpoint translation\n\t *\n\t *  Thus, we use them here as so.\n\t */\n\n\t/* Ensure breakpoint translation bit is set */\n\tif (data && !(data & HW_BRK_TYPE_TRANSLATE))\n\t\treturn -EIO;\n\thw_brk.address = data & (~HW_BRK_TYPE_DABR);\n\thw_brk.type = (data & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\n\thw_brk.len = 8;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif ((!data) || !(hw_brk.type & HW_BRK_TYPE_RDWR)) {\n\t\tif (bp) {\n\t\t\tunregister_hw_breakpoint(bp);\n\t\t\tthread->ptrace_bps[0] = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (bp) {\n\t\tattr = bp->attr;\n\t\tattr.bp_addr = hw_brk.address;\n\t\tarch_bp_generic_fields(hw_brk.type, &attr.bp_type);\n\n\t\t/* Enable breakpoint */\n\t\tattr.disabled = false;\n\n\t\tret =  modify_user_hw_breakpoint(bp, &attr);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tthread->ptrace_bps[0] = bp;\n\t\tthread->hw_brk = hw_brk;\n\t\treturn 0;\n\t}\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = hw_brk.address;\n\tarch_bp_generic_fields(hw_brk.type,\n\t\t\t       &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, task);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\ttask->thread.hw_brk = hw_brk;\n#else /* CONFIG_PPC_ADV_DEBUG_REGS */\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0\n\t   register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0\n\t   accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R|DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "task"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "task"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "task"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "task->thread.debug.dbcr0",
            "task->thread.debug.dbcr1"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbcr_dac",
          "args": [
            "task"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "bp"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "bp"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_user_hw_breakpoint",
          "args": [
            "&attr",
            "ptrace_triggered",
            "NULL",
            "task"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_bp_generic_fields",
          "args": [
            "hw_brk.type",
            "&attr.bp_type"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "arch_bp_generic_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "127-137",
          "snippet": "int arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_init",
          "args": [
            "&attr"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modify_user_hw_breakpoint",
          "args": [
            "bp",
            "&attr"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unregister_hw_breakpoint",
          "args": [
            "bp"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unregister_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "106-115",
          "snippet": "void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t */\n\tif (bp->ctx && bp->ctx->task)\n\t\tbp->ctx->task->thread.last_hit_ubp = NULL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t */\n\tif (bp->ctx && bp->ctx->task)\n\t\tbp->ctx->task->thread.last_hit_ubp = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,\n\t\t\t       unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &(task->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint hw_brk;\n#endif\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.\n\t *  It was assumed, on previous implementations, that 3 bits were\n\t *  passed together with the data address, fitting the design of the\n\t *  DABR register, as follows:\n\t *\n\t *  bit 0: Read flag\n\t *  bit 1: Write flag\n\t *  bit 2: Breakpoint translation\n\t *\n\t *  Thus, we use them here as so.\n\t */\n\n\t/* Ensure breakpoint translation bit is set */\n\tif (data && !(data & HW_BRK_TYPE_TRANSLATE))\n\t\treturn -EIO;\n\thw_brk.address = data & (~HW_BRK_TYPE_DABR);\n\thw_brk.type = (data & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\n\thw_brk.len = 8;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif ((!data) || !(hw_brk.type & HW_BRK_TYPE_RDWR)) {\n\t\tif (bp) {\n\t\t\tunregister_hw_breakpoint(bp);\n\t\t\tthread->ptrace_bps[0] = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (bp) {\n\t\tattr = bp->attr;\n\t\tattr.bp_addr = hw_brk.address;\n\t\tarch_bp_generic_fields(hw_brk.type, &attr.bp_type);\n\n\t\t/* Enable breakpoint */\n\t\tattr.disabled = false;\n\n\t\tret =  modify_user_hw_breakpoint(bp, &attr);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tthread->ptrace_bps[0] = bp;\n\t\tthread->hw_brk = hw_brk;\n\t\treturn 0;\n\t}\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = hw_brk.address;\n\tarch_bp_generic_fields(hw_brk.type,\n\t\t\t       &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, task);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\ttask->thread.hw_brk = hw_brk;\n#else /* CONFIG_PPC_ADV_DEBUG_REGS */\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0\n\t   register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0\n\t   accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R|DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\treturn 0;\n}"
  },
  {
    "function_name": "ptrace_triggered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "918-932",
    "snippet": "void ptrace_triggered(struct perf_event *bp,\n\t\t      struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modify_user_hw_breakpoint",
          "args": [
            "bp",
            "&attr"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid ptrace_triggered(struct perf_event *bp,\n\t\t      struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}"
  },
  {
    "function_name": "user_disable_single_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "886-915",
    "snippet": "void user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "task->thread.debug.dbcr0",
            "task->thread.debug.dbcr1"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  },
  {
    "function_name": "user_enable_block_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "869-884",
    "snippet": "void user_enable_block_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\ttask->thread.debug.dbcr0 = DBCR0_IDM | DBCR0_BT;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_SE;\n\t\tregs->msr |= MSR_BE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid user_enable_block_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\ttask->thread.debug.dbcr0 = DBCR0_IDM | DBCR0_BT;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_SE;\n\t\tregs->msr |= MSR_BE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  },
  {
    "function_name": "user_enable_single_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "852-867",
    "snippet": "void user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "task",
            "TIF_SINGLESTEP"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}"
  },
  {
    "function_name": "task_user_regset_view",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "842-849",
    "snippet": "const struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_PPC64\n\tif (test_tsk_thread_flag(task, TIF_32BIT))\n\t\treturn &user_ppc_compat_view;\n#endif\n\treturn &user_ppc_native_view;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_tsk_thread_flag",
          "args": [
            "task",
            "TIF_32BIT"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};\n\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_PPC64\n\tif (test_tsk_thread_flag(task, TIF_32BIT))\n\t\treturn &user_ppc_compat_view;\n#endif\n\treturn &user_ppc_native_view;\n}"
  },
  {
    "function_name": "gpr32_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "733-804",
    "snippet": "static int gpr32_set(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf)\n{\n\tunsigned long *regs = &target->thread.regs->gpr[0];\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PT_MAX_PUT_REG\tPT_CCR",
      "#define PT_MAX_PUT_REG\tPT_MQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin_ignore",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "(PT_TRAP + 1) * sizeof(reg)",
            "-1"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_trap",
          "args": [
            "target",
            "reg"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "212-216",
          "snippet": "static int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_msr",
          "args": [
            "target",
            "reg"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "176-181",
          "snippet": "static int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)",
            "#define MSR_DEBUGCHANGE\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)\n#define MSR_DEBUGCHANGE\t0\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "target->thread.regs"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define PT_MAX_PUT_REG\tPT_CCR\n#define PT_MAX_PUT_REG\tPT_MQ\n\nstatic int gpr32_set(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf)\n{\n\tunsigned long *regs = &target->thread.regs->gpr[0];\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}"
  },
  {
    "function_name": "gpr32_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "676-731",
    "snippet": "static int gpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     void *kbuf, void __user *ubuf)\n{\n\tconst unsigned long *regs = &target->thread.regs->gpr[0];\n\tcompat_ulong_t *k = kbuf;\n\tcompat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\tint i;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/* We have a partial register set.  Fill 14-31 with bogus values */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON; \n\t}\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\t*k++ = regs[pos++];\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tif (__put_user((compat_ulong_t) regs[pos++], u++))\n\t\t\t\treturn -EFAULT;\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\treg = get_user_msr(target);\n\t\tif (kbuf)\n\t\t\t*k++ = reg;\n\t\telse if (__put_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_REGS_COUNT; --count)\n\t\t\t*k++ = regs[pos++];\n\telse\n\t\tfor (; count > 0 && pos < PT_REGS_COUNT; --count)\n\t\t\tif (__put_user((compat_ulong_t) regs[pos++], u++))\n\t\t\t\treturn -EFAULT;\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\tPT_REGS_COUNT * sizeof(reg), -1);\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyout_zero",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "PT_REGS_COUNT * sizeof(reg)",
            "-1"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(compat_ulong_t) regs[pos++]",
            "u++"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "reg",
            "u++"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_msr",
          "args": [
            "target"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "171-174",
          "snippet": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(compat_ulong_t) regs[pos++]",
            "u++"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "target->thread.regs"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int gpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     void *kbuf, void __user *ubuf)\n{\n\tconst unsigned long *regs = &target->thread.regs->gpr[0];\n\tcompat_ulong_t *k = kbuf;\n\tcompat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\tint i;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/* We have a partial register set.  Fill 14-31 with bogus values */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON; \n\t}\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\t*k++ = regs[pos++];\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tif (__put_user((compat_ulong_t) regs[pos++], u++))\n\t\t\t\treturn -EFAULT;\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\treg = get_user_msr(target);\n\t\tif (kbuf)\n\t\t\t*k++ = reg;\n\t\telse if (__put_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_REGS_COUNT; --count)\n\t\t\t*k++ = regs[pos++];\n\telse\n\t\tfor (; count > 0 && pos < PT_REGS_COUNT; --count)\n\t\t\tif (__put_user((compat_ulong_t) regs[pos++], u++))\n\t\t\t\treturn -EFAULT;\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\tPT_REGS_COUNT * sizeof(reg), -1);\n}"
  },
  {
    "function_name": "evr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "592-613",
    "snippet": "static int evr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_spe_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.evr,\n\t\t\t\t 0, sizeof(target->thread.evr));\n\n\tBUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.acc,\n\t\t\t\t\t sizeof(target->thread.evr), -1);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.acc",
            "sizeof(target->thread.evr)",
            "-1"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr)"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.evr",
            "0",
            "sizeof(target->thread.evr)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "target"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "263-276",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int evr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_spe_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.evr,\n\t\t\t\t 0, sizeof(target->thread.evr));\n\n\tBUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.acc,\n\t\t\t\t\t sizeof(target->thread.evr), -1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "evr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "569-590",
    "snippet": "static int evr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tflush_spe_to_thread(target);\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.evr,\n\t\t\t\t  0, sizeof(target->thread.evr));\n\n\tBUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.acc,\n\t\t\t\t\t  sizeof(target->thread.evr), -1);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.acc",
            "sizeof(target->thread.evr)",
            "-1"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.evr",
            "0",
            "sizeof(target->thread.evr)"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "target"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "263-276",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int evr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tflush_spe_to_thread(target);\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.evr,\n\t\t\t\t  0, sizeof(target->thread.evr));\n\n\tBUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.acc,\n\t\t\t\t\t  sizeof(target->thread.evr), -1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "evr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "562-567",
    "snippet": "static int evr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_spe_to_thread(target);\n\treturn target->thread.used_spe ? regset->n : 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "target"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "263-276",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int evr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_spe_to_thread(target);\n\treturn target->thread.used_spe ? regset->n : 0;\n}"
  },
  {
    "function_name": "vsr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "531-547",
    "snippet": "static int vsr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret,i;\n\n\tflush_vsx_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "buf",
            "0",
            "32 * sizeof(double)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "230-242",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int vsr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret,i;\n\n\tflush_vsx_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vsr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "514-529",
    "snippet": "static int vsr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  buf, 0, 32 * sizeof(double));\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "buf",
            "0",
            "32 * sizeof(double)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "230-242",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int vsr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  buf, 0, 32 * sizeof(double));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vsr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "507-512",
    "snippet": "static int vsr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "target"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "230-242",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int vsr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}"
  },
  {
    "function_name": "vr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "466-497",
    "snippet": "static int vr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.vr_state, 0,\n\t\t\t\t 33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the first word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.vrsave;\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t 33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.vrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&vrsave",
            "33 * sizeof(vector128)",
            "-1"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vrsave",
            "0",
            "sizeof(vrsave)"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.vr_state",
            "0",
            "33 * sizeof(vector128)"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int vr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.vr_state, 0,\n\t\t\t\t 33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the first word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.vrsave;\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t 33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.vrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "435-464",
    "snippet": "static int vr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.vr_state, 0,\n\t\t\t\t  33 * sizeof(vector128));\n\tif (!ret) {\n\t\t/*\n\t\t * Copy out only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.vrsave;\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t  33 * sizeof(vector128), -1);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&vrsave",
            "33 * sizeof(vector128)",
            "-1"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vrsave",
            "0",
            "sizeof(vrsave)"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.vr_state",
            "0",
            "33 * sizeof(vector128)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int vr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.vr_state, 0,\n\t\t\t\t  33 * sizeof(vector128));\n\tif (!ret) {\n\t\t/*\n\t\t * Copy out only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.vrsave;\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t  33 * sizeof(vector128), -1);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vr_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "428-433",
    "snippet": "static int vr_active(struct task_struct *target,\n\t\t     const struct user_regset *regset)\n{\n\tflush_altivec_to_thread(target);\n\treturn target->thread.used_vr ? regset->n : 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "target"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int vr_active(struct task_struct *target,\n\t\t     const struct user_regset *regset)\n{\n\tflush_altivec_to_thread(target);\n\treturn target->thread.used_vr ? regset->n : 0;\n}"
  },
  {
    "function_name": "fpr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "386-412",
    "snippet": "static int fpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tu64 buf[33];\n\tint i;\n#endif\n\tflush_fp_to_thread(target);\n\n#ifdef CONFIG_VSX\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_FPR(i) = buf[i];\n\ttarget->thread.fp_state.fpscr = buf[32];\n\treturn 0;\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32][0]));\n\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.fp_state, 0, -1);\n#endif\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.fp_state",
            "0",
            "-1"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32][0]"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "buf",
            "0",
            "-1"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int fpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tu64 buf[33];\n\tint i;\n#endif\n\tflush_fp_to_thread(target);\n\n#ifdef CONFIG_VSX\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_FPR(i) = buf[i];\n\ttarget->thread.fp_state.fpscr = buf[32];\n\treturn 0;\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32][0]));\n\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.fp_state, 0, -1);\n#endif\n}"
  },
  {
    "function_name": "fpr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "360-384",
    "snippet": "static int fpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tu64 buf[33];\n\tint i;\n#endif\n\tflush_fp_to_thread(target);\n\n#ifdef CONFIG_VSX\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32][0]));\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.fp_state, 0, -1);\n#endif\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.fp_state",
            "0",
            "-1"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32][0]"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "buf",
            "0",
            "-1"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "target->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "target"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int fpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tu64 buf[33];\n\tint i;\n#endif\n\tflush_fp_to_thread(target);\n\n#ifdef CONFIG_VSX\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32][0]));\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.fp_state, 0, -1);\n#endif\n}"
  },
  {
    "function_name": "gpr_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "305-358",
    "snippet": "static int gpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t target->thread.regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.regs->orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PT_MAX_PUT_REG\tPT_CCR",
      "#define PT_MAX_PUT_REG\tPT_MQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyin_ignore",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "(PT_TRAP + 1) * sizeof(reg)",
            "-1"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_trap",
          "args": [
            "target",
            "reg"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "212-216",
          "snippet": "static int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&reg",
            "PT_TRAP * sizeof(reg)",
            "(PT_TRAP + 1) * sizeof(reg)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin_ignore",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "(PT_MAX_PUT_REG + 1) * sizeof(reg)",
            "PT_TRAP * sizeof(reg)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.regs->orig_gpr3",
            "PT_ORIG_R3 * sizeof(reg)",
            "(PT_MAX_PUT_REG + 1) * sizeof(reg)"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_user_msr",
          "args": [
            "target",
            "reg"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "176-181",
          "snippet": "static int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)",
            "#define MSR_DEBUGCHANGE\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)\n#define MSR_DEBUGCHANGE\t0\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&reg",
            "PT_MSR * sizeof(reg)",
            "(PT_MSR + 1) * sizeof(reg)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyin",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "target->thread.regs",
            "0",
            "PT_MSR * sizeof(reg)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "target->thread.regs"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define PT_MAX_PUT_REG\tPT_CCR\n#define PT_MAX_PUT_REG\tPT_MQ\n\nstatic int gpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t target->thread.regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.regs->orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "gpr_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "264-303",
    "snippet": "static int gpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tint i, ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/* We have a partial register set.  Fill 14-31 with bogus values */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  target->thread.regs,\n\t\t\t\t  0, offsetof(struct pt_regs, msr));\n\tif (!ret) {\n\t\tunsigned long msr = get_user_msr(target);\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,\n\t\t\t\t\t  offsetof(struct pt_regs, msr),\n\t\t\t\t\t  offsetof(struct pt_regs, msr) +\n\t\t\t\t\t  sizeof(msr));\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.regs->orig_gpr3,\n\t\t\t\t\t  offsetof(struct pt_regs, orig_gpr3),\n\t\t\t\t\t  sizeof(struct pt_regs));\n\tif (!ret)\n\t\tret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t       sizeof(struct pt_regs), -1);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_regset_copyout_zero",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "sizeof(struct pt_regs)",
            "-1"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&target->thread.regs->orig_gpr3",
            "offsetof(struct pt_regs, orig_gpr3)",
            "sizeof(struct pt_regs)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long)"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "&msr",
            "offsetof(struct pt_regs, msr)",
            "offsetof(struct pt_regs, msr) +\n\t\t\t\t\t  sizeof(msr)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_msr",
          "args": [
            "target"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "171-174",
          "snippet": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_regset_copyout",
          "args": [
            "&pos",
            "&count",
            "&kbuf",
            "&ubuf",
            "target->thread.regs",
            "0",
            "offsetof(struct pt_regs, msr)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "target->thread.regs"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int gpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tint i, ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/* We have a partial register set.  Fill 14-31 with bogus values */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  target->thread.regs,\n\t\t\t\t  0, offsetof(struct pt_regs, msr));\n\tif (!ret) {\n\t\tunsigned long msr = get_user_msr(target);\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,\n\t\t\t\t\t  offsetof(struct pt_regs, msr),\n\t\t\t\t\t  offsetof(struct pt_regs, msr) +\n\t\t\t\t\t  sizeof(msr));\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.regs->orig_gpr3,\n\t\t\t\t\t  offsetof(struct pt_regs, orig_gpr3),\n\t\t\t\t\t  sizeof(struct pt_regs));\n\tif (!ret)\n\t\tret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t       sizeof(struct pt_regs), -1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ptrace_put_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "245-262",
    "snippet": "int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PT_MAX_PUT_REG\tPT_CCR",
      "#define PT_MAX_PUT_REG\tPT_MQ"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_user_dscr",
          "args": [
            "task",
            "data"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "202-205",
          "snippet": "static int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_trap",
          "args": [
            "task",
            "data"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "212-216",
          "snippet": "static int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_user_msr",
          "args": [
            "task",
            "data"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "set_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "176-181",
          "snippet": "static int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)",
            "#define MSR_DEBUGCHANGE\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)\n#define MSR_DEBUGCHANGE\t0\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define PT_MAX_PUT_REG\tPT_CCR\n#define PT_MAX_PUT_REG\tPT_MQ\n\nint ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
  },
  {
    "function_name": "ptrace_get_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "221-240",
    "snippet": "int ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user_dscr",
          "args": [
            "task",
            "data"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "197-200",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_msr",
          "args": [
            "task"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_msr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "171-174",
          "snippet": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
  },
  {
    "function_name": "set_user_trap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "212-216",
    "snippet": "static int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}"
  },
  {
    "function_name": "set_user_dscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "202-205",
    "snippet": "static int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}"
  },
  {
    "function_name": "get_user_dscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "197-200",
    "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
  },
  {
    "function_name": "set_user_dscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "190-195",
    "snippet": "static int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\ttask->thread.dscr = dscr;\n\ttask->thread.dscr_inherit = 1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\ttask->thread.dscr = dscr;\n\ttask->thread.dscr_inherit = 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_user_dscr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "184-188",
    "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\t*data = task->thread.dscr;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\t*data = task->thread.dscr;\n\treturn 0;\n}"
  },
  {
    "function_name": "set_user_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "176-181",
    "snippet": "static int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)",
      "#define MSR_DEBUGCHANGE\t0"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)\n#define MSR_DEBUGCHANGE\t0\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_user_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "171-174",
    "snippet": "static unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}"
  },
  {
    "function_name": "regs_query_register_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "139-146",
    "snippet": "const char *regs_query_register_name(unsigned int offset)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (roff->offset == offset)\n\t\t\treturn roff->name;\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};\n\nconst char *regs_query_register_name(unsigned int offset)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (roff->offset == offset)\n\t\t\treturn roff->name;\n\treturn NULL;\n}"
  },
  {
    "function_name": "regs_query_register_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
    "lines": "123-130",
    "snippet": "int regs_query_register_offset(const char *name)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (!strcmp(roff->name, name))\n\t\t\treturn roff->offset;\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/compat.h>",
      "#include <trace/events/syscalls.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/context_tracking.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <trace/syscall.h>",
      "#include <linux/audit.h>",
      "#include <linux/seccomp.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/elf.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "roff->name",
            "name"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};\n\nint regs_query_register_offset(const char *name)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (!strcmp(roff->name, name))\n\t\t\treturn roff->offset;\n\treturn -EINVAL;\n}"
  }
]