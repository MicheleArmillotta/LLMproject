[
  {
    "function_name": "default_machine_crash_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "302-367",
    "snippet": "void default_machine_crash_shutdown(struct pt_regs *regs)\n{\n\tunsigned int i;\n\tint (*old_handler)(struct pt_regs *regs);\n\n\t/*\n\t * This function is only called after the system\n\t * has panicked or is otherwise in a critical state.\n\t * The minimum amount of code to allow a kexec'd kernel\n\t * to run successfully needs to happen here.\n\t *\n\t * In practice this means stopping other cpus in\n\t * an SMP system.\n\t * The kernel is broken so disable interrupts.\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * Make a note of crashing cpu. Will be used in machine_kexec\n\t * such that another IPI will not be sent.\n\t */\n\tcrashing_cpu = smp_processor_id();\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(regs) == 0x100)\n\t\tmdelay(PRIMARY_TIMEOUT);\n\n\tcrash_kexec_prepare_cpus(crashing_cpu);\n\n\tcrash_save_cpu(regs, crashing_cpu);\n\n\ttime_to_dump = 1;\n\n\tcrash_kexec_wait_realmode(crashing_cpu);\n\n\tmachine_kexec_mask_interrupts();\n\n\t/*\n\t * Call registered shutdown routines safely.  Swap out\n\t * __debugger_fault_handler, and replace on exit.\n\t */\n\told_handler = __debugger_fault_handler;\n\t__debugger_fault_handler = handle_fault;\n\tcrash_shutdown_cpu = smp_processor_id();\n\tfor (i = 0; crash_shutdown_handles[i]; i++) {\n\t\tif (setjmp(crash_shutdown_buf) == 0) {\n\t\t\t/*\n\t\t\t * Insert syncs and delay to ensure\n\t\t\t * instructions in the dangerous region don't\n\t\t\t * leak away from this protected region.\n\t\t\t */\n\t\t\tasm volatile(\"sync; isync\");\n\t\t\t/* dangerous region */\n\t\t\tcrash_shutdown_handles[i]();\n\t\t\tasm volatile(\"sync; isync\");\n\t\t}\n\t}\n\tcrash_shutdown_cpu = -1;\n\t__debugger_fault_handler = old_handler;\n\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(1, 0);\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define PRIMARY_TIMEOUT\t\t500"
    ],
    "globals_used": [
      "int crashing_cpu = -1;",
      "static int time_to_dump;",
      "static crash_shutdown_t crash_shutdown_handles[CRASH_HANDLER_MAX+1];",
      "static unsigned long crash_shutdown_buf[JMP_BUF_LEN];",
      "static int crash_shutdown_cpu = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.kexec_cpu_down",
          "args": [
            "1",
            "0"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_shutdown_handles[i]",
          "args": [],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setjmp",
          "args": [
            "crash_shutdown_buf"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_kexec_mask_interrupts",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "machine_kexec_mask_interrupts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "25-45",
          "snippet": "void machine_kexec_mask_interrupts(void) {\n\tunsigned int i;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\tstruct irq_chip *chip;\n\n\t\tchip = irq_desc_get_chip(desc);\n\t\tif (!chip)\n\t\t\tcontinue;\n\n\t\tif (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))\n\t\t\tchip->irq_eoi(&desc->irq_data);\n\n\t\tif (chip->irq_mask)\n\t\t\tchip->irq_mask(&desc->irq_data);\n\n\t\tif (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))\n\t\t\tchip->irq_disable(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/irq.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/threads.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid machine_kexec_mask_interrupts(void) {\n\tunsigned int i;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\tstruct irq_chip *chip;\n\n\t\tchip = irq_desc_get_chip(desc);\n\t\tif (!chip)\n\t\t\tcontinue;\n\n\t\tif (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))\n\t\t\tchip->irq_eoi(&desc->irq_data);\n\n\t\tif (chip->irq_mask)\n\t\t\tchip->irq_mask(&desc->irq_data);\n\n\t\tif (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))\n\t\t\tchip->irq_disable(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "crash_kexec_wait_realmode",
          "args": [
            "crashing_cpu"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "crash_kexec_wait_realmode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
          "lines": "246-246",
          "snippet": "static inline void crash_kexec_wait_realmode(int cpu) {}",
          "includes": [
            "#include <asm/debug.h>",
            "#include <asm/setjmp.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/kexec.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <linux/types.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/export.h>",
            "#include <linux/kexec.h>",
            "#include <linux/reboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nstatic inline void crash_kexec_wait_realmode(int cpu) {}"
        }
      },
      {
        "call_info": {
          "callee": "crash_save_cpu",
          "args": [
            "regs",
            "crashing_cpu"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_kexec_prepare_cpus",
          "args": [
            "crashing_cpu"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "crash_kexec_prepare_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
          "lines": "203-216",
          "snippet": "static void crash_kexec_prepare_cpus(int cpu)\n{\n\t/*\n\t * move the secondaries to us so that we can copy\n\t * the new kernel 0-0x100 safely\n\t *\n\t * do this if kexec in setup.c ?\n\t */\n#ifdef CONFIG_PPC64\n\tsmp_release_cpus();\n#else\n\t/* FIXME */\n#endif\n}",
          "includes": [
            "#include <asm/debug.h>",
            "#include <asm/setjmp.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/kexec.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <linux/types.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/export.h>",
            "#include <linux/kexec.h>",
            "#include <linux/reboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nstatic void crash_kexec_prepare_cpus(int cpu)\n{\n\t/*\n\t * move the secondaries to us so that we can copy\n\t * the new kernel 0-0x100 safely\n\t *\n\t * do this if kexec in setup.c ?\n\t */\n#ifdef CONFIG_PPC64\n\tsmp_release_cpus();\n#else\n\t/* FIXME */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "PRIMARY_TIMEOUT"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\n#define PRIMARY_TIMEOUT\t\t500\n\nint crashing_cpu = -1;\nstatic int time_to_dump;\nstatic crash_shutdown_t crash_shutdown_handles[CRASH_HANDLER_MAX+1];\nstatic unsigned long crash_shutdown_buf[JMP_BUF_LEN];\nstatic int crash_shutdown_cpu = -1;\n\nvoid default_machine_crash_shutdown(struct pt_regs *regs)\n{\n\tunsigned int i;\n\tint (*old_handler)(struct pt_regs *regs);\n\n\t/*\n\t * This function is only called after the system\n\t * has panicked or is otherwise in a critical state.\n\t * The minimum amount of code to allow a kexec'd kernel\n\t * to run successfully needs to happen here.\n\t *\n\t * In practice this means stopping other cpus in\n\t * an SMP system.\n\t * The kernel is broken so disable interrupts.\n\t */\n\thard_irq_disable();\n\n\t/*\n\t * Make a note of crashing cpu. Will be used in machine_kexec\n\t * such that another IPI will not be sent.\n\t */\n\tcrashing_cpu = smp_processor_id();\n\n\t/*\n\t * If we came in via system reset, wait a while for the secondary\n\t * CPUs to enter.\n\t */\n\tif (TRAP(regs) == 0x100)\n\t\tmdelay(PRIMARY_TIMEOUT);\n\n\tcrash_kexec_prepare_cpus(crashing_cpu);\n\n\tcrash_save_cpu(regs, crashing_cpu);\n\n\ttime_to_dump = 1;\n\n\tcrash_kexec_wait_realmode(crashing_cpu);\n\n\tmachine_kexec_mask_interrupts();\n\n\t/*\n\t * Call registered shutdown routines safely.  Swap out\n\t * __debugger_fault_handler, and replace on exit.\n\t */\n\told_handler = __debugger_fault_handler;\n\t__debugger_fault_handler = handle_fault;\n\tcrash_shutdown_cpu = smp_processor_id();\n\tfor (i = 0; crash_shutdown_handles[i]; i++) {\n\t\tif (setjmp(crash_shutdown_buf) == 0) {\n\t\t\t/*\n\t\t\t * Insert syncs and delay to ensure\n\t\t\t * instructions in the dangerous region don't\n\t\t\t * leak away from this protected region.\n\t\t\t */\n\t\t\tasm volatile(\"sync; isync\");\n\t\t\t/* dangerous region */\n\t\t\tcrash_shutdown_handles[i]();\n\t\t\tasm volatile(\"sync; isync\");\n\t\t}\n\t}\n\tcrash_shutdown_cpu = -1;\n\t__debugger_fault_handler = old_handler;\n\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(1, 0);\n}"
  },
  {
    "function_name": "crash_shutdown_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "277-299",
    "snippet": "int crash_shutdown_unregister(crash_shutdown_t handler)\n{\n\tunsigned int i, rc;\n\n\tspin_lock(&crash_handlers_lock);\n\tfor (i = 0 ; i < CRASH_HANDLER_MAX; i++)\n\t\tif (crash_shutdown_handles[i] == handler)\n\t\t\tbreak;\n\n\tif (i == CRASH_HANDLER_MAX) {\n\t\tprintk(KERN_ERR \"Crash shutdown handle not found\\n\");\n\t\trc = 1;\n\t} else {\n\t\t/* Shift handles down */\n\t\tfor (; crash_shutdown_handles[i]; i++)\n\t\t\tcrash_shutdown_handles[i] =\n\t\t\t\tcrash_shutdown_handles[i+1];\n\t\trc = 0;\n\t}\n\n\tspin_unlock(&crash_handlers_lock);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define CRASH_HANDLER_MAX 3"
    ],
    "globals_used": [
      "static crash_shutdown_t crash_shutdown_handles[CRASH_HANDLER_MAX+1];",
      "static DEFINE_SPINLOCK(crash_handlers_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&crash_handlers_lock"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Crash shutdown handle not found\\n\""
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&crash_handlers_lock"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\n#define CRASH_HANDLER_MAX 3\n\nstatic crash_shutdown_t crash_shutdown_handles[CRASH_HANDLER_MAX+1];\nstatic DEFINE_SPINLOCK(crash_handlers_lock);\n\nint crash_shutdown_unregister(crash_shutdown_t handler)\n{\n\tunsigned int i, rc;\n\n\tspin_lock(&crash_handlers_lock);\n\tfor (i = 0 ; i < CRASH_HANDLER_MAX; i++)\n\t\tif (crash_shutdown_handles[i] == handler)\n\t\t\tbreak;\n\n\tif (i == CRASH_HANDLER_MAX) {\n\t\tprintk(KERN_ERR \"Crash shutdown handle not found\\n\");\n\t\trc = 1;\n\t} else {\n\t\t/* Shift handles down */\n\t\tfor (; crash_shutdown_handles[i]; i++)\n\t\t\tcrash_shutdown_handles[i] =\n\t\t\t\tcrash_shutdown_handles[i+1];\n\t\trc = 0;\n\t}\n\n\tspin_unlock(&crash_handlers_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "crash_shutdown_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "253-274",
    "snippet": "int crash_shutdown_register(crash_shutdown_t handler)\n{\n\tunsigned int i, rc;\n\n\tspin_lock(&crash_handlers_lock);\n\tfor (i = 0 ; i < CRASH_HANDLER_MAX; i++)\n\t\tif (!crash_shutdown_handles[i]) {\n\t\t\t/* Insert handle at first empty entry */\n\t\t\tcrash_shutdown_handles[i] = handler;\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\tif (i == CRASH_HANDLER_MAX) {\n\t\tprintk(KERN_ERR \"Crash shutdown handles full, \"\n\t\t       \"not registered.\\n\");\n\t\trc = 1;\n\t}\n\n\tspin_unlock(&crash_handlers_lock);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define CRASH_HANDLER_MAX 3"
    ],
    "globals_used": [
      "static crash_shutdown_t crash_shutdown_handles[CRASH_HANDLER_MAX+1];",
      "static DEFINE_SPINLOCK(crash_handlers_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&crash_handlers_lock"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Crash shutdown handles full, \"\n\t\t       \"not registered.\\n\""
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&crash_handlers_lock"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\n#define CRASH_HANDLER_MAX 3\n\nstatic crash_shutdown_t crash_shutdown_handles[CRASH_HANDLER_MAX+1];\nstatic DEFINE_SPINLOCK(crash_handlers_lock);\n\nint crash_shutdown_register(crash_shutdown_t handler)\n{\n\tunsigned int i, rc;\n\n\tspin_lock(&crash_handlers_lock);\n\tfor (i = 0 ; i < CRASH_HANDLER_MAX; i++)\n\t\tif (!crash_shutdown_handles[i]) {\n\t\t\t/* Insert handle at first empty entry */\n\t\t\tcrash_shutdown_handles[i] = handler;\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\tif (i == CRASH_HANDLER_MAX) {\n\t\tprintk(KERN_ERR \"Crash shutdown handles full, \"\n\t\t       \"not registered.\\n\");\n\t\trc = 1;\n\t}\n\n\tspin_unlock(&crash_handlers_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "crash_kexec_wait_realmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "246-246",
    "snippet": "static inline void crash_kexec_wait_realmode(int cpu) {}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nstatic inline void crash_kexec_wait_realmode(int cpu) {}"
  },
  {
    "function_name": "crash_kexec_wait_realmode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "225-244",
    "snippet": "static void __maybe_unused crash_kexec_wait_realmode(int cpu)\n{\n\tunsigned int msecs;\n\tint i;\n\n\tmsecs = REAL_MODE_TIMEOUT;\n\tfor (i=0; i < nr_cpu_ids && msecs > 0; i++) {\n\t\tif (i == cpu)\n\t\t\tcontinue;\n\n\t\twhile (paca[i].kexec_state < KEXEC_STATE_REAL_MODE) {\n\t\t\tbarrier();\n\t\t\tif (!cpu_possible(i) || !cpu_online(i) || (msecs <= 0))\n\t\t\t\tbreak;\n\t\t\tmsecs--;\n\t\t\tmdelay(1);\n\t\t}\n\t}\n\tmb();\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define REAL_MODE_TIMEOUT\t10000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mb",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "i"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/sysfs.c",
          "lines": "788-866",
          "snippet": "static void unregister_cpu_online(unsigned int cpu)\n{\n\tstruct cpu *c = &per_cpu(cpu_devices, cpu);\n\tstruct device *s = &c->dev;\n\tstruct device_attribute *attrs, *pmc_attrs;\n\tint i, nattrs;\n\n\tBUG_ON(!c->hotpluggable);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_SMT))\n\t\tdevice_remove_file(s, &dev_attr_smt_snooze_delay);\n#endif\n\n\t/* PMC stuff */\n\tswitch (cur_cpu_spec->pmc_type) {\n#ifdef HAS_PPC_PMC_IBM\n\tcase PPC_PMC_IBM:\n\t\tattrs = ibm_common_attrs;\n\t\tnattrs = sizeof(ibm_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_IBM */\n#ifdef HAS_PPC_PMC_G4\n\tcase PPC_PMC_G4:\n\t\tattrs = g4_common_attrs;\n\t\tnattrs = sizeof(g4_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_G4 */\n#ifdef HAS_PPC_PMC_PA6T\n\tcase PPC_PMC_PA6T:\n\t\t/* PA Semi starts counting at PMC0 */\n\t\tattrs = pa6t_attrs;\n\t\tnattrs = sizeof(pa6t_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = NULL;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_PA6T */\n\tdefault:\n\t\tattrs = NULL;\n\t\tnattrs = 0;\n\t\tpmc_attrs = NULL;\n\t}\n\n\tfor (i = 0; i < nattrs; i++)\n\t\tdevice_remove_file(s, &attrs[i]);\n\n\tif (pmc_attrs)\n\t\tfor (i = 0; i < cur_cpu_spec->num_pmcs; i++)\n\t\t\tdevice_remove_file(s, &pmc_attrs[i]);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_MMCRA))\n\t\tdevice_remove_file(s, &dev_attr_mmcra);\n\n\tif (cpu_has_feature(CPU_FTR_PURR))\n\t\tdevice_remove_file(s, &dev_attr_purr);\n\n\tif (cpu_has_feature(CPU_FTR_SPURR))\n\t\tdevice_remove_file(s, &dev_attr_spurr);\n\n\tif (cpu_has_feature(CPU_FTR_DSCR))\n\t\tdevice_remove_file(s, &dev_attr_dscr);\n\n\tif (cpu_has_feature(CPU_FTR_PPCAS_ARCH_V2))\n\t\tdevice_remove_file(s, &dev_attr_pir);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_FSL_BOOK3E\n\tif (PVR_VER(cur_cpu_spec->pvr_value) == PVR_VER_E6500) {\n\t\tdevice_remove_file(s, &dev_attr_pw20_state);\n\t\tdevice_remove_file(s, &dev_attr_pw20_wait_time);\n\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle);\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle_wait_time);\n\t}\n#endif\n\tcacheinfo_cpu_offline(cpu);\n}",
          "includes": [
            "#include <asm/lppaca.h>",
            "#include <asm/paca.h>",
            "#include \"cacheinfo.h\"",
            "#include <asm/firmware.h>",
            "#include <asm/pmc.h>",
            "#include <asm/smp.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/cputable.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define HAS_PPC_PMC_G4\t\t1",
            "#define HAS_PPC_PMC_IBM\t\t1",
            "#define HAS_PPC_PMC_PA6T\t1",
            "#define HAS_PPC_PMC_IBM\t\t1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu, cpu_devices);",
            "static DEVICE_ATTR(physical_id, 0444, show_physical_id, NULL);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/lppaca.h>\n#include <asm/paca.h>\n#include \"cacheinfo.h\"\n#include <asm/firmware.h>\n#include <asm/pmc.h>\n#include <asm/smp.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/hvcall.h>\n#include <asm/cputable.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/notifier.h>\n#include <linux/cpumask.h>\n#include <linux/nodemask.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n\n#define HAS_PPC_PMC_G4\t\t1\n#define HAS_PPC_PMC_IBM\t\t1\n#define HAS_PPC_PMC_PA6T\t1\n#define HAS_PPC_PMC_IBM\t\t1\n\nstatic DEFINE_PER_CPU(struct cpu, cpu_devices);\nstatic DEVICE_ATTR(physical_id, 0444, show_physical_id, NULL);\n\nstatic void unregister_cpu_online(unsigned int cpu)\n{\n\tstruct cpu *c = &per_cpu(cpu_devices, cpu);\n\tstruct device *s = &c->dev;\n\tstruct device_attribute *attrs, *pmc_attrs;\n\tint i, nattrs;\n\n\tBUG_ON(!c->hotpluggable);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_SMT))\n\t\tdevice_remove_file(s, &dev_attr_smt_snooze_delay);\n#endif\n\n\t/* PMC stuff */\n\tswitch (cur_cpu_spec->pmc_type) {\n#ifdef HAS_PPC_PMC_IBM\n\tcase PPC_PMC_IBM:\n\t\tattrs = ibm_common_attrs;\n\t\tnattrs = sizeof(ibm_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_IBM */\n#ifdef HAS_PPC_PMC_G4\n\tcase PPC_PMC_G4:\n\t\tattrs = g4_common_attrs;\n\t\tnattrs = sizeof(g4_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_G4 */\n#ifdef HAS_PPC_PMC_PA6T\n\tcase PPC_PMC_PA6T:\n\t\t/* PA Semi starts counting at PMC0 */\n\t\tattrs = pa6t_attrs;\n\t\tnattrs = sizeof(pa6t_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = NULL;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_PA6T */\n\tdefault:\n\t\tattrs = NULL;\n\t\tnattrs = 0;\n\t\tpmc_attrs = NULL;\n\t}\n\n\tfor (i = 0; i < nattrs; i++)\n\t\tdevice_remove_file(s, &attrs[i]);\n\n\tif (pmc_attrs)\n\t\tfor (i = 0; i < cur_cpu_spec->num_pmcs; i++)\n\t\t\tdevice_remove_file(s, &pmc_attrs[i]);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_MMCRA))\n\t\tdevice_remove_file(s, &dev_attr_mmcra);\n\n\tif (cpu_has_feature(CPU_FTR_PURR))\n\t\tdevice_remove_file(s, &dev_attr_purr);\n\n\tif (cpu_has_feature(CPU_FTR_SPURR))\n\t\tdevice_remove_file(s, &dev_attr_spurr);\n\n\tif (cpu_has_feature(CPU_FTR_DSCR))\n\t\tdevice_remove_file(s, &dev_attr_dscr);\n\n\tif (cpu_has_feature(CPU_FTR_PPCAS_ARCH_V2))\n\t\tdevice_remove_file(s, &dev_attr_pir);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_FSL_BOOK3E\n\tif (PVR_VER(cur_cpu_spec->pvr_value) == PVR_VER_E6500) {\n\t\tdevice_remove_file(s, &dev_attr_pw20_state);\n\t\tdevice_remove_file(s, &dev_attr_pw20_wait_time);\n\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle);\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle_wait_time);\n\t}\n#endif\n\tcacheinfo_cpu_offline(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_possible",
          "args": [
            "i"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\n#define REAL_MODE_TIMEOUT\t10000\n\nstatic void __maybe_unused crash_kexec_wait_realmode(int cpu)\n{\n\tunsigned int msecs;\n\tint i;\n\n\tmsecs = REAL_MODE_TIMEOUT;\n\tfor (i=0; i < nr_cpu_ids && msecs > 0; i++) {\n\t\tif (i == cpu)\n\t\t\tcontinue;\n\n\t\twhile (paca[i].kexec_state < KEXEC_STATE_REAL_MODE) {\n\t\t\tbarrier();\n\t\t\tif (!cpu_possible(i) || !cpu_online(i) || (msecs <= 0))\n\t\t\t\tbreak;\n\t\t\tmsecs--;\n\t\t\tmdelay(1);\n\t\t}\n\t}\n\tmb();\n}"
  },
  {
    "function_name": "crash_kexec_secondary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "218-220",
    "snippet": "void crash_kexec_secondary(struct pt_regs *regs)\n{\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nvoid crash_kexec_secondary(struct pt_regs *regs)\n{\n}"
  },
  {
    "function_name": "crash_kexec_prepare_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "203-216",
    "snippet": "static void crash_kexec_prepare_cpus(int cpu)\n{\n\t/*\n\t * move the secondaries to us so that we can copy\n\t * the new kernel 0-0x100 safely\n\t *\n\t * do this if kexec in setup.c ?\n\t */\n#ifdef CONFIG_PPC64\n\tsmp_release_cpus();\n#else\n\t/* FIXME */\n#endif\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_release_cpus",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "smp_release_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/setup_64.c",
          "lines": "355-386",
          "snippet": "void smp_release_cpus(void)\n{\n\tunsigned long *ptr;\n\tint i;\n\n\tif (!use_spinloop())\n\t\treturn;\n\n\tDBG(\" -> smp_release_cpus()\\n\");\n\n\t/* All secondary cpus are spinning on a common spinloop, release them\n\t * all now so they can start to spin on their individual paca\n\t * spinloops. For non SMP kernels, the secondary cpus never get out\n\t * of the common spinloop.\n\t */\n\n\tptr  = (unsigned long *)((unsigned long)&__secondary_hold_spinloop\n\t\t\t- PHYSICAL_START);\n\t*ptr = ppc_function_entry(generic_secondary_smp_init);\n\n\t/* And wait a bit for them to catch up */\n\tfor (i = 0; i < 100000; i++) {\n\t\tmb();\n\t\tHMT_low();\n\t\tif (spinning_secondaries == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tDBG(\"spinning_secondaries = %d\\n\", spinning_secondaries);\n\n\tDBG(\" <- smp_release_cpus()\\n\");\n}",
          "includes": [
            "#include <asm/epapr_hcalls.h>",
            "#include <asm/hugetlb.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/kexec.h>",
            "#include <asm/udbg.h>",
            "#include <asm/xmon.h>",
            "#include <asm/firmware.h>",
            "#include <asm/mmu.h>",
            "#include <asm/page.h>",
            "#include <asm/cache.h>",
            "#include <asm/serial.h>",
            "#include <asm/iommu.h>",
            "#include <asm/rtas.h>",
            "#include <asm/setup.h>",
            "#include <asm/nvram.h>",
            "#include <asm/btext.h>",
            "#include <asm/sections.h>",
            "#include <asm/cputable.h>",
            "#include <asm/time.h>",
            "#include <asm/paca.h>",
            "#include <asm/machdep.h>",
            "#include <asm/elf.h>",
            "#include <asm/smp.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/processor.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memory.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/memblock.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/pci.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/serial_8250.h>",
            "#include <linux/serial.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/root_dev.h>",
            "#include <linux/tty.h>",
            "#include <linux/utsname.h>",
            "#include <linux/console.h>",
            "#include <linux/ioport.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int spinning_secondaries;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/epapr_hcalls.h>\n#include <asm/hugetlb.h>\n#include <asm/kvm_ppc.h>\n#include <asm/code-patching.h>\n#include <asm/mmu_context.h>\n#include <asm/kexec.h>\n#include <asm/udbg.h>\n#include <asm/xmon.h>\n#include <asm/firmware.h>\n#include <asm/mmu.h>\n#include <asm/page.h>\n#include <asm/cache.h>\n#include <asm/serial.h>\n#include <asm/iommu.h>\n#include <asm/rtas.h>\n#include <asm/setup.h>\n#include <asm/nvram.h>\n#include <asm/btext.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/paca.h>\n#include <asm/machdep.h>\n#include <asm/elf.h>\n#include <asm/smp.h>\n#include <asm/pgtable.h>\n#include <asm/processor.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <linux/nmi.h>\n#include <linux/memory.h>\n#include <linux/hugetlb.h>\n#include <linux/memblock.h>\n#include <linux/lockdep.h>\n#include <linux/pci.h>\n#include <linux/bootmem.h>\n#include <linux/serial_8250.h>\n#include <linux/serial.h>\n#include <linux/unistd.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/root_dev.h>\n#include <linux/tty.h>\n#include <linux/utsname.h>\n#include <linux/console.h>\n#include <linux/ioport.h>\n#include <linux/seq_file.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/export.h>\n\nint spinning_secondaries;\n\nvoid smp_release_cpus(void)\n{\n\tunsigned long *ptr;\n\tint i;\n\n\tif (!use_spinloop())\n\t\treturn;\n\n\tDBG(\" -> smp_release_cpus()\\n\");\n\n\t/* All secondary cpus are spinning on a common spinloop, release them\n\t * all now so they can start to spin on their individual paca\n\t * spinloops. For non SMP kernels, the secondary cpus never get out\n\t * of the common spinloop.\n\t */\n\n\tptr  = (unsigned long *)((unsigned long)&__secondary_hold_spinloop\n\t\t\t- PHYSICAL_START);\n\t*ptr = ppc_function_entry(generic_secondary_smp_init);\n\n\t/* And wait a bit for them to catch up */\n\tfor (i = 0; i < 100000; i++) {\n\t\tmb();\n\t\tHMT_low();\n\t\tif (spinning_secondaries == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tDBG(\"spinning_secondaries = %d\\n\", spinning_secondaries);\n\n\tDBG(\" <- smp_release_cpus()\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nstatic void crash_kexec_prepare_cpus(int cpu)\n{\n\t/*\n\t * move the secondaries to us so that we can copy\n\t * the new kernel 0-0x100 safely\n\t *\n\t * do this if kexec in setup.c ?\n\t */\n#ifdef CONFIG_PPC64\n\tsmp_release_cpus();\n#else\n\t/* FIXME */\n#endif\n}"
  },
  {
    "function_name": "crash_kexec_secondary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "180-199",
    "snippet": "void crash_kexec_secondary(struct pt_regs *regs)\n{\n\tunsigned long flags;\n\tint msecs = SECONDARY_TIMEOUT;\n\n\tlocal_irq_save(flags);\n\n\t/* Wait for the primary crash CPU to signal its progress */\n\twhile (crashing_cpu < 0) {\n\t\tif (--msecs < 0) {\n\t\t\t/* No response, kdump image may not have been loaded */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tmdelay(1);\n\t}\n\n\tcrash_ipi_callback(regs);\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SECONDARY_TIMEOUT\t1000"
    ],
    "globals_used": [
      "int crashing_cpu = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crash_ipi_callback",
          "args": [
            "regs"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "crash_ipi_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
          "lines": "68-103",
          "snippet": "void crash_ipi_callback(struct pt_regs *regs)\n{\n\tstatic cpumask_t cpus_state_saved = CPU_MASK_NONE;\n\n\tint cpu = smp_processor_id();\n\n\tif (!cpu_online(cpu))\n\t\treturn;\n\n\thard_irq_disable();\n\tif (!cpumask_test_cpu(cpu, &cpus_state_saved)) {\n\t\tcrash_save_cpu(regs, cpu);\n\t\tcpumask_set_cpu(cpu, &cpus_state_saved);\n\t}\n\n\tatomic_inc(&cpus_in_crash);\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * Starting the kdump boot.\n\t * This barrier is needed to make sure that all CPUs are stopped.\n\t */\n\twhile (!time_to_dump)\n\t\tcpu_relax();\n\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(1, 1);\n\n#ifdef CONFIG_PPC64\n\tkexec_smp_wait();\n#else\n\tfor (;;);\t/* FIXME */\n#endif\n\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include <asm/debug.h>",
            "#include <asm/setjmp.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/kexec.h>",
            "#include <asm/machdep.h>",
            "#include <asm/processor.h>",
            "#include <linux/types.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/export.h>",
            "#include <linux/kexec.h>",
            "#include <linux/reboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int time_to_dump;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nstatic int time_to_dump;\n\nvoid crash_ipi_callback(struct pt_regs *regs)\n{\n\tstatic cpumask_t cpus_state_saved = CPU_MASK_NONE;\n\n\tint cpu = smp_processor_id();\n\n\tif (!cpu_online(cpu))\n\t\treturn;\n\n\thard_irq_disable();\n\tif (!cpumask_test_cpu(cpu, &cpus_state_saved)) {\n\t\tcrash_save_cpu(regs, cpu);\n\t\tcpumask_set_cpu(cpu, &cpus_state_saved);\n\t}\n\n\tatomic_inc(&cpus_in_crash);\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * Starting the kdump boot.\n\t * This barrier is needed to make sure that all CPUs are stopped.\n\t */\n\twhile (!time_to_dump)\n\t\tcpu_relax();\n\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(1, 1);\n\n#ifdef CONFIG_PPC64\n\tkexec_smp_wait();\n#else\n\tfor (;;);\t/* FIXME */\n#endif\n\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "202-277",
          "snippet": "notrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\n#define SECONDARY_TIMEOUT\t1000\n\nint crashing_cpu = -1;\n\nvoid crash_kexec_secondary(struct pt_regs *regs)\n{\n\tunsigned long flags;\n\tint msecs = SECONDARY_TIMEOUT;\n\n\tlocal_irq_save(flags);\n\n\t/* Wait for the primary crash CPU to signal its progress */\n\twhile (crashing_cpu < 0) {\n\t\tif (--msecs < 0) {\n\t\t\t/* No response, kdump image may not have been loaded */\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn;\n\t\t}\n\n\t\tmdelay(1);\n\t}\n\n\tcrash_ipi_callback(regs);\n}"
  },
  {
    "function_name": "crash_kexec_prepare_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "105-175",
    "snippet": "static void crash_kexec_prepare_cpus(int cpu)\n{\n\tunsigned int msecs;\n\tunsigned int ncpus = num_online_cpus() - 1;/* Excluding the panic cpu */\n\tint tries = 0;\n\tint (*old_handler)(struct pt_regs *regs);\n\n\tprintk(KERN_EMERG \"Sending IPI to other CPUs\\n\");\n\n\tcrash_send_ipi(crash_ipi_callback);\n\tsmp_wmb();\n\nagain:\n\t/*\n\t * FIXME: Until we will have the way to stop other CPUs reliably,\n\t * the crash CPU will send an IPI and wait for other CPUs to\n\t * respond.\n\t */\n\tmsecs = IPI_TIMEOUT;\n\twhile ((atomic_read(&cpus_in_crash) < ncpus) && (--msecs > 0))\n\t\tmdelay(1);\n\n\t/* Would it be better to replace the trap vector here? */\n\n\tif (atomic_read(&cpus_in_crash) >= ncpus) {\n\t\tprintk(KERN_EMERG \"IPI complete\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"ERROR: %d cpu(s) not responding\\n\",\n\t\tncpus - atomic_read(&cpus_in_crash));\n\n\t/*\n\t * If we have a panic timeout set then we can't wait indefinitely\n\t * for someone to activate system reset. We also give up on the\n\t * second time through if system reset fail to work.\n\t */\n\tif ((panic_timeout > 0) || (tries > 0))\n\t\treturn;\n\n\t/*\n\t * A system reset will cause all CPUs to take an 0x100 exception.\n\t * The primary CPU returns here via setjmp, and the secondary\n\t * CPUs reexecute the crash_kexec_secondary path.\n\t */\n\told_handler = __debugger;\n\t__debugger = handle_fault;\n\tcrash_shutdown_cpu = smp_processor_id();\n\n\tif (setjmp(crash_shutdown_buf) == 0) {\n\t\tprintk(KERN_EMERG \"Activate system reset (dumprestart) \"\n\t\t\t\t  \"to stop other cpu(s)\\n\");\n\n\t\t/*\n\t\t * A system reset will force all CPUs to execute the\n\t\t * crash code again. We need to reset cpus_in_crash so we\n\t\t * wait for everyone to do this.\n\t\t */\n\t\tatomic_set(&cpus_in_crash, 0);\n\t\tsmp_mb();\n\n\t\twhile (atomic_read(&cpus_in_crash) < ncpus)\n\t\t\tcpu_relax();\n\t}\n\n\tcrash_shutdown_cpu = -1;\n\t__debugger = old_handler;\n\n\ttries++;\n\tgoto again;\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define IPI_TIMEOUT\t\t10000"
    ],
    "globals_used": [
      "static unsigned long crash_shutdown_buf[JMP_BUF_LEN];",
      "static int crash_shutdown_cpu = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cpus_in_crash"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cpus_in_crash",
            "0"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Activate system reset (dumprestart) \"\n\t\t\t\t  \"to stop other cpu(s)\\n\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setjmp",
          "args": [
            "crash_shutdown_buf"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"ERROR: %d cpu(s) not responding\\n\"",
            "ncpus - atomic_read(&cpus_in_crash)"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cpus_in_crash"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"IPI complete\\n\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cpus_in_crash"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "1"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cpus_in_crash"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_send_ipi",
          "args": [
            "crash_ipi_callback"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "crash_send_ipi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp.c",
          "lines": "323-330",
          "snippet": "void crash_send_ipi(void (*crash_ipi_callback)(struct pt_regs *))\n{\n\tcrash_ipi_function_ptr = crash_ipi_callback;\n\tif (crash_ipi_callback) {\n\t\tmb();\n\t\tsmp_send_debugger_break();\n\t}\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debug.h>",
            "#include <asm/vdso.h>",
            "#include <asm/paca.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/mpic.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/machdep.h>",
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/irq.h>",
            "#include <linux/atomic.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/topology.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/cache.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void (*crash_ipi_function_ptr)(struct pt_regs *) = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/kexec.h>\n#include <asm/debug.h>\n#include <asm/vdso.h>\n#include <asm/paca.h>\n#include <asm/vdso_datapage.h>\n#include <asm/mpic.h>\n#include <asm/cputable.h>\n#include <asm/cputhreads.h>\n#include <asm/machdep.h>\n#include <asm/time.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/kvm_ppc.h>\n#include <asm/hw_irq.h>\n#include <asm/irq.h>\n#include <linux/atomic.h>\n#include <asm/ptrace.h>\n#include <linux/topology.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void (*crash_ipi_function_ptr)(struct pt_regs *) = NULL;\n\nvoid crash_send_ipi(void (*crash_ipi_callback)(struct pt_regs *))\n{\n\tcrash_ipi_function_ptr = crash_ipi_callback;\n\tif (crash_ipi_callback) {\n\t\tmb();\n\t\tsmp_send_debugger_break();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"Sending IPI to other CPUs\\n\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\n#define IPI_TIMEOUT\t\t10000\n\nstatic unsigned long crash_shutdown_buf[JMP_BUF_LEN];\nstatic int crash_shutdown_cpu = -1;\n\nstatic void crash_kexec_prepare_cpus(int cpu)\n{\n\tunsigned int msecs;\n\tunsigned int ncpus = num_online_cpus() - 1;/* Excluding the panic cpu */\n\tint tries = 0;\n\tint (*old_handler)(struct pt_regs *regs);\n\n\tprintk(KERN_EMERG \"Sending IPI to other CPUs\\n\");\n\n\tcrash_send_ipi(crash_ipi_callback);\n\tsmp_wmb();\n\nagain:\n\t/*\n\t * FIXME: Until we will have the way to stop other CPUs reliably,\n\t * the crash CPU will send an IPI and wait for other CPUs to\n\t * respond.\n\t */\n\tmsecs = IPI_TIMEOUT;\n\twhile ((atomic_read(&cpus_in_crash) < ncpus) && (--msecs > 0))\n\t\tmdelay(1);\n\n\t/* Would it be better to replace the trap vector here? */\n\n\tif (atomic_read(&cpus_in_crash) >= ncpus) {\n\t\tprintk(KERN_EMERG \"IPI complete\\n\");\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"ERROR: %d cpu(s) not responding\\n\",\n\t\tncpus - atomic_read(&cpus_in_crash));\n\n\t/*\n\t * If we have a panic timeout set then we can't wait indefinitely\n\t * for someone to activate system reset. We also give up on the\n\t * second time through if system reset fail to work.\n\t */\n\tif ((panic_timeout > 0) || (tries > 0))\n\t\treturn;\n\n\t/*\n\t * A system reset will cause all CPUs to take an 0x100 exception.\n\t * The primary CPU returns here via setjmp, and the secondary\n\t * CPUs reexecute the crash_kexec_secondary path.\n\t */\n\told_handler = __debugger;\n\t__debugger = handle_fault;\n\tcrash_shutdown_cpu = smp_processor_id();\n\n\tif (setjmp(crash_shutdown_buf) == 0) {\n\t\tprintk(KERN_EMERG \"Activate system reset (dumprestart) \"\n\t\t\t\t  \"to stop other cpu(s)\\n\");\n\n\t\t/*\n\t\t * A system reset will force all CPUs to execute the\n\t\t * crash code again. We need to reset cpus_in_crash so we\n\t\t * wait for everyone to do this.\n\t\t */\n\t\tatomic_set(&cpus_in_crash, 0);\n\t\tsmp_mb();\n\n\t\twhile (atomic_read(&cpus_in_crash) < ncpus)\n\t\t\tcpu_relax();\n\t}\n\n\tcrash_shutdown_cpu = -1;\n\t__debugger = old_handler;\n\n\ttries++;\n\tgoto again;\n}"
  },
  {
    "function_name": "crash_ipi_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "68-103",
    "snippet": "void crash_ipi_callback(struct pt_regs *regs)\n{\n\tstatic cpumask_t cpus_state_saved = CPU_MASK_NONE;\n\n\tint cpu = smp_processor_id();\n\n\tif (!cpu_online(cpu))\n\t\treturn;\n\n\thard_irq_disable();\n\tif (!cpumask_test_cpu(cpu, &cpus_state_saved)) {\n\t\tcrash_save_cpu(regs, cpu);\n\t\tcpumask_set_cpu(cpu, &cpus_state_saved);\n\t}\n\n\tatomic_inc(&cpus_in_crash);\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * Starting the kdump boot.\n\t * This barrier is needed to make sure that all CPUs are stopped.\n\t */\n\twhile (!time_to_dump)\n\t\tcpu_relax();\n\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(1, 1);\n\n#ifdef CONFIG_PPC64\n\tkexec_smp_wait();\n#else\n\tfor (;;);\t/* FIXME */\n#endif\n\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int time_to_dump;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kexec_smp_wait",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.kexec_cpu_down",
          "args": [
            "1",
            "1"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cpus_in_crash"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "cpu",
            "&cpus_state_saved"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crash_save_cpu",
          "args": [
            "regs",
            "cpu"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&cpus_state_saved"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/sysfs.c",
          "lines": "788-866",
          "snippet": "static void unregister_cpu_online(unsigned int cpu)\n{\n\tstruct cpu *c = &per_cpu(cpu_devices, cpu);\n\tstruct device *s = &c->dev;\n\tstruct device_attribute *attrs, *pmc_attrs;\n\tint i, nattrs;\n\n\tBUG_ON(!c->hotpluggable);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_SMT))\n\t\tdevice_remove_file(s, &dev_attr_smt_snooze_delay);\n#endif\n\n\t/* PMC stuff */\n\tswitch (cur_cpu_spec->pmc_type) {\n#ifdef HAS_PPC_PMC_IBM\n\tcase PPC_PMC_IBM:\n\t\tattrs = ibm_common_attrs;\n\t\tnattrs = sizeof(ibm_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_IBM */\n#ifdef HAS_PPC_PMC_G4\n\tcase PPC_PMC_G4:\n\t\tattrs = g4_common_attrs;\n\t\tnattrs = sizeof(g4_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_G4 */\n#ifdef HAS_PPC_PMC_PA6T\n\tcase PPC_PMC_PA6T:\n\t\t/* PA Semi starts counting at PMC0 */\n\t\tattrs = pa6t_attrs;\n\t\tnattrs = sizeof(pa6t_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = NULL;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_PA6T */\n\tdefault:\n\t\tattrs = NULL;\n\t\tnattrs = 0;\n\t\tpmc_attrs = NULL;\n\t}\n\n\tfor (i = 0; i < nattrs; i++)\n\t\tdevice_remove_file(s, &attrs[i]);\n\n\tif (pmc_attrs)\n\t\tfor (i = 0; i < cur_cpu_spec->num_pmcs; i++)\n\t\t\tdevice_remove_file(s, &pmc_attrs[i]);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_MMCRA))\n\t\tdevice_remove_file(s, &dev_attr_mmcra);\n\n\tif (cpu_has_feature(CPU_FTR_PURR))\n\t\tdevice_remove_file(s, &dev_attr_purr);\n\n\tif (cpu_has_feature(CPU_FTR_SPURR))\n\t\tdevice_remove_file(s, &dev_attr_spurr);\n\n\tif (cpu_has_feature(CPU_FTR_DSCR))\n\t\tdevice_remove_file(s, &dev_attr_dscr);\n\n\tif (cpu_has_feature(CPU_FTR_PPCAS_ARCH_V2))\n\t\tdevice_remove_file(s, &dev_attr_pir);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_FSL_BOOK3E\n\tif (PVR_VER(cur_cpu_spec->pvr_value) == PVR_VER_E6500) {\n\t\tdevice_remove_file(s, &dev_attr_pw20_state);\n\t\tdevice_remove_file(s, &dev_attr_pw20_wait_time);\n\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle);\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle_wait_time);\n\t}\n#endif\n\tcacheinfo_cpu_offline(cpu);\n}",
          "includes": [
            "#include <asm/lppaca.h>",
            "#include <asm/paca.h>",
            "#include \"cacheinfo.h\"",
            "#include <asm/firmware.h>",
            "#include <asm/pmc.h>",
            "#include <asm/smp.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/cputable.h>",
            "#include <asm/processor.h>",
            "#include <asm/current.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/export.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [
            "#define HAS_PPC_PMC_G4\t\t1",
            "#define HAS_PPC_PMC_IBM\t\t1",
            "#define HAS_PPC_PMC_PA6T\t1",
            "#define HAS_PPC_PMC_IBM\t\t1"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu, cpu_devices);",
            "static DEVICE_ATTR(physical_id, 0444, show_physical_id, NULL);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/lppaca.h>\n#include <asm/paca.h>\n#include \"cacheinfo.h\"\n#include <asm/firmware.h>\n#include <asm/pmc.h>\n#include <asm/smp.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/hvcall.h>\n#include <asm/cputable.h>\n#include <asm/processor.h>\n#include <asm/current.h>\n#include <linux/notifier.h>\n#include <linux/cpumask.h>\n#include <linux/nodemask.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n\n#define HAS_PPC_PMC_G4\t\t1\n#define HAS_PPC_PMC_IBM\t\t1\n#define HAS_PPC_PMC_PA6T\t1\n#define HAS_PPC_PMC_IBM\t\t1\n\nstatic DEFINE_PER_CPU(struct cpu, cpu_devices);\nstatic DEVICE_ATTR(physical_id, 0444, show_physical_id, NULL);\n\nstatic void unregister_cpu_online(unsigned int cpu)\n{\n\tstruct cpu *c = &per_cpu(cpu_devices, cpu);\n\tstruct device *s = &c->dev;\n\tstruct device_attribute *attrs, *pmc_attrs;\n\tint i, nattrs;\n\n\tBUG_ON(!c->hotpluggable);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_SMT))\n\t\tdevice_remove_file(s, &dev_attr_smt_snooze_delay);\n#endif\n\n\t/* PMC stuff */\n\tswitch (cur_cpu_spec->pmc_type) {\n#ifdef HAS_PPC_PMC_IBM\n\tcase PPC_PMC_IBM:\n\t\tattrs = ibm_common_attrs;\n\t\tnattrs = sizeof(ibm_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_IBM */\n#ifdef HAS_PPC_PMC_G4\n\tcase PPC_PMC_G4:\n\t\tattrs = g4_common_attrs;\n\t\tnattrs = sizeof(g4_common_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = classic_pmc_attrs;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_G4 */\n#ifdef HAS_PPC_PMC_PA6T\n\tcase PPC_PMC_PA6T:\n\t\t/* PA Semi starts counting at PMC0 */\n\t\tattrs = pa6t_attrs;\n\t\tnattrs = sizeof(pa6t_attrs) / sizeof(struct device_attribute);\n\t\tpmc_attrs = NULL;\n\t\tbreak;\n#endif /* HAS_PPC_PMC_PA6T */\n\tdefault:\n\t\tattrs = NULL;\n\t\tnattrs = 0;\n\t\tpmc_attrs = NULL;\n\t}\n\n\tfor (i = 0; i < nattrs; i++)\n\t\tdevice_remove_file(s, &attrs[i]);\n\n\tif (pmc_attrs)\n\t\tfor (i = 0; i < cur_cpu_spec->num_pmcs; i++)\n\t\t\tdevice_remove_file(s, &pmc_attrs[i]);\n\n#ifdef CONFIG_PPC64\n\tif (cpu_has_feature(CPU_FTR_MMCRA))\n\t\tdevice_remove_file(s, &dev_attr_mmcra);\n\n\tif (cpu_has_feature(CPU_FTR_PURR))\n\t\tdevice_remove_file(s, &dev_attr_purr);\n\n\tif (cpu_has_feature(CPU_FTR_SPURR))\n\t\tdevice_remove_file(s, &dev_attr_spurr);\n\n\tif (cpu_has_feature(CPU_FTR_DSCR))\n\t\tdevice_remove_file(s, &dev_attr_dscr);\n\n\tif (cpu_has_feature(CPU_FTR_PPCAS_ARCH_V2))\n\t\tdevice_remove_file(s, &dev_attr_pir);\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_FSL_BOOK3E\n\tif (PVR_VER(cur_cpu_spec->pvr_value) == PVR_VER_E6500) {\n\t\tdevice_remove_file(s, &dev_attr_pw20_state);\n\t\tdevice_remove_file(s, &dev_attr_pw20_wait_time);\n\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle);\n\t\tdevice_remove_file(s, &dev_attr_altivec_idle_wait_time);\n\t}\n#endif\n\tcacheinfo_cpu_offline(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nstatic int time_to_dump;\n\nvoid crash_ipi_callback(struct pt_regs *regs)\n{\n\tstatic cpumask_t cpus_state_saved = CPU_MASK_NONE;\n\n\tint cpu = smp_processor_id();\n\n\tif (!cpu_online(cpu))\n\t\treturn;\n\n\thard_irq_disable();\n\tif (!cpumask_test_cpu(cpu, &cpus_state_saved)) {\n\t\tcrash_save_cpu(regs, cpu);\n\t\tcpumask_set_cpu(cpu, &cpus_state_saved);\n\t}\n\n\tatomic_inc(&cpus_in_crash);\n\tsmp_mb__after_atomic();\n\n\t/*\n\t * Starting the kdump boot.\n\t * This barrier is needed to make sure that all CPUs are stopped.\n\t */\n\twhile (!time_to_dump)\n\t\tcpu_relax();\n\n\tif (ppc_md.kexec_cpu_down)\n\t\tppc_md.kexec_cpu_down(1, 1);\n\n#ifdef CONFIG_PPC64\n\tkexec_smp_wait();\n#else\n\tfor (;;);\t/* FIXME */\n#endif\n\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "handle_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash.c",
    "lines": "58-63",
    "snippet": "static int handle_fault(struct pt_regs *regs)\n{\n\tif (crash_shutdown_cpu == smp_processor_id())\n\t\tlongjmp(crash_shutdown_buf, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/debug.h>",
      "#include <asm/setjmp.h>",
      "#include <asm/smp.h>",
      "#include <asm/prom.h>",
      "#include <asm/kdump.h>",
      "#include <asm/kexec.h>",
      "#include <asm/machdep.h>",
      "#include <asm/processor.h>",
      "#include <linux/types.h>",
      "#include <linux/irq.h>",
      "#include <linux/delay.h>",
      "#include <linux/crash_dump.h>",
      "#include <linux/export.h>",
      "#include <linux/kexec.h>",
      "#include <linux/reboot.h>",
      "#include <linux/smp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long crash_shutdown_buf[JMP_BUF_LEN];",
      "static int crash_shutdown_cpu = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "longjmp",
          "args": [
            "crash_shutdown_buf",
            "1"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "longjmp_break_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/kprobes.c",
          "lines": "529-541",
          "snippet": "int __kprobes longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\t/*\n\t * FIXME - we should ideally be validating that we got here 'cos\n\t * of the \"trap\" in jprobe_return() above, before restoring the\n\t * saved regs...\n\t */\n\tmemcpy(regs, &kcb->jprobe_saved_regs, sizeof(struct pt_regs));\n\tpreempt_enable_no_resched();\n\treturn 1;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/slab.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/module.h>",
            "#include <linux/preempt.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/kprobes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/cacheflush.h>\n#include <asm/code-patching.h>\n#include <linux/slab.h>\n#include <linux/kdebug.h>\n#include <linux/module.h>\n#include <linux/preempt.h>\n#include <linux/ptrace.h>\n#include <linux/kprobes.h>\n\nint __kprobes longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)\n{\n\tstruct kprobe_ctlblk *kcb = get_kprobe_ctlblk();\n\n\t/*\n\t * FIXME - we should ideally be validating that we got here 'cos\n\t * of the \"trap\" in jprobe_return() above, before restoring the\n\t * saved regs...\n\t */\n\tmemcpy(regs, &kcb->jprobe_saved_regs, sizeof(struct pt_regs));\n\tpreempt_enable_no_resched();\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/debug.h>\n#include <asm/setjmp.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/kexec.h>\n#include <asm/machdep.h>\n#include <asm/processor.h>\n#include <linux/types.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/crash_dump.h>\n#include <linux/export.h>\n#include <linux/kexec.h>\n#include <linux/reboot.h>\n#include <linux/smp.h>\n#include <linux/kernel.h>\n\nstatic unsigned long crash_shutdown_buf[JMP_BUF_LEN];\nstatic int crash_shutdown_cpu = -1;\n\nstatic int handle_fault(struct pt_regs *regs)\n{\n\tif (crash_shutdown_cpu == smp_processor_id())\n\t\tlongjmp(crash_shutdown_buf, 1);\n\treturn 0;\n}"
  }
]