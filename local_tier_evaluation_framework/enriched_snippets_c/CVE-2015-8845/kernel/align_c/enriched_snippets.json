[
  {
    "function_name": "fix_alignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
    "lines": "736-1042",
    "snippet": "int fix_alignment(struct pt_regs *regs)\n{\n\tunsigned int instr, nb, flags, instruction = 0;\n\tunsigned int reg, areg;\n\tunsigned int dsisr;\n\tunsigned char __user *addr;\n\tunsigned long p, swiz;\n\tint ret, i;\n\tunion data {\n\t\tu64 ll;\n\t\tdouble dd;\n\t\tunsigned char v[8];\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN__\n\t\t\tint\t low32;\n\t\t\tunsigned hi32;\n#else\n\t\t\tunsigned hi32;\n\t\t\tint\t low32;\n#endif\n\t\t} x32;\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN__\n\t\t\tshort\t      low16;\n\t\t\tunsigned char hi48[6];\n#else\n\t\t\tunsigned char hi48[6];\n\t\t\tshort\t      low16;\n#endif\n\t\t} x16;\n\t} data;\n\n\t/*\n\t * We require a complete register set, if not, then our assembly\n\t * is broken\n\t */\n\tCHECK_FULL_REGS(regs);\n\n\tdsisr = regs->dsisr;\n\n\t/* Some processors don't provide us with a DSISR we can use here,\n\t * let's make one up from the instruction\n\t */\n\tif (cpu_has_feature(CPU_FTR_NODSISRALIGN)) {\n\t\tunsigned long pc = regs->nip;\n\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE) && (regs->msr & MSR_LE))\n\t\t\tpc ^= 4;\n\t\tif (unlikely(__get_user_inatomic(instr,\n\t\t\t\t\t\t (unsigned int __user *)pc)))\n\t\t\treturn -EFAULT;\n\t\tif (cpu_has_feature(CPU_FTR_REAL_LE) && (regs->msr & MSR_LE))\n\t\t\tinstr = cpu_to_le32(instr);\n\t\tdsisr = make_dsisr(instr);\n\t\tinstruction = instr;\n\t}\n\n\t/* extract the operation and registers from the dsisr */\n\treg = (dsisr >> 5) & 0x1f;\t/* source/dest register */\n\tareg = dsisr & 0x1f;\t\t/* register to update */\n\n#ifdef CONFIG_SPE\n\tif ((instr >> 26) == 0x4) {\n\t\tPPC_WARN_ALIGNMENT(spe, regs);\n\t\treturn emulate_spe(regs, reg, instr);\n\t}\n#endif\n\n\tinstr = (dsisr >> 10) & 0x7f;\n\tinstr |= (dsisr >> 13) & 0x60;\n\n\t/* Lookup the operation in our table */\n\tnb = aligninfo[instr].len;\n\tflags = aligninfo[instr].flags;\n\n\t/* ldbrx/stdbrx overlap lfs/stfs in the DSISR unfortunately */\n\tif (IS_XFORM(instruction) && ((instruction >> 1) & 0x3ff) == 532) {\n\t\tnb = 8;\n\t\tflags = LD+SW;\n\t} else if (IS_XFORM(instruction) &&\n\t\t   ((instruction >> 1) & 0x3ff) == 660) {\n\t\tnb = 8;\n\t\tflags = ST+SW;\n\t}\n\n\t/* Byteswap little endian loads and stores */\n\tswiz = 0;\n\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {\n\t\tflags ^= SW;\n#ifdef __BIG_ENDIAN__\n\t\t/*\n\t\t * So-called \"PowerPC little endian\" mode works by\n\t\t * swizzling addresses rather than by actually doing\n\t\t * any byte-swapping.  To emulate this, we XOR each\n\t\t * byte address with 7.  We also byte-swap, because\n\t\t * the processor's address swizzling depends on the\n\t\t * operand size (it xors the address with 7 for bytes,\n\t\t * 6 for halfwords, 4 for words, 0 for doublewords) but\n\t\t * we will xor with 7 and load/store each byte separately.\n\t\t */\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE))\n\t\t\tswiz = 7;\n#endif\n\t}\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n#ifdef CONFIG_VSX\n\tif ((instruction & 0xfc00003e) == 0x7c000018) {\n\t\tunsigned int elsize;\n\n\t\t/* Additional register addressing bit (64 VSX vs 32 FPR/GPR) */\n\t\treg |= (instruction & 0x1) << 5;\n\t\t/* Simple inline decoder instead of a table */\n\t\t/* VSX has only 8 and 16 byte memory accesses */\n\t\tnb = 8;\n\t\tif (instruction & 0x200)\n\t\t\tnb = 16;\n\n\t\t/* Vector stores in little-endian mode swap individual\n\t\t   elements, so process them separately */\n\t\telsize = 4;\n\t\tif (instruction & 0x80)\n\t\t\telsize = 8;\n\n\t\tflags = 0;\n\t\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE))\n\t\t\tflags |= SW;\n\t\tif (instruction & 0x100)\n\t\t\tflags |= ST;\n\t\tif (instruction & 0x040)\n\t\t\tflags |= U;\n\t\t/* splat load needs a special decoder */\n\t\tif ((instruction & 0x400) == 0){\n\t\t\tflags |= SPLT;\n\t\t\tnb = 8;\n\t\t}\n\t\tPPC_WARN_ALIGNMENT(vsx, regs);\n\t\treturn emulate_vsx(addr, reg, areg, regs, flags, nb, elsize);\n\t}\n#endif\n\t/* A size of 0 indicates an instruction we don't support, with\n\t * the exception of DCBZ which is handled as a special case here\n\t */\n\tif (instr == DCBZ) {\n\t\tPPC_WARN_ALIGNMENT(dcbz, regs);\n\t\treturn emulate_dcbz(regs, addr);\n\t}\n\tif (unlikely(nb == 0))\n\t\treturn 0;\n\n\t/* Load/Store Multiple instructions are handled in their own\n\t * function\n\t */\n\tif (flags & M) {\n\t\tPPC_WARN_ALIGNMENT(multiple, regs);\n\t\treturn emulate_multiple(regs, addr, reg, nb,\n\t\t\t\t\tflags, instr, swiz);\n\t}\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)))\n\t\treturn -EFAULT;\n\n\t/* Force the fprs into the save area so we can reference them */\n\tif (flags & F) {\n\t\t/* userland only */\n\t\tif (unlikely(!user_mode(regs)))\n\t\t\treturn 0;\n\t\tflush_fp_to_thread(current);\n\t}\n\n\tif (nb == 16) {\n\t\tif (flags & F) {\n\t\t\t/* Special case for 16-byte FP loads and stores */\n\t\t\tPPC_WARN_ALIGNMENT(fp_pair, regs);\n\t\t\treturn emulate_fp_pair(addr, reg, flags);\n\t\t} else {\n#ifdef CONFIG_PPC64\n\t\t\t/* Special case for 16-byte loads and stores */\n\t\t\tPPC_WARN_ALIGNMENT(lq_stq, regs);\n\t\t\treturn emulate_lq_stq(regs, addr, reg, flags);\n#else\n\t\t\treturn 0;\n#endif\n\t\t}\n\t}\n\n\tPPC_WARN_ALIGNMENT(unaligned, regs);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (!(flags & ST)) {\n\t\tunsigned int start = 0;\n\n\t\tswitch (nb) {\n\t\tcase 4:\n\t\t\tstart = offsetof(union data, x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = offsetof(union data, x16.low16);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata.ll = 0;\n\t\tret = 0;\n\t\tp = (unsigned long)addr;\n\n\t\tfor (i = 0; i < nb; i++)\n\t\t\tret |= __get_user_inatomic(data.v[start + i],\n\t\t\t\t\t\t   SWIZ_PTR(p++));\n\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\n\t} else if (flags & F) {\n\t\tdata.ll = current->thread.TS_FPR(reg);\n\t\tif (flags & S) {\n\t\t\t/* Single-precision FP store requires conversion... */\n#ifdef CONFIG_PPC_FPU\n\t\t\tpreempt_disable();\n\t\t\tenable_kernel_fp();\n\t\t\tcvt_df(&data.dd, (float *)&data.x32.low32);\n\t\t\tpreempt_enable();\n#else\n\t\t\treturn 0;\n#endif\n\t\t}\n\t} else\n\t\tdata.ll = regs->gpr[reg];\n\n\tif (flags & SW) {\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdata.x32.low32 = swab32(data.x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata.x16.low16 = swab16(data.x16.low16);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Perform other misc operations like sign extension\n\t * or floating point single precision conversion\n\t */\n\tswitch (flags & ~(U|SW)) {\n\tcase LD+SE:\t/* sign extending integer loads */\n\tcase LD+F+SE:\t/* sign extend for lfiwax */\n\t\tif ( nb == 2 )\n\t\t\tdata.ll = data.x16.low16;\n\t\telse\t/* nb must be 4 */\n\t\t\tdata.ll = data.x32.low32;\n\t\tbreak;\n\n\t/* Single-precision FP load requires conversion... */\n\tcase LD+F+S:\n#ifdef CONFIG_PPC_FPU\n\t\tpreempt_disable();\n\t\tenable_kernel_fp();\n\t\tcvt_fd((float *)&data.x32.low32, &data.dd);\n\t\tpreempt_enable();\n#else\n\t\treturn 0;\n#endif\n\t\tbreak;\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tunsigned int start = 0;\n\n\t\tswitch (nb) {\n\t\tcase 4:\n\t\t\tstart = offsetof(union data, x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = offsetof(union data, x16.low16);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = 0;\n\t\tp = (unsigned long)addr;\n\n\t\tfor (i = 0; i < nb; i++)\n\t\t\tret |= __put_user_inatomic(data.v[start + i],\n\t\t\t\t\t\t   SWIZ_PTR(p++));\n\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else if (flags & F)\n\t\tcurrent->thread.TS_FPR(reg) = data.ll;\n\telse\n\t\tregs->gpr[reg] = data.ll;\n\n\t/* Update RA as needed */\n\tif (flags & U)\n\t\tregs->gpr[areg] = regs->dar;\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define DCBZ\t0x5f\t/* 8xx/82xx dcbz faults when cache not enabled */",
      "#define SPLT\t0x80\t/* VSX SPLAT load */",
      "#define S\t0x40\t/* single-precision fp or... */",
      "#define SW\t0x20\t/* byte swap */",
      "#define M\t0x10\t/* multiple load/store */",
      "#define U\t8\t/* update index register */",
      "#define F\t4\t/* to/from fp regs */",
      "#define SE\t2\t/* sign-extend value, or FP ld/st as word */",
      "#define ST\t1\t/* store */",
      "#define LD\t0\t/* load */"
    ],
    "globals_used": [
      "static struct aligninfo aligninfo[128] = {\n\t{ 4, LD },\t\t/* 00 0 0000: lwz / lwarx */\n\tINVALID,\t\t/* 00 0 0001 */\n\t{ 4, ST },\t\t/* 00 0 0010: stw */\n\tINVALID,\t\t/* 00 0 0011 */\n\t{ 2, LD },\t\t/* 00 0 0100: lhz */\n\t{ 2, LD+SE },\t\t/* 00 0 0101: lha */\n\t{ 2, ST },\t\t/* 00 0 0110: sth */\n\t{ 4, LD+M },\t\t/* 00 0 0111: lmw */\n\t{ 4, LD+F+S },\t\t/* 00 0 1000: lfs */\n\t{ 8, LD+F },\t\t/* 00 0 1001: lfd */\n\t{ 4, ST+F+S },\t\t/* 00 0 1010: stfs */\n\t{ 8, ST+F },\t\t/* 00 0 1011: stfd */\n\t{ 16, LD },\t\t/* 00 0 1100: lq */\n\t{ 8, LD },\t\t/* 00 0 1101: ld/ldu/lwa */\n\tINVALID,\t\t/* 00 0 1110 */\n\t{ 8, ST },\t\t/* 00 0 1111: std/stdu */\n\t{ 4, LD+U },\t\t/* 00 1 0000: lwzu */\n\tINVALID,\t\t/* 00 1 0001 */\n\t{ 4, ST+U },\t\t/* 00 1 0010: stwu */\n\tINVALID,\t\t/* 00 1 0011 */\n\t{ 2, LD+U },\t\t/* 00 1 0100: lhzu */\n\t{ 2, LD+SE+U },\t\t/* 00 1 0101: lhau */\n\t{ 2, ST+U },\t\t/* 00 1 0110: sthu */\n\t{ 4, ST+M },\t\t/* 00 1 0111: stmw */\n\t{ 4, LD+F+S+U },\t/* 00 1 1000: lfsu */\n\t{ 8, LD+F+U },\t\t/* 00 1 1001: lfdu */\n\t{ 4, ST+F+S+U },\t/* 00 1 1010: stfsu */\n\t{ 8, ST+F+U },\t\t/* 00 1 1011: stfdu */\n\t{ 16, LD+F },\t\t/* 00 1 1100: lfdp */\n\tINVALID,\t\t/* 00 1 1101 */\n\t{ 16, ST+F },\t\t/* 00 1 1110: stfdp */\n\tINVALID,\t\t/* 00 1 1111 */\n\t{ 8, LD },\t\t/* 01 0 0000: ldx */\n\tINVALID,\t\t/* 01 0 0001 */\n\t{ 8, ST },\t\t/* 01 0 0010: stdx */\n\tINVALID,\t\t/* 01 0 0011 */\n\tINVALID,\t\t/* 01 0 0100 */\n\t{ 4, LD+SE },\t\t/* 01 0 0101: lwax */\n\tINVALID,\t\t/* 01 0 0110 */\n\tINVALID,\t\t/* 01 0 0111 */\n\t{ 4, LD+M+HARD+SX },\t/* 01 0 1000: lswx */\n\t{ 4, LD+M+HARD },\t/* 01 0 1001: lswi */\n\t{ 4, ST+M+HARD+SX },\t/* 01 0 1010: stswx */\n\t{ 4, ST+M+HARD },\t/* 01 0 1011: stswi */\n\tINVALID,\t\t/* 01 0 1100 */\n\t{ 8, LD+U },\t\t/* 01 0 1101: ldu */\n\tINVALID,\t\t/* 01 0 1110 */\n\t{ 8, ST+U },\t\t/* 01 0 1111: stdu */\n\t{ 8, LD+U },\t\t/* 01 1 0000: ldux */\n\tINVALID,\t\t/* 01 1 0001 */\n\t{ 8, ST+U },\t\t/* 01 1 0010: stdux */\n\tINVALID,\t\t/* 01 1 0011 */\n\tINVALID,\t\t/* 01 1 0100 */\n\t{ 4, LD+SE+U },\t\t/* 01 1 0101: lwaux */\n\tINVALID,\t\t/* 01 1 0110 */\n\tINVALID,\t\t/* 01 1 0111 */\n\tINVALID,\t\t/* 01 1 1000 */\n\tINVALID,\t\t/* 01 1 1001 */\n\tINVALID,\t\t/* 01 1 1010 */\n\tINVALID,\t\t/* 01 1 1011 */\n\tINVALID,\t\t/* 01 1 1100 */\n\tINVALID,\t\t/* 01 1 1101 */\n\tINVALID,\t\t/* 01 1 1110 */\n\tINVALID,\t\t/* 01 1 1111 */\n\tINVALID,\t\t/* 10 0 0000 */\n\tINVALID,\t\t/* 10 0 0001 */\n\tINVALID,\t\t/* 10 0 0010: stwcx. */\n\tINVALID,\t\t/* 10 0 0011 */\n\tINVALID,\t\t/* 10 0 0100 */\n\tINVALID,\t\t/* 10 0 0101 */\n\tINVALID,\t\t/* 10 0 0110 */\n\tINVALID,\t\t/* 10 0 0111 */\n\t{ 4, LD+SW },\t\t/* 10 0 1000: lwbrx */\n\tINVALID,\t\t/* 10 0 1001 */\n\t{ 4, ST+SW },\t\t/* 10 0 1010: stwbrx */\n\tINVALID,\t\t/* 10 0 1011 */\n\t{ 2, LD+SW },\t\t/* 10 0 1100: lhbrx */\n\t{ 4, LD+SE },\t\t/* 10 0 1101  lwa */\n\t{ 2, ST+SW },\t\t/* 10 0 1110: sthbrx */\n\t{ 16, ST },\t\t/* 10 0 1111: stq */\n\tINVALID,\t\t/* 10 1 0000 */\n\tINVALID,\t\t/* 10 1 0001 */\n\tINVALID,\t\t/* 10 1 0010 */\n\tINVALID,\t\t/* 10 1 0011 */\n\tINVALID,\t\t/* 10 1 0100 */\n\tINVALID,\t\t/* 10 1 0101 */\n\tINVALID,\t\t/* 10 1 0110 */\n\tINVALID,\t\t/* 10 1 0111 */\n\tINVALID,\t\t/* 10 1 1000 */\n\tINVALID,\t\t/* 10 1 1001 */\n\tINVALID,\t\t/* 10 1 1010 */\n\tINVALID,\t\t/* 10 1 1011 */\n\tINVALID,\t\t/* 10 1 1100 */\n\tINVALID,\t\t/* 10 1 1101 */\n\tINVALID,\t\t/* 10 1 1110 */\n\t{ 0, ST+HARD },\t\t/* 10 1 1111: dcbz */\n\t{ 4, LD },\t\t/* 11 0 0000: lwzx */\n\tINVALID,\t\t/* 11 0 0001 */\n\t{ 4, ST },\t\t/* 11 0 0010: stwx */\n\tINVALID,\t\t/* 11 0 0011 */\n\t{ 2, LD },\t\t/* 11 0 0100: lhzx */\n\t{ 2, LD+SE },\t\t/* 11 0 0101: lhax */\n\t{ 2, ST },\t\t/* 11 0 0110: sthx */\n\tINVALID,\t\t/* 11 0 0111 */\n\t{ 4, LD+F+S },\t\t/* 11 0 1000: lfsx */\n\t{ 8, LD+F },\t\t/* 11 0 1001: lfdx */\n\t{ 4, ST+F+S },\t\t/* 11 0 1010: stfsx */\n\t{ 8, ST+F },\t\t/* 11 0 1011: stfdx */\n\t{ 16, LD+F },\t\t/* 11 0 1100: lfdpx */\n\t{ 4, LD+F+SE },\t\t/* 11 0 1101: lfiwax */\n\t{ 16, ST+F },\t\t/* 11 0 1110: stfdpx */\n\t{ 4, ST+F },\t\t/* 11 0 1111: stfiwx */\n\t{ 4, LD+U },\t\t/* 11 1 0000: lwzux */\n\tINVALID,\t\t/* 11 1 0001 */\n\t{ 4, ST+U },\t\t/* 11 1 0010: stwux */\n\tINVALID,\t\t/* 11 1 0011 */\n\t{ 2, LD+U },\t\t/* 11 1 0100: lhzux */\n\t{ 2, LD+SE+U },\t\t/* 11 1 0101: lhaux */\n\t{ 2, ST+U },\t\t/* 11 1 0110: sthux */\n\tINVALID,\t\t/* 11 1 0111 */\n\t{ 4, LD+F+S+U },\t/* 11 1 1000: lfsux */\n\t{ 8, LD+F+U },\t\t/* 11 1 1001: lfdux */\n\t{ 4, ST+F+S+U },\t/* 11 1 1010: stfsux */\n\t{ 8, ST+F+U },\t\t/* 11 1 1011: stfdux */\n\tINVALID,\t\t/* 11 1 1100 */\n\t{ 4, LD+F },\t\t/* 11 1 1101: lfiwzx */\n\tINVALID,\t\t/* 11 1 1110 */\n\tINVALID,\t\t/* 11 1 1111 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "current->thread.TS_FPR",
          "args": [
            "reg"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[start + i]",
            "SWIZ_PTR(p++)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWIZ_PTR",
          "args": [
            "p++"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cvt_fd",
          "args": [
            "(float *)&data.x32.low32",
            "&data.dd"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enable_kernel_fp",
          "args": [],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "enable_kernel_fp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "155-167",
          "snippet": "void enable_kernel_fp(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_FP))\n\t\tgiveup_fpu_maybe_transactional(current);\n\telse\n\t\tgiveup_fpu(NULL);\t/* just enables FP for kernel */\n#else\n\tgiveup_fpu_maybe_transactional(last_task_used_math);\n#endif /* CONFIG_SMP */\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid enable_kernel_fp(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_FP))\n\t\tgiveup_fpu_maybe_transactional(current);\n\telse\n\t\tgiveup_fpu(NULL);\t/* just enables FP for kernel */\n#else\n\tgiveup_fpu_maybe_transactional(last_task_used_math);\n#endif /* CONFIG_SMP */\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.x16.low16"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32",
          "args": [
            "data.x32.low32"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab64",
          "args": [
            "data.ll"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cvt_df",
          "args": [
            "&data.dd",
            "(float *)&data.x32.low32"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current->thread.TS_FPR",
          "args": [
            "reg"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "data.v[start + i]",
            "SWIZ_PTR(p++)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWIZ_PTR",
          "args": [
            "p++"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "unaligned",
            "regs"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_lq_stq",
          "args": [
            "regs",
            "addr",
            "reg",
            "flags"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_lq_stq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
          "lines": "376-400",
          "snippet": "static int emulate_lq_stq(struct pt_regs *regs, unsigned char __user *addr,\n\t\t\t  unsigned int reg, unsigned int flags)\n{\n\tchar *ptr0 = (char *)&regs->gpr[reg];\n\tchar *ptr1 = (char *)&regs->gpr[reg+1];\n\tint i, ret, sw = 0;\n\n\tif (reg & 1)\n\t\treturn 0;\t/* invalid form: GPR must be even */\n\tif (flags & SW)\n\t\tsw = 7;\n\tret = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!(flags & ST)) {\n\t\t\tret |= __get_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __get_user(ptr1[i^sw], addr + i + 8);\n\t\t} else {\n\t\t\tret |= __put_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __put_user(ptr1[i^sw], addr + i + 8);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 1;\t/* exception handled and fixed up */\n}",
          "includes": [
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SW\t0x20\t/* byte swap */",
            "#define ST\t1\t/* store */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define SW\t0x20\t/* byte swap */\n#define ST\t1\t/* store */\n\nstatic int emulate_lq_stq(struct pt_regs *regs, unsigned char __user *addr,\n\t\t\t  unsigned int reg, unsigned int flags)\n{\n\tchar *ptr0 = (char *)&regs->gpr[reg];\n\tchar *ptr1 = (char *)&regs->gpr[reg+1];\n\tint i, ret, sw = 0;\n\n\tif (reg & 1)\n\t\treturn 0;\t/* invalid form: GPR must be even */\n\tif (flags & SW)\n\t\tsw = 7;\n\tret = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!(flags & ST)) {\n\t\t\tret |= __get_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __get_user(ptr1[i^sw], addr + i + 8);\n\t\t} else {\n\t\t\tret |= __put_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __put_user(ptr1[i^sw], addr + i + 8);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 1;\t/* exception handled and fixed up */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "lq_stq",
            "regs"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_fp_pair",
          "args": [
            "addr",
            "reg",
            "flags"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_fp_pair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
          "lines": "349-373",
          "snippet": "static int emulate_fp_pair(unsigned char __user *addr, unsigned int reg,\n\t\t\t   unsigned int flags)\n{\n\tchar *ptr0 = (char *) &current->thread.TS_FPR(reg);\n\tchar *ptr1 = (char *) &current->thread.TS_FPR(reg+1);\n\tint i, ret, sw = 0;\n\n\tif (reg & 1)\n\t\treturn 0;\t/* invalid form: FRS/FRT must be even */\n\tif (flags & SW)\n\t\tsw = 7;\n\tret = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!(flags & ST)) {\n\t\t\tret |= __get_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __get_user(ptr1[i^sw], addr + i + 8);\n\t\t} else {\n\t\t\tret |= __put_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __put_user(ptr1[i^sw], addr + i + 8);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 1;\t/* exception handled and fixed up */\n}",
          "includes": [
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SW\t0x20\t/* byte swap */",
            "#define ST\t1\t/* store */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define SW\t0x20\t/* byte swap */\n#define ST\t1\t/* store */\n\nstatic int emulate_fp_pair(unsigned char __user *addr, unsigned int reg,\n\t\t\t   unsigned int flags)\n{\n\tchar *ptr0 = (char *) &current->thread.TS_FPR(reg);\n\tchar *ptr1 = (char *) &current->thread.TS_FPR(reg+1);\n\tint i, ret, sw = 0;\n\n\tif (reg & 1)\n\t\treturn 0;\t/* invalid form: FRS/FRT must be even */\n\tif (flags & SW)\n\t\tsw = 7;\n\tret = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!(flags & ST)) {\n\t\t\tret |= __get_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __get_user(ptr1[i^sw], addr + i + 8);\n\t\t} else {\n\t\t\tret |= __put_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __put_user(ptr1[i^sw], addr + i + 8);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 1;\t/* exception handled and fixed up */\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "fp_pair",
            "regs"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "current"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!user_mode(regs)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "(flags & ST ? VERIFY_WRITE : VERIFY_READ)",
            "addr",
            "nb"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_multiple",
          "args": [
            "regs",
            "addr",
            "reg",
            "nb",
            "flags",
            "instr",
            "swiz"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_multiple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
          "lines": "239-342",
          "snippet": "static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,\n\t\t\t    unsigned int reg, unsigned int nb,\n\t\t\t    unsigned int flags, unsigned int instr,\n\t\t\t    unsigned long swiz)\n{\n\tunsigned long *rptr;\n\tunsigned int nb0, i, bswiz;\n\tunsigned long p;\n\n\t/*\n\t * We do not try to emulate 8 bytes multiple as they aren't really\n\t * available in our operating environments and we don't try to\n\t * emulate multiples operations in kernel land as they should never\n\t * be used/generated there at least not on unaligned boundaries\n\t */\n\tif (unlikely((nb > 4) || !user_mode(regs)))\n\t\treturn 0;\n\n\t/* lmw, stmw, lswi/x, stswi/x */\n\tnb0 = 0;\n\tif (flags & HARD) {\n\t\tif (flags & SX) {\n\t\t\tnb = regs->xer & 127;\n\t\t\tif (nb == 0)\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tunsigned long pc = regs->nip ^ (swiz & 4);\n\n\t\t\tif (__get_user_inatomic(instr,\n\t\t\t\t\t\t(unsigned int __user *)pc))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (swiz == 0 && (flags & SW))\n\t\t\t\tinstr = cpu_to_le32(instr);\n\t\t\tnb = (instr >> 11) & 0x1f;\n\t\t\tif (nb == 0)\n\t\t\t\tnb = 32;\n\t\t}\n\t\tif (nb + reg * 4 > 128) {\n\t\t\tnb0 = nb + reg * 4 - 128;\n\t\t\tnb = 128 - reg * 4;\n\t\t}\n#ifdef __LITTLE_ENDIAN__\n\t\t/*\n\t\t *  String instructions are endian neutral but the code\n\t\t *  below is not.  Force byte swapping on so that the\n\t\t *  effects of swizzling are undone in the load/store\n\t\t *  loops below.\n\t\t */\n\t\tflags ^= SW;\n#endif\n\t} else {\n\t\t/* lwm, stmw */\n\t\tnb = (32 - reg) * 4;\n\t}\n\n\tif (!access_ok((flags & ST ? VERIFY_WRITE: VERIFY_READ), addr, nb+nb0))\n\t\treturn -EFAULT;\t/* bad address */\n\n\trptr = &regs->gpr[reg];\n\tp = (unsigned long) addr;\n\tbswiz = (flags & SW)? 3: 0;\n\n\tif (!(flags & ST)) {\n\t\t/*\n\t\t * This zeroes the top 4 bytes of the affected registers\n\t\t * in 64-bit mode, and also zeroes out any remaining\n\t\t * bytes of the last register for lsw*.\n\t\t */\n\t\tmemset(rptr, 0, ((nb + 3) / 4) * sizeof(unsigned long));\n\t\tif (nb0 > 0)\n\t\t\tmemset(&regs->gpr[0], 0,\n\t\t\t       ((nb0 + 3) / 4) * sizeof(unsigned long));\n\n\t\tfor (i = 0; i < nb; ++i, ++p)\n\t\t\tif (__get_user_inatomic(REG_BYTE(rptr, i ^ bswiz),\n\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\treturn -EFAULT;\n\t\tif (nb0 > 0) {\n\t\t\trptr = &regs->gpr[0];\n\t\t\taddr += nb;\n\t\t\tfor (i = 0; i < nb0; ++i, ++p)\n\t\t\t\tif (__get_user_inatomic(REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz),\n\t\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t} else {\n\t\tfor (i = 0; i < nb; ++i, ++p)\n\t\t\tif (__put_user_inatomic(REG_BYTE(rptr, i ^ bswiz),\n\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\treturn -EFAULT;\n\t\tif (nb0 > 0) {\n\t\t\trptr = &regs->gpr[0];\n\t\t\taddr += nb;\n\t\t\tfor (i = 0; i < nb0; ++i, ++p)\n\t\t\t\tif (__put_user_inatomic(REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz),\n\t\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define HARD\t0x80\t/* string, stwcx. */",
            "#define SX\t0x40\t/* ... byte count in XER */",
            "#define SW\t0x20\t/* byte swap */",
            "#define ST\t1\t/* store */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define HARD\t0x80\t/* string, stwcx. */\n#define SX\t0x40\t/* ... byte count in XER */\n#define SW\t0x20\t/* byte swap */\n#define ST\t1\t/* store */\n\nstatic int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,\n\t\t\t    unsigned int reg, unsigned int nb,\n\t\t\t    unsigned int flags, unsigned int instr,\n\t\t\t    unsigned long swiz)\n{\n\tunsigned long *rptr;\n\tunsigned int nb0, i, bswiz;\n\tunsigned long p;\n\n\t/*\n\t * We do not try to emulate 8 bytes multiple as they aren't really\n\t * available in our operating environments and we don't try to\n\t * emulate multiples operations in kernel land as they should never\n\t * be used/generated there at least not on unaligned boundaries\n\t */\n\tif (unlikely((nb > 4) || !user_mode(regs)))\n\t\treturn 0;\n\n\t/* lmw, stmw, lswi/x, stswi/x */\n\tnb0 = 0;\n\tif (flags & HARD) {\n\t\tif (flags & SX) {\n\t\t\tnb = regs->xer & 127;\n\t\t\tif (nb == 0)\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tunsigned long pc = regs->nip ^ (swiz & 4);\n\n\t\t\tif (__get_user_inatomic(instr,\n\t\t\t\t\t\t(unsigned int __user *)pc))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (swiz == 0 && (flags & SW))\n\t\t\t\tinstr = cpu_to_le32(instr);\n\t\t\tnb = (instr >> 11) & 0x1f;\n\t\t\tif (nb == 0)\n\t\t\t\tnb = 32;\n\t\t}\n\t\tif (nb + reg * 4 > 128) {\n\t\t\tnb0 = nb + reg * 4 - 128;\n\t\t\tnb = 128 - reg * 4;\n\t\t}\n#ifdef __LITTLE_ENDIAN__\n\t\t/*\n\t\t *  String instructions are endian neutral but the code\n\t\t *  below is not.  Force byte swapping on so that the\n\t\t *  effects of swizzling are undone in the load/store\n\t\t *  loops below.\n\t\t */\n\t\tflags ^= SW;\n#endif\n\t} else {\n\t\t/* lwm, stmw */\n\t\tnb = (32 - reg) * 4;\n\t}\n\n\tif (!access_ok((flags & ST ? VERIFY_WRITE: VERIFY_READ), addr, nb+nb0))\n\t\treturn -EFAULT;\t/* bad address */\n\n\trptr = &regs->gpr[reg];\n\tp = (unsigned long) addr;\n\tbswiz = (flags & SW)? 3: 0;\n\n\tif (!(flags & ST)) {\n\t\t/*\n\t\t * This zeroes the top 4 bytes of the affected registers\n\t\t * in 64-bit mode, and also zeroes out any remaining\n\t\t * bytes of the last register for lsw*.\n\t\t */\n\t\tmemset(rptr, 0, ((nb + 3) / 4) * sizeof(unsigned long));\n\t\tif (nb0 > 0)\n\t\t\tmemset(&regs->gpr[0], 0,\n\t\t\t       ((nb0 + 3) / 4) * sizeof(unsigned long));\n\n\t\tfor (i = 0; i < nb; ++i, ++p)\n\t\t\tif (__get_user_inatomic(REG_BYTE(rptr, i ^ bswiz),\n\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\treturn -EFAULT;\n\t\tif (nb0 > 0) {\n\t\t\trptr = &regs->gpr[0];\n\t\t\taddr += nb;\n\t\t\tfor (i = 0; i < nb0; ++i, ++p)\n\t\t\t\tif (__get_user_inatomic(REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz),\n\t\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t} else {\n\t\tfor (i = 0; i < nb; ++i, ++p)\n\t\t\tif (__put_user_inatomic(REG_BYTE(rptr, i ^ bswiz),\n\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\treturn -EFAULT;\n\t\tif (nb0 > 0) {\n\t\t\trptr = &regs->gpr[0];\n\t\t\taddr += nb;\n\t\t\tfor (i = 0; i < nb0; ++i, ++p)\n\t\t\t\tif (__put_user_inatomic(REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz),\n\t\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "multiple",
            "regs"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nb == 0"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_dcbz",
          "args": [
            "regs",
            "addr"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_dcbz",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
          "lines": "200-217",
          "snippet": "static int emulate_dcbz(struct pt_regs *regs, unsigned char __user *addr)\n{\n\tlong __user *p;\n\tint i, size;\n\n#ifdef __powerpc64__\n\tsize = ppc64_caches.dline_size;\n#else\n\tsize = L1_CACHE_BYTES;\n#endif\n\tp = (long __user *) (regs->dar & -size);\n\tif (user_mode(regs) && !access_ok(VERIFY_WRITE, p, size))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < size / sizeof(long); ++i)\n\t\tif (__put_user_inatomic(0, p+i))\n\t\t\treturn -EFAULT;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int emulate_dcbz(struct pt_regs *regs, unsigned char __user *addr)\n{\n\tlong __user *p;\n\tint i, size;\n\n#ifdef __powerpc64__\n\tsize = ppc64_caches.dline_size;\n#else\n\tsize = L1_CACHE_BYTES;\n#endif\n\tp = (long __user *) (regs->dar & -size);\n\tif (user_mode(regs) && !access_ok(VERIFY_WRITE, p, size))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < size / sizeof(long); ++i)\n\t\tif (__put_user_inatomic(0, p+i))\n\t\t\treturn -EFAULT;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "dcbz",
            "regs"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_vsx",
          "args": [
            "addr",
            "reg",
            "areg",
            "regs",
            "flags",
            "nb",
            "elsize"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_vsx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
          "lines": "644-725",
          "snippet": "static int emulate_vsx(unsigned char __user *addr, unsigned int reg,\n\t\t       unsigned int areg, struct pt_regs *regs,\n\t\t       unsigned int flags, unsigned int length,\n\t\t       unsigned int elsize)\n{\n\tchar *ptr;\n\tunsigned long *lptr;\n\tint ret = 0;\n\tint sw = 0;\n\tint i, j;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_vsx_to_thread(current);\n\n\tif (reg < 32)\n\t\tptr = (char *) &current->thread.fp_state.fpr[reg][0];\n\telse\n\t\tptr = (char *) &current->thread.vr_state.vr[reg - 32];\n\n\tlptr = (unsigned long *) ptr;\n\n#ifdef __LITTLE_ENDIAN__\n\tif (flags & SW) {\n\t\telsize = length;\n\t\tsw = length-1;\n\t} else {\n\t\t/*\n\t\t * The elements are BE ordered, even in LE mode, so process\n\t\t * them in reverse order.\n\t\t */\n\t\taddr += length - elsize;\n\n\t\t/* 8 byte memory accesses go in the top 8 bytes of the VR */\n\t\tif (length == 8)\n\t\t\tptr += 8;\n\t}\n#else\n\tif (flags & SW)\n\t\tsw = elsize-1;\n#endif\n\n\tfor (j = 0; j < length; j += elsize) {\n\t\tfor (i = 0; i < elsize; ++i) {\n\t\t\tif (flags & ST)\n\t\t\t\tret |= __put_user(ptr[i^sw], addr + i);\n\t\t\telse\n\t\t\t\tret |= __get_user(ptr[i^sw], addr + i);\n\t\t}\n\t\tptr  += elsize;\n#ifdef __LITTLE_ENDIAN__\n\t\taddr -= elsize;\n#else\n\t\taddr += elsize;\n#endif\n\t}\n\n#ifdef __BIG_ENDIAN__\n#define VSX_HI 0\n#define VSX_LO 1\n#else\n#define VSX_HI 1\n#define VSX_LO 0\n#endif\n\n\tif (!ret) {\n\t\tif (flags & U)\n\t\t\tregs->gpr[areg] = regs->dar;\n\n\t\t/* Splat load copies the same data to top and bottom 8 bytes */\n\t\tif (flags & SPLT)\n\t\t\tlptr[VSX_LO] = lptr[VSX_HI];\n\t\t/* For 8 byte loads, zero the low 8 bytes */\n\t\telse if (!(flags & ST) && (8 == length))\n\t\t\tlptr[VSX_LO] = 0;\n\t} else\n\t\treturn -EFAULT;\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define VSX_LO 0",
            "#define VSX_HI 1",
            "#define VSX_LO 1",
            "#define VSX_HI 0",
            "#define SPLT\t0x80\t/* VSX SPLAT load */",
            "#define SW\t0x20\t/* byte swap */",
            "#define U\t8\t/* update index register */",
            "#define ST\t1\t/* store */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define VSX_LO 0\n#define VSX_HI 1\n#define VSX_LO 1\n#define VSX_HI 0\n#define SPLT\t0x80\t/* VSX SPLAT load */\n#define SW\t0x20\t/* byte swap */\n#define U\t8\t/* update index register */\n#define ST\t1\t/* store */\n\nstatic int emulate_vsx(unsigned char __user *addr, unsigned int reg,\n\t\t       unsigned int areg, struct pt_regs *regs,\n\t\t       unsigned int flags, unsigned int length,\n\t\t       unsigned int elsize)\n{\n\tchar *ptr;\n\tunsigned long *lptr;\n\tint ret = 0;\n\tint sw = 0;\n\tint i, j;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_vsx_to_thread(current);\n\n\tif (reg < 32)\n\t\tptr = (char *) &current->thread.fp_state.fpr[reg][0];\n\telse\n\t\tptr = (char *) &current->thread.vr_state.vr[reg - 32];\n\n\tlptr = (unsigned long *) ptr;\n\n#ifdef __LITTLE_ENDIAN__\n\tif (flags & SW) {\n\t\telsize = length;\n\t\tsw = length-1;\n\t} else {\n\t\t/*\n\t\t * The elements are BE ordered, even in LE mode, so process\n\t\t * them in reverse order.\n\t\t */\n\t\taddr += length - elsize;\n\n\t\t/* 8 byte memory accesses go in the top 8 bytes of the VR */\n\t\tif (length == 8)\n\t\t\tptr += 8;\n\t}\n#else\n\tif (flags & SW)\n\t\tsw = elsize-1;\n#endif\n\n\tfor (j = 0; j < length; j += elsize) {\n\t\tfor (i = 0; i < elsize; ++i) {\n\t\t\tif (flags & ST)\n\t\t\t\tret |= __put_user(ptr[i^sw], addr + i);\n\t\t\telse\n\t\t\t\tret |= __get_user(ptr[i^sw], addr + i);\n\t\t}\n\t\tptr  += elsize;\n#ifdef __LITTLE_ENDIAN__\n\t\taddr -= elsize;\n#else\n\t\taddr += elsize;\n#endif\n\t}\n\n#ifdef __BIG_ENDIAN__\n#define VSX_HI 0\n#define VSX_LO 1\n#else\n#define VSX_HI 1\n#define VSX_LO 0\n#endif\n\n\tif (!ret) {\n\t\tif (flags & U)\n\t\t\tregs->gpr[areg] = regs->dar;\n\n\t\t/* Splat load copies the same data to top and bottom 8 bytes */\n\t\tif (flags & SPLT)\n\t\t\tlptr[VSX_LO] = lptr[VSX_HI];\n\t\t/* For 8 byte loads, zero the low 8 bytes */\n\t\telse if (!(flags & ST) && (8 == length))\n\t\t\tlptr[VSX_LO] = 0;\n\t} else\n\t\treturn -EFAULT;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "vsx",
            "regs"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_PPC_LE"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_XFORM",
          "args": [
            "instruction"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_XFORM",
          "args": [
            "instruction"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_spe",
          "args": [
            "regs",
            "reg",
            "instr"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_spe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
          "lines": "465-637",
          "snippet": "static int emulate_spe(struct pt_regs *regs, unsigned int reg,\n\t\t       unsigned int instr)\n{\n\tint ret;\n\tunion {\n\t\tu64 ll;\n\t\tu32 w[2];\n\t\tu16 h[4];\n\t\tu8 v[8];\n\t} data, temp;\n\tunsigned char __user *p, *addr;\n\tunsigned long *evr = &current->thread.evr[reg];\n\tunsigned int nb, flags;\n\n\tinstr = (instr >> 1) & 0x1f;\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n\tnb = spe_aligninfo[instr].len;\n\tflags = spe_aligninfo[instr].flags;\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)))\n\t\treturn -EFAULT;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_spe_to_thread(current);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (flags & ST) {\n\t\tdata.ll = 0;\n\t\tswitch (instr) {\n\t\tcase EVSTDD:\n\t\tcase EVSTDW:\n\t\tcase EVSTDH:\n\t\t\tdata.w[0] = *evr;\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tcase EVSTWHE:\n\t\t\tdata.h[2] = *evr >> 16;\n\t\t\tdata.h[3] = regs->gpr[reg] >> 16;\n\t\t\tbreak;\n\t\tcase EVSTWHO:\n\t\t\tdata.h[2] = *evr & 0xffff;\n\t\t\tdata.h[3] = regs->gpr[reg] & 0xffff;\n\t\t\tbreak;\n\t\tcase EVSTWWE:\n\t\t\tdata.w[1] = *evr;\n\t\t\tbreak;\n\t\tcase EVSTWWO:\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttemp.ll = data.ll = 0;\n\t\tret = 0;\n\t\tp = addr;\n\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __get_user_inatomic(temp.v[0], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[1], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[2], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[3], p++);\n\t\tcase 4:\n\t\t\tret |= __get_user_inatomic(temp.v[4], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[5], p++);\n\t\tcase 2:\n\t\t\tret |= __get_user_inatomic(temp.v[6], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[7], p++);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (instr) {\n\t\tcase EVLDD:\n\t\tcase EVLDW:\n\t\tcase EVLDH:\n\t\t\tdata.ll = temp.ll;\n\t\t\tbreak;\n\t\tcase EVLHHESPLAT:\n\t\t\tdata.h[0] = temp.h[3];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLHHOUSPLAT:\n\t\tcase EVLHHOSSPLAT:\n\t\t\tdata.h[1] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHE:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHOU:\n\t\tcase EVLWHOS:\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWWSPLAT:\n\t\t\tdata.w[0] = temp.w[1];\n\t\t\tdata.w[1] = temp.w[1];\n\t\t\tbreak;\n\t\tcase EVLWHSPLAT:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flags & SW) {\n\t\tswitch (flags & 0xf0) {\n\t\tcase E8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase E4:\n\t\t\tdata.w[0] = swab32(data.w[0]);\n\t\t\tdata.w[1] = swab32(data.w[1]);\n\t\t\tbreak;\n\t\t/* Its half word endian */\n\t\tdefault:\n\t\t\tdata.h[0] = swab16(data.h[0]);\n\t\t\tdata.h[1] = swab16(data.h[1]);\n\t\t\tdata.h[2] = swab16(data.h[2]);\n\t\t\tdata.h[3] = swab16(data.h[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & SE) {\n\t\tdata.w[0] = (s16)data.h[1];\n\t\tdata.w[1] = (s16)data.h[3];\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tret = 0;\n\t\tp = addr;\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __put_user_inatomic(data.v[0], p++);\n\t\t\tret |= __put_user_inatomic(data.v[1], p++);\n\t\t\tret |= __put_user_inatomic(data.v[2], p++);\n\t\t\tret |= __put_user_inatomic(data.v[3], p++);\n\t\tcase 4:\n\t\t\tret |= __put_user_inatomic(data.v[4], p++);\n\t\t\tret |= __put_user_inatomic(data.v[5], p++);\n\t\tcase 2:\n\t\t\tret |= __put_user_inatomic(data.v[6], p++);\n\t\t\tret |= __put_user_inatomic(data.v[7], p++);\n\t\t}\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t*evr = data.w[0];\n\t\tregs->gpr[reg] = data.w[1];\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include <asm/disassemble.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/emulated_ops.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cache.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/processor.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define\tEVSTWWO\t\t0x1E",
            "#define\tEVSTWWE\t\t0x1C",
            "#define\tEVSTWHO\t\t0x1A",
            "#define\tEVSTWHE\t\t0x18",
            "#define\tEVSTDH\t\t0x12",
            "#define\tEVSTDW\t\t0x11",
            "#define\tEVSTDD\t\t0x10",
            "#define\tEVLWHSPLAT\t0x0E",
            "#define\tEVLWWSPLAT\t0x0C",
            "#define\tEVLWHOS\t\t0x0B",
            "#define\tEVLWHOU\t\t0x0A",
            "#define\tEVLWHE\t\t0x08",
            "#define\tEVLHHOSSPLAT\t0x07",
            "#define\tEVLHHOUSPLAT\t0x06",
            "#define\tEVLHHESPLAT\t0x04",
            "#define\tEVLDH\t\t0x02",
            "#define\tEVLDW\t\t0x01",
            "#define\tEVLDD\t\t0x00",
            "#define E8\t0x80\t/* SPE endianness is double word */",
            "#define E4\t0x40\t/* SPE endianness is word */",
            "#define SW\t0x20\t/* byte swap */",
            "#define SE\t2\t/* sign-extend value, or FP ld/st as word */",
            "#define ST\t1\t/* store */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define\tEVSTWWO\t\t0x1E\n#define\tEVSTWWE\t\t0x1C\n#define\tEVSTWHO\t\t0x1A\n#define\tEVSTWHE\t\t0x18\n#define\tEVSTDH\t\t0x12\n#define\tEVSTDW\t\t0x11\n#define\tEVSTDD\t\t0x10\n#define\tEVLWHSPLAT\t0x0E\n#define\tEVLWWSPLAT\t0x0C\n#define\tEVLWHOS\t\t0x0B\n#define\tEVLWHOU\t\t0x0A\n#define\tEVLWHE\t\t0x08\n#define\tEVLHHOSSPLAT\t0x07\n#define\tEVLHHOUSPLAT\t0x06\n#define\tEVLHHESPLAT\t0x04\n#define\tEVLDH\t\t0x02\n#define\tEVLDW\t\t0x01\n#define\tEVLDD\t\t0x00\n#define E8\t0x80\t/* SPE endianness is double word */\n#define E4\t0x40\t/* SPE endianness is word */\n#define SW\t0x20\t/* byte swap */\n#define SE\t2\t/* sign-extend value, or FP ld/st as word */\n#define ST\t1\t/* store */\n\nstatic int emulate_spe(struct pt_regs *regs, unsigned int reg,\n\t\t       unsigned int instr)\n{\n\tint ret;\n\tunion {\n\t\tu64 ll;\n\t\tu32 w[2];\n\t\tu16 h[4];\n\t\tu8 v[8];\n\t} data, temp;\n\tunsigned char __user *p, *addr;\n\tunsigned long *evr = &current->thread.evr[reg];\n\tunsigned int nb, flags;\n\n\tinstr = (instr >> 1) & 0x1f;\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n\tnb = spe_aligninfo[instr].len;\n\tflags = spe_aligninfo[instr].flags;\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)))\n\t\treturn -EFAULT;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_spe_to_thread(current);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (flags & ST) {\n\t\tdata.ll = 0;\n\t\tswitch (instr) {\n\t\tcase EVSTDD:\n\t\tcase EVSTDW:\n\t\tcase EVSTDH:\n\t\t\tdata.w[0] = *evr;\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tcase EVSTWHE:\n\t\t\tdata.h[2] = *evr >> 16;\n\t\t\tdata.h[3] = regs->gpr[reg] >> 16;\n\t\t\tbreak;\n\t\tcase EVSTWHO:\n\t\t\tdata.h[2] = *evr & 0xffff;\n\t\t\tdata.h[3] = regs->gpr[reg] & 0xffff;\n\t\t\tbreak;\n\t\tcase EVSTWWE:\n\t\t\tdata.w[1] = *evr;\n\t\t\tbreak;\n\t\tcase EVSTWWO:\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttemp.ll = data.ll = 0;\n\t\tret = 0;\n\t\tp = addr;\n\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __get_user_inatomic(temp.v[0], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[1], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[2], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[3], p++);\n\t\tcase 4:\n\t\t\tret |= __get_user_inatomic(temp.v[4], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[5], p++);\n\t\tcase 2:\n\t\t\tret |= __get_user_inatomic(temp.v[6], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[7], p++);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (instr) {\n\t\tcase EVLDD:\n\t\tcase EVLDW:\n\t\tcase EVLDH:\n\t\t\tdata.ll = temp.ll;\n\t\t\tbreak;\n\t\tcase EVLHHESPLAT:\n\t\t\tdata.h[0] = temp.h[3];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLHHOUSPLAT:\n\t\tcase EVLHHOSSPLAT:\n\t\t\tdata.h[1] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHE:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHOU:\n\t\tcase EVLWHOS:\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWWSPLAT:\n\t\t\tdata.w[0] = temp.w[1];\n\t\t\tdata.w[1] = temp.w[1];\n\t\t\tbreak;\n\t\tcase EVLWHSPLAT:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flags & SW) {\n\t\tswitch (flags & 0xf0) {\n\t\tcase E8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase E4:\n\t\t\tdata.w[0] = swab32(data.w[0]);\n\t\t\tdata.w[1] = swab32(data.w[1]);\n\t\t\tbreak;\n\t\t/* Its half word endian */\n\t\tdefault:\n\t\t\tdata.h[0] = swab16(data.h[0]);\n\t\t\tdata.h[1] = swab16(data.h[1]);\n\t\t\tdata.h[2] = swab16(data.h[2]);\n\t\t\tdata.h[3] = swab16(data.h[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & SE) {\n\t\tdata.w[0] = (s16)data.h[1];\n\t\tdata.w[1] = (s16)data.h[3];\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tret = 0;\n\t\tp = addr;\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __put_user_inatomic(data.v[0], p++);\n\t\t\tret |= __put_user_inatomic(data.v[1], p++);\n\t\t\tret |= __put_user_inatomic(data.v[2], p++);\n\t\t\tret |= __put_user_inatomic(data.v[3], p++);\n\t\tcase 4:\n\t\t\tret |= __put_user_inatomic(data.v[4], p++);\n\t\t\tret |= __put_user_inatomic(data.v[5], p++);\n\t\tcase 2:\n\t\t\tret |= __put_user_inatomic(data.v[6], p++);\n\t\t\tret |= __put_user_inatomic(data.v[7], p++);\n\t\t}\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t*evr = data.w[0];\n\t\tregs->gpr[reg] = data.w[1];\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PPC_WARN_ALIGNMENT",
          "args": [
            "spe",
            "regs"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_dsisr",
          "args": [
            "instr"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "instr"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_REAL_LE"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__get_user_inatomic(instr,\n\t\t\t\t\t\t (unsigned int __user *)pc)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "instr",
            "(unsigned int __user *)pc"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_PPC_LE"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_NODSISRALIGN"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define DCBZ\t0x5f\t/* 8xx/82xx dcbz faults when cache not enabled */\n#define SPLT\t0x80\t/* VSX SPLAT load */\n#define S\t0x40\t/* single-precision fp or... */\n#define SW\t0x20\t/* byte swap */\n#define M\t0x10\t/* multiple load/store */\n#define U\t8\t/* update index register */\n#define F\t4\t/* to/from fp regs */\n#define SE\t2\t/* sign-extend value, or FP ld/st as word */\n#define ST\t1\t/* store */\n#define LD\t0\t/* load */\n\nstatic struct aligninfo aligninfo[128] = {\n\t{ 4, LD },\t\t/* 00 0 0000: lwz / lwarx */\n\tINVALID,\t\t/* 00 0 0001 */\n\t{ 4, ST },\t\t/* 00 0 0010: stw */\n\tINVALID,\t\t/* 00 0 0011 */\n\t{ 2, LD },\t\t/* 00 0 0100: lhz */\n\t{ 2, LD+SE },\t\t/* 00 0 0101: lha */\n\t{ 2, ST },\t\t/* 00 0 0110: sth */\n\t{ 4, LD+M },\t\t/* 00 0 0111: lmw */\n\t{ 4, LD+F+S },\t\t/* 00 0 1000: lfs */\n\t{ 8, LD+F },\t\t/* 00 0 1001: lfd */\n\t{ 4, ST+F+S },\t\t/* 00 0 1010: stfs */\n\t{ 8, ST+F },\t\t/* 00 0 1011: stfd */\n\t{ 16, LD },\t\t/* 00 0 1100: lq */\n\t{ 8, LD },\t\t/* 00 0 1101: ld/ldu/lwa */\n\tINVALID,\t\t/* 00 0 1110 */\n\t{ 8, ST },\t\t/* 00 0 1111: std/stdu */\n\t{ 4, LD+U },\t\t/* 00 1 0000: lwzu */\n\tINVALID,\t\t/* 00 1 0001 */\n\t{ 4, ST+U },\t\t/* 00 1 0010: stwu */\n\tINVALID,\t\t/* 00 1 0011 */\n\t{ 2, LD+U },\t\t/* 00 1 0100: lhzu */\n\t{ 2, LD+SE+U },\t\t/* 00 1 0101: lhau */\n\t{ 2, ST+U },\t\t/* 00 1 0110: sthu */\n\t{ 4, ST+M },\t\t/* 00 1 0111: stmw */\n\t{ 4, LD+F+S+U },\t/* 00 1 1000: lfsu */\n\t{ 8, LD+F+U },\t\t/* 00 1 1001: lfdu */\n\t{ 4, ST+F+S+U },\t/* 00 1 1010: stfsu */\n\t{ 8, ST+F+U },\t\t/* 00 1 1011: stfdu */\n\t{ 16, LD+F },\t\t/* 00 1 1100: lfdp */\n\tINVALID,\t\t/* 00 1 1101 */\n\t{ 16, ST+F },\t\t/* 00 1 1110: stfdp */\n\tINVALID,\t\t/* 00 1 1111 */\n\t{ 8, LD },\t\t/* 01 0 0000: ldx */\n\tINVALID,\t\t/* 01 0 0001 */\n\t{ 8, ST },\t\t/* 01 0 0010: stdx */\n\tINVALID,\t\t/* 01 0 0011 */\n\tINVALID,\t\t/* 01 0 0100 */\n\t{ 4, LD+SE },\t\t/* 01 0 0101: lwax */\n\tINVALID,\t\t/* 01 0 0110 */\n\tINVALID,\t\t/* 01 0 0111 */\n\t{ 4, LD+M+HARD+SX },\t/* 01 0 1000: lswx */\n\t{ 4, LD+M+HARD },\t/* 01 0 1001: lswi */\n\t{ 4, ST+M+HARD+SX },\t/* 01 0 1010: stswx */\n\t{ 4, ST+M+HARD },\t/* 01 0 1011: stswi */\n\tINVALID,\t\t/* 01 0 1100 */\n\t{ 8, LD+U },\t\t/* 01 0 1101: ldu */\n\tINVALID,\t\t/* 01 0 1110 */\n\t{ 8, ST+U },\t\t/* 01 0 1111: stdu */\n\t{ 8, LD+U },\t\t/* 01 1 0000: ldux */\n\tINVALID,\t\t/* 01 1 0001 */\n\t{ 8, ST+U },\t\t/* 01 1 0010: stdux */\n\tINVALID,\t\t/* 01 1 0011 */\n\tINVALID,\t\t/* 01 1 0100 */\n\t{ 4, LD+SE+U },\t\t/* 01 1 0101: lwaux */\n\tINVALID,\t\t/* 01 1 0110 */\n\tINVALID,\t\t/* 01 1 0111 */\n\tINVALID,\t\t/* 01 1 1000 */\n\tINVALID,\t\t/* 01 1 1001 */\n\tINVALID,\t\t/* 01 1 1010 */\n\tINVALID,\t\t/* 01 1 1011 */\n\tINVALID,\t\t/* 01 1 1100 */\n\tINVALID,\t\t/* 01 1 1101 */\n\tINVALID,\t\t/* 01 1 1110 */\n\tINVALID,\t\t/* 01 1 1111 */\n\tINVALID,\t\t/* 10 0 0000 */\n\tINVALID,\t\t/* 10 0 0001 */\n\tINVALID,\t\t/* 10 0 0010: stwcx. */\n\tINVALID,\t\t/* 10 0 0011 */\n\tINVALID,\t\t/* 10 0 0100 */\n\tINVALID,\t\t/* 10 0 0101 */\n\tINVALID,\t\t/* 10 0 0110 */\n\tINVALID,\t\t/* 10 0 0111 */\n\t{ 4, LD+SW },\t\t/* 10 0 1000: lwbrx */\n\tINVALID,\t\t/* 10 0 1001 */\n\t{ 4, ST+SW },\t\t/* 10 0 1010: stwbrx */\n\tINVALID,\t\t/* 10 0 1011 */\n\t{ 2, LD+SW },\t\t/* 10 0 1100: lhbrx */\n\t{ 4, LD+SE },\t\t/* 10 0 1101  lwa */\n\t{ 2, ST+SW },\t\t/* 10 0 1110: sthbrx */\n\t{ 16, ST },\t\t/* 10 0 1111: stq */\n\tINVALID,\t\t/* 10 1 0000 */\n\tINVALID,\t\t/* 10 1 0001 */\n\tINVALID,\t\t/* 10 1 0010 */\n\tINVALID,\t\t/* 10 1 0011 */\n\tINVALID,\t\t/* 10 1 0100 */\n\tINVALID,\t\t/* 10 1 0101 */\n\tINVALID,\t\t/* 10 1 0110 */\n\tINVALID,\t\t/* 10 1 0111 */\n\tINVALID,\t\t/* 10 1 1000 */\n\tINVALID,\t\t/* 10 1 1001 */\n\tINVALID,\t\t/* 10 1 1010 */\n\tINVALID,\t\t/* 10 1 1011 */\n\tINVALID,\t\t/* 10 1 1100 */\n\tINVALID,\t\t/* 10 1 1101 */\n\tINVALID,\t\t/* 10 1 1110 */\n\t{ 0, ST+HARD },\t\t/* 10 1 1111: dcbz */\n\t{ 4, LD },\t\t/* 11 0 0000: lwzx */\n\tINVALID,\t\t/* 11 0 0001 */\n\t{ 4, ST },\t\t/* 11 0 0010: stwx */\n\tINVALID,\t\t/* 11 0 0011 */\n\t{ 2, LD },\t\t/* 11 0 0100: lhzx */\n\t{ 2, LD+SE },\t\t/* 11 0 0101: lhax */\n\t{ 2, ST },\t\t/* 11 0 0110: sthx */\n\tINVALID,\t\t/* 11 0 0111 */\n\t{ 4, LD+F+S },\t\t/* 11 0 1000: lfsx */\n\t{ 8, LD+F },\t\t/* 11 0 1001: lfdx */\n\t{ 4, ST+F+S },\t\t/* 11 0 1010: stfsx */\n\t{ 8, ST+F },\t\t/* 11 0 1011: stfdx */\n\t{ 16, LD+F },\t\t/* 11 0 1100: lfdpx */\n\t{ 4, LD+F+SE },\t\t/* 11 0 1101: lfiwax */\n\t{ 16, ST+F },\t\t/* 11 0 1110: stfdpx */\n\t{ 4, ST+F },\t\t/* 11 0 1111: stfiwx */\n\t{ 4, LD+U },\t\t/* 11 1 0000: lwzux */\n\tINVALID,\t\t/* 11 1 0001 */\n\t{ 4, ST+U },\t\t/* 11 1 0010: stwux */\n\tINVALID,\t\t/* 11 1 0011 */\n\t{ 2, LD+U },\t\t/* 11 1 0100: lhzux */\n\t{ 2, LD+SE+U },\t\t/* 11 1 0101: lhaux */\n\t{ 2, ST+U },\t\t/* 11 1 0110: sthux */\n\tINVALID,\t\t/* 11 1 0111 */\n\t{ 4, LD+F+S+U },\t/* 11 1 1000: lfsux */\n\t{ 8, LD+F+U },\t\t/* 11 1 1001: lfdux */\n\t{ 4, ST+F+S+U },\t/* 11 1 1010: stfsux */\n\t{ 8, ST+F+U },\t\t/* 11 1 1011: stfdux */\n\tINVALID,\t\t/* 11 1 1100 */\n\t{ 4, LD+F },\t\t/* 11 1 1101: lfiwzx */\n\tINVALID,\t\t/* 11 1 1110 */\n\tINVALID,\t\t/* 11 1 1111 */\n};\n\nint fix_alignment(struct pt_regs *regs)\n{\n\tunsigned int instr, nb, flags, instruction = 0;\n\tunsigned int reg, areg;\n\tunsigned int dsisr;\n\tunsigned char __user *addr;\n\tunsigned long p, swiz;\n\tint ret, i;\n\tunion data {\n\t\tu64 ll;\n\t\tdouble dd;\n\t\tunsigned char v[8];\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN__\n\t\t\tint\t low32;\n\t\t\tunsigned hi32;\n#else\n\t\t\tunsigned hi32;\n\t\t\tint\t low32;\n#endif\n\t\t} x32;\n\t\tstruct {\n#ifdef __LITTLE_ENDIAN__\n\t\t\tshort\t      low16;\n\t\t\tunsigned char hi48[6];\n#else\n\t\t\tunsigned char hi48[6];\n\t\t\tshort\t      low16;\n#endif\n\t\t} x16;\n\t} data;\n\n\t/*\n\t * We require a complete register set, if not, then our assembly\n\t * is broken\n\t */\n\tCHECK_FULL_REGS(regs);\n\n\tdsisr = regs->dsisr;\n\n\t/* Some processors don't provide us with a DSISR we can use here,\n\t * let's make one up from the instruction\n\t */\n\tif (cpu_has_feature(CPU_FTR_NODSISRALIGN)) {\n\t\tunsigned long pc = regs->nip;\n\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE) && (regs->msr & MSR_LE))\n\t\t\tpc ^= 4;\n\t\tif (unlikely(__get_user_inatomic(instr,\n\t\t\t\t\t\t (unsigned int __user *)pc)))\n\t\t\treturn -EFAULT;\n\t\tif (cpu_has_feature(CPU_FTR_REAL_LE) && (regs->msr & MSR_LE))\n\t\t\tinstr = cpu_to_le32(instr);\n\t\tdsisr = make_dsisr(instr);\n\t\tinstruction = instr;\n\t}\n\n\t/* extract the operation and registers from the dsisr */\n\treg = (dsisr >> 5) & 0x1f;\t/* source/dest register */\n\tareg = dsisr & 0x1f;\t\t/* register to update */\n\n#ifdef CONFIG_SPE\n\tif ((instr >> 26) == 0x4) {\n\t\tPPC_WARN_ALIGNMENT(spe, regs);\n\t\treturn emulate_spe(regs, reg, instr);\n\t}\n#endif\n\n\tinstr = (dsisr >> 10) & 0x7f;\n\tinstr |= (dsisr >> 13) & 0x60;\n\n\t/* Lookup the operation in our table */\n\tnb = aligninfo[instr].len;\n\tflags = aligninfo[instr].flags;\n\n\t/* ldbrx/stdbrx overlap lfs/stfs in the DSISR unfortunately */\n\tif (IS_XFORM(instruction) && ((instruction >> 1) & 0x3ff) == 532) {\n\t\tnb = 8;\n\t\tflags = LD+SW;\n\t} else if (IS_XFORM(instruction) &&\n\t\t   ((instruction >> 1) & 0x3ff) == 660) {\n\t\tnb = 8;\n\t\tflags = ST+SW;\n\t}\n\n\t/* Byteswap little endian loads and stores */\n\tswiz = 0;\n\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE)) {\n\t\tflags ^= SW;\n#ifdef __BIG_ENDIAN__\n\t\t/*\n\t\t * So-called \"PowerPC little endian\" mode works by\n\t\t * swizzling addresses rather than by actually doing\n\t\t * any byte-swapping.  To emulate this, we XOR each\n\t\t * byte address with 7.  We also byte-swap, because\n\t\t * the processor's address swizzling depends on the\n\t\t * operand size (it xors the address with 7 for bytes,\n\t\t * 6 for halfwords, 4 for words, 0 for doublewords) but\n\t\t * we will xor with 7 and load/store each byte separately.\n\t\t */\n\t\tif (cpu_has_feature(CPU_FTR_PPC_LE))\n\t\t\tswiz = 7;\n#endif\n\t}\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n#ifdef CONFIG_VSX\n\tif ((instruction & 0xfc00003e) == 0x7c000018) {\n\t\tunsigned int elsize;\n\n\t\t/* Additional register addressing bit (64 VSX vs 32 FPR/GPR) */\n\t\treg |= (instruction & 0x1) << 5;\n\t\t/* Simple inline decoder instead of a table */\n\t\t/* VSX has only 8 and 16 byte memory accesses */\n\t\tnb = 8;\n\t\tif (instruction & 0x200)\n\t\t\tnb = 16;\n\n\t\t/* Vector stores in little-endian mode swap individual\n\t\t   elements, so process them separately */\n\t\telsize = 4;\n\t\tif (instruction & 0x80)\n\t\t\telsize = 8;\n\n\t\tflags = 0;\n\t\tif ((regs->msr & MSR_LE) != (MSR_KERNEL & MSR_LE))\n\t\t\tflags |= SW;\n\t\tif (instruction & 0x100)\n\t\t\tflags |= ST;\n\t\tif (instruction & 0x040)\n\t\t\tflags |= U;\n\t\t/* splat load needs a special decoder */\n\t\tif ((instruction & 0x400) == 0){\n\t\t\tflags |= SPLT;\n\t\t\tnb = 8;\n\t\t}\n\t\tPPC_WARN_ALIGNMENT(vsx, regs);\n\t\treturn emulate_vsx(addr, reg, areg, regs, flags, nb, elsize);\n\t}\n#endif\n\t/* A size of 0 indicates an instruction we don't support, with\n\t * the exception of DCBZ which is handled as a special case here\n\t */\n\tif (instr == DCBZ) {\n\t\tPPC_WARN_ALIGNMENT(dcbz, regs);\n\t\treturn emulate_dcbz(regs, addr);\n\t}\n\tif (unlikely(nb == 0))\n\t\treturn 0;\n\n\t/* Load/Store Multiple instructions are handled in their own\n\t * function\n\t */\n\tif (flags & M) {\n\t\tPPC_WARN_ALIGNMENT(multiple, regs);\n\t\treturn emulate_multiple(regs, addr, reg, nb,\n\t\t\t\t\tflags, instr, swiz);\n\t}\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)))\n\t\treturn -EFAULT;\n\n\t/* Force the fprs into the save area so we can reference them */\n\tif (flags & F) {\n\t\t/* userland only */\n\t\tif (unlikely(!user_mode(regs)))\n\t\t\treturn 0;\n\t\tflush_fp_to_thread(current);\n\t}\n\n\tif (nb == 16) {\n\t\tif (flags & F) {\n\t\t\t/* Special case for 16-byte FP loads and stores */\n\t\t\tPPC_WARN_ALIGNMENT(fp_pair, regs);\n\t\t\treturn emulate_fp_pair(addr, reg, flags);\n\t\t} else {\n#ifdef CONFIG_PPC64\n\t\t\t/* Special case for 16-byte loads and stores */\n\t\t\tPPC_WARN_ALIGNMENT(lq_stq, regs);\n\t\t\treturn emulate_lq_stq(regs, addr, reg, flags);\n#else\n\t\t\treturn 0;\n#endif\n\t\t}\n\t}\n\n\tPPC_WARN_ALIGNMENT(unaligned, regs);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (!(flags & ST)) {\n\t\tunsigned int start = 0;\n\n\t\tswitch (nb) {\n\t\tcase 4:\n\t\t\tstart = offsetof(union data, x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = offsetof(union data, x16.low16);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata.ll = 0;\n\t\tret = 0;\n\t\tp = (unsigned long)addr;\n\n\t\tfor (i = 0; i < nb; i++)\n\t\t\tret |= __get_user_inatomic(data.v[start + i],\n\t\t\t\t\t\t   SWIZ_PTR(p++));\n\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\n\t} else if (flags & F) {\n\t\tdata.ll = current->thread.TS_FPR(reg);\n\t\tif (flags & S) {\n\t\t\t/* Single-precision FP store requires conversion... */\n#ifdef CONFIG_PPC_FPU\n\t\t\tpreempt_disable();\n\t\t\tenable_kernel_fp();\n\t\t\tcvt_df(&data.dd, (float *)&data.x32.low32);\n\t\t\tpreempt_enable();\n#else\n\t\t\treturn 0;\n#endif\n\t\t}\n\t} else\n\t\tdata.ll = regs->gpr[reg];\n\n\tif (flags & SW) {\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdata.x32.low32 = swab32(data.x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata.x16.low16 = swab16(data.x16.low16);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Perform other misc operations like sign extension\n\t * or floating point single precision conversion\n\t */\n\tswitch (flags & ~(U|SW)) {\n\tcase LD+SE:\t/* sign extending integer loads */\n\tcase LD+F+SE:\t/* sign extend for lfiwax */\n\t\tif ( nb == 2 )\n\t\t\tdata.ll = data.x16.low16;\n\t\telse\t/* nb must be 4 */\n\t\t\tdata.ll = data.x32.low32;\n\t\tbreak;\n\n\t/* Single-precision FP load requires conversion... */\n\tcase LD+F+S:\n#ifdef CONFIG_PPC_FPU\n\t\tpreempt_disable();\n\t\tenable_kernel_fp();\n\t\tcvt_fd((float *)&data.x32.low32, &data.dd);\n\t\tpreempt_enable();\n#else\n\t\treturn 0;\n#endif\n\t\tbreak;\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tunsigned int start = 0;\n\n\t\tswitch (nb) {\n\t\tcase 4:\n\t\t\tstart = offsetof(union data, x32.low32);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = offsetof(union data, x16.low16);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = 0;\n\t\tp = (unsigned long)addr;\n\n\t\tfor (i = 0; i < nb; i++)\n\t\t\tret |= __put_user_inatomic(data.v[start + i],\n\t\t\t\t\t\t   SWIZ_PTR(p++));\n\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else if (flags & F)\n\t\tcurrent->thread.TS_FPR(reg) = data.ll;\n\telse\n\t\tregs->gpr[reg] = data.ll;\n\n\t/* Update RA as needed */\n\tif (flags & U)\n\t\tregs->gpr[areg] = regs->dar;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "emulate_vsx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
    "lines": "644-725",
    "snippet": "static int emulate_vsx(unsigned char __user *addr, unsigned int reg,\n\t\t       unsigned int areg, struct pt_regs *regs,\n\t\t       unsigned int flags, unsigned int length,\n\t\t       unsigned int elsize)\n{\n\tchar *ptr;\n\tunsigned long *lptr;\n\tint ret = 0;\n\tint sw = 0;\n\tint i, j;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_vsx_to_thread(current);\n\n\tif (reg < 32)\n\t\tptr = (char *) &current->thread.fp_state.fpr[reg][0];\n\telse\n\t\tptr = (char *) &current->thread.vr_state.vr[reg - 32];\n\n\tlptr = (unsigned long *) ptr;\n\n#ifdef __LITTLE_ENDIAN__\n\tif (flags & SW) {\n\t\telsize = length;\n\t\tsw = length-1;\n\t} else {\n\t\t/*\n\t\t * The elements are BE ordered, even in LE mode, so process\n\t\t * them in reverse order.\n\t\t */\n\t\taddr += length - elsize;\n\n\t\t/* 8 byte memory accesses go in the top 8 bytes of the VR */\n\t\tif (length == 8)\n\t\t\tptr += 8;\n\t}\n#else\n\tif (flags & SW)\n\t\tsw = elsize-1;\n#endif\n\n\tfor (j = 0; j < length; j += elsize) {\n\t\tfor (i = 0; i < elsize; ++i) {\n\t\t\tif (flags & ST)\n\t\t\t\tret |= __put_user(ptr[i^sw], addr + i);\n\t\t\telse\n\t\t\t\tret |= __get_user(ptr[i^sw], addr + i);\n\t\t}\n\t\tptr  += elsize;\n#ifdef __LITTLE_ENDIAN__\n\t\taddr -= elsize;\n#else\n\t\taddr += elsize;\n#endif\n\t}\n\n#ifdef __BIG_ENDIAN__\n#define VSX_HI 0\n#define VSX_LO 1\n#else\n#define VSX_HI 1\n#define VSX_LO 0\n#endif\n\n\tif (!ret) {\n\t\tif (flags & U)\n\t\t\tregs->gpr[areg] = regs->dar;\n\n\t\t/* Splat load copies the same data to top and bottom 8 bytes */\n\t\tif (flags & SPLT)\n\t\t\tlptr[VSX_LO] = lptr[VSX_HI];\n\t\t/* For 8 byte loads, zero the low 8 bytes */\n\t\telse if (!(flags & ST) && (8 == length))\n\t\t\tlptr[VSX_LO] = 0;\n\t} else\n\t\treturn -EFAULT;\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define VSX_LO 0",
      "#define VSX_HI 1",
      "#define VSX_LO 1",
      "#define VSX_HI 0",
      "#define SPLT\t0x80\t/* VSX SPLAT load */",
      "#define SW\t0x20\t/* byte swap */",
      "#define U\t8\t/* update index register */",
      "#define ST\t1\t/* store */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "ptr[i^sw]",
            "addr + i"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ptr[i^sw]",
            "addr + i"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "current"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "230-242",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!user_mode(regs)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define VSX_LO 0\n#define VSX_HI 1\n#define VSX_LO 1\n#define VSX_HI 0\n#define SPLT\t0x80\t/* VSX SPLAT load */\n#define SW\t0x20\t/* byte swap */\n#define U\t8\t/* update index register */\n#define ST\t1\t/* store */\n\nstatic int emulate_vsx(unsigned char __user *addr, unsigned int reg,\n\t\t       unsigned int areg, struct pt_regs *regs,\n\t\t       unsigned int flags, unsigned int length,\n\t\t       unsigned int elsize)\n{\n\tchar *ptr;\n\tunsigned long *lptr;\n\tint ret = 0;\n\tint sw = 0;\n\tint i, j;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_vsx_to_thread(current);\n\n\tif (reg < 32)\n\t\tptr = (char *) &current->thread.fp_state.fpr[reg][0];\n\telse\n\t\tptr = (char *) &current->thread.vr_state.vr[reg - 32];\n\n\tlptr = (unsigned long *) ptr;\n\n#ifdef __LITTLE_ENDIAN__\n\tif (flags & SW) {\n\t\telsize = length;\n\t\tsw = length-1;\n\t} else {\n\t\t/*\n\t\t * The elements are BE ordered, even in LE mode, so process\n\t\t * them in reverse order.\n\t\t */\n\t\taddr += length - elsize;\n\n\t\t/* 8 byte memory accesses go in the top 8 bytes of the VR */\n\t\tif (length == 8)\n\t\t\tptr += 8;\n\t}\n#else\n\tif (flags & SW)\n\t\tsw = elsize-1;\n#endif\n\n\tfor (j = 0; j < length; j += elsize) {\n\t\tfor (i = 0; i < elsize; ++i) {\n\t\t\tif (flags & ST)\n\t\t\t\tret |= __put_user(ptr[i^sw], addr + i);\n\t\t\telse\n\t\t\t\tret |= __get_user(ptr[i^sw], addr + i);\n\t\t}\n\t\tptr  += elsize;\n#ifdef __LITTLE_ENDIAN__\n\t\taddr -= elsize;\n#else\n\t\taddr += elsize;\n#endif\n\t}\n\n#ifdef __BIG_ENDIAN__\n#define VSX_HI 0\n#define VSX_LO 1\n#else\n#define VSX_HI 1\n#define VSX_LO 0\n#endif\n\n\tif (!ret) {\n\t\tif (flags & U)\n\t\t\tregs->gpr[areg] = regs->dar;\n\n\t\t/* Splat load copies the same data to top and bottom 8 bytes */\n\t\tif (flags & SPLT)\n\t\t\tlptr[VSX_LO] = lptr[VSX_HI];\n\t\t/* For 8 byte loads, zero the low 8 bytes */\n\t\telse if (!(flags & ST) && (8 == length))\n\t\t\tlptr[VSX_LO] = 0;\n\t} else\n\t\treturn -EFAULT;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "emulate_spe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
    "lines": "465-637",
    "snippet": "static int emulate_spe(struct pt_regs *regs, unsigned int reg,\n\t\t       unsigned int instr)\n{\n\tint ret;\n\tunion {\n\t\tu64 ll;\n\t\tu32 w[2];\n\t\tu16 h[4];\n\t\tu8 v[8];\n\t} data, temp;\n\tunsigned char __user *p, *addr;\n\tunsigned long *evr = &current->thread.evr[reg];\n\tunsigned int nb, flags;\n\n\tinstr = (instr >> 1) & 0x1f;\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n\tnb = spe_aligninfo[instr].len;\n\tflags = spe_aligninfo[instr].flags;\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)))\n\t\treturn -EFAULT;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_spe_to_thread(current);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (flags & ST) {\n\t\tdata.ll = 0;\n\t\tswitch (instr) {\n\t\tcase EVSTDD:\n\t\tcase EVSTDW:\n\t\tcase EVSTDH:\n\t\t\tdata.w[0] = *evr;\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tcase EVSTWHE:\n\t\t\tdata.h[2] = *evr >> 16;\n\t\t\tdata.h[3] = regs->gpr[reg] >> 16;\n\t\t\tbreak;\n\t\tcase EVSTWHO:\n\t\t\tdata.h[2] = *evr & 0xffff;\n\t\t\tdata.h[3] = regs->gpr[reg] & 0xffff;\n\t\t\tbreak;\n\t\tcase EVSTWWE:\n\t\t\tdata.w[1] = *evr;\n\t\t\tbreak;\n\t\tcase EVSTWWO:\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttemp.ll = data.ll = 0;\n\t\tret = 0;\n\t\tp = addr;\n\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __get_user_inatomic(temp.v[0], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[1], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[2], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[3], p++);\n\t\tcase 4:\n\t\t\tret |= __get_user_inatomic(temp.v[4], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[5], p++);\n\t\tcase 2:\n\t\t\tret |= __get_user_inatomic(temp.v[6], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[7], p++);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (instr) {\n\t\tcase EVLDD:\n\t\tcase EVLDW:\n\t\tcase EVLDH:\n\t\t\tdata.ll = temp.ll;\n\t\t\tbreak;\n\t\tcase EVLHHESPLAT:\n\t\t\tdata.h[0] = temp.h[3];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLHHOUSPLAT:\n\t\tcase EVLHHOSSPLAT:\n\t\t\tdata.h[1] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHE:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHOU:\n\t\tcase EVLWHOS:\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWWSPLAT:\n\t\t\tdata.w[0] = temp.w[1];\n\t\t\tdata.w[1] = temp.w[1];\n\t\t\tbreak;\n\t\tcase EVLWHSPLAT:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flags & SW) {\n\t\tswitch (flags & 0xf0) {\n\t\tcase E8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase E4:\n\t\t\tdata.w[0] = swab32(data.w[0]);\n\t\t\tdata.w[1] = swab32(data.w[1]);\n\t\t\tbreak;\n\t\t/* Its half word endian */\n\t\tdefault:\n\t\t\tdata.h[0] = swab16(data.h[0]);\n\t\t\tdata.h[1] = swab16(data.h[1]);\n\t\t\tdata.h[2] = swab16(data.h[2]);\n\t\t\tdata.h[3] = swab16(data.h[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & SE) {\n\t\tdata.w[0] = (s16)data.h[1];\n\t\tdata.w[1] = (s16)data.h[3];\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tret = 0;\n\t\tp = addr;\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __put_user_inatomic(data.v[0], p++);\n\t\t\tret |= __put_user_inatomic(data.v[1], p++);\n\t\t\tret |= __put_user_inatomic(data.v[2], p++);\n\t\t\tret |= __put_user_inatomic(data.v[3], p++);\n\t\tcase 4:\n\t\t\tret |= __put_user_inatomic(data.v[4], p++);\n\t\t\tret |= __put_user_inatomic(data.v[5], p++);\n\t\tcase 2:\n\t\t\tret |= __put_user_inatomic(data.v[6], p++);\n\t\t\tret |= __put_user_inatomic(data.v[7], p++);\n\t\t}\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t*evr = data.w[0];\n\t\tregs->gpr[reg] = data.w[1];\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define\tEVSTWWO\t\t0x1E",
      "#define\tEVSTWWE\t\t0x1C",
      "#define\tEVSTWHO\t\t0x1A",
      "#define\tEVSTWHE\t\t0x18",
      "#define\tEVSTDH\t\t0x12",
      "#define\tEVSTDW\t\t0x11",
      "#define\tEVSTDD\t\t0x10",
      "#define\tEVLWHSPLAT\t0x0E",
      "#define\tEVLWWSPLAT\t0x0C",
      "#define\tEVLWHOS\t\t0x0B",
      "#define\tEVLWHOU\t\t0x0A",
      "#define\tEVLWHE\t\t0x08",
      "#define\tEVLHHOSSPLAT\t0x07",
      "#define\tEVLHHOUSPLAT\t0x06",
      "#define\tEVLHHESPLAT\t0x04",
      "#define\tEVLDH\t\t0x02",
      "#define\tEVLDW\t\t0x01",
      "#define\tEVLDD\t\t0x00",
      "#define E8\t0x80\t/* SPE endianness is double word */",
      "#define E4\t0x40\t/* SPE endianness is word */",
      "#define SW\t0x20\t/* byte swap */",
      "#define SE\t2\t/* sign-extend value, or FP ld/st as word */",
      "#define ST\t1\t/* store */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[7]",
            "p++"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[6]",
            "p++"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[5]",
            "p++"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[4]",
            "p++"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[3]",
            "p++"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[2]",
            "p++"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[1]",
            "p++"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "data.v[0]",
            "p++"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.h[3]"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.h[2]"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.h[1]"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab16",
          "args": [
            "data.h[0]"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32",
          "args": [
            "data.w[1]"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab32",
          "args": [
            "data.w[0]"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swab64",
          "args": [
            "data.ll"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[7]",
            "p++"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[6]",
            "p++"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[5]",
            "p++"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[4]",
            "p++"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[3]",
            "p++"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[2]",
            "p++"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[1]",
            "p++"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "temp.v[0]",
            "p++"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "current"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "263-276",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!user_mode(regs)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "(flags & ST ? VERIFY_WRITE : VERIFY_READ)",
            "addr",
            "nb"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define\tEVSTWWO\t\t0x1E\n#define\tEVSTWWE\t\t0x1C\n#define\tEVSTWHO\t\t0x1A\n#define\tEVSTWHE\t\t0x18\n#define\tEVSTDH\t\t0x12\n#define\tEVSTDW\t\t0x11\n#define\tEVSTDD\t\t0x10\n#define\tEVLWHSPLAT\t0x0E\n#define\tEVLWWSPLAT\t0x0C\n#define\tEVLWHOS\t\t0x0B\n#define\tEVLWHOU\t\t0x0A\n#define\tEVLWHE\t\t0x08\n#define\tEVLHHOSSPLAT\t0x07\n#define\tEVLHHOUSPLAT\t0x06\n#define\tEVLHHESPLAT\t0x04\n#define\tEVLDH\t\t0x02\n#define\tEVLDW\t\t0x01\n#define\tEVLDD\t\t0x00\n#define E8\t0x80\t/* SPE endianness is double word */\n#define E4\t0x40\t/* SPE endianness is word */\n#define SW\t0x20\t/* byte swap */\n#define SE\t2\t/* sign-extend value, or FP ld/st as word */\n#define ST\t1\t/* store */\n\nstatic int emulate_spe(struct pt_regs *regs, unsigned int reg,\n\t\t       unsigned int instr)\n{\n\tint ret;\n\tunion {\n\t\tu64 ll;\n\t\tu32 w[2];\n\t\tu16 h[4];\n\t\tu8 v[8];\n\t} data, temp;\n\tunsigned char __user *p, *addr;\n\tunsigned long *evr = &current->thread.evr[reg];\n\tunsigned int nb, flags;\n\n\tinstr = (instr >> 1) & 0x1f;\n\n\t/* DAR has the operand effective address */\n\taddr = (unsigned char __user *)regs->dar;\n\n\tnb = spe_aligninfo[instr].len;\n\tflags = spe_aligninfo[instr].flags;\n\n\t/* Verify the address of the operand */\n\tif (unlikely(user_mode(regs) &&\n\t\t     !access_ok((flags & ST ? VERIFY_WRITE : VERIFY_READ),\n\t\t\t\taddr, nb)))\n\t\treturn -EFAULT;\n\n\t/* userland only */\n\tif (unlikely(!user_mode(regs)))\n\t\treturn 0;\n\n\tflush_spe_to_thread(current);\n\n\t/* If we are loading, get the data from user space, else\n\t * get it from register values\n\t */\n\tif (flags & ST) {\n\t\tdata.ll = 0;\n\t\tswitch (instr) {\n\t\tcase EVSTDD:\n\t\tcase EVSTDW:\n\t\tcase EVSTDH:\n\t\t\tdata.w[0] = *evr;\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tcase EVSTWHE:\n\t\t\tdata.h[2] = *evr >> 16;\n\t\t\tdata.h[3] = regs->gpr[reg] >> 16;\n\t\t\tbreak;\n\t\tcase EVSTWHO:\n\t\t\tdata.h[2] = *evr & 0xffff;\n\t\t\tdata.h[3] = regs->gpr[reg] & 0xffff;\n\t\t\tbreak;\n\t\tcase EVSTWWE:\n\t\t\tdata.w[1] = *evr;\n\t\t\tbreak;\n\t\tcase EVSTWWO:\n\t\t\tdata.w[1] = regs->gpr[reg];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\ttemp.ll = data.ll = 0;\n\t\tret = 0;\n\t\tp = addr;\n\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __get_user_inatomic(temp.v[0], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[1], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[2], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[3], p++);\n\t\tcase 4:\n\t\t\tret |= __get_user_inatomic(temp.v[4], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[5], p++);\n\t\tcase 2:\n\t\t\tret |= __get_user_inatomic(temp.v[6], p++);\n\t\t\tret |= __get_user_inatomic(temp.v[7], p++);\n\t\t\tif (unlikely(ret))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tswitch (instr) {\n\t\tcase EVLDD:\n\t\tcase EVLDW:\n\t\tcase EVLDH:\n\t\t\tdata.ll = temp.ll;\n\t\t\tbreak;\n\t\tcase EVLHHESPLAT:\n\t\t\tdata.h[0] = temp.h[3];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLHHOUSPLAT:\n\t\tcase EVLHHOSSPLAT:\n\t\t\tdata.h[1] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHE:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWHOU:\n\t\tcase EVLWHOS:\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tcase EVLWWSPLAT:\n\t\t\tdata.w[0] = temp.w[1];\n\t\t\tdata.w[1] = temp.w[1];\n\t\t\tbreak;\n\t\tcase EVLWHSPLAT:\n\t\t\tdata.h[0] = temp.h[2];\n\t\t\tdata.h[1] = temp.h[2];\n\t\t\tdata.h[2] = temp.h[3];\n\t\t\tdata.h[3] = temp.h[3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (flags & SW) {\n\t\tswitch (flags & 0xf0) {\n\t\tcase E8:\n\t\t\tdata.ll = swab64(data.ll);\n\t\t\tbreak;\n\t\tcase E4:\n\t\t\tdata.w[0] = swab32(data.w[0]);\n\t\t\tdata.w[1] = swab32(data.w[1]);\n\t\t\tbreak;\n\t\t/* Its half word endian */\n\t\tdefault:\n\t\t\tdata.h[0] = swab16(data.h[0]);\n\t\t\tdata.h[1] = swab16(data.h[1]);\n\t\t\tdata.h[2] = swab16(data.h[2]);\n\t\t\tdata.h[3] = swab16(data.h[3]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flags & SE) {\n\t\tdata.w[0] = (s16)data.h[1];\n\t\tdata.w[1] = (s16)data.h[3];\n\t}\n\n\t/* Store result to memory or update registers */\n\tif (flags & ST) {\n\t\tret = 0;\n\t\tp = addr;\n\t\tswitch (nb) {\n\t\tcase 8:\n\t\t\tret |= __put_user_inatomic(data.v[0], p++);\n\t\t\tret |= __put_user_inatomic(data.v[1], p++);\n\t\t\tret |= __put_user_inatomic(data.v[2], p++);\n\t\t\tret |= __put_user_inatomic(data.v[3], p++);\n\t\tcase 4:\n\t\t\tret |= __put_user_inatomic(data.v[4], p++);\n\t\t\tret |= __put_user_inatomic(data.v[5], p++);\n\t\tcase 2:\n\t\t\tret |= __put_user_inatomic(data.v[6], p++);\n\t\t\tret |= __put_user_inatomic(data.v[7], p++);\n\t\t}\n\t\tif (unlikely(ret))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\t*evr = data.w[0];\n\t\tregs->gpr[reg] = data.w[1];\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "emulate_lq_stq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
    "lines": "376-400",
    "snippet": "static int emulate_lq_stq(struct pt_regs *regs, unsigned char __user *addr,\n\t\t\t  unsigned int reg, unsigned int flags)\n{\n\tchar *ptr0 = (char *)&regs->gpr[reg];\n\tchar *ptr1 = (char *)&regs->gpr[reg+1];\n\tint i, ret, sw = 0;\n\n\tif (reg & 1)\n\t\treturn 0;\t/* invalid form: GPR must be even */\n\tif (flags & SW)\n\t\tsw = 7;\n\tret = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!(flags & ST)) {\n\t\t\tret |= __get_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __get_user(ptr1[i^sw], addr + i + 8);\n\t\t} else {\n\t\t\tret |= __put_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __put_user(ptr1[i^sw], addr + i + 8);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 1;\t/* exception handled and fixed up */\n}",
    "includes": [
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SW\t0x20\t/* byte swap */",
      "#define ST\t1\t/* store */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ptr1[i^sw]",
            "addr + i + 8"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ptr0[i^sw]",
            "addr + i"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "ptr1[i^sw]",
            "addr + i + 8"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "ptr0[i^sw]",
            "addr + i"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define SW\t0x20\t/* byte swap */\n#define ST\t1\t/* store */\n\nstatic int emulate_lq_stq(struct pt_regs *regs, unsigned char __user *addr,\n\t\t\t  unsigned int reg, unsigned int flags)\n{\n\tchar *ptr0 = (char *)&regs->gpr[reg];\n\tchar *ptr1 = (char *)&regs->gpr[reg+1];\n\tint i, ret, sw = 0;\n\n\tif (reg & 1)\n\t\treturn 0;\t/* invalid form: GPR must be even */\n\tif (flags & SW)\n\t\tsw = 7;\n\tret = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!(flags & ST)) {\n\t\t\tret |= __get_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __get_user(ptr1[i^sw], addr + i + 8);\n\t\t} else {\n\t\t\tret |= __put_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __put_user(ptr1[i^sw], addr + i + 8);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 1;\t/* exception handled and fixed up */\n}"
  },
  {
    "function_name": "emulate_fp_pair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
    "lines": "349-373",
    "snippet": "static int emulate_fp_pair(unsigned char __user *addr, unsigned int reg,\n\t\t\t   unsigned int flags)\n{\n\tchar *ptr0 = (char *) &current->thread.TS_FPR(reg);\n\tchar *ptr1 = (char *) &current->thread.TS_FPR(reg+1);\n\tint i, ret, sw = 0;\n\n\tif (reg & 1)\n\t\treturn 0;\t/* invalid form: FRS/FRT must be even */\n\tif (flags & SW)\n\t\tsw = 7;\n\tret = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!(flags & ST)) {\n\t\t\tret |= __get_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __get_user(ptr1[i^sw], addr + i + 8);\n\t\t} else {\n\t\t\tret |= __put_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __put_user(ptr1[i^sw], addr + i + 8);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 1;\t/* exception handled and fixed up */\n}",
    "includes": [
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SW\t0x20\t/* byte swap */",
      "#define ST\t1\t/* store */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ptr1[i^sw]",
            "addr + i + 8"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ptr0[i^sw]",
            "addr + i"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "ptr1[i^sw]",
            "addr + i + 8"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "ptr0[i^sw]",
            "addr + i"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current->thread.TS_FPR",
          "args": [
            "reg+1"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current->thread.TS_FPR",
          "args": [
            "reg"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define SW\t0x20\t/* byte swap */\n#define ST\t1\t/* store */\n\nstatic int emulate_fp_pair(unsigned char __user *addr, unsigned int reg,\n\t\t\t   unsigned int flags)\n{\n\tchar *ptr0 = (char *) &current->thread.TS_FPR(reg);\n\tchar *ptr1 = (char *) &current->thread.TS_FPR(reg+1);\n\tint i, ret, sw = 0;\n\n\tif (reg & 1)\n\t\treturn 0;\t/* invalid form: FRS/FRT must be even */\n\tif (flags & SW)\n\t\tsw = 7;\n\tret = 0;\n\tfor (i = 0; i < 8; ++i) {\n\t\tif (!(flags & ST)) {\n\t\t\tret |= __get_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __get_user(ptr1[i^sw], addr + i + 8);\n\t\t} else {\n\t\t\tret |= __put_user(ptr0[i^sw], addr + i);\n\t\t\tret |= __put_user(ptr1[i^sw], addr + i + 8);\n\t\t}\n\t}\n\tif (ret)\n\t\treturn -EFAULT;\n\treturn 1;\t/* exception handled and fixed up */\n}"
  },
  {
    "function_name": "emulate_multiple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
    "lines": "239-342",
    "snippet": "static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,\n\t\t\t    unsigned int reg, unsigned int nb,\n\t\t\t    unsigned int flags, unsigned int instr,\n\t\t\t    unsigned long swiz)\n{\n\tunsigned long *rptr;\n\tunsigned int nb0, i, bswiz;\n\tunsigned long p;\n\n\t/*\n\t * We do not try to emulate 8 bytes multiple as they aren't really\n\t * available in our operating environments and we don't try to\n\t * emulate multiples operations in kernel land as they should never\n\t * be used/generated there at least not on unaligned boundaries\n\t */\n\tif (unlikely((nb > 4) || !user_mode(regs)))\n\t\treturn 0;\n\n\t/* lmw, stmw, lswi/x, stswi/x */\n\tnb0 = 0;\n\tif (flags & HARD) {\n\t\tif (flags & SX) {\n\t\t\tnb = regs->xer & 127;\n\t\t\tif (nb == 0)\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tunsigned long pc = regs->nip ^ (swiz & 4);\n\n\t\t\tif (__get_user_inatomic(instr,\n\t\t\t\t\t\t(unsigned int __user *)pc))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (swiz == 0 && (flags & SW))\n\t\t\t\tinstr = cpu_to_le32(instr);\n\t\t\tnb = (instr >> 11) & 0x1f;\n\t\t\tif (nb == 0)\n\t\t\t\tnb = 32;\n\t\t}\n\t\tif (nb + reg * 4 > 128) {\n\t\t\tnb0 = nb + reg * 4 - 128;\n\t\t\tnb = 128 - reg * 4;\n\t\t}\n#ifdef __LITTLE_ENDIAN__\n\t\t/*\n\t\t *  String instructions are endian neutral but the code\n\t\t *  below is not.  Force byte swapping on so that the\n\t\t *  effects of swizzling are undone in the load/store\n\t\t *  loops below.\n\t\t */\n\t\tflags ^= SW;\n#endif\n\t} else {\n\t\t/* lwm, stmw */\n\t\tnb = (32 - reg) * 4;\n\t}\n\n\tif (!access_ok((flags & ST ? VERIFY_WRITE: VERIFY_READ), addr, nb+nb0))\n\t\treturn -EFAULT;\t/* bad address */\n\n\trptr = &regs->gpr[reg];\n\tp = (unsigned long) addr;\n\tbswiz = (flags & SW)? 3: 0;\n\n\tif (!(flags & ST)) {\n\t\t/*\n\t\t * This zeroes the top 4 bytes of the affected registers\n\t\t * in 64-bit mode, and also zeroes out any remaining\n\t\t * bytes of the last register for lsw*.\n\t\t */\n\t\tmemset(rptr, 0, ((nb + 3) / 4) * sizeof(unsigned long));\n\t\tif (nb0 > 0)\n\t\t\tmemset(&regs->gpr[0], 0,\n\t\t\t       ((nb0 + 3) / 4) * sizeof(unsigned long));\n\n\t\tfor (i = 0; i < nb; ++i, ++p)\n\t\t\tif (__get_user_inatomic(REG_BYTE(rptr, i ^ bswiz),\n\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\treturn -EFAULT;\n\t\tif (nb0 > 0) {\n\t\t\trptr = &regs->gpr[0];\n\t\t\taddr += nb;\n\t\t\tfor (i = 0; i < nb0; ++i, ++p)\n\t\t\t\tif (__get_user_inatomic(REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz),\n\t\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t} else {\n\t\tfor (i = 0; i < nb; ++i, ++p)\n\t\t\tif (__put_user_inatomic(REG_BYTE(rptr, i ^ bswiz),\n\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\treturn -EFAULT;\n\t\tif (nb0 > 0) {\n\t\t\trptr = &regs->gpr[0];\n\t\t\taddr += nb;\n\t\t\tfor (i = 0; i < nb0; ++i, ++p)\n\t\t\t\tif (__put_user_inatomic(REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz),\n\t\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define HARD\t0x80\t/* string, stwcx. */",
      "#define SX\t0x40\t/* ... byte count in XER */",
      "#define SW\t0x20\t/* byte swap */",
      "#define ST\t1\t/* store */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz)",
            "SWIZ_PTR(p)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWIZ_PTR",
          "args": [
            "p"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_BYTE",
          "args": [
            "rptr",
            "i ^ bswiz"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "REG_BYTE(rptr, i ^ bswiz)",
            "SWIZ_PTR(p)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWIZ_PTR",
          "args": [
            "p"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_BYTE",
          "args": [
            "rptr",
            "i ^ bswiz"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz)",
            "SWIZ_PTR(p)"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWIZ_PTR",
          "args": [
            "p"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_BYTE",
          "args": [
            "rptr",
            "i ^ bswiz"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "REG_BYTE(rptr, i ^ bswiz)",
            "SWIZ_PTR(p)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SWIZ_PTR",
          "args": [
            "p"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_BYTE",
          "args": [
            "rptr",
            "i ^ bswiz"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&regs->gpr[0]",
            "0",
            "((nb0 + 3) / 4) * sizeof(unsigned long)"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "(flags & ST ? VERIFY_WRITE: VERIFY_READ)",
            "addr",
            "nb+nb0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "instr"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "instr",
            "(unsigned int __user *)pc"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(nb > 4) || !user_mode(regs)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\n#define HARD\t0x80\t/* string, stwcx. */\n#define SX\t0x40\t/* ... byte count in XER */\n#define SW\t0x20\t/* byte swap */\n#define ST\t1\t/* store */\n\nstatic int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,\n\t\t\t    unsigned int reg, unsigned int nb,\n\t\t\t    unsigned int flags, unsigned int instr,\n\t\t\t    unsigned long swiz)\n{\n\tunsigned long *rptr;\n\tunsigned int nb0, i, bswiz;\n\tunsigned long p;\n\n\t/*\n\t * We do not try to emulate 8 bytes multiple as they aren't really\n\t * available in our operating environments and we don't try to\n\t * emulate multiples operations in kernel land as they should never\n\t * be used/generated there at least not on unaligned boundaries\n\t */\n\tif (unlikely((nb > 4) || !user_mode(regs)))\n\t\treturn 0;\n\n\t/* lmw, stmw, lswi/x, stswi/x */\n\tnb0 = 0;\n\tif (flags & HARD) {\n\t\tif (flags & SX) {\n\t\t\tnb = regs->xer & 127;\n\t\t\tif (nb == 0)\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tunsigned long pc = regs->nip ^ (swiz & 4);\n\n\t\t\tif (__get_user_inatomic(instr,\n\t\t\t\t\t\t(unsigned int __user *)pc))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (swiz == 0 && (flags & SW))\n\t\t\t\tinstr = cpu_to_le32(instr);\n\t\t\tnb = (instr >> 11) & 0x1f;\n\t\t\tif (nb == 0)\n\t\t\t\tnb = 32;\n\t\t}\n\t\tif (nb + reg * 4 > 128) {\n\t\t\tnb0 = nb + reg * 4 - 128;\n\t\t\tnb = 128 - reg * 4;\n\t\t}\n#ifdef __LITTLE_ENDIAN__\n\t\t/*\n\t\t *  String instructions are endian neutral but the code\n\t\t *  below is not.  Force byte swapping on so that the\n\t\t *  effects of swizzling are undone in the load/store\n\t\t *  loops below.\n\t\t */\n\t\tflags ^= SW;\n#endif\n\t} else {\n\t\t/* lwm, stmw */\n\t\tnb = (32 - reg) * 4;\n\t}\n\n\tif (!access_ok((flags & ST ? VERIFY_WRITE: VERIFY_READ), addr, nb+nb0))\n\t\treturn -EFAULT;\t/* bad address */\n\n\trptr = &regs->gpr[reg];\n\tp = (unsigned long) addr;\n\tbswiz = (flags & SW)? 3: 0;\n\n\tif (!(flags & ST)) {\n\t\t/*\n\t\t * This zeroes the top 4 bytes of the affected registers\n\t\t * in 64-bit mode, and also zeroes out any remaining\n\t\t * bytes of the last register for lsw*.\n\t\t */\n\t\tmemset(rptr, 0, ((nb + 3) / 4) * sizeof(unsigned long));\n\t\tif (nb0 > 0)\n\t\t\tmemset(&regs->gpr[0], 0,\n\t\t\t       ((nb0 + 3) / 4) * sizeof(unsigned long));\n\n\t\tfor (i = 0; i < nb; ++i, ++p)\n\t\t\tif (__get_user_inatomic(REG_BYTE(rptr, i ^ bswiz),\n\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\treturn -EFAULT;\n\t\tif (nb0 > 0) {\n\t\t\trptr = &regs->gpr[0];\n\t\t\taddr += nb;\n\t\t\tfor (i = 0; i < nb0; ++i, ++p)\n\t\t\t\tif (__get_user_inatomic(REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz),\n\t\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t} else {\n\t\tfor (i = 0; i < nb; ++i, ++p)\n\t\t\tif (__put_user_inatomic(REG_BYTE(rptr, i ^ bswiz),\n\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\treturn -EFAULT;\n\t\tif (nb0 > 0) {\n\t\t\trptr = &regs->gpr[0];\n\t\t\taddr += nb;\n\t\t\tfor (i = 0; i < nb0; ++i, ++p)\n\t\t\t\tif (__put_user_inatomic(REG_BYTE(rptr,\n\t\t\t\t\t\t\t\t i ^ bswiz),\n\t\t\t\t\t\t\tSWIZ_PTR(p)))\n\t\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "emulate_dcbz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/align.c",
    "lines": "200-217",
    "snippet": "static int emulate_dcbz(struct pt_regs *regs, unsigned char __user *addr)\n{\n\tlong __user *p;\n\tint i, size;\n\n#ifdef __powerpc64__\n\tsize = ppc64_caches.dline_size;\n#else\n\tsize = L1_CACHE_BYTES;\n#endif\n\tp = (long __user *) (regs->dar & -size);\n\tif (user_mode(regs) && !access_ok(VERIFY_WRITE, p, size))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < size / sizeof(long); ++i)\n\t\tif (__put_user_inatomic(0, p+i))\n\t\t\treturn -EFAULT;\n\treturn 1;\n}",
    "includes": [
      "#include <asm/disassemble.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/emulated_ops.h>",
      "#include <asm/cputable.h>",
      "#include <asm/cache.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/processor.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user_inatomic",
          "args": [
            "0",
            "p+i"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "p",
            "size"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/disassemble.h>\n#include <asm/switch_to.h>\n#include <asm/emulated_ops.h>\n#include <asm/cputable.h>\n#include <asm/cache.h>\n#include <asm/uaccess.h>\n#include <asm/processor.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nstatic int emulate_dcbz(struct pt_regs *regs, unsigned char __user *addr)\n{\n\tlong __user *p;\n\tint i, size;\n\n#ifdef __powerpc64__\n\tsize = ppc64_caches.dline_size;\n#else\n\tsize = L1_CACHE_BYTES;\n#endif\n\tp = (long __user *) (regs->dar & -size);\n\tif (user_mode(regs) && !access_ok(VERIFY_WRITE, p, size))\n\t\treturn -EFAULT;\n\tfor (i = 0; i < size / sizeof(long); ++i)\n\t\tif (__put_user_inatomic(0, p+i))\n\t\t\treturn -EFAULT;\n\treturn 1;\n}"
  }
]