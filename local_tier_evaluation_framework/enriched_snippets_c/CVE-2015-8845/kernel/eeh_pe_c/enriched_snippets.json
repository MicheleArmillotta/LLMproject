[
  {
    "function_name": "eeh_pe_bus_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "924-947",
    "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&pe->edevs",
            "structeeh_dev",
            "list"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}"
  },
  {
    "function_name": "eeh_pe_loc_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "883-912",
    "snippet": "const char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\tconst char *loc = NULL;\n\n\tif (!dn)\n\t\tgoto out;\n\n\t/* PHB PE or root PE ? */\n\tif (pci_is_root_bus(bus)) {\n\t\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\t\tif (!loc)\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\tif (loc)\n\t\t\tgoto out;\n\n\t\t/* Check the root port */\n\t\tdn = dn->child;\n\t\tif (!dn)\n\t\t\tgoto out;\n\t}\n\n\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\tif (!loc)\n\t\tloc = of_get_property(dn, \"ibm,slot-location-code\", NULL);\n\nout:\n\treturn loc ? loc : \"N/A\";\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,slot-location-code\"",
            "NULL"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,loc-code\"",
            "NULL"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,io-base-loc-code\"",
            "NULL"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "dn",
            "\"ibm,loc-code\"",
            "NULL"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_is_root_bus",
          "args": [
            "bus"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_bus_to_OF_node",
          "args": [
            "bus"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_bus_get",
          "args": [
            "pe"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_bus_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "924-947",
          "snippet": "struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = NULL;\n\tstruct eeh_dev *edev;\n\tstruct pci_dev *pdev;\n\n\tif (pe->type & EEH_PE_PHB) {\n\t\tbus = pe->phb->bus;\n\t} else if (pe->type & EEH_PE_BUS ||\n\t\t   pe->type & EEH_PE_DEVICE) {\n\t\tif (pe->bus) {\n\t\t\tbus = pe->bus;\n\t\t\tgoto out;\n\t\t}\n\n\t\tedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tbus = pdev->bus;\n\t}\n\nout:\n\treturn bus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nconst char *eeh_pe_loc_get(struct eeh_pe *pe)\n{\n\tstruct pci_bus *bus = eeh_pe_bus_get(pe);\n\tstruct device_node *dn = pci_bus_to_OF_node(bus);\n\tconst char *loc = NULL;\n\n\tif (!dn)\n\t\tgoto out;\n\n\t/* PHB PE or root PE ? */\n\tif (pci_is_root_bus(bus)) {\n\t\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\t\tif (!loc)\n\t\t\tloc = of_get_property(dn, \"ibm,io-base-loc-code\", NULL);\n\t\tif (loc)\n\t\t\tgoto out;\n\n\t\t/* Check the root port */\n\t\tdn = dn->child;\n\t\tif (!dn)\n\t\t\tgoto out;\n\t}\n\n\tloc = of_get_property(dn, \"ibm,loc-code\", NULL);\n\tif (!loc)\n\t\tloc = of_get_property(dn, \"ibm,slot-location-code\", NULL);\n\nout:\n\treturn loc ? loc : \"N/A\";\n}"
  },
  {
    "function_name": "eeh_pe_restore_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "865-872",
    "snippet": "void eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "eeh_restore_one_device_bars",
            "NULL"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "198-221",
          "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\n{\n\t/*\n\t * We needn't take the EEH lock since eeh_pe_dev_traverse()\n\t * will take that.\n\t */\n\teeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\n}"
  },
  {
    "function_name": "eeh_restore_one_device_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "841-856",
    "snippet": "static void *eeh_restore_one_device_bars(void *data, void *flag)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\n\t/* Do special restore for bridges */\n\tif (edev->mode & EEH_DEV_BRIDGE)\n\t\teeh_restore_bridge_bars(edev);\n\telse\n\t\teeh_restore_device_bars(edev);\n\n\tif (eeh_ops->restore_config && pdn)\n\t\teeh_ops->restore_config(pdn);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->restore_config",
          "args": [
            "pdn"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_restore_device_bars",
          "args": [
            "edev"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_restore_device_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "797-830",
          "snippet": "static void eeh_restore_device_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint i;\n\tu32 cmd;\n\n\tfor (i = 4; i < 10; i++)\n\t\teeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\n\t/* 12 == Expansion ROM Address */\n\teeh_ops->write_config(pdn, 12*4, 4, edev->config_space[12]);\n\n\teeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\n\t\tSAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\n\t/* max latency, min grant, interrupt pin and line */\n\teeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\n\n\t/*\n\t * Restore PERR & SERR bits, some devices require it,\n\t * don't touch the other command bits\n\t */\n\teeh_ops->read_config(pdn, PCI_COMMAND, 4, &cmd);\n\tif (edev->config_space[1] & PCI_COMMAND_PARITY)\n\t\tcmd |= PCI_COMMAND_PARITY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_PARITY;\n\tif (edev->config_space[1] & PCI_COMMAND_SERR)\n\t\tcmd |= PCI_COMMAND_SERR;\n\telse\n\t\tcmd &= ~PCI_COMMAND_SERR;\n\teeh_ops->write_config(pdn, PCI_COMMAND, 4, cmd);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_device_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint i;\n\tu32 cmd;\n\n\tfor (i = 4; i < 10; i++)\n\t\teeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\n\t/* 12 == Expansion ROM Address */\n\teeh_ops->write_config(pdn, 12*4, 4, edev->config_space[12]);\n\n\teeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\n\t\tSAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\n\t/* max latency, min grant, interrupt pin and line */\n\teeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\n\n\t/*\n\t * Restore PERR & SERR bits, some devices require it,\n\t * don't touch the other command bits\n\t */\n\teeh_ops->read_config(pdn, PCI_COMMAND, 4, &cmd);\n\tif (edev->config_space[1] & PCI_COMMAND_PARITY)\n\t\tcmd |= PCI_COMMAND_PARITY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_PARITY;\n\tif (edev->config_space[1] & PCI_COMMAND_SERR)\n\t\tcmd |= PCI_COMMAND_SERR;\n\telse\n\t\tcmd &= ~PCI_COMMAND_SERR;\n\teeh_ops->write_config(pdn, PCI_COMMAND, 4, cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_restore_bridge_bars",
          "args": [
            "edev"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_restore_bridge_bars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "768-795",
          "snippet": "static void eeh_restore_bridge_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint i;\n\n\t/*\n\t * Device BARs: 0x10 - 0x18\n\t * Bus numbers and windows: 0x18 - 0x30\n\t */\n\tfor (i = 4; i < 13; i++)\n\t\teeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\n\t/* Rom: 0x38 */\n\teeh_ops->write_config(pdn, 14*4, 4, edev->config_space[14]);\n\n\t/* Cache line & Latency timer: 0xC 0xD */\n\teeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\n                SAVED_BYTE(PCI_CACHE_LINE_SIZE));\n        eeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\n                SAVED_BYTE(PCI_LATENCY_TIMER));\n\t/* Max latency, min grant, interrupt ping and line: 0x3C */\n\teeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\n\n\t/* PCI Command: 0x4 */\n\teeh_ops->write_config(pdn, PCI_COMMAND, 4, edev->config_space[1]);\n\n\t/* Check the PCIe link is ready */\n\teeh_bridge_check_link(edev);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_bridge_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint i;\n\n\t/*\n\t * Device BARs: 0x10 - 0x18\n\t * Bus numbers and windows: 0x18 - 0x30\n\t */\n\tfor (i = 4; i < 13; i++)\n\t\teeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\n\t/* Rom: 0x38 */\n\teeh_ops->write_config(pdn, 14*4, 4, edev->config_space[14]);\n\n\t/* Cache line & Latency timer: 0xC 0xD */\n\teeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\n                SAVED_BYTE(PCI_CACHE_LINE_SIZE));\n        eeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\n                SAVED_BYTE(PCI_LATENCY_TIMER));\n\t/* Max latency, min grant, interrupt ping and line: 0x3C */\n\teeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\n\n\t/* PCI Command: 0x4 */\n\teeh_ops->write_config(pdn, PCI_COMMAND, 4, edev->config_space[1]);\n\n\t/* Check the PCIe link is ready */\n\teeh_bridge_check_link(edev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void *eeh_restore_one_device_bars(void *data, void *flag)\n{\n\tstruct eeh_dev *edev = (struct eeh_dev *)data;\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\n\t/* Do special restore for bridges */\n\tif (edev->mode & EEH_DEV_BRIDGE)\n\t\teeh_restore_bridge_bars(edev);\n\telse\n\t\teeh_restore_device_bars(edev);\n\n\tif (eeh_ops->restore_config && pdn)\n\t\teeh_ops->restore_config(pdn);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_restore_device_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "797-830",
    "snippet": "static void eeh_restore_device_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint i;\n\tu32 cmd;\n\n\tfor (i = 4; i < 10; i++)\n\t\teeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\n\t/* 12 == Expansion ROM Address */\n\teeh_ops->write_config(pdn, 12*4, 4, edev->config_space[12]);\n\n\teeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\n\t\tSAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\n\t/* max latency, min grant, interrupt pin and line */\n\teeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\n\n\t/*\n\t * Restore PERR & SERR bits, some devices require it,\n\t * don't touch the other command bits\n\t */\n\teeh_ops->read_config(pdn, PCI_COMMAND, 4, &cmd);\n\tif (edev->config_space[1] & PCI_COMMAND_PARITY)\n\t\tcmd |= PCI_COMMAND_PARITY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_PARITY;\n\tif (edev->config_space[1] & PCI_COMMAND_SERR)\n\t\tcmd |= PCI_COMMAND_SERR;\n\telse\n\t\tcmd &= ~PCI_COMMAND_SERR;\n\teeh_ops->write_config(pdn, PCI_COMMAND, 4, cmd);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "PCI_COMMAND",
            "4",
            "cmd"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "PCI_COMMAND",
            "4",
            "&cmd"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "15*4",
            "4",
            "edev->config_space[15]"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "PCI_LATENCY_TIMER",
            "1",
            "SAVED_BYTE(PCI_LATENCY_TIMER)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVED_BYTE",
          "args": [
            "PCI_LATENCY_TIMER"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "PCI_CACHE_LINE_SIZE",
            "1",
            "SAVED_BYTE(PCI_CACHE_LINE_SIZE)"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVED_BYTE",
          "args": [
            "PCI_CACHE_LINE_SIZE"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "12*4",
            "4",
            "edev->config_space[12]"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "i*4",
            "4",
            "edev->config_space[i]"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_device_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint i;\n\tu32 cmd;\n\n\tfor (i = 4; i < 10; i++)\n\t\teeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\n\t/* 12 == Expansion ROM Address */\n\teeh_ops->write_config(pdn, 12*4, 4, edev->config_space[12]);\n\n\teeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\n\t\tSAVED_BYTE(PCI_CACHE_LINE_SIZE));\n\teeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\n\t\tSAVED_BYTE(PCI_LATENCY_TIMER));\n\n\t/* max latency, min grant, interrupt pin and line */\n\teeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\n\n\t/*\n\t * Restore PERR & SERR bits, some devices require it,\n\t * don't touch the other command bits\n\t */\n\teeh_ops->read_config(pdn, PCI_COMMAND, 4, &cmd);\n\tif (edev->config_space[1] & PCI_COMMAND_PARITY)\n\t\tcmd |= PCI_COMMAND_PARITY;\n\telse\n\t\tcmd &= ~PCI_COMMAND_PARITY;\n\tif (edev->config_space[1] & PCI_COMMAND_SERR)\n\t\tcmd |= PCI_COMMAND_SERR;\n\telse\n\t\tcmd &= ~PCI_COMMAND_SERR;\n\teeh_ops->write_config(pdn, PCI_COMMAND, 4, cmd);\n}"
  },
  {
    "function_name": "eeh_restore_bridge_bars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "768-795",
    "snippet": "static void eeh_restore_bridge_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint i;\n\n\t/*\n\t * Device BARs: 0x10 - 0x18\n\t * Bus numbers and windows: 0x18 - 0x30\n\t */\n\tfor (i = 4; i < 13; i++)\n\t\teeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\n\t/* Rom: 0x38 */\n\teeh_ops->write_config(pdn, 14*4, 4, edev->config_space[14]);\n\n\t/* Cache line & Latency timer: 0xC 0xD */\n\teeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\n                SAVED_BYTE(PCI_CACHE_LINE_SIZE));\n        eeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\n                SAVED_BYTE(PCI_LATENCY_TIMER));\n\t/* Max latency, min grant, interrupt ping and line: 0x3C */\n\teeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\n\n\t/* PCI Command: 0x4 */\n\teeh_ops->write_config(pdn, PCI_COMMAND, 4, edev->config_space[1]);\n\n\t/* Check the PCIe link is ready */\n\teeh_bridge_check_link(edev);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_bridge_check_link",
          "args": [
            "edev"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_bridge_check_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "693-763",
          "snippet": "static void eeh_bridge_check_link(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint cap;\n\tuint32_t val;\n\tint timeout = 0;\n\n\t/*\n\t * We only check root port and downstream ports of\n\t * PCIe switches\n\t */\n\tif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\n\t\treturn;\n\n\tpr_debug(\"%s: Check PCIe link for %04x:%02x:%02x.%01x ...\\n\",\n\t\t __func__, edev->phb->global_number,\n\t\t edev->config_addr >> 8,\n\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\n\t/* Check slot status */\n\tcap = edev->pcie_cap;\n\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTSTA, 2, &val);\n\tif (!(val & PCI_EXP_SLTSTA_PDS)) {\n\t\tpr_debug(\"  No card in the slot (0x%04x) !\\n\", val);\n\t\treturn;\n\t}\n\n\t/* Check power status if we have the capability */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTCAP, 2, &val);\n\tif (val & PCI_EXP_SLTCAP_PCP) {\n\t\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTCTL, 2, &val);\n\t\tif (val & PCI_EXP_SLTCTL_PCC) {\n\t\t\tpr_debug(\"  In power-off state, power it on ...\\n\");\n\t\t\tval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\n\t\t\tval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\n\t\t\teeh_ops->write_config(pdn, cap + PCI_EXP_SLTCTL, 2, val);\n\t\t\tmsleep(2 * 1000);\n\t\t}\n\t}\n\n\t/* Enable link */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKCTL, 2, &val);\n\tval &= ~PCI_EXP_LNKCTL_LD;\n\teeh_ops->write_config(pdn, cap + PCI_EXP_LNKCTL, 2, val);\n\n\t/* Check link */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKCAP, 4, &val);\n\tif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\n\t\tpr_debug(\"  No link reporting capability (0x%08x) \\n\", val);\n\t\tmsleep(1000);\n\t\treturn;\n\t}\n\n\t/* Wait the link is up until timeout (5s) */\n\ttimeout = 0;\n\twhile (timeout < 5000) {\n\t\tmsleep(20);\n\t\ttimeout += 20;\n\n\t\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKSTA, 2, &val);\n\t\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t}\n\n\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\tpr_debug(\"  Link up (%s)\\n\",\n\t\t\t (val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\");\n\telse\n\t\tpr_debug(\"  Link not ready (0x%04x)\\n\", val);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_bridge_check_link(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint cap;\n\tuint32_t val;\n\tint timeout = 0;\n\n\t/*\n\t * We only check root port and downstream ports of\n\t * PCIe switches\n\t */\n\tif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\n\t\treturn;\n\n\tpr_debug(\"%s: Check PCIe link for %04x:%02x:%02x.%01x ...\\n\",\n\t\t __func__, edev->phb->global_number,\n\t\t edev->config_addr >> 8,\n\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\n\t/* Check slot status */\n\tcap = edev->pcie_cap;\n\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTSTA, 2, &val);\n\tif (!(val & PCI_EXP_SLTSTA_PDS)) {\n\t\tpr_debug(\"  No card in the slot (0x%04x) !\\n\", val);\n\t\treturn;\n\t}\n\n\t/* Check power status if we have the capability */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTCAP, 2, &val);\n\tif (val & PCI_EXP_SLTCAP_PCP) {\n\t\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTCTL, 2, &val);\n\t\tif (val & PCI_EXP_SLTCTL_PCC) {\n\t\t\tpr_debug(\"  In power-off state, power it on ...\\n\");\n\t\t\tval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\n\t\t\tval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\n\t\t\teeh_ops->write_config(pdn, cap + PCI_EXP_SLTCTL, 2, val);\n\t\t\tmsleep(2 * 1000);\n\t\t}\n\t}\n\n\t/* Enable link */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKCTL, 2, &val);\n\tval &= ~PCI_EXP_LNKCTL_LD;\n\teeh_ops->write_config(pdn, cap + PCI_EXP_LNKCTL, 2, val);\n\n\t/* Check link */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKCAP, 4, &val);\n\tif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\n\t\tpr_debug(\"  No link reporting capability (0x%08x) \\n\", val);\n\t\tmsleep(1000);\n\t\treturn;\n\t}\n\n\t/* Wait the link is up until timeout (5s) */\n\ttimeout = 0;\n\twhile (timeout < 5000) {\n\t\tmsleep(20);\n\t\ttimeout += 20;\n\n\t\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKSTA, 2, &val);\n\t\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t}\n\n\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\tpr_debug(\"  Link up (%s)\\n\",\n\t\t\t (val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\");\n\telse\n\t\tpr_debug(\"  Link not ready (0x%04x)\\n\", val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "PCI_COMMAND",
            "4",
            "edev->config_space[1]"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "15*4",
            "4",
            "edev->config_space[15]"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "PCI_LATENCY_TIMER",
            "1",
            "SAVED_BYTE(PCI_LATENCY_TIMER)"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVED_BYTE",
          "args": [
            "PCI_LATENCY_TIMER"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "PCI_CACHE_LINE_SIZE",
            "1",
            "SAVED_BYTE(PCI_CACHE_LINE_SIZE)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SAVED_BYTE",
          "args": [
            "PCI_CACHE_LINE_SIZE"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "14*4",
            "4",
            "edev->config_space[14]"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "i*4",
            "4",
            "edev->config_space[i]"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_restore_bridge_bars(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint i;\n\n\t/*\n\t * Device BARs: 0x10 - 0x18\n\t * Bus numbers and windows: 0x18 - 0x30\n\t */\n\tfor (i = 4; i < 13; i++)\n\t\teeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\n\t/* Rom: 0x38 */\n\teeh_ops->write_config(pdn, 14*4, 4, edev->config_space[14]);\n\n\t/* Cache line & Latency timer: 0xC 0xD */\n\teeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\n                SAVED_BYTE(PCI_CACHE_LINE_SIZE));\n        eeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\n                SAVED_BYTE(PCI_LATENCY_TIMER));\n\t/* Max latency, min grant, interrupt ping and line: 0x3C */\n\teeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\n\n\t/* PCI Command: 0x4 */\n\teeh_ops->write_config(pdn, PCI_COMMAND, 4, edev->config_space[1]);\n\n\t/* Check the PCIe link is ready */\n\teeh_bridge_check_link(edev);\n}"
  },
  {
    "function_name": "eeh_bridge_check_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "693-763",
    "snippet": "static void eeh_bridge_check_link(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint cap;\n\tuint32_t val;\n\tint timeout = 0;\n\n\t/*\n\t * We only check root port and downstream ports of\n\t * PCIe switches\n\t */\n\tif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\n\t\treturn;\n\n\tpr_debug(\"%s: Check PCIe link for %04x:%02x:%02x.%01x ...\\n\",\n\t\t __func__, edev->phb->global_number,\n\t\t edev->config_addr >> 8,\n\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\n\t/* Check slot status */\n\tcap = edev->pcie_cap;\n\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTSTA, 2, &val);\n\tif (!(val & PCI_EXP_SLTSTA_PDS)) {\n\t\tpr_debug(\"  No card in the slot (0x%04x) !\\n\", val);\n\t\treturn;\n\t}\n\n\t/* Check power status if we have the capability */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTCAP, 2, &val);\n\tif (val & PCI_EXP_SLTCAP_PCP) {\n\t\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTCTL, 2, &val);\n\t\tif (val & PCI_EXP_SLTCTL_PCC) {\n\t\t\tpr_debug(\"  In power-off state, power it on ...\\n\");\n\t\t\tval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\n\t\t\tval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\n\t\t\teeh_ops->write_config(pdn, cap + PCI_EXP_SLTCTL, 2, val);\n\t\t\tmsleep(2 * 1000);\n\t\t}\n\t}\n\n\t/* Enable link */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKCTL, 2, &val);\n\tval &= ~PCI_EXP_LNKCTL_LD;\n\teeh_ops->write_config(pdn, cap + PCI_EXP_LNKCTL, 2, val);\n\n\t/* Check link */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKCAP, 4, &val);\n\tif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\n\t\tpr_debug(\"  No link reporting capability (0x%08x) \\n\", val);\n\t\tmsleep(1000);\n\t\treturn;\n\t}\n\n\t/* Wait the link is up until timeout (5s) */\n\ttimeout = 0;\n\twhile (timeout < 5000) {\n\t\tmsleep(20);\n\t\ttimeout += 20;\n\n\t\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKSTA, 2, &val);\n\t\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t}\n\n\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\tpr_debug(\"  Link up (%s)\\n\",\n\t\t\t (val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\");\n\telse\n\t\tpr_debug(\"  Link not ready (0x%04x)\\n\", val);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  Link not ready (0x%04x)\\n\"",
            "val"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  Link up (%s)\\n\"",
            "(val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap + PCI_EXP_LNKSTA",
            "2",
            "&val"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "20"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "1000"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  No link reporting capability (0x%08x) \\n\"",
            "val"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap + PCI_EXP_LNKCAP",
            "4",
            "&val"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "cap + PCI_EXP_LNKCTL",
            "2",
            "val"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap + PCI_EXP_LNKCTL",
            "2",
            "&val"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "2 * 1000"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->write_config",
          "args": [
            "pdn",
            "cap + PCI_EXP_SLTCTL",
            "2",
            "val"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  In power-off state, power it on ...\\n\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap + PCI_EXP_SLTCTL",
            "2",
            "&val"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap + PCI_EXP_SLTCAP",
            "2",
            "&val"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"  No card in the slot (0x%04x) !\\n\"",
            "val"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_ops->read_config",
          "args": [
            "pdn",
            "cap + PCI_EXP_SLTSTA",
            "2",
            "&val"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: Check PCIe link for %04x:%02x:%02x.%01x ...\\n\"",
            "__func__",
            "edev->phb->global_number",
            "edev->config_addr >> 8",
            "PCI_SLOT(edev->config_addr & 0xFF)",
            "PCI_FUNC(edev->config_addr & 0xFF)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void eeh_bridge_check_link(struct eeh_dev *edev)\n{\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\tint cap;\n\tuint32_t val;\n\tint timeout = 0;\n\n\t/*\n\t * We only check root port and downstream ports of\n\t * PCIe switches\n\t */\n\tif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\n\t\treturn;\n\n\tpr_debug(\"%s: Check PCIe link for %04x:%02x:%02x.%01x ...\\n\",\n\t\t __func__, edev->phb->global_number,\n\t\t edev->config_addr >> 8,\n\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\n\t/* Check slot status */\n\tcap = edev->pcie_cap;\n\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTSTA, 2, &val);\n\tif (!(val & PCI_EXP_SLTSTA_PDS)) {\n\t\tpr_debug(\"  No card in the slot (0x%04x) !\\n\", val);\n\t\treturn;\n\t}\n\n\t/* Check power status if we have the capability */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTCAP, 2, &val);\n\tif (val & PCI_EXP_SLTCAP_PCP) {\n\t\teeh_ops->read_config(pdn, cap + PCI_EXP_SLTCTL, 2, &val);\n\t\tif (val & PCI_EXP_SLTCTL_PCC) {\n\t\t\tpr_debug(\"  In power-off state, power it on ...\\n\");\n\t\t\tval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\n\t\t\tval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\n\t\t\teeh_ops->write_config(pdn, cap + PCI_EXP_SLTCTL, 2, val);\n\t\t\tmsleep(2 * 1000);\n\t\t}\n\t}\n\n\t/* Enable link */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKCTL, 2, &val);\n\tval &= ~PCI_EXP_LNKCTL_LD;\n\teeh_ops->write_config(pdn, cap + PCI_EXP_LNKCTL, 2, val);\n\n\t/* Check link */\n\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKCAP, 4, &val);\n\tif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\n\t\tpr_debug(\"  No link reporting capability (0x%08x) \\n\", val);\n\t\tmsleep(1000);\n\t\treturn;\n\t}\n\n\t/* Wait the link is up until timeout (5s) */\n\ttimeout = 0;\n\twhile (timeout < 5000) {\n\t\tmsleep(20);\n\t\ttimeout += 20;\n\n\t\teeh_ops->read_config(pdn, cap + PCI_EXP_LNKSTA, 2, &val);\n\t\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\t\tbreak;\n\t}\n\n\tif (val & PCI_EXP_LNKSTA_DLLLA)\n\t\tpr_debug(\"  Link up (%s)\\n\",\n\t\t\t (val & PCI_EXP_LNKSTA_CLS_2_5GB) ? \"2.5GB\" : \"5GB\");\n\telse\n\t\tpr_debug(\"  Link not ready (0x%04x)\\n\", val);\n}"
  },
  {
    "function_name": "eeh_pe_state_mark_with_cfg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "671-680",
    "snippet": "void eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "pe",
            "__eeh_pe_state_clear",
            "&state"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "175-187",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn;\n\n\t/* Clear EEH_PE_CFG_BLOCKED, which might be set just now */\n\tstate = EEH_PE_CFG_BLOCKED;\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
  },
  {
    "function_name": "eeh_pe_state_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "655-658",
    "snippet": "void eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "pe",
            "__eeh_pe_state_clear",
            "&state"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "175-187",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\n}"
  },
  {
    "function_name": "__eeh_pe_state_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "609-644",
    "snippet": "static void *__eeh_pe_state_clear(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tint state = *((int *)flag);\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\t/* Keep the state of permanently removed PE intact */\n\tif (pe->state & EEH_PE_REMOVED)\n\t\treturn NULL;\n\n\tpe->state &= ~state;\n\n\t/*\n\t * Special treatment on clearing isolated state. Clear\n\t * check count since last isolation and put all affected\n\t * devices to normal state.\n\t */\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn NULL;\n\n\tpe->check_count = 0;\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tpdev->error_state = pci_channel_io_normal;\n\t}\n\n\t/* Unblock PCI config access if required */\n\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void *__eeh_pe_state_clear(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tint state = *((int *)flag);\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\t/* Keep the state of permanently removed PE intact */\n\tif (pe->state & EEH_PE_REMOVED)\n\t\treturn NULL;\n\n\tpe->state &= ~state;\n\n\t/*\n\t * Special treatment on clearing isolated state. Clear\n\t * check count since last isolation and put all affected\n\t * devices to normal state.\n\t */\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn NULL;\n\n\tpe->check_count = 0;\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (!pdev)\n\t\t\tcontinue;\n\n\t\tpdev->error_state = pci_channel_io_normal;\n\t}\n\n\t/* Unblock PCI config access if required */\n\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\tpe->state &= ~EEH_PE_CFG_BLOCKED;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_dev_mode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "595-598",
    "snippet": "void eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\n{\n\teeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_dev_traverse",
          "args": [
            "pe",
            "__eeh_pe_dev_mode_mark",
            "&mode"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_dev_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "198-221",
          "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\n{\n\teeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\n}"
  },
  {
    "function_name": "__eeh_pe_dev_mode_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "579-587",
    "snippet": "static void *__eeh_pe_dev_mode_mark(void *data, void *flag)\n{\n\tstruct eeh_dev *edev = data;\n\tint mode = *((int *)flag);\n\n\tedev->mode |= mode;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void *__eeh_pe_dev_mode_mark(void *data, void *flag)\n{\n\tstruct eeh_dev *edev = data;\n\tint mode = *((int *)flag);\n\n\tedev->mode |= mode;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_state_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "574-577",
    "snippet": "void eeh_pe_state_mark(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "pe",
            "__eeh_pe_state_mark",
            "&state"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "175-187",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_state_mark(struct eeh_pe *pe, int state)\n{\n\teeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\n}"
  },
  {
    "function_name": "__eeh_pe_state_mark",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "536-564",
    "snippet": "static void *__eeh_pe_state_mark(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tint state = *((int *)flag);\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\t/* Keep the state of permanently removed PE intact */\n\tif (pe->state & EEH_PE_REMOVED)\n\t\treturn NULL;\n\n\tpe->state |= state;\n\n\t/* Offline PCI devices if applicable */\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn NULL;\n\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t}\n\n\t/* Block PCI config access if required */\n\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_dev_to_pci_dev",
          "args": [
            "edev"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void *__eeh_pe_state_mark(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tint state = *((int *)flag);\n\tstruct eeh_dev *edev, *tmp;\n\tstruct pci_dev *pdev;\n\n\t/* Keep the state of permanently removed PE intact */\n\tif (pe->state & EEH_PE_REMOVED)\n\t\treturn NULL;\n\n\tpe->state |= state;\n\n\t/* Offline PCI devices if applicable */\n\tif (!(state & EEH_PE_ISOLATED))\n\t\treturn NULL;\n\n\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\tpdev = eeh_dev_to_pci_dev(edev);\n\t\tif (pdev)\n\t\t\tpdev->error_state = pci_channel_io_frozen;\n\t}\n\n\t/* Block PCI config access if required */\n\tif (pe->state & EEH_PE_CFG_RESTRICTED)\n\t\tpe->state |= EEH_PE_CFG_BLOCKED;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_update_time_stamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "509-525",
    "snippet": "void eeh_pe_update_time_stamp(struct eeh_pe *pe)\n{\n\tstruct timeval tstamp;\n\n\tif (!pe) return;\n\n\tif (pe->freeze_count <= 0) {\n\t\tpe->freeze_count = 0;\n\t\tdo_gettimeofday(&pe->tstamp);\n\t} else {\n\t\tdo_gettimeofday(&tstamp);\n\t\tif (tstamp.tv_sec - pe->tstamp.tv_sec > 3600) {\n\t\t\tpe->tstamp = tstamp;\n\t\t\tpe->freeze_count = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_gettimeofday",
          "args": [
            "&tstamp"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_gettimeofday",
          "args": [
            "&pe->tstamp"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid eeh_pe_update_time_stamp(struct eeh_pe *pe)\n{\n\tstruct timeval tstamp;\n\n\tif (!pe) return;\n\n\tif (pe->freeze_count <= 0) {\n\t\tpe->freeze_count = 0;\n\t\tdo_gettimeofday(&pe->tstamp);\n\t} else {\n\t\tdo_gettimeofday(&tstamp);\n\t\tif (tstamp.tv_sec - pe->tstamp.tv_sec > 3600) {\n\t\t\tpe->tstamp = tstamp;\n\t\t\tpe->freeze_count = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "eeh_rmv_from_parent_pe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "439-498",
    "snippet": "int eeh_rmv_from_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tint cnt;\n\n\tif (!edev->pe) {\n\t\tpr_debug(\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\",\n\t\t\t __func__,  edev->phb->global_number,\n\t\t\t edev->config_addr >> 8,\n\t\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tpe = eeh_dev_to_pe(edev);\n\tedev->pe = NULL;\n\tlist_del(&edev->list);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\tif (!(pe->state & EEH_PE_KEEP)) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "child",
            "&pe->child_list",
            "child"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pe->edevs"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pe->child"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pe->child_list"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&pe->edevs"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&edev->list"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pe",
          "args": [
            "edev"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\"",
            "__func__",
            "edev->phb->global_number",
            "edev->config_addr >> 8",
            "PCI_SLOT(edev->config_addr & 0xFF)",
            "PCI_FUNC(edev->config_addr & 0xFF)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_rmv_from_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent, *child;\n\tint cnt;\n\n\tif (!edev->pe) {\n\t\tpr_debug(\"%s: No PE found for device %04x:%02x:%02x.%01x\\n\",\n\t\t\t __func__,  edev->phb->global_number,\n\t\t\t edev->config_addr >> 8,\n\t\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t\t PCI_FUNC(edev->config_addr & 0xFF));\n\t\treturn -EEXIST;\n\t}\n\n\t/* Remove the EEH device */\n\tpe = eeh_dev_to_pe(edev);\n\tedev->pe = NULL;\n\tlist_del(&edev->list);\n\n\t/*\n\t * Check if the parent PE includes any EEH devices.\n\t * If not, we should delete that. Also, we should\n\t * delete the parent PE if it doesn't have associated\n\t * child PEs and EEH devices.\n\t */\n\twhile (1) {\n\t\tparent = pe->parent;\n\t\tif (pe->type & EEH_PE_PHB)\n\t\t\tbreak;\n\n\t\tif (!(pe->state & EEH_PE_KEEP)) {\n\t\t\tif (list_empty(&pe->edevs) &&\n\t\t\t    list_empty(&pe->child_list)) {\n\t\t\t\tlist_del(&pe->child);\n\t\t\t\tkfree(pe);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (list_empty(&pe->edevs)) {\n\t\t\t\tcnt = 0;\n\t\t\t\tlist_for_each_entry(child, &pe->child_list, child) {\n\t\t\t\t\tif (!(child->type & EEH_PE_INVALID)) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!cnt)\n\t\t\t\t\tpe->type |= EEH_PE_INVALID;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpe = parent;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_add_to_parent_pe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "327-428",
    "snippet": "int eeh_add_to_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent;\n\n\t/* Check if the PE number is valid */\n\tif (!eeh_has_flag(EEH_VALID_PE_ZERO) && !edev->pe_config_addr) {\n\t\tpr_err(\"%s: Invalid PE#0 for edev 0x%x on PHB#%d\\n\",\n\t\t       __func__, edev->config_addr, edev->phb->global_number);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Search the PE has been existing or not according\n\t * to the PE address. If that has been existing, the\n\t * PE should be composed of PCI bus and its subordinate\n\t * components.\n\t */\n\tpe = eeh_pe_get(edev);\n\tif (pe && !(pe->type & EEH_PE_INVALID)) {\n\t\t/* Mark the PE as type of PCI bus */\n\t\tpe->type = EEH_PE_BUS;\n\t\tedev->pe = pe;\n\n\t\t/* Put the edev to PE */\n\t\tlist_add_tail(&edev->list, &pe->edevs);\n\t\tpr_debug(\"EEH: Add %04x:%02x:%02x.%01x to Bus PE#%x\\n\",\n\t\t\tedev->phb->global_number,\n\t\t\tedev->config_addr >> 8,\n\t\t\tPCI_SLOT(edev->config_addr & 0xFF),\n\t\t\tPCI_FUNC(edev->config_addr & 0xFF),\n\t\t\tpe->addr);\n\t\treturn 0;\n\t} else if (pe && (pe->type & EEH_PE_INVALID)) {\n\t\tlist_add_tail(&edev->list, &pe->edevs);\n\t\tedev->pe = pe;\n\t\t/*\n\t\t * We're running to here because of PCI hotplug caused by\n\t\t * EEH recovery. We need clear EEH_PE_INVALID until the top.\n\t\t */\n\t\tparent = pe;\n\t\twhile (parent) {\n\t\t\tif (!(parent->type & EEH_PE_INVALID))\n\t\t\t\tbreak;\n\t\t\tparent->type &= ~(EEH_PE_INVALID | EEH_PE_KEEP);\n\t\t\tparent = parent->parent;\n\t\t}\n\n\t\tpr_debug(\"EEH: Add %04x:%02x:%02x.%01x to Device \"\n\t\t\t \"PE#%x, Parent PE#%x\\n\",\n\t\t\tedev->phb->global_number,\n\t\t\tedev->config_addr >> 8,\n                        PCI_SLOT(edev->config_addr & 0xFF),\n                        PCI_FUNC(edev->config_addr & 0xFF),\n\t\t\tpe->addr, pe->parent->addr);\n\t\treturn 0;\n\t}\n\n\t/* Create a new EEH PE */\n\tpe = eeh_pe_alloc(edev->phb, EEH_PE_DEVICE);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tpe->addr\t= edev->pe_config_addr;\n\tpe->config_addr\t= edev->config_addr;\n\n\t/*\n\t * Put the new EEH PE into hierarchy tree. If the parent\n\t * can't be found, the newly created PE will be attached\n\t * to PHB directly. Otherwise, we have to associate the\n\t * PE with its parent.\n\t */\n\tparent = eeh_pe_get_parent(edev);\n\tif (!parent) {\n\t\tparent = eeh_phb_pe_get(edev->phb);\n\t\tif (!parent) {\n\t\t\tpr_err(\"%s: No PHB PE is found (PHB Domain=%d)\\n\",\n\t\t\t\t__func__, edev->phb->global_number);\n\t\t\tedev->pe = NULL;\n\t\t\tkfree(pe);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tpe->parent = parent;\n\n\t/*\n\t * Put the newly created PE into the child list and\n\t * link the EEH device accordingly.\n\t */\n\tlist_add_tail(&pe->child, &parent->child_list);\n\tlist_add_tail(&edev->list, &pe->edevs);\n\tedev->pe = pe;\n\tpr_debug(\"EEH: Add %04x:%02x:%02x.%01x to \"\n\t\t \"Device PE#%x, Parent PE#%x\\n\",\n\t\t edev->phb->global_number,\n\t\t edev->config_addr >> 8,\n\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t PCI_FUNC(edev->config_addr & 0xFF),\n\t\t pe->addr, pe->parent->addr);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Add %04x:%02x:%02x.%01x to \"\n\t\t \"Device PE#%x, Parent PE#%x\\n\"",
            "edev->phb->global_number",
            "edev->config_addr >> 8",
            "PCI_SLOT(edev->config_addr & 0xFF)",
            "PCI_FUNC(edev->config_addr & 0xFF)",
            "pe->addr",
            "pe->parent->addr"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&edev->list",
            "&pe->edevs"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pe->child",
            "&parent->child_list"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pe"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: No PHB PE is found (PHB Domain=%d)\\n\"",
            "__func__",
            "edev->phb->global_number"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "edev->phb"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "120-135",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_get_parent",
          "args": [
            "edev"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_get_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "292-316",
          "snippet": "static struct eeh_pe *eeh_pe_get_parent(struct eeh_dev *edev)\n{\n\tstruct eeh_dev *parent;\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\n\t/*\n\t * It might have the case for the indirect parent\n\t * EEH device already having associated PE, but\n\t * the direct parent EEH device doesn't have yet.\n\t */\n\tpdn = pdn ? pdn->parent : NULL;\n\twhile (pdn) {\n\t\t/* We're poking out of PCI territory */\n\t\tparent = pdn_to_eeh_dev(pdn);\n\t\tif (!parent)\n\t\t\treturn NULL;\n\n\t\tif (parent->pe)\n\t\t\treturn parent->pe;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic struct eeh_pe *eeh_pe_get_parent(struct eeh_dev *edev)\n{\n\tstruct eeh_dev *parent;\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\n\t/*\n\t * It might have the case for the indirect parent\n\t * EEH device already having associated PE, but\n\t * the direct parent EEH device doesn't have yet.\n\t */\n\tpdn = pdn ? pdn->parent : NULL;\n\twhile (pdn) {\n\t\t/* We're poking out of PCI territory */\n\t\tparent = pdn_to_eeh_dev(pdn);\n\t\tif (!parent)\n\t\t\treturn NULL;\n\n\t\tif (parent->pe)\n\t\t\treturn parent->pe;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: out of memory!\\n\"",
            "__func__"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_alloc",
          "args": [
            "edev->phb",
            "EEH_PE_DEVICE"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "59-84",
          "snippet": "static struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->child);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int eeh_pe_aux_size = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_aux_size = 0;\n\nstatic struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->child);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Add %04x:%02x:%02x.%01x to Device \"\n\t\t\t \"PE#%x, Parent PE#%x\\n\"",
            "edev->phb->global_number",
            "edev->config_addr >> 8",
            "PCI_SLOT(edev->config_addr & 0xFF)",
            "PCI_FUNC(edev->config_addr & 0xFF)",
            "pe->addr",
            "pe->parent->addr"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&edev->list",
            "&pe->edevs"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Add %04x:%02x:%02x.%01x to Bus PE#%x\\n\"",
            "edev->phb->global_number",
            "edev->config_addr >> 8",
            "PCI_SLOT(edev->config_addr & 0xFF)",
            "PCI_FUNC(edev->config_addr & 0xFF)",
            "pe->addr"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_FUNC",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PCI_SLOT",
          "args": [
            "edev->config_addr & 0xFF"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&edev->list",
            "&pe->edevs"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Invalid PE#0 for edev 0x%x on PHB#%d\\n\"",
            "__func__",
            "edev->config_addr",
            "edev->phb->global_number"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_VALID_PE_ZERO"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nint eeh_add_to_parent_pe(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *pe, *parent;\n\n\t/* Check if the PE number is valid */\n\tif (!eeh_has_flag(EEH_VALID_PE_ZERO) && !edev->pe_config_addr) {\n\t\tpr_err(\"%s: Invalid PE#0 for edev 0x%x on PHB#%d\\n\",\n\t\t       __func__, edev->config_addr, edev->phb->global_number);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Search the PE has been existing or not according\n\t * to the PE address. If that has been existing, the\n\t * PE should be composed of PCI bus and its subordinate\n\t * components.\n\t */\n\tpe = eeh_pe_get(edev);\n\tif (pe && !(pe->type & EEH_PE_INVALID)) {\n\t\t/* Mark the PE as type of PCI bus */\n\t\tpe->type = EEH_PE_BUS;\n\t\tedev->pe = pe;\n\n\t\t/* Put the edev to PE */\n\t\tlist_add_tail(&edev->list, &pe->edevs);\n\t\tpr_debug(\"EEH: Add %04x:%02x:%02x.%01x to Bus PE#%x\\n\",\n\t\t\tedev->phb->global_number,\n\t\t\tedev->config_addr >> 8,\n\t\t\tPCI_SLOT(edev->config_addr & 0xFF),\n\t\t\tPCI_FUNC(edev->config_addr & 0xFF),\n\t\t\tpe->addr);\n\t\treturn 0;\n\t} else if (pe && (pe->type & EEH_PE_INVALID)) {\n\t\tlist_add_tail(&edev->list, &pe->edevs);\n\t\tedev->pe = pe;\n\t\t/*\n\t\t * We're running to here because of PCI hotplug caused by\n\t\t * EEH recovery. We need clear EEH_PE_INVALID until the top.\n\t\t */\n\t\tparent = pe;\n\t\twhile (parent) {\n\t\t\tif (!(parent->type & EEH_PE_INVALID))\n\t\t\t\tbreak;\n\t\t\tparent->type &= ~(EEH_PE_INVALID | EEH_PE_KEEP);\n\t\t\tparent = parent->parent;\n\t\t}\n\n\t\tpr_debug(\"EEH: Add %04x:%02x:%02x.%01x to Device \"\n\t\t\t \"PE#%x, Parent PE#%x\\n\",\n\t\t\tedev->phb->global_number,\n\t\t\tedev->config_addr >> 8,\n                        PCI_SLOT(edev->config_addr & 0xFF),\n                        PCI_FUNC(edev->config_addr & 0xFF),\n\t\t\tpe->addr, pe->parent->addr);\n\t\treturn 0;\n\t}\n\n\t/* Create a new EEH PE */\n\tpe = eeh_pe_alloc(edev->phb, EEH_PE_DEVICE);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tpe->addr\t= edev->pe_config_addr;\n\tpe->config_addr\t= edev->config_addr;\n\n\t/*\n\t * Put the new EEH PE into hierarchy tree. If the parent\n\t * can't be found, the newly created PE will be attached\n\t * to PHB directly. Otherwise, we have to associate the\n\t * PE with its parent.\n\t */\n\tparent = eeh_pe_get_parent(edev);\n\tif (!parent) {\n\t\tparent = eeh_phb_pe_get(edev->phb);\n\t\tif (!parent) {\n\t\t\tpr_err(\"%s: No PHB PE is found (PHB Domain=%d)\\n\",\n\t\t\t\t__func__, edev->phb->global_number);\n\t\t\tedev->pe = NULL;\n\t\t\tkfree(pe);\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\tpe->parent = parent;\n\n\t/*\n\t * Put the newly created PE into the child list and\n\t * link the EEH device accordingly.\n\t */\n\tlist_add_tail(&pe->child, &parent->child_list);\n\tlist_add_tail(&edev->list, &pe->edevs);\n\tedev->pe = pe;\n\tpr_debug(\"EEH: Add %04x:%02x:%02x.%01x to \"\n\t\t \"Device PE#%x, Parent PE#%x\\n\",\n\t\t edev->phb->global_number,\n\t\t edev->config_addr >> 8,\n\t\t PCI_SLOT(edev->config_addr & 0xFF),\n\t\t PCI_FUNC(edev->config_addr & 0xFF),\n\t\t pe->addr, pe->parent->addr);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "292-316",
    "snippet": "static struct eeh_pe *eeh_pe_get_parent(struct eeh_dev *edev)\n{\n\tstruct eeh_dev *parent;\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\n\t/*\n\t * It might have the case for the indirect parent\n\t * EEH device already having associated PE, but\n\t * the direct parent EEH device doesn't have yet.\n\t */\n\tpdn = pdn ? pdn->parent : NULL;\n\twhile (pdn) {\n\t\t/* We're poking out of PCI territory */\n\t\tparent = pdn_to_eeh_dev(pdn);\n\t\tif (!parent)\n\t\t\treturn NULL;\n\n\t\tif (parent->pe)\n\t\t\treturn parent->pe;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdn_to_eeh_dev",
          "args": [
            "pdn"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_to_pdn",
          "args": [
            "edev"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic struct eeh_pe *eeh_pe_get_parent(struct eeh_dev *edev)\n{\n\tstruct eeh_dev *parent;\n\tstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\n\n\t/*\n\t * It might have the case for the indirect parent\n\t * EEH device already having associated PE, but\n\t * the direct parent EEH device doesn't have yet.\n\t */\n\tpdn = pdn ? pdn->parent : NULL;\n\twhile (pdn) {\n\t\t/* We're poking out of PCI territory */\n\t\tparent = pdn_to_eeh_dev(pdn);\n\t\tif (!parent)\n\t\t\treturn NULL;\n\n\t\tif (parent->pe)\n\t\t\treturn parent->pe;\n\n\t\tpdn = pdn->parent;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "274-282",
    "snippet": "struct eeh_pe *eeh_pe_get(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *root = eeh_phb_pe_get(edev->phb);\n\tstruct eeh_pe *pe;\n\n\tpe = eeh_pe_traverse(root, __eeh_pe_get, edev);\n\n\treturn pe;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_pe_traverse",
          "args": [
            "root",
            "__eeh_pe_get",
            "edev"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_traverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "175-187",
          "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_phb_pe_get",
          "args": [
            "edev->phb"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_phb_pe_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "120-135",
          "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(eeh_phb_pe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstruct eeh_pe *eeh_pe_get(struct eeh_dev *edev)\n{\n\tstruct eeh_pe *root = eeh_phb_pe_get(edev->phb);\n\tstruct eeh_pe *pe;\n\n\tpe = eeh_pe_traverse(root, __eeh_pe_get, edev);\n\n\treturn pe;\n}"
  },
  {
    "function_name": "__eeh_pe_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "233-261",
    "snippet": "static void *__eeh_pe_get(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tstruct eeh_dev *edev = (struct eeh_dev *)flag;\n\n\t/* Unexpected PHB PE */\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn NULL;\n\n\t/*\n\t * We prefer PE address. For most cases, we should\n\t * have non-zero PE address\n\t */\n\tif (eeh_has_flag(EEH_VALID_PE_ZERO)) {\n\t\tif (edev->pe_config_addr == pe->addr)\n\t\t\treturn pe;\n\t} else {\n\t\tif (edev->pe_config_addr &&\n\t\t    (edev->pe_config_addr == pe->addr))\n\t\treturn pe;\n\t}\n\n\t/* Try BDF address */\n\tif (edev->config_addr &&\n\t   (edev->config_addr == pe->config_addr))\n\t\treturn pe;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_has_flag",
          "args": [
            "EEH_VALID_PE_ZERO"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic void *__eeh_pe_get(void *data, void *flag)\n{\n\tstruct eeh_pe *pe = (struct eeh_pe *)data;\n\tstruct eeh_dev *edev = (struct eeh_dev *)flag;\n\n\t/* Unexpected PHB PE */\n\tif (pe->type & EEH_PE_PHB)\n\t\treturn NULL;\n\n\t/*\n\t * We prefer PE address. For most cases, we should\n\t * have non-zero PE address\n\t */\n\tif (eeh_has_flag(EEH_VALID_PE_ZERO)) {\n\t\tif (edev->pe_config_addr == pe->addr)\n\t\t\treturn pe;\n\t} else {\n\t\tif (edev->pe_config_addr &&\n\t\t    (edev->pe_config_addr == pe->addr))\n\t\treturn pe;\n\t}\n\n\t/* Try BDF address */\n\tif (edev->config_addr &&\n\t   (edev->config_addr == pe->config_addr))\n\t\treturn pe;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_dev_traverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "198-221",
    "snippet": "void *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "edev",
            "flag"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "70-105",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_for_each_dev",
          "args": [
            "pe",
            "edev",
            "tmp"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_next",
          "args": [
            "pe",
            "root"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "145-162",
          "snippet": "static struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\n\t\t\t\t  struct eeh_pe *root)\n{\n\tstruct list_head *next = pe->child_list.next;\n\n\tif (next == &pe->child_list) {\n\t\twhile (1) {\n\t\t\tif (pe == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = pe->child.next;\n\t\t\tif (next != &pe->parent->child_list)\n\t\t\t\tbreak;\n\t\t\tpe = pe->parent;\n\t\t}\n\t}\n\n\treturn list_entry(next, struct eeh_pe, child);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\n\t\t\t\t  struct eeh_pe *root)\n{\n\tstruct list_head *next = pe->child_list.next;\n\n\tif (next == &pe->child_list) {\n\t\twhile (1) {\n\t\t\tif (pe == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = pe->child.next;\n\t\t\tif (next != &pe->parent->child_list)\n\t\t\t\tbreak;\n\t\t\tpe = pe->parent;\n\t\t}\n\t}\n\n\treturn list_entry(next, struct eeh_pe, child);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Invalid PE %p\\n\"",
            "__func__",
            "root"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\n\t\teeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tstruct eeh_dev *edev, *tmp;\n\tvoid *ret;\n\n\tif (!root) {\n\t\tpr_warn(\"%s: Invalid PE %p\\n\",\n\t\t\t__func__, root);\n\t\treturn NULL;\n\t}\n\n\t/* Traverse root PE */\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\teeh_pe_for_each_dev(pe, edev, tmp) {\n\t\t\tret = fn(edev, flag);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_traverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "175-187",
    "snippet": "void *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "pe",
            "flag"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "pci_get_pdn_by_devfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "70-105",
          "snippet": "struct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_dn *pci_get_pdn_by_devfn(struct pci_bus *bus,\n\t\t\t\t    int devfn)\n{\n\tstruct device_node *dn = NULL;\n\tstruct pci_dn *parent, *pdn;\n\tstruct pci_dev *pdev = NULL;\n\n\t/* Fast path: fetch from PCI device */\n\tlist_for_each_entry(pdev, &bus->devices, bus_list) {\n\t\tif (pdev->devfn == devfn) {\n\t\t\tif (pdev->dev.archdata.pci_data)\n\t\t\t\treturn pdev->dev.archdata.pci_data;\n\n\t\t\tdn = pci_device_to_OF_node(pdev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Fast path: fetch from device node */\n\tpdn = dn ? PCI_DN(dn) : NULL;\n\tif (pdn)\n\t\treturn pdn;\n\n\t/* Slow path: fetch from firmware data hierarchy */\n\tparent = pci_bus_to_pdn(bus);\n\tif (!parent)\n\t\treturn NULL;\n\n\tlist_for_each_entry(pdn, &parent->child_list, list) {\n\t\tif (pdn->busno == bus->number &&\n                    pdn->devfn == devfn)\n                        return pdn;\n        }\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_pe_next",
          "args": [
            "pe",
            "root"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "145-162",
          "snippet": "static struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\n\t\t\t\t  struct eeh_pe *root)\n{\n\tstruct list_head *next = pe->child_list.next;\n\n\tif (next == &pe->child_list) {\n\t\twhile (1) {\n\t\t\tif (pe == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = pe->child.next;\n\t\t\tif (next != &pe->parent->child_list)\n\t\t\t\tbreak;\n\t\t\tpe = pe->parent;\n\t\t}\n\t}\n\n\treturn list_entry(next, struct eeh_pe, child);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\n\t\t\t\t  struct eeh_pe *root)\n{\n\tstruct list_head *next = pe->child_list.next;\n\n\tif (next == &pe->child_list) {\n\t\twhile (1) {\n\t\t\tif (pe == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = pe->child.next;\n\t\t\tif (next != &pe->parent->child_list)\n\t\t\t\tbreak;\n\t\t\tpe = pe->parent;\n\t\t}\n\t}\n\n\treturn list_entry(next, struct eeh_pe, child);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nvoid *eeh_pe_traverse(struct eeh_pe *root,\n\t\t      eeh_traverse_func fn, void *flag)\n{\n\tstruct eeh_pe *pe;\n\tvoid *ret;\n\n\tfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\n\t\tret = fn(pe, flag);\n\t\tif (ret) return ret;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_pe_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "145-162",
    "snippet": "static struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\n\t\t\t\t  struct eeh_pe *root)\n{\n\tstruct list_head *next = pe->child_list.next;\n\n\tif (next == &pe->child_list) {\n\t\twhile (1) {\n\t\t\tif (pe == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = pe->child.next;\n\t\t\tif (next != &pe->parent->child_list)\n\t\t\t\tbreak;\n\t\t\tpe = pe->parent;\n\t\t}\n\t}\n\n\treturn list_entry(next, struct eeh_pe, child);\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "next",
            "structeeh_pe",
            "child"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\n\t\t\t\t  struct eeh_pe *root)\n{\n\tstruct list_head *next = pe->child_list.next;\n\n\tif (next == &pe->child_list) {\n\t\twhile (1) {\n\t\t\tif (pe == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = pe->child.next;\n\t\t\tif (next != &pe->parent->child_list)\n\t\t\t\tbreak;\n\t\t\tpe = pe->parent;\n\t\t}\n\t}\n\n\treturn list_entry(next, struct eeh_pe, child);\n}"
  },
  {
    "function_name": "eeh_phb_pe_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "120-135",
    "snippet": "struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(eeh_phb_pe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "pe",
            "&eeh_phb_pe",
            "child"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\tlist_for_each_entry(pe, &eeh_phb_pe, child) {\n\t\t/*\n\t\t * Actually, we needn't check the type since\n\t\t * the PE for PHB has been determined when that\n\t\t * was created.\n\t\t */\n\t\tif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\n\t\t\treturn pe;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "eeh_phb_pe_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "93-110",
    "snippet": "int eeh_phb_pe_create(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\t/* Allocate PHB PE */\n\tpe = eeh_pe_alloc(phb, EEH_PE_PHB);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Put it into the list */\n\tlist_add_tail(&pe->child, &eeh_phb_pe);\n\n\tpr_debug(\"EEH: Add PE for PHB#%d\\n\", phb->global_number);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(eeh_phb_pe);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"EEH: Add PE for PHB#%d\\n\"",
            "phb->global_number"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pe->child",
            "&eeh_phb_pe"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: out of memory!\\n\"",
            "__func__"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_pe_alloc",
          "args": [
            "phb",
            "EEH_PE_PHB"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_pe_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
          "lines": "59-84",
          "snippet": "static struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->child);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int eeh_pe_aux_size = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_aux_size = 0;\n\nstatic struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->child);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic LIST_HEAD(eeh_phb_pe);\n\nint eeh_phb_pe_create(struct pci_controller *phb)\n{\n\tstruct eeh_pe *pe;\n\n\t/* Allocate PHB PE */\n\tpe = eeh_pe_alloc(phb, EEH_PE_PHB);\n\tif (!pe) {\n\t\tpr_err(\"%s: out of memory!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Put it into the list */\n\tlist_add_tail(&pe->child, &eeh_phb_pe);\n\n\tpr_debug(\"EEH: Add PE for PHB#%d\\n\", phb->global_number);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "eeh_pe_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "59-84",
    "snippet": "static struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->child);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int eeh_pe_aux_size = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "sizeof(struct eeh_pe)",
            "cache_line_size()"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_line_size",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pe->edevs"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pe->child"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&pe->child_list"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "alloc_size",
            "GFP_KERNEL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "alloc_size",
            "cache_line_size()"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_line_size",
          "args": [],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_aux_size = 0;\n\nstatic struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\n{\n\tstruct eeh_pe *pe;\n\tsize_t alloc_size;\n\n\talloc_size = sizeof(struct eeh_pe);\n\tif (eeh_pe_aux_size) {\n\t\talloc_size = ALIGN(alloc_size, cache_line_size());\n\t\talloc_size += eeh_pe_aux_size;\n\t}\n\n\t/* Allocate PHB PE */\n\tpe = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!pe) return NULL;\n\n\t/* Initialize PHB PE */\n\tpe->type = type;\n\tpe->phb = phb;\n\tINIT_LIST_HEAD(&pe->child_list);\n\tINIT_LIST_HEAD(&pe->child);\n\tINIT_LIST_HEAD(&pe->edevs);\n\n\tpe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\n\t\t\t\t      cache_line_size());\n\treturn pe;\n}"
  },
  {
    "function_name": "eeh_set_pe_aux_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_pe.c",
    "lines": "44-50",
    "snippet": "void eeh_set_pe_aux_size(int size)\n{\n\tif (size < 0)\n\t\treturn;\n\n\teeh_pe_aux_size = size;\n}",
    "includes": [
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <linux/string.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>",
      "#include <linux/gfp.h>",
      "#include <linux/export.h>",
      "#include <linux/delay.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int eeh_pe_aux_size = 0;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n\nstatic int eeh_pe_aux_size = 0;\n\nvoid eeh_set_pe_aux_size(int size)\n{\n\tif (size < 0)\n\t\treturn;\n\n\teeh_pe_aux_size = size;\n}"
  }
]