[
  {
    "function_name": "rtas_take_timebase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1229-1237",
    "snippet": "void rtas_take_timebase(void)\n{\n\twhile (!timebase)\n\t\tbarrier();\n\tarch_spin_lock(&timebase_lock);\n\tset_tb(timebase >> 32, timebase & 0xffffffff);\n\ttimebase = 0;\n\tarch_spin_unlock(&timebase_lock);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t timebase_lock;",
      "static u64 timebase = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&timebase_lock"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_tb",
          "args": [
            "timebase >> 32",
            "timebase & 0xffffffff"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&timebase_lock"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic arch_spinlock_t timebase_lock;\nstatic u64 timebase = 0;\n\nvoid rtas_take_timebase(void)\n{\n\twhile (!timebase)\n\t\tbarrier();\n\tarch_spin_lock(&timebase_lock);\n\tset_tb(timebase >> 32, timebase & 0xffffffff);\n\ttimebase = 0;\n\tarch_spin_unlock(&timebase_lock);\n}"
  },
  {
    "function_name": "rtas_give_timebase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1212-1227",
    "snippet": "void rtas_give_timebase(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\tarch_spin_lock(&timebase_lock);\n\trtas_call(rtas_token(\"freeze-time-base\"), 0, 1, NULL);\n\ttimebase = get_tb();\n\tarch_spin_unlock(&timebase_lock);\n\n\twhile (timebase)\n\t\tbarrier();\n\trtas_call(rtas_token(\"thaw-time-base\"), 0, 1, NULL);\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static arch_spinlock_t timebase_lock;",
      "static u64 timebase = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "202-277",
          "snippet": "notrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"thaw-time-base\")",
            "0",
            "1",
            "NULL"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"thaw-time-base\""
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "barrier",
          "args": [],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&timebase_lock"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_tb",
          "args": [],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&timebase_lock"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic arch_spinlock_t timebase_lock;\nstatic u64 timebase = 0;\n\nvoid rtas_give_timebase(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\tarch_spin_lock(&timebase_lock);\n\trtas_call(rtas_token(\"freeze-time-base\"), 0, 1, NULL);\n\ttimebase = get_tb();\n\tarch_spin_unlock(&timebase_lock);\n\n\twhile (timebase)\n\t\tbarrier();\n\trtas_call(rtas_token(\"thaw-time-base\"), 0, 1, NULL);\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "early_init_dt_scan_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1172-1207",
    "snippet": "int __init early_init_dt_scan_rtas(unsigned long node,\n\t\tconst char *uname, int depth, void *data)\n{\n\tconst u32 *basep, *entryp, *sizep;\n\n\tif (depth != 1 || strcmp(uname, \"rtas\") != 0)\n\t\treturn 0;\n\n\tbasep  = of_get_flat_dt_prop(node, \"linux,rtas-base\", NULL);\n\tentryp = of_get_flat_dt_prop(node, \"linux,rtas-entry\", NULL);\n\tsizep  = of_get_flat_dt_prop(node, \"rtas-size\", NULL);\n\n\tif (basep && entryp && sizep) {\n\t\trtas.base = *basep;\n\t\trtas.entry = *entryp;\n\t\trtas.size = *sizep;\n\t}\n\n#ifdef CONFIG_UDBG_RTAS_CONSOLE\n\tbasep = of_get_flat_dt_prop(node, \"put-term-char\", NULL);\n\tif (basep)\n\t\trtas_putchar_token = *basep;\n\n\tbasep = of_get_flat_dt_prop(node, \"get-term-char\", NULL);\n\tif (basep)\n\t\trtas_getchar_token = *basep;\n\n\tif (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&\n\t    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)\n\t\tudbg_init_rtas_console();\n\n#endif\n\n\t/* break now */\n\treturn 1;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udbg_init_rtas_console",
          "args": [],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_init_rtas_console",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "195-200",
          "snippet": "void __init udbg_init_rtas_console(void)\n{\n\tudbg_putc = udbg_rtascon_putc;\n\tudbg_getc = udbg_rtascon_getc;\n\tudbg_getc_poll = udbg_rtascon_getc_poll;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid __init udbg_init_rtas_console(void)\n{\n\tudbg_putc = udbg_rtascon_putc;\n\tudbg_getc = udbg_rtascon_getc;\n\tudbg_getc_poll = udbg_rtascon_getc_poll;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"get-term-char\"",
            "NULL"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"put-term-char\"",
            "NULL"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"rtas-size\"",
            "NULL"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,rtas-entry\"",
            "NULL"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,rtas-base\"",
            "NULL"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "\"rtas\""
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint __init early_init_dt_scan_rtas(unsigned long node,\n\t\tconst char *uname, int depth, void *data)\n{\n\tconst u32 *basep, *entryp, *sizep;\n\n\tif (depth != 1 || strcmp(uname, \"rtas\") != 0)\n\t\treturn 0;\n\n\tbasep  = of_get_flat_dt_prop(node, \"linux,rtas-base\", NULL);\n\tentryp = of_get_flat_dt_prop(node, \"linux,rtas-entry\", NULL);\n\tsizep  = of_get_flat_dt_prop(node, \"rtas-size\", NULL);\n\n\tif (basep && entryp && sizep) {\n\t\trtas.base = *basep;\n\t\trtas.entry = *entryp;\n\t\trtas.size = *sizep;\n\t}\n\n#ifdef CONFIG_UDBG_RTAS_CONSOLE\n\tbasep = of_get_flat_dt_prop(node, \"put-term-char\", NULL);\n\tif (basep)\n\t\trtas_putchar_token = *basep;\n\n\tbasep = of_get_flat_dt_prop(node, \"get-term-char\", NULL);\n\tif (basep)\n\t\trtas_getchar_token = *basep;\n\n\tif (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&\n\t    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)\n\t\tudbg_init_rtas_console();\n\n#endif\n\n\t/* break now */\n\treturn 1;\n}"
  },
  {
    "function_name": "rtas_initialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1128-1170",
    "snippet": "void __init rtas_initialize(void)\n{\n\tunsigned long rtas_region = RTAS_INSTANTIATE_MAX;\n\n\t/* Get RTAS dev node and fill up our \"rtas\" structure with infos\n\t * about it.\n\t */\n\trtas.dev = of_find_node_by_name(NULL, \"rtas\");\n\tif (rtas.dev) {\n\t\tconst __be32 *basep, *entryp, *sizep;\n\n\t\tbasep = of_get_property(rtas.dev, \"linux,rtas-base\", NULL);\n\t\tsizep = of_get_property(rtas.dev, \"rtas-size\", NULL);\n\t\tif (basep != NULL && sizep != NULL) {\n\t\t\trtas.base = __be32_to_cpu(*basep);\n\t\t\trtas.size = __be32_to_cpu(*sizep);\n\t\t\tentryp = of_get_property(rtas.dev,\n\t\t\t\t\t\"linux,rtas-entry\", NULL);\n\t\t\tif (entryp == NULL) /* Ugh */\n\t\t\t\trtas.entry = rtas.base;\n\t\t\telse\n\t\t\t\trtas.entry = __be32_to_cpu(*entryp);\n\t\t} else\n\t\t\trtas.dev = NULL;\n\t}\n\tif (!rtas.dev)\n\t\treturn;\n\n\t/* If RTAS was found, allocate the RMO buffer for it and look for\n\t * the stop-self token if any\n\t */\n#ifdef CONFIG_PPC64\n\tif (machine_is(pseries) && firmware_has_feature(FW_FEATURE_LPAR)) {\n\t\trtas_region = min(ppc64_rma_size, RTAS_INSTANTIATE_MAX);\n\t\tibm_suspend_me_token = rtas_token(\"ibm,suspend-me\");\n\t}\n#endif\n\trtas_rmo_buf = memblock_alloc_base(RTAS_RMOBUF_MAX, PAGE_SIZE, rtas_region);\n\n#ifdef CONFIG_RTAS_ERROR_LOGGING\n\trtas_last_error_token = rtas_token(\"rtas-last-error\");\n#endif\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};",
      "unsigned long rtas_rmo_buf;",
      "static int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"rtas-last-error\""
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_alloc_base",
          "args": [
            "RTAS_RMOBUF_MAX",
            "PAGE_SIZE",
            "rtas_region"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ppc64_rma_size",
            "RTAS_INSTANTIATE_MAX"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_LPAR"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_is",
          "args": [
            "pseries"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__be32_to_cpu",
          "args": [
            "*entryp"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "\"linux,rtas-entry\"",
            "NULL"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__be32_to_cpu",
          "args": [
            "*sizep"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__be32_to_cpu",
          "args": [
            "*basep"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "\"rtas-size\"",
            "NULL"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "\"linux,rtas-base\"",
            "NULL"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_name",
          "args": [
            "NULL",
            "\"rtas\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\nunsigned long rtas_rmo_buf;\nstatic int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;\n\nvoid __init rtas_initialize(void)\n{\n\tunsigned long rtas_region = RTAS_INSTANTIATE_MAX;\n\n\t/* Get RTAS dev node and fill up our \"rtas\" structure with infos\n\t * about it.\n\t */\n\trtas.dev = of_find_node_by_name(NULL, \"rtas\");\n\tif (rtas.dev) {\n\t\tconst __be32 *basep, *entryp, *sizep;\n\n\t\tbasep = of_get_property(rtas.dev, \"linux,rtas-base\", NULL);\n\t\tsizep = of_get_property(rtas.dev, \"rtas-size\", NULL);\n\t\tif (basep != NULL && sizep != NULL) {\n\t\t\trtas.base = __be32_to_cpu(*basep);\n\t\t\trtas.size = __be32_to_cpu(*sizep);\n\t\t\tentryp = of_get_property(rtas.dev,\n\t\t\t\t\t\"linux,rtas-entry\", NULL);\n\t\t\tif (entryp == NULL) /* Ugh */\n\t\t\t\trtas.entry = rtas.base;\n\t\t\telse\n\t\t\t\trtas.entry = __be32_to_cpu(*entryp);\n\t\t} else\n\t\t\trtas.dev = NULL;\n\t}\n\tif (!rtas.dev)\n\t\treturn;\n\n\t/* If RTAS was found, allocate the RMO buffer for it and look for\n\t * the stop-self token if any\n\t */\n#ifdef CONFIG_PPC64\n\tif (machine_is(pseries) && firmware_has_feature(FW_FEATURE_LPAR)) {\n\t\trtas_region = min(ppc64_rma_size, RTAS_INSTANTIATE_MAX);\n\t\tibm_suspend_me_token = rtas_token(\"ibm,suspend-me\");\n\t}\n#endif\n\trtas_rmo_buf = memblock_alloc_base(RTAS_RMOBUF_MAX, PAGE_SIZE, rtas_region);\n\n#ifdef CONFIG_RTAS_ERROR_LOGGING\n\trtas_last_error_token = rtas_token(\"rtas-last-error\");\n#endif\n}"
  },
  {
    "function_name": "ppc_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1036-1121",
    "snippet": "asmlinkage int ppc_rtas(struct rtas_args __user *uargs)\n{\n\tstruct rtas_args args;\n\tunsigned long flags;\n\tchar *buff_copy, *errbuf = NULL;\n\tint nargs, nret, token;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtas.entry)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)\n\t\treturn -EFAULT;\n\n\tnargs = be32_to_cpu(args.nargs);\n\tnret  = be32_to_cpu(args.nret);\n\ttoken = be32_to_cpu(args.token);\n\n\tif (nargs > ARRAY_SIZE(args.args)\n\t    || nret > ARRAY_SIZE(args.args)\n\t    || nargs + nret > ARRAY_SIZE(args.args))\n\t\treturn -EINVAL;\n\n\t/* Copy in args. */\n\tif (copy_from_user(args.args, uargs->args,\n\t\t\t   nargs * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -EINVAL;\n\n\targs.rets = &args.args[nargs];\n\tmemset(args.rets, 0, nret * sizeof(rtas_arg_t));\n\n\t/* Need to handle ibm,suspend_me call specially */\n\tif (token == ibm_suspend_me_token) {\n\n\t\t/*\n\t\t * rtas_ibm_suspend_me assumes the streamid handle is in cpu\n\t\t * endian, or at least the hcall within it requires it.\n\t\t */\n\t\tint rc = 0;\n\t\tu64 handle = ((u64)be32_to_cpu(args.args[0]) << 32)\n\t\t              | be32_to_cpu(args.args[1]);\n\t\trc = rtas_ibm_suspend_me(handle);\n\t\tif (rc == -EAGAIN)\n\t\t\targs.rets[0] = cpu_to_be32(RTAS_NOT_SUSPENDABLE);\n\t\telse if (rc == -EIO)\n\t\t\targs.rets[0] = cpu_to_be32(-1);\n\t\telse if (rc)\n\t\t\treturn rc;\n\t\tgoto copy_return;\n\t}\n\n\tbuff_copy = get_errorlog_buffer();\n\n\tflags = lock_rtas();\n\n\trtas.args = args;\n\tenter_rtas(__pa(&rtas.args));\n\targs = rtas.args;\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(args.rets[0]) == -1)\n\t\terrbuf = __fetch_rtas_last_error(buff_copy);\n\n\tunlock_rtas(flags);\n\n\tif (buff_copy) {\n\t\tif (errbuf)\n\t\t\tlog_error(errbuf, ERR_TYPE_RTAS_LOG, 0);\n\t\tkfree(buff_copy);\n\t}\n\n copy_return:\n\t/* Copy out args. */\n\tif (copy_to_user(uargs->args + nargs,\n\t\t\t args.args + nargs,\n\t\t\t nret * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};",
      "static int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uargs->args + nargs",
            "args.args + nargs",
            "nret * sizeof(rtas_arg_t)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buff_copy"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "errbuf",
            "ERR_TYPE_RTAS_LOG",
            "0"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "pSeries_log_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "197-273",
          "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(rtasd_log_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
            "static char *rtas_log_buf;",
            "static unsigned long rtas_log_start;",
            "static unsigned long rtas_log_size;",
            "static unsigned int rtas_error_log_buffer_max;",
            "static int logging_enabled;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rtas",
          "args": [
            "flags"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "82-87",
          "snippet": "static void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fetch_rtas_last_error",
          "args": [
            "buff_copy"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "__fetch_rtas_last_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "372-412",
          "snippet": "static char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "args.rets[0]"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_rtas",
          "args": [
            "__pa(&rtas.args)"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "&rtas.args"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_rtas",
          "args": [],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "lock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "72-80",
          "snippet": "static unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock_flags(&rtas.lock, flags);\n\treturn flags;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock_flags(&rtas.lock, flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_errorlog_buffer",
          "args": [],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "-1"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "RTAS_NOT_SUSPENDABLE"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_ibm_suspend_me",
          "args": [
            "handle"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_ibm_suspend_me",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "992-995",
          "snippet": "int rtas_ibm_suspend_me(u64 handle)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_ibm_suspend_me(u64 handle)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "args.args[1]"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "args.args[0]"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "args.rets",
            "0",
            "nret * sizeof(rtas_arg_t)"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "args.args",
            "uargs->args",
            "nargs * sizeof(rtas_arg_t)"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "args.args"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "args.args"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "args.args"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "args.token"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "args.nret"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "args.nargs"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&args",
            "uargs",
            "3 * sizeof(u32)"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\nstatic int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;\n\nasmlinkage int ppc_rtas(struct rtas_args __user *uargs)\n{\n\tstruct rtas_args args;\n\tunsigned long flags;\n\tchar *buff_copy, *errbuf = NULL;\n\tint nargs, nret, token;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtas.entry)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)\n\t\treturn -EFAULT;\n\n\tnargs = be32_to_cpu(args.nargs);\n\tnret  = be32_to_cpu(args.nret);\n\ttoken = be32_to_cpu(args.token);\n\n\tif (nargs > ARRAY_SIZE(args.args)\n\t    || nret > ARRAY_SIZE(args.args)\n\t    || nargs + nret > ARRAY_SIZE(args.args))\n\t\treturn -EINVAL;\n\n\t/* Copy in args. */\n\tif (copy_from_user(args.args, uargs->args,\n\t\t\t   nargs * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -EINVAL;\n\n\targs.rets = &args.args[nargs];\n\tmemset(args.rets, 0, nret * sizeof(rtas_arg_t));\n\n\t/* Need to handle ibm,suspend_me call specially */\n\tif (token == ibm_suspend_me_token) {\n\n\t\t/*\n\t\t * rtas_ibm_suspend_me assumes the streamid handle is in cpu\n\t\t * endian, or at least the hcall within it requires it.\n\t\t */\n\t\tint rc = 0;\n\t\tu64 handle = ((u64)be32_to_cpu(args.args[0]) << 32)\n\t\t              | be32_to_cpu(args.args[1]);\n\t\trc = rtas_ibm_suspend_me(handle);\n\t\tif (rc == -EAGAIN)\n\t\t\targs.rets[0] = cpu_to_be32(RTAS_NOT_SUSPENDABLE);\n\t\telse if (rc == -EIO)\n\t\t\targs.rets[0] = cpu_to_be32(-1);\n\t\telse if (rc)\n\t\t\treturn rc;\n\t\tgoto copy_return;\n\t}\n\n\tbuff_copy = get_errorlog_buffer();\n\n\tflags = lock_rtas();\n\n\trtas.args = args;\n\tenter_rtas(__pa(&rtas.args));\n\targs = rtas.args;\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(args.rets[0]) == -1)\n\t\terrbuf = __fetch_rtas_last_error(buff_copy);\n\n\tunlock_rtas(flags);\n\n\tif (buff_copy) {\n\t\tif (errbuf)\n\t\t\tlog_error(errbuf, ERR_TYPE_RTAS_LOG, 0);\n\t\tkfree(buff_copy);\n\t}\n\n copy_return:\n\t/* Copy out args. */\n\tif (copy_to_user(uargs->args + nargs,\n\t\t\t args.args + nargs,\n\t\t\t nret * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_pseries_errorlog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "1005-1033",
    "snippet": "struct pseries_errorlog *get_pseries_errorlog(struct rtas_error_log *log,\n\t\t\t\t\t      uint16_t section_id)\n{\n\tstruct rtas_ext_event_log_v6 *ext_log =\n\t\t(struct rtas_ext_event_log_v6 *)log->buffer;\n\tstruct pseries_errorlog *sect;\n\tunsigned char *p, *log_end;\n\tuint32_t ext_log_length = rtas_error_extended_log_length(log);\n\tuint8_t log_format = rtas_ext_event_log_format(ext_log);\n\tuint32_t company_id = rtas_ext_event_company_id(ext_log);\n\n\t/* Check that we understand the format */\n\tif (ext_log_length < sizeof(struct rtas_ext_event_log_v6) ||\n\t    log_format != RTAS_V6EXT_LOG_FORMAT_EVENT_LOG ||\n\t    company_id != RTAS_V6EXT_COMPANY_ID_IBM)\n\t\treturn NULL;\n\n\tlog_end = log->buffer + ext_log_length;\n\tp = ext_log->vendor_log;\n\n\twhile (p < log_end) {\n\t\tsect = (struct pseries_errorlog *)p;\n\t\tif (pseries_errorlog_id(sect) == section_id)\n\t\t\treturn sect;\n\t\tp += pseries_errorlog_length(sect);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pseries_errorlog_length",
          "args": [
            "sect"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pseries_errorlog_id",
          "args": [
            "sect"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_ext_event_company_id",
          "args": [
            "ext_log"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_ext_event_log_format",
          "args": [
            "ext_log"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_error_extended_log_length",
          "args": [
            "log"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct pseries_errorlog *get_pseries_errorlog(struct rtas_error_log *log,\n\t\t\t\t\t      uint16_t section_id)\n{\n\tstruct rtas_ext_event_log_v6 *ext_log =\n\t\t(struct rtas_ext_event_log_v6 *)log->buffer;\n\tstruct pseries_errorlog *sect;\n\tunsigned char *p, *log_end;\n\tuint32_t ext_log_length = rtas_error_extended_log_length(log);\n\tuint8_t log_format = rtas_ext_event_log_format(ext_log);\n\tuint32_t company_id = rtas_ext_event_company_id(ext_log);\n\n\t/* Check that we understand the format */\n\tif (ext_log_length < sizeof(struct rtas_ext_event_log_v6) ||\n\t    log_format != RTAS_V6EXT_LOG_FORMAT_EVENT_LOG ||\n\t    company_id != RTAS_V6EXT_COMPANY_ID_IBM)\n\t\treturn NULL;\n\n\tlog_end = log->buffer + ext_log_length;\n\tp = ext_log->vendor_log;\n\n\twhile (p < log_end) {\n\t\tsect = (struct pseries_errorlog *)p;\n\t\tif (pseries_errorlog_id(sect) == section_id)\n\t\t\treturn sect;\n\t\tp += pseries_errorlog_length(sect);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "rtas_ibm_suspend_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "992-995",
    "snippet": "int rtas_ibm_suspend_me(u64 handle)\n{\n\treturn -ENOSYS;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_ibm_suspend_me(u64 handle)\n{\n\treturn -ENOSYS;\n}"
  },
  {
    "function_name": "rtas_ibm_suspend_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "919-990",
    "snippet": "int rtas_ibm_suspend_me(u64 handle)\n{\n\tlong state;\n\tlong rc;\n\tunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\n\tstruct rtas_suspend_me_data data;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tcpumask_var_t offline_mask;\n\tint cpuret;\n\n\tif (!rtas_service_present(\"ibm,suspend-me\"))\n\t\treturn -ENOSYS;\n\n\t/* Make sure the state is valid */\n\trc = plpar_hcall(H_VASI_STATE, retbuf, handle);\n\n\tstate = retbuf[0];\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned %ld\\n\",rc);\n\t\treturn rc;\n\t} else if (state == H_VASI_ENABLED) {\n\t\treturn -EAGAIN;\n\t} else if (state != H_VASI_SUSPENDING) {\n\t\tprintk(KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned state %ld\\n\",\n\t\t       state);\n\t\treturn -EIO;\n\t}\n\n\tif (!alloc_cpumask_var(&offline_mask, GFP_TEMPORARY))\n\t\treturn -ENOMEM;\n\n\tatomic_set(&data.working, 0);\n\tatomic_set(&data.done, 0);\n\tatomic_set(&data.error, 0);\n\tdata.token = rtas_token(\"ibm,suspend-me\");\n\tdata.complete = &done;\n\n\t/* All present CPUs must be online */\n\tcpumask_andnot(offline_mask, cpu_present_mask, cpu_online_mask);\n\tcpuret = rtas_online_cpus_mask(offline_mask);\n\tif (cpuret) {\n\t\tpr_err(\"%s: Could not bring present CPUs online.\\n\", __func__);\n\t\tatomic_set(&data.error, cpuret);\n\t\tgoto out;\n\t}\n\n\tstop_topology_update();\n\n\t/* Call function on all CPUs.  One of us will make the\n\t * rtas call\n\t */\n\tif (on_each_cpu(rtas_percpu_suspend_me, &data, 0))\n\t\tatomic_set(&data.error, -EINVAL);\n\n\twait_for_completion(&done);\n\n\tif (atomic_read(&data.error) != 0)\n\t\tprintk(KERN_ERR \"Error doing global join\\n\");\n\n\tstart_topology_update();\n\n\t/* Take down CPUs not online prior to suspend */\n\tcpuret = rtas_offline_cpus_mask(offline_mask);\n\tif (cpuret)\n\t\tpr_warn(\"%s: Could not restore CPUs to offline state.\\n\",\n\t\t\t\t__func__);\n\nout:\n\tfree_cpumask_var(offline_mask);\n\treturn atomic_read(&data.error);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data.error"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "offline_mask"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: Could not restore CPUs to offline state.\\n\"",
            "__func__"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_offline_cpus_mask",
          "args": [
            "offline_mask"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_offline_cpus_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "913-916",
          "snippet": "int rtas_offline_cpus_mask(cpumask_var_t cpus)\n{\n\treturn rtas_cpu_state_change_mask(DOWN, cpus);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_offline_cpus_mask(cpumask_var_t cpus)\n{\n\treturn rtas_cpu_state_change_mask(DOWN, cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_topology_update",
          "args": [],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error doing global join\\n\""
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data.error"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&done"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data.error",
            "-EINVAL"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_each_cpu",
          "args": [
            "rtas_percpu_suspend_me",
            "&data",
            "0"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stop_topology_update",
          "args": [],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data.error",
            "cpuret"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: Could not bring present CPUs online.\\n\"",
            "__func__"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_online_cpus_mask",
          "args": [
            "offline_mask"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_online_cpus_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "891-910",
          "snippet": "int rtas_online_cpus_mask(cpumask_var_t cpus)\n{\n\tint ret;\n\n\tret = rtas_cpu_state_change_mask(UP, cpus);\n\n\tif (ret) {\n\t\tcpumask_var_t tmp_mask;\n\n\t\tif (!alloc_cpumask_var(&tmp_mask, GFP_TEMPORARY))\n\t\t\treturn ret;\n\n\t\t/* Use tmp_mask to preserve cpus mask from first failure */\n\t\tcpumask_copy(tmp_mask, cpus);\n\t\trtas_offline_cpus_mask(tmp_mask);\n\t\tfree_cpumask_var(tmp_mask);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_online_cpus_mask(cpumask_var_t cpus)\n{\n\tint ret;\n\n\tret = rtas_cpu_state_change_mask(UP, cpus);\n\n\tif (ret) {\n\t\tcpumask_var_t tmp_mask;\n\n\t\tif (!alloc_cpumask_var(&tmp_mask, GFP_TEMPORARY))\n\t\t\treturn ret;\n\n\t\t/* Use tmp_mask to preserve cpus mask from first failure */\n\t\tcpumask_copy(tmp_mask, cpus);\n\t\trtas_offline_cpus_mask(tmp_mask);\n\t\tfree_cpumask_var(tmp_mask);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_andnot",
          "args": [
            "offline_mask",
            "cpu_present_mask",
            "cpu_online_mask"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,suspend-me\""
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data.error",
            "0"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data.done",
            "0"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data.working",
            "0"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&offline_mask",
            "GFP_TEMPORARY"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned state %ld\\n\"",
            "state"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "plpar_hcall",
          "args": [
            "H_VASI_STATE",
            "retbuf",
            "handle"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_service_present",
          "args": [
            "\"ibm,suspend-me\""
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_service_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "333-336",
          "snippet": "int rtas_service_present(const char *service)\n{\n\treturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_service_present(const char *service)\n{\n\treturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "done"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_ibm_suspend_me(u64 handle)\n{\n\tlong state;\n\tlong rc;\n\tunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\n\tstruct rtas_suspend_me_data data;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tcpumask_var_t offline_mask;\n\tint cpuret;\n\n\tif (!rtas_service_present(\"ibm,suspend-me\"))\n\t\treturn -ENOSYS;\n\n\t/* Make sure the state is valid */\n\trc = plpar_hcall(H_VASI_STATE, retbuf, handle);\n\n\tstate = retbuf[0];\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned %ld\\n\",rc);\n\t\treturn rc;\n\t} else if (state == H_VASI_ENABLED) {\n\t\treturn -EAGAIN;\n\t} else if (state != H_VASI_SUSPENDING) {\n\t\tprintk(KERN_ERR \"rtas_ibm_suspend_me: vasi_state returned state %ld\\n\",\n\t\t       state);\n\t\treturn -EIO;\n\t}\n\n\tif (!alloc_cpumask_var(&offline_mask, GFP_TEMPORARY))\n\t\treturn -ENOMEM;\n\n\tatomic_set(&data.working, 0);\n\tatomic_set(&data.done, 0);\n\tatomic_set(&data.error, 0);\n\tdata.token = rtas_token(\"ibm,suspend-me\");\n\tdata.complete = &done;\n\n\t/* All present CPUs must be online */\n\tcpumask_andnot(offline_mask, cpu_present_mask, cpu_online_mask);\n\tcpuret = rtas_online_cpus_mask(offline_mask);\n\tif (cpuret) {\n\t\tpr_err(\"%s: Could not bring present CPUs online.\\n\", __func__);\n\t\tatomic_set(&data.error, cpuret);\n\t\tgoto out;\n\t}\n\n\tstop_topology_update();\n\n\t/* Call function on all CPUs.  One of us will make the\n\t * rtas call\n\t */\n\tif (on_each_cpu(rtas_percpu_suspend_me, &data, 0))\n\t\tatomic_set(&data.error, -EINVAL);\n\n\twait_for_completion(&done);\n\n\tif (atomic_read(&data.error) != 0)\n\t\tprintk(KERN_ERR \"Error doing global join\\n\");\n\n\tstart_topology_update();\n\n\t/* Take down CPUs not online prior to suspend */\n\tcpuret = rtas_offline_cpus_mask(offline_mask);\n\tif (cpuret)\n\t\tpr_warn(\"%s: Could not restore CPUs to offline state.\\n\",\n\t\t\t\t__func__);\n\nout:\n\tfree_cpumask_var(offline_mask);\n\treturn atomic_read(&data.error);\n}"
  },
  {
    "function_name": "rtas_offline_cpus_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "913-916",
    "snippet": "int rtas_offline_cpus_mask(cpumask_var_t cpus)\n{\n\treturn rtas_cpu_state_change_mask(DOWN, cpus);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_cpu_state_change_mask",
          "args": [
            "DOWN",
            "cpus"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_cpu_state_change_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "849-888",
          "snippet": "static int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\n\t\t\t\tcpumask_var_t cpus)\n{\n\tint cpu;\n\tint cpuret = 0;\n\tint ret = 0;\n\n\tif (cpumask_empty(cpus))\n\t\treturn 0;\n\n\tfor_each_cpu(cpu, cpus) {\n\t\tswitch (state) {\n\t\tcase DOWN:\n\t\t\tcpuret = cpu_down(cpu);\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tcpuret = cpu_up(cpu);\n\t\t\tbreak;\n\t\t}\n\t\tif (cpuret) {\n\t\t\tpr_debug(\"%s: cpu_%s for cpu#%d returned %d.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t((state == UP) ? \"up\" : \"down\"),\n\t\t\t\t\tcpu, cpuret);\n\t\t\tif (!ret)\n\t\t\t\tret = cpuret;\n\t\t\tif (state == UP) {\n\t\t\t\t/* clear bits for unchanged cpus, return */\n\t\t\t\tcpumask_shift_right(cpus, cpus, cpu);\n\t\t\t\tcpumask_shift_left(cpus, cpus, cpu);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* clear bit for unchanged cpu, continue */\n\t\t\t\tcpumask_clear_cpu(cpu, cpus);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\n\t\t\t\tcpumask_var_t cpus)\n{\n\tint cpu;\n\tint cpuret = 0;\n\tint ret = 0;\n\n\tif (cpumask_empty(cpus))\n\t\treturn 0;\n\n\tfor_each_cpu(cpu, cpus) {\n\t\tswitch (state) {\n\t\tcase DOWN:\n\t\t\tcpuret = cpu_down(cpu);\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tcpuret = cpu_up(cpu);\n\t\t\tbreak;\n\t\t}\n\t\tif (cpuret) {\n\t\t\tpr_debug(\"%s: cpu_%s for cpu#%d returned %d.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t((state == UP) ? \"up\" : \"down\"),\n\t\t\t\t\tcpu, cpuret);\n\t\t\tif (!ret)\n\t\t\t\tret = cpuret;\n\t\t\tif (state == UP) {\n\t\t\t\t/* clear bits for unchanged cpus, return */\n\t\t\t\tcpumask_shift_right(cpus, cpus, cpu);\n\t\t\t\tcpumask_shift_left(cpus, cpus, cpu);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* clear bit for unchanged cpu, continue */\n\t\t\t\tcpumask_clear_cpu(cpu, cpus);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_offline_cpus_mask(cpumask_var_t cpus)\n{\n\treturn rtas_cpu_state_change_mask(DOWN, cpus);\n}"
  },
  {
    "function_name": "rtas_online_cpus_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "891-910",
    "snippet": "int rtas_online_cpus_mask(cpumask_var_t cpus)\n{\n\tint ret;\n\n\tret = rtas_cpu_state_change_mask(UP, cpus);\n\n\tif (ret) {\n\t\tcpumask_var_t tmp_mask;\n\n\t\tif (!alloc_cpumask_var(&tmp_mask, GFP_TEMPORARY))\n\t\t\treturn ret;\n\n\t\t/* Use tmp_mask to preserve cpus mask from first failure */\n\t\tcpumask_copy(tmp_mask, cpus);\n\t\trtas_offline_cpus_mask(tmp_mask);\n\t\tfree_cpumask_var(tmp_mask);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "tmp_mask"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_offline_cpus_mask",
          "args": [
            "tmp_mask"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_offline_cpus_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "913-916",
          "snippet": "int rtas_offline_cpus_mask(cpumask_var_t cpus)\n{\n\treturn rtas_cpu_state_change_mask(DOWN, cpus);\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_offline_cpus_mask(cpumask_var_t cpus)\n{\n\treturn rtas_cpu_state_change_mask(DOWN, cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_copy",
          "args": [
            "tmp_mask",
            "cpus"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&tmp_mask",
            "GFP_TEMPORARY"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_cpu_state_change_mask",
          "args": [
            "UP",
            "cpus"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_cpu_state_change_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "849-888",
          "snippet": "static int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\n\t\t\t\tcpumask_var_t cpus)\n{\n\tint cpu;\n\tint cpuret = 0;\n\tint ret = 0;\n\n\tif (cpumask_empty(cpus))\n\t\treturn 0;\n\n\tfor_each_cpu(cpu, cpus) {\n\t\tswitch (state) {\n\t\tcase DOWN:\n\t\t\tcpuret = cpu_down(cpu);\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tcpuret = cpu_up(cpu);\n\t\t\tbreak;\n\t\t}\n\t\tif (cpuret) {\n\t\t\tpr_debug(\"%s: cpu_%s for cpu#%d returned %d.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t((state == UP) ? \"up\" : \"down\"),\n\t\t\t\t\tcpu, cpuret);\n\t\t\tif (!ret)\n\t\t\t\tret = cpuret;\n\t\t\tif (state == UP) {\n\t\t\t\t/* clear bits for unchanged cpus, return */\n\t\t\t\tcpumask_shift_right(cpus, cpus, cpu);\n\t\t\t\tcpumask_shift_left(cpus, cpus, cpu);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* clear bit for unchanged cpu, continue */\n\t\t\t\tcpumask_clear_cpu(cpu, cpus);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\n\t\t\t\tcpumask_var_t cpus)\n{\n\tint cpu;\n\tint cpuret = 0;\n\tint ret = 0;\n\n\tif (cpumask_empty(cpus))\n\t\treturn 0;\n\n\tfor_each_cpu(cpu, cpus) {\n\t\tswitch (state) {\n\t\tcase DOWN:\n\t\t\tcpuret = cpu_down(cpu);\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tcpuret = cpu_up(cpu);\n\t\t\tbreak;\n\t\t}\n\t\tif (cpuret) {\n\t\t\tpr_debug(\"%s: cpu_%s for cpu#%d returned %d.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t((state == UP) ? \"up\" : \"down\"),\n\t\t\t\t\tcpu, cpuret);\n\t\t\tif (!ret)\n\t\t\t\tret = cpuret;\n\t\t\tif (state == UP) {\n\t\t\t\t/* clear bits for unchanged cpus, return */\n\t\t\t\tcpumask_shift_right(cpus, cpus, cpu);\n\t\t\t\tcpumask_shift_left(cpus, cpus, cpu);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* clear bit for unchanged cpu, continue */\n\t\t\t\tcpumask_clear_cpu(cpu, cpus);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_online_cpus_mask(cpumask_var_t cpus)\n{\n\tint ret;\n\n\tret = rtas_cpu_state_change_mask(UP, cpus);\n\n\tif (ret) {\n\t\tcpumask_var_t tmp_mask;\n\n\t\tif (!alloc_cpumask_var(&tmp_mask, GFP_TEMPORARY))\n\t\t\treturn ret;\n\n\t\t/* Use tmp_mask to preserve cpus mask from first failure */\n\t\tcpumask_copy(tmp_mask, cpus);\n\t\trtas_offline_cpus_mask(tmp_mask);\n\t\tfree_cpumask_var(tmp_mask);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rtas_cpu_state_change_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "849-888",
    "snippet": "static int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\n\t\t\t\tcpumask_var_t cpus)\n{\n\tint cpu;\n\tint cpuret = 0;\n\tint ret = 0;\n\n\tif (cpumask_empty(cpus))\n\t\treturn 0;\n\n\tfor_each_cpu(cpu, cpus) {\n\t\tswitch (state) {\n\t\tcase DOWN:\n\t\t\tcpuret = cpu_down(cpu);\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tcpuret = cpu_up(cpu);\n\t\t\tbreak;\n\t\t}\n\t\tif (cpuret) {\n\t\t\tpr_debug(\"%s: cpu_%s for cpu#%d returned %d.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t((state == UP) ? \"up\" : \"down\"),\n\t\t\t\t\tcpu, cpuret);\n\t\t\tif (!ret)\n\t\t\t\tret = cpuret;\n\t\t\tif (state == UP) {\n\t\t\t\t/* clear bits for unchanged cpus, return */\n\t\t\t\tcpumask_shift_right(cpus, cpus, cpu);\n\t\t\t\tcpumask_shift_left(cpus, cpus, cpu);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* clear bit for unchanged cpu, continue */\n\t\t\t\tcpumask_clear_cpu(cpu, cpus);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "cpu",
            "cpus"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_shift_left",
          "args": [
            "cpus",
            "cpus",
            "cpu"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_shift_right",
          "args": [
            "cpus",
            "cpus",
            "cpu"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: cpu_%s for cpu#%d returned %d.\\n\"",
            "__func__",
            "((state == UP) ? \"up\" : \"down\")",
            "cpu",
            "cpuret"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_up",
          "args": [
            "cpu"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "generic_set_cpu_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/smp.c",
          "lines": "447-450",
          "snippet": "void generic_set_cpu_up(unsigned int cpu)\n{\n\tper_cpu(cpu_state, cpu) = CPU_UP_PREPARE;\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debug.h>",
            "#include <asm/vdso.h>",
            "#include <asm/paca.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/mpic.h>",
            "#include <asm/cputable.h>",
            "#include <asm/cputhreads.h>",
            "#include <asm/machdep.h>",
            "#include <asm/time.h>",
            "#include <asm/smp.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/kvm_ppc.h>",
            "#include <asm/hw_irq.h>",
            "#include <asm/irq.h>",
            "#include <linux/atomic.h>",
            "#include <asm/ptrace.h>",
            "#include <linux/topology.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/device.h>",
            "#include <linux/err.h>",
            "#include <linux/cache.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/kexec.h>\n#include <asm/debug.h>\n#include <asm/vdso.h>\n#include <asm/paca.h>\n#include <asm/vdso_datapage.h>\n#include <asm/mpic.h>\n#include <asm/cputable.h>\n#include <asm/cputhreads.h>\n#include <asm/machdep.h>\n#include <asm/time.h>\n#include <asm/smp.h>\n#include <asm/prom.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/kvm_ppc.h>\n#include <asm/hw_irq.h>\n#include <asm/irq.h>\n#include <linux/atomic.h>\n#include <asm/ptrace.h>\n#include <linux/topology.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/cache.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nvoid generic_set_cpu_up(unsigned int cpu)\n{\n\tper_cpu(cpu_state, cpu) = CPU_UP_PREPARE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_down",
          "args": [
            "cpu"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "cpus"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpus"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\n\t\t\t\tcpumask_var_t cpus)\n{\n\tint cpu;\n\tint cpuret = 0;\n\tint ret = 0;\n\n\tif (cpumask_empty(cpus))\n\t\treturn 0;\n\n\tfor_each_cpu(cpu, cpus) {\n\t\tswitch (state) {\n\t\tcase DOWN:\n\t\t\tcpuret = cpu_down(cpu);\n\t\t\tbreak;\n\t\tcase UP:\n\t\t\tcpuret = cpu_up(cpu);\n\t\t\tbreak;\n\t\t}\n\t\tif (cpuret) {\n\t\t\tpr_debug(\"%s: cpu_%s for cpu#%d returned %d.\\n\",\n\t\t\t\t\t__func__,\n\t\t\t\t\t((state == UP) ? \"up\" : \"down\"),\n\t\t\t\t\tcpu, cpuret);\n\t\t\tif (!ret)\n\t\t\t\tret = cpuret;\n\t\t\tif (state == UP) {\n\t\t\t\t/* clear bits for unchanged cpus, return */\n\t\t\t\tcpumask_shift_right(cpus, cpus, cpu);\n\t\t\t\tcpumask_shift_left(cpus, cpus, cpu);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* clear bit for unchanged cpu, continue */\n\t\t\t\tcpumask_clear_cpu(cpu, cpus);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rtas_cpu_state_change_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "836-844",
    "snippet": "static int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\n\t\t\t\tcpumask_var_t cpus)\n{\n\tif (!cpumask_empty(cpus)) {\n\t\tcpumask_clear(cpus);\n\t\treturn -EINVAL;\n\t} else\n\t\treturn 0;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "cpus"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_empty",
          "args": [
            "cpus"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\n\t\t\t\tcpumask_var_t cpus)\n{\n\tif (!cpumask_empty(cpus)) {\n\t\tcpumask_clear(cpus);\n\t\treturn -EINVAL;\n\t} else\n\t\treturn 0;\n}"
  },
  {
    "function_name": "rtas_percpu_suspend_me",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "825-828",
    "snippet": "static void rtas_percpu_suspend_me(void *info)\n{\n\t__rtas_suspend_cpu((struct rtas_suspend_me_data *)info, 1);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rtas_suspend_cpu",
          "args": [
            "(struct rtas_suspend_me_data *)info",
            "1"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "__rtas_suspend_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "773-818",
          "snippet": "static int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void rtas_percpu_suspend_me(void *info)\n{\n\t__rtas_suspend_cpu((struct rtas_suspend_me_data *)info, 1);\n}"
  },
  {
    "function_name": "rtas_suspend_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "820-823",
    "snippet": "int rtas_suspend_cpu(struct rtas_suspend_me_data *data)\n{\n\treturn __rtas_suspend_cpu(data, 0);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rtas_suspend_cpu",
          "args": [
            "data",
            "0"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "__rtas_suspend_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "773-818",
          "snippet": "static int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_suspend_cpu(struct rtas_suspend_me_data *data)\n{\n\treturn __rtas_suspend_cpu(data, 0);\n}"
  },
  {
    "function_name": "__rtas_suspend_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "773-818",
    "snippet": "static int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "data->complete"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "ibmebus_bus_pm_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ibmebus.c",
          "lines": "452-458",
          "snippet": "static void ibmebus_bus_pm_complete(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\n\tif (drv && drv->pm && drv->pm->complete)\n\t\tdrv->pm->complete(dev);\n}",
          "includes": [
            "#include <asm/ibmebus.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/kobject.h>",
            "#include <linux/console.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ibmebus.h>\n#include <linux/of_platform.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/kobject.h>\n#include <linux/console.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic void ibmebus_bus_pm_complete(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\n\tif (drv && drv->pm && drv->pm->complete)\n\t\tdrv->pm->complete(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&data->working"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data->done",
            "1"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data->error",
            "rc"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\"",
            "smp_processor_id()",
            "rc"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rtas_suspend_last_cpu",
          "args": [
            "data",
            "wake_when_done"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "__rtas_suspend_last_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "730-765",
          "snippet": "static int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtmsr",
          "args": [
            "msr_save"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plpar_hcall_norets",
          "args": [
            "H_JOIN"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->done"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtmsr",
          "args": [
            "msr_save & ~(MSR_EE)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&data->working"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tlong rc = H_SUCCESS;\n\tunsigned long msr_save;\n\tint cpu;\n\n\tatomic_inc(&data->working);\n\n\t/* really need to ensure MSR.EE is off for H_JOIN */\n\tmsr_save = mfmsr();\n\tmtmsr(msr_save & ~(MSR_EE));\n\n\twhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\n\t\trc = plpar_hcall_norets(H_JOIN);\n\n\tmtmsr(msr_save);\n\n\tif (rc == H_SUCCESS) {\n\t\t/* This cpu was prodded and the suspend is complete. */\n\t\tgoto out;\n\t} else if (rc == H_CONTINUE) {\n\t\t/* All other cpus are in H_JOIN, this cpu does\n\t\t * the suspend.\n\t\t */\n\t\treturn __rtas_suspend_last_cpu(data, wake_when_done);\n\t} else {\n\t\tprintk(KERN_ERR \"H_JOIN on cpu %i failed with rc = %ld\\n\",\n\t\t       smp_processor_id(), rc);\n\t\tatomic_set(&data->error, rc);\n\t}\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\t/* This cpu did the suspend or got an error; in either case,\n\t\t * we need to prod all other other cpus out of join state.\n\t\t * Extra prods are harmless.\n\t\t */\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\nout:\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_suspend_last_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "767-771",
    "snippet": "int rtas_suspend_last_cpu(struct rtas_suspend_me_data *data)\n{\n\tatomic_inc(&data->working);\n\treturn __rtas_suspend_last_cpu(data, 0);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rtas_suspend_last_cpu",
          "args": [
            "data",
            "0"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "__rtas_suspend_last_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "730-765",
          "snippet": "static int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&data->working"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_suspend_last_cpu(struct rtas_suspend_me_data *data)\n{\n\tatomic_inc(&data->working);\n\treturn __rtas_suspend_last_cpu(data, 0);\n}"
  },
  {
    "function_name": "__rtas_suspend_last_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "730-765",
    "snippet": "static int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "data->complete"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ibmebus_bus_pm_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ibmebus.c",
          "lines": "452-458",
          "snippet": "static void ibmebus_bus_pm_complete(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\n\tif (drv && drv->pm && drv->pm->complete)\n\t\tdrv->pm->complete(dev);\n}",
          "includes": [
            "#include <asm/ibmebus.h>",
            "#include <linux/of_platform.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/kobject.h>",
            "#include <linux/console.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ibmebus.h>\n#include <linux/of_platform.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/kobject.h>\n#include <linux/console.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic void ibmebus_bus_pm_complete(struct device *dev)\n{\n\tstruct device_driver *drv = dev->driver;\n\n\tif (drv && drv->pm && drv->pm->complete)\n\t\tdrv->pm->complete(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&data->working"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data->done",
            "1"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pSeries_coalesce_init",
          "args": [],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&data->error",
            "rc"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slb_set_size",
          "args": [
            "slb_size"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"ibm,suspend-me returned %d\\n\"",
            "rc"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "data->token",
            "0",
            "1",
            "NULL"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->error"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&data->done"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slb_set_size",
          "args": [
            "SLB_MIN_SIZE"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\n{\n\tu16 slb_size = mmu_slb_size;\n\tint rc = H_MULTI_THREADS_ACTIVE;\n\tint cpu;\n\n\tslb_set_size(SLB_MIN_SIZE);\n\tprintk(KERN_DEBUG \"calling ibm,suspend-me on cpu %i\\n\", smp_processor_id());\n\n\twhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\n\t       !atomic_read(&data->error))\n\t\trc = rtas_call(data->token, 0, 1, NULL);\n\n\tif (rc || atomic_read(&data->error)) {\n\t\tprintk(KERN_DEBUG \"ibm,suspend-me returned %d\\n\", rc);\n\t\tslb_set_size(slb_size);\n\t}\n\n\tif (atomic_read(&data->error))\n\t\trc = atomic_read(&data->error);\n\n\tatomic_set(&data->error, rc);\n\tpSeries_coalesce_init();\n\n\tif (wake_when_done) {\n\t\tatomic_set(&data->done, 1);\n\n\t\tfor_each_online_cpu(cpu)\n\t\t\tplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\n\t}\n\n\tif (atomic_dec_return(&data->working) == 0)\n\t\tcomplete(data->complete);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_os_term",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "703-726",
    "snippet": "void rtas_os_term(char *str)\n{\n\tint status;\n\n\t/*\n\t * Firmware with the ibm,extended-os-term property is guaranteed\n\t * to always return from an ibm,os-term call. Earlier versions without\n\t * this property may terminate the partition which we want to avoid\n\t * since it interferes with panic_timeout.\n\t */\n\tif (RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,os-term\") ||\n\t    RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,extended-os-term\"))\n\t\treturn;\n\n\tsnprintf(rtas_os_term_buf, 2048, \"OS panic: %s\", str);\n\n\tdo {\n\t\tstatus = rtas_call(rtas_token(\"ibm,os-term\"), 1, 1, NULL,\n\t\t\t\t   __pa(rtas_os_term_buf));\n\t} while (rtas_busy_delay(status));\n\n\tif (status != 0)\n\t\tprintk(KERN_EMERG \"ibm,os-term call failed %d\\n\", status);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char rtas_os_term_buf[2048];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"ibm,os-term call failed %d\\n\"",
            "status"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "status"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "493-503",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"ibm,os-term\")",
            "1",
            "1",
            "NULL",
            "__pa(rtas_os_term_buf)"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "rtas_os_term_buf"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"ibm,os-term\""
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "rtas_os_term_buf",
            "2048",
            "\"OS panic: %s\"",
            "str"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic char rtas_os_term_buf[2048];\n\nvoid rtas_os_term(char *str)\n{\n\tint status;\n\n\t/*\n\t * Firmware with the ibm,extended-os-term property is guaranteed\n\t * to always return from an ibm,os-term call. Earlier versions without\n\t * this property may terminate the partition which we want to avoid\n\t * since it interferes with panic_timeout.\n\t */\n\tif (RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,os-term\") ||\n\t    RTAS_UNKNOWN_SERVICE == rtas_token(\"ibm,extended-os-term\"))\n\t\treturn;\n\n\tsnprintf(rtas_os_term_buf, 2048, \"OS panic: %s\", str);\n\n\tdo {\n\t\tstatus = rtas_call(rtas_token(\"ibm,os-term\"), 1, 1, NULL,\n\t\t\t\t   __pa(rtas_os_term_buf));\n\t} while (rtas_busy_delay(status));\n\n\tif (status != 0)\n\t\tprintk(KERN_EMERG \"ibm,os-term call failed %d\\n\", status);\n}"
  },
  {
    "function_name": "rtas_halt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "690-698",
    "snippet": "void rtas_halt(void)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_HALT);\n\t/* allow power on only with power button press */\n\tprintk(\"RTAS power-off returned %d\\n\",\n\t       rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1));\n\tfor (;;);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void (*rtas_flash_term_hook)(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"RTAS power-off returned %d\\n\"",
            "rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1)"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"power-off\")",
            "2",
            "1",
            "NULL",
            "-1",
            "-1"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"power-off\""
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_flash_term_hook",
          "args": [
            "SYS_HALT"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid (*rtas_flash_term_hook)(int);\n\nvoid rtas_halt(void)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_HALT);\n\t/* allow power on only with power button press */\n\tprintk(\"RTAS power-off returned %d\\n\",\n\t       rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1));\n\tfor (;;);\n}"
  },
  {
    "function_name": "rtas_power_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "680-688",
    "snippet": "void rtas_power_off(void)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_POWER_OFF);\n\t/* allow power on only with power button press */\n\tprintk(\"RTAS power-off returned %d\\n\",\n\t       rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1));\n\tfor (;;);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void (*rtas_flash_term_hook)(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"RTAS power-off returned %d\\n\"",
            "rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1)"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"power-off\")",
            "2",
            "1",
            "NULL",
            "-1",
            "-1"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"power-off\""
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_flash_term_hook",
          "args": [
            "SYS_POWER_OFF"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid (*rtas_flash_term_hook)(int);\n\nvoid rtas_power_off(void)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_POWER_OFF);\n\t/* allow power on only with power button press */\n\tprintk(\"RTAS power-off returned %d\\n\",\n\t       rtas_call(rtas_token(\"power-off\"), 2, 1, NULL, -1, -1));\n\tfor (;;);\n}"
  },
  {
    "function_name": "rtas_restart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "671-678",
    "snippet": "void rtas_restart(char *cmd)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_RESTART);\n\tprintk(\"RTAS system-reboot returned %d\\n\",\n\t       rtas_call(rtas_token(\"system-reboot\"), 0, 1, NULL));\n\tfor (;;);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void (*rtas_flash_term_hook)(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"RTAS system-reboot returned %d\\n\"",
            "rtas_call(rtas_token(\"system-reboot\"), 0, 1, NULL)"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_token(\"system-reboot\")",
            "0",
            "1",
            "NULL"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"system-reboot\""
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_flash_term_hook",
          "args": [
            "SYS_RESTART"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid (*rtas_flash_term_hook)(int);\n\nvoid rtas_restart(char *cmd)\n{\n\tif (rtas_flash_term_hook)\n\t\trtas_flash_term_hook(SYS_RESTART);\n\tprintk(\"RTAS system-reboot returned %d\\n\",\n\t       rtas_call(rtas_token(\"system-reboot\"), 0, 1, NULL));\n\tfor (;;);\n}"
  },
  {
    "function_name": "rtas_set_indicator_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "652-669",
    "snippet": "int rtas_set_indicator_fast(int indicator, int index, int new_value)\n{\n\tint rc;\n\tint token = rtas_token(\"set-indicator\");\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "506-533",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "3",
            "1",
            "NULL",
            "indicator",
            "index",
            "new_value"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_set_indicator_fast(int indicator, int index, int new_value)\n{\n\tint rc;\n\tint token = rtas_token(\"set-indicator\");\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_set_indicator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "631-646",
    "snippet": "int rtas_set_indicator(int indicator, int index, int new_value)\n{\n\tint token = rtas_token(\"set-indicator\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "506-533",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "rc"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "493-503",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "3",
            "1",
            "NULL",
            "indicator",
            "index",
            "new_value"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_set_indicator(int indicator, int index, int new_value)\n{\n\tint token = rtas_token(\"set-indicator\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_indicator_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "605-628",
    "snippet": "bool rtas_indicator_present(int token, int *maxindex)\n{\n\tint proplen, count, i;\n\tconst struct indicator_elem {\n\t\t__be32 token;\n\t\t__be32 maxindex;\n\t} *indicators;\n\n\tindicators = of_get_property(rtas.dev, \"rtas-indicators\", &proplen);\n\tif (!indicators)\n\t\treturn false;\n\n\tcount = proplen / sizeof(struct indicator_elem);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (__be32_to_cpu(indicators[i].token) != token)\n\t\t\tcontinue;\n\t\tif (maxindex)\n\t\t\t*maxindex = __be32_to_cpu(indicators[i].maxindex);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__be32_to_cpu",
          "args": [
            "indicators[i].maxindex"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__be32_to_cpu",
          "args": [
            "indicators[i].token"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "\"rtas-indicators\"",
            "&proplen"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nbool rtas_indicator_present(int token, int *maxindex)\n{\n\tint proplen, count, i;\n\tconst struct indicator_elem {\n\t\t__be32 token;\n\t\t__be32 maxindex;\n\t} *indicators;\n\n\tindicators = of_get_property(rtas.dev, \"rtas-indicators\", &proplen);\n\tif (!indicators)\n\t\treturn false;\n\n\tcount = proplen / sizeof(struct indicator_elem);\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (__be32_to_cpu(indicators[i].token) != token)\n\t\t\tcontinue;\n\t\tif (maxindex)\n\t\t\t*maxindex = __be32_to_cpu(indicators[i].maxindex);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "rtas_get_sensor_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "588-603",
    "snippet": "int rtas_get_sensor_fast(int sensor, int index, int *state)\n{\n\tint token = rtas_token(\"get-sensor-state\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 2, 2, state, sensor, index);\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "506-533",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "2",
            "2",
            "state",
            "sensor",
            "index"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-sensor-state\""
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_get_sensor_fast(int sensor, int index, int *state)\n{\n\tint token = rtas_token(\"get-sensor-state\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\trc = rtas_call(token, 2, 2, state, sensor, index);\n\tWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t\t\t    rc <= RTAS_EXTENDED_DELAY_MAX));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_get_sensor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "570-585",
    "snippet": "int rtas_get_sensor(int sensor, int index, int *state)\n{\n\tint token = rtas_token(\"get-sensor-state\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 2, 2, state, sensor, index);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "506-533",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "rc"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "493-503",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "2",
            "2",
            "state",
            "sensor",
            "index"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-sensor-state\""
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_get_sensor(int sensor, int index, int *state)\n{\n\tint token = rtas_token(\"get-sensor-state\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 2, 2, state, sensor, index);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_set_power_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "552-567",
    "snippet": "int rtas_set_power_level(int powerdomain, int level, int *setlevel)\n{\n\tint token = rtas_token(\"set-power-level\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 2, 2, setlevel, powerdomain, level);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "506-533",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay",
          "args": [
            "rc"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "493-503",
          "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "2",
            "2",
            "setlevel",
            "powerdomain",
            "level"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-power-level\""
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_set_power_level(int powerdomain, int level, int *setlevel)\n{\n\tint token = rtas_token(\"set-power-level\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\tdo {\n\t\trc = rtas_call(token, 2, 2, setlevel, powerdomain, level);\n\t} while (rtas_busy_delay(rc));\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_get_power_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "535-549",
    "snippet": "int rtas_get_power_level(int powerdomain, int *level)\n{\n\tint token = rtas_token(\"get-power-level\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\twhile ((rc = rtas_call(token, 1, 2, level, powerdomain)) == RTAS_BUSY)\n\t\tudelay(1);\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_error_rc",
          "args": [
            "rc"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_error_rc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "506-533",
          "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "udelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/time.c",
          "lines": "410-413",
          "snippet": "void udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}",
          "includes": [
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/cputime.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/clk-provider.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/clockchips.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long tb_ticks_per_usec = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/cputime.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/clk-provider.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/clockchips.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nunsigned long tb_ticks_per_usec = 100;\n\nvoid udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "token",
            "1",
            "2",
            "level",
            "powerdomain"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"get-power-level\""
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_get_power_level(int powerdomain, int *level)\n{\n\tint token = rtas_token(\"get-power-level\");\n\tint rc;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -ENOENT;\n\n\twhile ((rc = rtas_call(token, 1, 2, level, powerdomain)) == RTAS_BUSY)\n\t\tudelay(1);\n\n\tif (rc < 0)\n\t\treturn rtas_error_rc(rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_error_rc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "506-533",
    "snippet": "static int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: unexpected RTAS error %d\\n\"",
            "__func__",
            "rtas_rc"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int rtas_error_rc(int rtas_rc)\n{\n\tint rc;\n\n\tswitch (rtas_rc) {\n\t\tcase -1: \t\t/* Hardware Error */\n\t\t\trc = -EIO;\n\t\t\tbreak;\n\t\tcase -3:\t\t/* Bad indicator/domain/etc */\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t\tcase -9000:\t\t/* Isolation error */\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase -9001:\t\t/* Outstanding TCE/PTE */\n\t\t\trc = -EEXIST;\n\t\t\tbreak;\n\t\tcase -9002:\t\t/* No usable slot */\n\t\t\trc = -ENODEV;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"%s: unexpected RTAS error %d\\n\",\n\t\t\t\t\t__func__, rtas_rc);\n\t\t\trc = -ERANGE;\n\t\t\tbreak;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "rtas_busy_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "493-503",
    "snippet": "unsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msleep",
          "args": [
            "ms"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_busy_delay_time",
          "args": [
            "status"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_busy_delay_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "474-489",
          "snippet": "unsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay(int status)\n{\n\tunsigned int ms;\n\n\tmight_sleep();\n\tms = rtas_busy_delay_time(status);\n\tif (ms && need_resched())\n\t\tmsleep(ms);\n\n\treturn ms;\n}"
  },
  {
    "function_name": "rtas_busy_delay_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "474-489",
    "snippet": "unsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nunsigned int rtas_busy_delay_time(int status)\n{\n\tint order;\n\tunsigned int ms = 0;\n\n\tif (status == RTAS_BUSY) {\n\t\tms = 1;\n\t} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\n\t\t   status <= RTAS_EXTENDED_DELAY_MAX) {\n\t\torder = status - RTAS_EXTENDED_DELAY_MIN;\n\t\tfor (ms = 1; order > 0; order--)\n\t\t\tms *= 10;\n\t}\n\n\treturn ms;\n}"
  },
  {
    "function_name": "rtas_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "421-468",
    "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buff_copy"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_error",
          "args": [
            "buff_copy",
            "ERR_TYPE_RTAS_LOG",
            "0"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "pSeries_log_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "197-273",
          "snippet": "void pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(rtasd_log_lock);",
            "static DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);",
            "static char *rtas_log_buf;",
            "static unsigned long rtas_log_start;",
            "static unsigned long rtas_log_size;",
            "static unsigned int rtas_error_log_buffer_max;",
            "static int logging_enabled;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(rtasd_log_lock);\nstatic DECLARE_WAIT_QUEUE_HEAD(rtas_log_wait);\nstatic char *rtas_log_buf;\nstatic unsigned long rtas_log_start;\nstatic unsigned long rtas_log_size;\nstatic unsigned int rtas_error_log_buffer_max;\nstatic int logging_enabled;\nstatic int error_log_cnt;\n\nvoid pSeries_log_error(char *buf, unsigned int err_type, int fatal)\n{\n\tunsigned long offset;\n\tunsigned long s;\n\tint len = 0;\n\n\tpr_debug(\"rtasd: logging event\\n\");\n\tif (buf == NULL)\n\t\treturn;\n\n\tspin_lock_irqsave(&rtasd_log_lock, s);\n\n\t/* get length and increase count */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\tlen = log_rtas_len(buf);\n\t\tif (!(err_type & ERR_FLAG_BOOT))\n\t\t\terror_log_cnt++;\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_PPC64\n\t/* Write error to NVRAM */\n\tif (logging_enabled && !(err_type & ERR_FLAG_BOOT))\n\t\tnvram_write_error_log(buf, len, err_type, error_log_cnt);\n#endif /* CONFIG_PPC64 */\n\n\t/*\n\t * rtas errors can occur during boot, and we do want to capture\n\t * those somewhere, even if nvram isn't ready (why not?), and even\n\t * if rtasd isn't ready. Put them into the boot log, at least.\n\t */\n\tif ((err_type & ERR_TYPE_MASK) == ERR_TYPE_RTAS_LOG)\n\t\tprintk_log_rtas(buf, len);\n\n\t/* Check to see if we need to or have stopped logging */\n\tif (fatal || !logging_enabled) {\n\t\tlogging_enabled = 0;\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n\n\t/* call type specific method for error */\n\tswitch (err_type & ERR_TYPE_MASK) {\n\tcase ERR_TYPE_RTAS_LOG:\n\t\toffset = rtas_error_log_buffer_max *\n\t\t\t((rtas_log_start+rtas_log_size) & LOG_NUMBER_MASK);\n\n\t\t/* First copy over sequence number */\n\t\tmemcpy(&rtas_log_buf[offset], (void *) &error_log_cnt, sizeof(int));\n\n\t\t/* Second copy over error log data */\n\t\toffset += sizeof(int);\n\t\tmemcpy(&rtas_log_buf[offset], buf, len);\n\n\t\tif (rtas_log_size < LOG_NUMBER)\n\t\t\trtas_log_size += 1;\n\t\telse\n\t\t\trtas_log_start += 1;\n\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\twake_up_interruptible(&rtas_log_wait);\n\t\tbreak;\n\tcase ERR_TYPE_KERNEL_PANIC:\n\tdefault:\n\t\tWARN_ON_ONCE(!irqs_disabled()); /* @@@ DEBUG @@@ */\n\t\tspin_unlock_irqrestore(&rtasd_log_lock, s);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_rtas",
          "args": [
            "s"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "82-87",
          "snippet": "static void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rtas_args->rets[0]"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rtas_args->rets[i+1]"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fetch_rtas_last_error",
          "args": [
            "NULL"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__fetch_rtas_last_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "372-412",
          "snippet": "static char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "rtas_args->rets[0]"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_rtas",
          "args": [
            "__pa(rtas_args)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "rtas_args"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "va_arg(list, __u32)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "list",
            "__u32"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "outputs"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nret"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "nargs"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "token"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_rtas",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "lock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "72-80",
          "snippet": "static unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock_flags(&rtas.lock, flags);\n\treturn flags;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock_flags(&rtas.lock, flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__fetch_rtas_last_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "372-412",
    "snippet": "static char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "rtas_err_buf",
            "RTAS_ERROR_LOG_MAX"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "RTAS_ERROR_LOG_MAX",
            "GFP_ATOMIC"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slab_is_available",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err_args.args[2] == 0"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_rtas",
          "args": [
            "__pa(&rtas.args)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "&rtas.args"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "bufsz"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "__pa(rtas_err_buf)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "2"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "rtas_last_error_token"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_get_error_log_max",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_get_error_log_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "345-359",
          "snippet": "int rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic char *__fetch_rtas_last_error(char *altbuf)\n{\n\tstruct rtas_args err_args, save_args;\n\tu32 bufsz;\n\tchar *buf = NULL;\n\n\tif (rtas_last_error_token == -1)\n\t\treturn NULL;\n\n\tbufsz = rtas_get_error_log_max();\n\n\terr_args.token = cpu_to_be32(rtas_last_error_token);\n\terr_args.nargs = cpu_to_be32(2);\n\terr_args.nret = cpu_to_be32(1);\n\terr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\n\terr_args.args[1] = cpu_to_be32(bufsz);\n\terr_args.args[2] = 0;\n\n\tsave_args = rtas.args;\n\trtas.args = err_args;\n\n\tenter_rtas(__pa(&rtas.args));\n\n\terr_args = rtas.args;\n\trtas.args = save_args;\n\n\t/* Log the error in the unlikely case that there was one. */\n\tif (unlikely(err_args.args[2] == 0)) {\n\t\tif (altbuf) {\n\t\t\tbuf = altbuf;\n\t\t} else {\n\t\t\tbuf = rtas_err_buf;\n\t\t\tif (slab_is_available())\n\t\t\t\tbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\n\t\t}\n\t\tif (buf)\n\t\t\tmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\n\t}\n\n\treturn buf;\n}"
  },
  {
    "function_name": "rtas_get_error_log_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "345-359",
    "snippet": "int rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"RTAS: bad log buffer size %d\\n\"",
            "rtas_error_log_max"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"rtas-error-log-max\""
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_get_error_log_max(void)\n{\n\tstatic int rtas_error_log_max;\n\tif (rtas_error_log_max)\n\t\treturn rtas_error_log_max;\n\n\trtas_error_log_max = rtas_token (\"rtas-error-log-max\");\n\tif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\n\t    (rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\n\t\tprintk (KERN_WARNING \"RTAS: bad log buffer size %d\\n\",\n\t\t\trtas_error_log_max);\n\t\trtas_error_log_max = RTAS_ERROR_LOG_MAX;\n\t}\n\treturn rtas_error_log_max;\n}"
  },
  {
    "function_name": "rtas_service_present",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "333-336",
    "snippet": "int rtas_service_present(const char *service)\n{\n\treturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "service"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint rtas_service_present(const char *service)\n{\n\treturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\n}"
  },
  {
    "function_name": "rtas_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "323-330",
    "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*tokp"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "rtas.dev",
            "service",
            "NULL"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
  },
  {
    "function_name": "rtas_progress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "203-320",
    "snippet": "void rtas_progress(char *s, unsigned short hex)\n{\n\tstruct device_node *root;\n\tint width;\n\tconst __be32 *p;\n\tchar *os;\n\tstatic int display_character, set_indicator;\n\tstatic int display_width, display_lines, form_feed;\n\tstatic const int *row_width;\n\tstatic DEFINE_SPINLOCK(progress_lock);\n\tstatic int current_line;\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\n\tif (!rtas.base)\n\t\treturn;\n\n\tif (display_width == 0) {\n\t\tdisplay_width = 0x10;\n\t\tif ((root = of_find_node_by_path(\"/rtas\"))) {\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-line-length\", NULL)))\n\t\t\t\tdisplay_width = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,form-feed\", NULL)))\n\t\t\t\tform_feed = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-number-of-lines\", NULL)))\n\t\t\t\tdisplay_lines = be32_to_cpu(*p);\n\t\t\trow_width = of_get_property(root,\n\t\t\t\t\t\"ibm,display-truncation-length\", NULL);\n\t\t\tof_node_put(root);\n\t\t}\n\t\tdisplay_character = rtas_token(\"display-character\");\n\t\tset_indicator = rtas_token(\"set-indicator\");\n\t}\n\n\tif (display_character == RTAS_UNKNOWN_SERVICE) {\n\t\t/* use hex display if available */\n\t\tif (set_indicator != RTAS_UNKNOWN_SERVICE)\n\t\t\trtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);\n\t\treturn;\n\t}\n\n\tspin_lock(&progress_lock);\n\n\t/*\n\t * Last write ended with newline, but we didn't print it since\n\t * it would just clear the bottom line of output. Print it now\n\t * instead.\n\t *\n\t * If no newline is pending and form feed is supported, clear the\n\t * display with a form feed; otherwise, print a CR to start output\n\t * at the beginning of the line.\n\t */\n\tif (pending_newline) {\n\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\tpending_newline = 0;\n\t} else {\n\t\tcurrent_line = 0;\n\t\tif (form_feed)\n\t\t\trtas_call(display_character, 1, 1, NULL,\n\t\t\t\t  (char)form_feed);\n\t\telse\n\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t}\n \n\tif (row_width)\n\t\twidth = row_width[current_line];\n\telse\n\t\twidth = display_width;\n\tos = s;\n\twhile (*os) {\n\t\tif (*os == '\\n' || *os == '\\r') {\n\t\t\t/* If newline is the last character, save it\n\t\t\t * until next call to avoid bumping up the\n\t\t\t * display output.\n\t\t\t */\n\t\t\tif (*os == '\\n' && !os[1]) {\n\t\t\t\tpending_newline = 1;\n\t\t\t\tcurrent_line++;\n\t\t\t\tif (current_line > display_lines-1)\n\t\t\t\t\tcurrent_line = display_lines-1;\n\t\t\t\tspin_unlock(&progress_lock);\n\t\t\t\treturn;\n\t\t\t}\n \n\t\t\t/* RTAS wants CR-LF, not just LF */\n \n\t\t\tif (*os == '\\n') {\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\t\t} else {\n\t\t\t\t/* CR might be used to re-draw a line, so we'll\n\t\t\t\t * leave it alone and not add LF.\n\t\t\t\t */\n\t\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t\t}\n \n\t\t\tif (row_width)\n\t\t\t\twidth = row_width[current_line];\n\t\t\telse\n\t\t\t\twidth = display_width;\n\t\t} else {\n\t\t\twidth--;\n\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t}\n \n\t\tos++;\n \n\t\t/* if we overwrite the screen length */\n\t\tif (width <= 0)\n\t\t\twhile ((*os != 0) && (*os != '\\n') && (*os != '\\r'))\n\t\t\t\tos++;\n\t}\n \n\tspin_unlock(&progress_lock);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&progress_lock"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "display_character",
            "1",
            "1",
            "NULL",
            "*os"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&progress_lock"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&progress_lock"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtas_token",
          "args": [
            "\"set-indicator\""
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "323-330",
          "snippet": "int rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_token(const char *service)\n{\n\tconst __be32 *tokp;\n\tif (rtas.dev == NULL)\n\t\treturn RTAS_UNKNOWN_SERVICE;\n\ttokp = of_get_property(rtas.dev, service, NULL);\n\treturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "root"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "root",
            "\"ibm,display-truncation-length\"",
            "NULL"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "root",
            "\"ibm,display-number-of-lines\"",
            "NULL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "root",
            "\"ibm,form-feed\"",
            "NULL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "*p"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "root",
            "\"ibm,display-line-length\"",
            "NULL"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "\"/rtas\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nvoid rtas_progress(char *s, unsigned short hex)\n{\n\tstruct device_node *root;\n\tint width;\n\tconst __be32 *p;\n\tchar *os;\n\tstatic int display_character, set_indicator;\n\tstatic int display_width, display_lines, form_feed;\n\tstatic const int *row_width;\n\tstatic DEFINE_SPINLOCK(progress_lock);\n\tstatic int current_line;\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\n\tif (!rtas.base)\n\t\treturn;\n\n\tif (display_width == 0) {\n\t\tdisplay_width = 0x10;\n\t\tif ((root = of_find_node_by_path(\"/rtas\"))) {\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-line-length\", NULL)))\n\t\t\t\tdisplay_width = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,form-feed\", NULL)))\n\t\t\t\tform_feed = be32_to_cpu(*p);\n\t\t\tif ((p = of_get_property(root,\n\t\t\t\t\t\"ibm,display-number-of-lines\", NULL)))\n\t\t\t\tdisplay_lines = be32_to_cpu(*p);\n\t\t\trow_width = of_get_property(root,\n\t\t\t\t\t\"ibm,display-truncation-length\", NULL);\n\t\t\tof_node_put(root);\n\t\t}\n\t\tdisplay_character = rtas_token(\"display-character\");\n\t\tset_indicator = rtas_token(\"set-indicator\");\n\t}\n\n\tif (display_character == RTAS_UNKNOWN_SERVICE) {\n\t\t/* use hex display if available */\n\t\tif (set_indicator != RTAS_UNKNOWN_SERVICE)\n\t\t\trtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);\n\t\treturn;\n\t}\n\n\tspin_lock(&progress_lock);\n\n\t/*\n\t * Last write ended with newline, but we didn't print it since\n\t * it would just clear the bottom line of output. Print it now\n\t * instead.\n\t *\n\t * If no newline is pending and form feed is supported, clear the\n\t * display with a form feed; otherwise, print a CR to start output\n\t * at the beginning of the line.\n\t */\n\tif (pending_newline) {\n\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\tpending_newline = 0;\n\t} else {\n\t\tcurrent_line = 0;\n\t\tif (form_feed)\n\t\t\trtas_call(display_character, 1, 1, NULL,\n\t\t\t\t  (char)form_feed);\n\t\telse\n\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t}\n \n\tif (row_width)\n\t\twidth = row_width[current_line];\n\telse\n\t\twidth = display_width;\n\tos = s;\n\twhile (*os) {\n\t\tif (*os == '\\n' || *os == '\\r') {\n\t\t\t/* If newline is the last character, save it\n\t\t\t * until next call to avoid bumping up the\n\t\t\t * display output.\n\t\t\t */\n\t\t\tif (*os == '\\n' && !os[1]) {\n\t\t\t\tpending_newline = 1;\n\t\t\t\tcurrent_line++;\n\t\t\t\tif (current_line > display_lines-1)\n\t\t\t\t\tcurrent_line = display_lines-1;\n\t\t\t\tspin_unlock(&progress_lock);\n\t\t\t\treturn;\n\t\t\t}\n \n\t\t\t/* RTAS wants CR-LF, not just LF */\n \n\t\t\tif (*os == '\\n') {\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\r');\n\t\t\t\trtas_call(display_character, 1, 1, NULL, '\\n');\n\t\t\t} else {\n\t\t\t\t/* CR might be used to re-draw a line, so we'll\n\t\t\t\t * leave it alone and not add LF.\n\t\t\t\t */\n\t\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t\t}\n \n\t\t\tif (row_width)\n\t\t\t\twidth = row_width[current_line];\n\t\t\telse\n\t\t\t\twidth = display_width;\n\t\t} else {\n\t\t\twidth--;\n\t\t\trtas_call(display_character, 1, 1, NULL, *os);\n\t\t}\n \n\t\tos++;\n \n\t\t/* if we overwrite the screen length */\n\t\tif (width <= 0)\n\t\t\twhile ((*os != 0) && (*os != '\\n') && (*os != '\\r'))\n\t\t\t\tos++;\n\t}\n \n\tspin_unlock(&progress_lock);\n}"
  },
  {
    "function_name": "udbg_init_rtas_console",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "195-200",
    "snippet": "void __init udbg_init_rtas_console(void)\n{\n\tudbg_putc = udbg_rtascon_putc;\n\tudbg_getc = udbg_rtascon_getc;\n\tudbg_getc_poll = udbg_rtascon_getc_poll;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid __init udbg_init_rtas_console(void)\n{\n\tudbg_putc = udbg_rtascon_putc;\n\tudbg_getc = udbg_rtascon_getc;\n\tudbg_getc_poll = udbg_rtascon_getc_poll;\n}"
  },
  {
    "function_name": "udbg_rtascon_getc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "184-192",
    "snippet": "static int udbg_rtascon_getc(void)\n{\n\tint c;\n\n\twhile ((c = udbg_rtascon_getc_poll()) == -1)\n\t\t;\n\n\treturn c;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udbg_rtascon_getc_poll",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_rtascon_getc_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "171-182",
          "snippet": "static int udbg_rtascon_getc_poll(void)\n{\n\tint c;\n\n\tif (!rtas.base)\n\t\treturn -1;\n\n\tif (rtas_call(rtas_getchar_token, 0, 2, &c))\n\t\treturn -1;\n\n\treturn c;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic int udbg_rtascon_getc_poll(void)\n{\n\tint c;\n\n\tif (!rtas.base)\n\t\treturn -1;\n\n\tif (rtas_call(rtas_getchar_token, 0, 2, &c))\n\t\treturn -1;\n\n\treturn c;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int udbg_rtascon_getc(void)\n{\n\tint c;\n\n\twhile ((c = udbg_rtascon_getc_poll()) == -1)\n\t\t;\n\n\treturn c;\n}"
  },
  {
    "function_name": "udbg_rtascon_getc_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "171-182",
    "snippet": "static int udbg_rtascon_getc_poll(void)\n{\n\tint c;\n\n\tif (!rtas.base)\n\t\treturn -1;\n\n\tif (rtas_call(rtas_getchar_token, 0, 2, &c))\n\t\treturn -1;\n\n\treturn c;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_getchar_token",
            "0",
            "2",
            "&c"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic int udbg_rtascon_getc_poll(void)\n{\n\tint c;\n\n\tif (!rtas.base)\n\t\treturn -1;\n\n\tif (rtas_call(rtas_getchar_token, 0, 2, &c))\n\t\treturn -1;\n\n\treturn c;\n}"
  },
  {
    "function_name": "udbg_rtascon_putc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "152-169",
    "snippet": "static void udbg_rtascon_putc(char c)\n{\n\tint tries;\n\n\tif (!rtas.base)\n\t\treturn;\n\n\t/* Add CRs before LFs */\n\tif (c == '\\n')\n\t\tudbg_rtascon_putc('\\r');\n\n\t/* if there is more than one character to be displayed, wait a bit */\n\tfor (tries = 0; tries < 16; tries++) {\n\t\tif (rtas_call(rtas_putchar_token, 1, 1, NULL, c) == 0)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "1000"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "udelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/time.c",
          "lines": "410-413",
          "snippet": "void udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}",
          "includes": [
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/cputime.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/clk-provider.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/clockchips.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long tb_ticks_per_usec = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/cputime.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/clk-provider.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/clockchips.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nunsigned long tb_ticks_per_usec = 100;\n\nvoid udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtas_call",
          "args": [
            "rtas_putchar_token",
            "1",
            "1",
            "NULL",
            "c"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "rtas_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "421-468",
          "snippet": "int rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\n{\n\tva_list list;\n\tint i;\n\tunsigned long s;\n\tstruct rtas_args *rtas_args;\n\tchar *buff_copy = NULL;\n\tint ret;\n\n\tif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -1;\n\n\ts = lock_rtas();\n\trtas_args = &rtas.args;\n\n\trtas_args->token = cpu_to_be32(token);\n\trtas_args->nargs = cpu_to_be32(nargs);\n\trtas_args->nret  = cpu_to_be32(nret);\n\trtas_args->rets  = &(rtas_args->args[nargs]);\n\tva_start(list, outputs);\n\tfor (i = 0; i < nargs; ++i)\n\t\trtas_args->args[i] = cpu_to_be32(va_arg(list, __u32));\n\tva_end(list);\n\n\tfor (i = 0; i < nret; ++i)\n\t\trtas_args->rets[i] = 0;\n\n\tenter_rtas(__pa(rtas_args));\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(rtas_args->rets[0]) == -1)\n\t\tbuff_copy = __fetch_rtas_last_error(NULL);\n\n\tif (nret > 1 && outputs != NULL)\n\t\tfor (i = 0; i < nret-1; ++i)\n\t\t\toutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\n\tret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\n\n\tunlock_rtas(s);\n\n\tif (buff_copy) {\n\t\tlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\n\t\tif (slab_is_available())\n\t\t\tkfree(buff_copy);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "udbg_rtascon_putc",
          "args": [
            "'\\r'"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "udbg_rtascon_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "152-169",
          "snippet": "static void udbg_rtascon_putc(char c)\n{\n\tint tries;\n\n\tif (!rtas.base)\n\t\treturn;\n\n\t/* Add CRs before LFs */\n\tif (c == '\\n')\n\t\tudbg_rtascon_putc('\\r');\n\n\t/* if there is more than one character to be displayed, wait a bit */\n\tfor (tries = 0; tries < 16; tries++) {\n\t\tif (rtas_call(rtas_putchar_token, 1, 1, NULL, c) == 0)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void udbg_rtascon_putc(char c)\n{\n\tint tries;\n\n\tif (!rtas.base)\n\t\treturn;\n\n\t/* Add CRs before LFs */\n\tif (c == '\\n')\n\t\tudbg_rtascon_putc('\\r');\n\n\t/* if there is more than one character to be displayed, wait a bit */\n\tfor (tries = 0; tries < 16; tries++) {\n\t\tif (rtas_call(rtas_putchar_token, 1, 1, NULL, c) == 0)\n\t\t\tbreak;\n\t\tudelay(1000);\n\t}\n}"
  },
  {
    "function_name": "udbg_init_rtas_panel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "138-141",
    "snippet": "void __init udbg_init_rtas_panel(void)\n{\n\tudbg_putc = call_rtas_display_status_delay;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid __init udbg_init_rtas_panel(void)\n{\n\tudbg_putc = call_rtas_display_status_delay;\n}"
  },
  {
    "function_name": "call_rtas_display_status_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "114-136",
    "snippet": "static void call_rtas_display_status_delay(char c)\n{\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\tstatic int width = 16;\n\n\tif (c == '\\n') {\t\n\t\twhile (width-- > 0)\n\t\t\tcall_rtas_display_status(' ');\n\t\twidth = 16;\n\t\tmdelay(500);\n\t\tpending_newline = 1;\n\t} else {\n\t\tif (pending_newline) {\n\t\t\tcall_rtas_display_status('\\r');\n\t\t\tcall_rtas_display_status('\\n');\n\t\t} \n\t\tpending_newline = 0;\n\t\tif (width--) {\n\t\t\tcall_rtas_display_status(c);\n\t\t\tudelay(10000);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "udelay",
          "args": [
            "10000"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "udelay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/time.c",
          "lines": "410-413",
          "snippet": "void udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}",
          "includes": [
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/clockchips.h>",
            "#include <asm/cputime.h>",
            "#include <asm/firmware.h>",
            "#include <asm/vdso_datapage.h>",
            "#include <asm/smp.h>",
            "#include <asm/div64.h>",
            "#include <asm/irq.h>",
            "#include <asm/prom.h>",
            "#include <asm/time.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/machdep.h>",
            "#include <asm/cache.h>",
            "#include <asm/nvram.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/trace.h>",
            "#include <linux/clk-provider.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/delay.h>",
            "#include <linux/irq.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/rtc.h>",
            "#include <linux/percpu.h>",
            "#include <linux/security.h>",
            "#include <linux/cpu.h>",
            "#include <linux/profile.h>",
            "#include <linux/init.h>",
            "#include <linux/clockchips.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long tb_ticks_per_usec = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/timekeeper_internal.h>\n#include <linux/clockchips.h>\n#include <asm/cputime.h>\n#include <asm/firmware.h>\n#include <asm/vdso_datapage.h>\n#include <asm/smp.h>\n#include <asm/div64.h>\n#include <asm/irq.h>\n#include <asm/prom.h>\n#include <asm/time.h>\n#include <asm/uaccess.h>\n#include <asm/machdep.h>\n#include <asm/cache.h>\n#include <asm/nvram.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/trace.h>\n#include <linux/clk-provider.h>\n#include <linux/irq_work.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/rtc.h>\n#include <linux/percpu.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/profile.h>\n#include <linux/init.h>\n#include <linux/clockchips.h>\n#include <linux/time.h>\n#include <linux/kernel_stat.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/errno.h>\n\nunsigned long tb_ticks_per_usec = 100;\n\nvoid udelay(unsigned long usecs)\n{\n\t__delay(tb_ticks_per_usec * usecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rtas_display_status",
          "args": [
            "c"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "call_rtas_display_status_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "114-136",
          "snippet": "static void call_rtas_display_status_delay(char c)\n{\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\tstatic int width = 16;\n\n\tif (c == '\\n') {\t\n\t\twhile (width-- > 0)\n\t\t\tcall_rtas_display_status(' ');\n\t\twidth = 16;\n\t\tmdelay(500);\n\t\tpending_newline = 1;\n\t} else {\n\t\tif (pending_newline) {\n\t\t\tcall_rtas_display_status('\\r');\n\t\t\tcall_rtas_display_status('\\n');\n\t\t} \n\t\tpending_newline = 0;\n\t\tif (width--) {\n\t\t\tcall_rtas_display_status(c);\n\t\t\tudelay(10000);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mdelay",
          "args": [
            "500"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void call_rtas_display_status_delay(char c)\n{\n\tstatic int pending_newline = 0;  /* did last write end with unprinted newline? */\n\tstatic int width = 16;\n\n\tif (c == '\\n') {\t\n\t\twhile (width-- > 0)\n\t\t\tcall_rtas_display_status(' ');\n\t\twidth = 16;\n\t\tmdelay(500);\n\t\tpending_newline = 1;\n\t} else {\n\t\tif (pending_newline) {\n\t\t\tcall_rtas_display_status('\\r');\n\t\t\tcall_rtas_display_status('\\n');\n\t\t} \n\t\tpending_newline = 0;\n\t\tif (width--) {\n\t\t\tcall_rtas_display_status(c);\n\t\t\tudelay(10000);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "call_rtas_display_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "94-112",
    "snippet": "static void call_rtas_display_status(unsigned char c)\n{\n\tstruct rtas_args *args = &rtas.args;\n\tunsigned long s;\n\n\tif (!rtas.base)\n\t\treturn;\n\ts = lock_rtas();\n\n\targs->token = cpu_to_be32(10);\n\targs->nargs = cpu_to_be32(1);\n\targs->nret  = cpu_to_be32(1);\n\targs->rets  = &(args->args[1]);\n\targs->args[0] = cpu_to_be32(c);\n\n\tenter_rtas(__pa(args));\n\n\tunlock_rtas(s);\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_rtas",
          "args": [
            "s"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "82-87",
          "snippet": "static void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_rtas",
          "args": [
            "__pa(args)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "args"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "c"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "10"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_rtas",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "lock_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
          "lines": "72-80",
          "snippet": "static unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock_flags(&rtas.lock, flags);\n\treturn flags;\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/mmu.h>",
            "#include <asm/time.h>",
            "#include <linux/atomic.h>",
            "#include <asm/smp.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/udbg.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/delay.h>",
            "#include <asm/param.h>",
            "#include <asm/page.h>",
            "#include <asm/firmware.h>",
            "#include <asm/machdep.h>",
            "#include <asm/hvcall.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/memblock.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/completion.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/delay.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock_flags(&rtas.lock, flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void call_rtas_display_status(unsigned char c)\n{\n\tstruct rtas_args *args = &rtas.args;\n\tunsigned long s;\n\n\tif (!rtas.base)\n\t\treturn;\n\ts = lock_rtas();\n\n\targs->token = cpu_to_be32(10);\n\targs->nargs = cpu_to_be32(1);\n\targs->nret  = cpu_to_be32(1);\n\targs->rets  = &(args->args[1]);\n\targs->args[0] = cpu_to_be32(c);\n\n\tenter_rtas(__pa(args));\n\n\tunlock_rtas(s);\n}"
  },
  {
    "function_name": "unlock_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "82-87",
    "snippet": "static void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "202-277",
          "snippet": "notrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&rtas.lock"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic void unlock_rtas(unsigned long flags)\n{\n\tarch_spin_unlock(&rtas.lock);\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "lock_rtas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtas.c",
    "lines": "72-80",
    "snippet": "static unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock_flags(&rtas.lock, flags);\n\treturn flags;\n}",
    "includes": [
      "#include <asm/topology.h>",
      "#include <asm/mmu.h>",
      "#include <asm/time.h>",
      "#include <linux/atomic.h>",
      "#include <asm/smp.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/udbg.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/delay.h>",
      "#include <asm/param.h>",
      "#include <asm/page.h>",
      "#include <asm/firmware.h>",
      "#include <asm/machdep.h>",
      "#include <asm/hvcall.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/reboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/memblock.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/completion.h>",
      "#include <linux/smp.h>",
      "#include <linux/cpu.h>",
      "#include <linux/delay.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_lock_flags",
          "args": [
            "&rtas.lock",
            "flags"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <asm/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\n\nstatic unsigned long lock_rtas(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tarch_spin_lock_flags(&rtas.lock, flags);\n\treturn flags;\n}"
  }
]