[
  {
    "function_name": "handle_rt_signal64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "726-827",
    "snippet": "int handle_rt_signal64(struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tunsigned long newsp = 0;\n\tlong err = 0;\n\n\tframe = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*frame), 0);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\n\terr |= __put_user(&frame->info, &frame->pinfo);\n\terr |= __put_user(&frame->uc, &frame->puc);\n\terr |= copy_siginfo_to_user(&frame->info, &ksig->info);\n\tif (err)\n\t\tgoto badframe;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __save_altstack(&frame->uc.uc_stack, regs->gpr[1]);\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\t/* The ucontext_t passed to userland points to the second\n\t\t * ucontext_t (for transactional state) with its uc_link ptr.\n\t\t */\n\t\terr |= __put_user(&frame->uc_transact, &frame->uc.uc_link);\n\t\terr |= setup_tm_sigcontexts(&frame->uc.uc_mcontext,\n\t\t\t\t\t    &frame->uc_transact.uc_mcontext,\n\t\t\t\t\t    regs, ksig->sig,\n\t\t\t\t\t    NULL,\n\t\t\t\t\t    (unsigned long)ksig->ka.sa.sa_handler);\n\t} else\n#endif\n\t{\n\t\terr |= __put_user(0, &frame->uc.uc_link);\n\t\terr |= setup_sigcontext(&frame->uc.uc_mcontext, regs, ksig->sig,\n\t\t\t\t\tNULL, (unsigned long)ksig->ka.sa.sa_handler,\n\t\t\t\t\t1);\n\t}\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto badframe;\n\n\t/* Make sure signal handler doesn't get spurious FP exceptions */\n\tcurrent->thread.fp_state.fpscr = 0;\n\n\t/* Set up to return from userspace. */\n\tif (vdso64_rt_sigtramp && current->mm->context.vdso_base) {\n\t\tregs->link = current->mm->context.vdso_base + vdso64_rt_sigtramp;\n\t} else {\n\t\terr |= setup_trampoline(__NR_rt_sigreturn, &frame->tramp[0]);\n\t\tif (err)\n\t\t\tgoto badframe;\n\t\tregs->link = (unsigned long) &frame->tramp[0];\n\t}\n\n\t/* Allocate a dummy caller frame for the signal handler. */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\terr |= put_user(regs->gpr[1], (unsigned long __user *)newsp);\n\n\t/* Set up \"regs\" so we \"return\" to the signal handler. */\n\tif (is_elf2_task()) {\n\t\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t\tregs->gpr[12] = regs->nip;\n\t} else {\n\t\t/* Handler is *really* a pointer to the function descriptor for\n\t\t * the signal routine.  The first entry in the function\n\t\t * descriptor is the entry address of signal and the second\n\t\t * entry is the TOC value we need to use.\n\t\t */\n\t\tfunc_descr_t __user *funct_desc_ptr =\n\t\t\t(func_descr_t __user *) ksig->ka.sa.sa_handler;\n\n\t\terr |= get_user(regs->nip, &funct_desc_ptr->entry);\n\t\terr |= get_user(regs->gpr[2], &funct_desc_ptr->toc);\n\t}\n\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->result = 0;\n\tif (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n\t\terr |= get_user(regs->gpr[4], (unsigned long __user *)&frame->pinfo);\n\t\terr |= get_user(regs->gpr[5], (unsigned long __user *)&frame->puc);\n\t\tregs->gpr[6] = (unsigned long) frame;\n\t} else {\n\t\tregs->gpr[4] = (unsigned long)&frame->uc.uc_mcontext;\n\t}\n\tif (err)\n\t\tgoto badframe;\n\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, \"setup_rt_frame\",\n\t\t\t\t   (long)frame, regs->nip, regs->link);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char fmt32[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx\\n\";",
      "static const char fmt64[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx\\n\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "regs->msr & MSR_64BIT ? fmt64 : fmt32",
            "current->comm",
            "current->pid",
            "\"setup_rt_frame\"",
            "(long)frame",
            "regs->nip",
            "regs->link"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "regs->gpr[5]",
            "(unsigned long __user *)&frame->puc"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "197-200",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_elf2_task",
          "args": [],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "regs->gpr[1]",
            "(unsigned long __user *)newsp"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_trampoline",
          "args": [
            "__NR_rt_sigreturn",
            "&frame->tramp[0]"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "setup_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "568-589",
          "snippet": "static long setup_trampoline(unsigned int syscall, unsigned int __user *tramp)\n{\n\tint i;\n\tlong err = 0;\n\n\t/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */\n\terr |= __put_user(0x38210000UL | (__SIGNAL_FRAMESIZE & 0xffff), &tramp[0]);\n\t/* li r0, __NR_[rt_]sigreturn| */\n\terr |= __put_user(0x38000000UL | (syscall & 0xffff), &tramp[1]);\n\t/* sc */\n\terr |= __put_user(0x44000002UL, &tramp[2]);\n\n\t/* Minimal traceback info */\n\tfor (i=TRAMP_TRACEBACK; i < TRAMP_SIZE ;i++)\n\t\terr |= __put_user(0, &tramp[i]);\n\n\tif (!err)\n\t\tflush_icache_range((unsigned long) &tramp[0],\n\t\t\t   (unsigned long) &tramp[TRAMP_SIZE]);\n\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TRAMP_SIZE\t6",
            "#define TRAMP_TRACEBACK\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define TRAMP_SIZE\t6\n#define TRAMP_TRACEBACK\t3\n\nstatic long setup_trampoline(unsigned int syscall, unsigned int __user *tramp)\n{\n\tint i;\n\tlong err = 0;\n\n\t/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */\n\terr |= __put_user(0x38210000UL | (__SIGNAL_FRAMESIZE & 0xffff), &tramp[0]);\n\t/* li r0, __NR_[rt_]sigreturn| */\n\terr |= __put_user(0x38000000UL | (syscall & 0xffff), &tramp[1]);\n\t/* sc */\n\terr |= __put_user(0x44000002UL, &tramp[2]);\n\n\t/* Minimal traceback info */\n\tfor (i=TRAMP_TRACEBACK; i < TRAMP_SIZE ;i++)\n\t\terr |= __put_user(0, &tramp[i]);\n\n\tif (!err)\n\t\tflush_icache_range((unsigned long) &tramp[0],\n\t\t\t   (unsigned long) &tramp[TRAMP_SIZE]);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->uc.uc_sigmask",
            "set",
            "sizeof(*set)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_sigcontext",
          "args": [
            "&frame->uc.uc_mcontext",
            "regs",
            "ksig->sig",
            "NULL",
            "(unsigned long)ksig->ka.sa.sa_handler",
            "1"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "setup_sigcontext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "93-169",
          "snippet": "static long setup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\n\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(current);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\n\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(current);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&frame->uc.uc_link"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_tm_sigcontexts",
          "args": [
            "&frame->uc.uc_mcontext",
            "&frame->uc_transact.uc_mcontext",
            "regs",
            "ksig->sig",
            "NULL",
            "(unsigned long)ksig->ka.sa.sa_handler"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "setup_tm_sigcontexts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "183-305",
          "snippet": "static long setup_tm_sigcontexts(struct sigcontext __user *sc,\n\t\t\t\t struct sigcontext __user *tm_sc,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t int signr, sigset_t *set, unsigned long handler)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know wether it can rely on the\n\t * v_regs pointer or not.\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\telf_vrreg_t __user *tm_v_regs = sigcontext_vmx_regs(tm_sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n\tBUG_ON(!MSR_TM_ACTIVE(regs->msr));\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\tflush_fp_to_thread(current);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\terr |= __put_user(tm_v_regs, &tm_sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* If VEC was enabled there are transactional VRs valid too,\n\t\t * else they're a copy of the checkpointed VRs.\n\t\t */\n\t\tif (msr & MSR_VEC)\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &current->thread.transact_vr,\n\t\t\t\t\t      33 * sizeof(vector128));\n\t\telse\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &current->thread.vr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate\n\t\t * that sc->v_reg contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\tif (msr & MSR_VEC)\n\t\terr |= __put_user(current->thread.transact_vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\telse\n\t\terr |= __put_user(current->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n\terr |= __put_user(0, &tm_sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\tif (msr & MSR_FP)\n\t\terr |= copy_transact_fpr_to_user(&tm_sc->fp_regs, current);\n\telse\n\t\terr |= copy_fpr_to_user(&tm_sc->fp_regs, current);\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\n\t\tif (msr & MSR_VSX)\n\t\t\terr |= copy_transact_vsx_to_user(tm_v_regs, current);\n\t\telse\n\t\t\terr |= copy_vsx_to_user(tm_v_regs, current);\n\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\terr |= __put_user(&tm_sc->gp_regs, &tm_sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&tm_sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __copy_to_user(&sc->gp_regs,\n\t\t\t      &current->thread.ckpt_regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &tm_sc->gp_regs[PT_MSR]);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_tm_sigcontexts(struct sigcontext __user *sc,\n\t\t\t\t struct sigcontext __user *tm_sc,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t int signr, sigset_t *set, unsigned long handler)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know wether it can rely on the\n\t * v_regs pointer or not.\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\telf_vrreg_t __user *tm_v_regs = sigcontext_vmx_regs(tm_sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n\tBUG_ON(!MSR_TM_ACTIVE(regs->msr));\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\tflush_fp_to_thread(current);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\terr |= __put_user(tm_v_regs, &tm_sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* If VEC was enabled there are transactional VRs valid too,\n\t\t * else they're a copy of the checkpointed VRs.\n\t\t */\n\t\tif (msr & MSR_VEC)\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &current->thread.transact_vr,\n\t\t\t\t\t      33 * sizeof(vector128));\n\t\telse\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &current->thread.vr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate\n\t\t * that sc->v_reg contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\tif (msr & MSR_VEC)\n\t\terr |= __put_user(current->thread.transact_vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\telse\n\t\terr |= __put_user(current->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n\terr |= __put_user(0, &tm_sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\tif (msr & MSR_FP)\n\t\terr |= copy_transact_fpr_to_user(&tm_sc->fp_regs, current);\n\telse\n\t\terr |= copy_fpr_to_user(&tm_sc->fp_regs, current);\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\n\t\tif (msr & MSR_VSX)\n\t\t\terr |= copy_transact_vsx_to_user(tm_v_regs, current);\n\t\telse\n\t\t\terr |= copy_vsx_to_user(tm_v_regs, current);\n\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\terr |= __put_user(&tm_sc->gp_regs, &tm_sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&tm_sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __copy_to_user(&sc->gp_regs,\n\t\t\t      &current->thread.ckpt_regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &tm_sc->gp_regs[PT_MSR]);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&frame->uc_transact",
            "&frame->uc.uc_link"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "regs->msr"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_altstack",
          "args": [
            "&frame->uc.uc_stack",
            "regs->gpr[1]"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&frame->uc.uc_flags"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_user",
          "args": [
            "&frame->info",
            "&ksig->info"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_to_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "914-972",
          "snippet": "int copy_siginfo_to_user32(struct compat_siginfo __user *d, const siginfo_t *s)\n{\n\tint err;\n\n\tif (!access_ok (VERIFY_WRITE, d, sizeof(*d)))\n\t\treturn -EFAULT;\n\n\t/* If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t * It should never copy any pad contained in the structure\n\t * to avoid security leaks, but must copy the generic\n\t * 3 ints plus the relevant union member.\n\t * This routine must convert siginfo from 64bit to 32bit as well\n\t * at the same time.\n\t */\n\terr = __put_user(s->si_signo, &d->si_signo);\n\terr |= __put_user(s->si_errno, &d->si_errno);\n\terr |= __put_user((short)s->si_code, &d->si_code);\n\tif (s->si_code < 0)\n\t\terr |= __copy_to_user(&d->_sifields._pad, &s->_sifields._pad,\n\t\t\t\t      SI_PAD_SIZE32);\n\telse switch(s->si_code >> 16) {\n\tcase __SI_CHLD >> 16:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\terr |= __put_user(s->si_utime, &d->si_utime);\n\t\terr |= __put_user(s->si_stime, &d->si_stime);\n\t\terr |= __put_user(s->si_status, &d->si_status);\n\t\tbreak;\n\tcase __SI_FAULT >> 16:\n\t\terr |= __put_user((unsigned int)(unsigned long)s->si_addr,\n\t\t\t\t  &d->si_addr);\n\t\tbreak;\n\tcase __SI_POLL >> 16:\n\t\terr |= __put_user(s->si_band, &d->si_band);\n\t\terr |= __put_user(s->si_fd, &d->si_fd);\n\t\tbreak;\n\tcase __SI_TIMER >> 16:\n\t\terr |= __put_user(s->si_tid, &d->si_tid);\n\t\terr |= __put_user(s->si_overrun, &d->si_overrun);\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\tbreak;\n\tcase __SI_SYS >> 16:\n\t\terr |= __put_user(ptr_to_compat(s->si_call_addr), &d->si_call_addr);\n\t\terr |= __put_user(s->si_syscall, &d->si_syscall);\n\t\terr |= __put_user(s->si_arch, &d->si_arch);\n\t\tbreak;\n\tcase __SI_RT >> 16: /* This is not generated by the kernel as of now.  */\n\tcase __SI_MESGQ >> 16:\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\t/* fallthrough */\n\tcase __SI_KILL >> 16:\n\tdefault:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nint copy_siginfo_to_user32(struct compat_siginfo __user *d, const siginfo_t *s)\n{\n\tint err;\n\n\tif (!access_ok (VERIFY_WRITE, d, sizeof(*d)))\n\t\treturn -EFAULT;\n\n\t/* If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t * It should never copy any pad contained in the structure\n\t * to avoid security leaks, but must copy the generic\n\t * 3 ints plus the relevant union member.\n\t * This routine must convert siginfo from 64bit to 32bit as well\n\t * at the same time.\n\t */\n\terr = __put_user(s->si_signo, &d->si_signo);\n\terr |= __put_user(s->si_errno, &d->si_errno);\n\terr |= __put_user((short)s->si_code, &d->si_code);\n\tif (s->si_code < 0)\n\t\terr |= __copy_to_user(&d->_sifields._pad, &s->_sifields._pad,\n\t\t\t\t      SI_PAD_SIZE32);\n\telse switch(s->si_code >> 16) {\n\tcase __SI_CHLD >> 16:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\terr |= __put_user(s->si_utime, &d->si_utime);\n\t\terr |= __put_user(s->si_stime, &d->si_stime);\n\t\terr |= __put_user(s->si_status, &d->si_status);\n\t\tbreak;\n\tcase __SI_FAULT >> 16:\n\t\terr |= __put_user((unsigned int)(unsigned long)s->si_addr,\n\t\t\t\t  &d->si_addr);\n\t\tbreak;\n\tcase __SI_POLL >> 16:\n\t\terr |= __put_user(s->si_band, &d->si_band);\n\t\terr |= __put_user(s->si_fd, &d->si_fd);\n\t\tbreak;\n\tcase __SI_TIMER >> 16:\n\t\terr |= __put_user(s->si_tid, &d->si_tid);\n\t\terr |= __put_user(s->si_overrun, &d->si_overrun);\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\tbreak;\n\tcase __SI_SYS >> 16:\n\t\terr |= __put_user(ptr_to_compat(s->si_call_addr), &d->si_call_addr);\n\t\terr |= __put_user(s->si_syscall, &d->si_syscall);\n\t\terr |= __put_user(s->si_arch, &d->si_arch);\n\t\tbreak;\n\tcase __SI_RT >> 16: /* This is not generated by the kernel as of now.  */\n\tcase __SI_MESGQ >> 16:\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\t/* fallthrough */\n\tcase __SI_KILL >> 16:\n\tdefault:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&frame->uc",
            "&frame->puc"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&frame->info",
            "&frame->pinfo"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "frame == NULL"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigframe",
          "args": [
            "ksig",
            "get_tm_stackpointer(regs)",
            "sizeof(*frame)",
            "0"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
          "lines": "34-49",
          "snippet": "void __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok(VERIFY_WRITE, (void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok(VERIFY_WRITE, (void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tm_stackpointer",
          "args": [
            "regs"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "get_tm_stackpointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
          "lines": "165-197",
          "snippet": "unsigned long get_tm_stackpointer(struct pt_regs *regs)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted becuase of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(regs->msr))\n\t\t\treturn current->thread.ckpt_regs.gpr[1];\n\t}\n#endif\n\treturn regs->gpr[1];\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long get_tm_stackpointer(struct pt_regs *regs)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted becuase of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(regs->msr))\n\t\t\treturn current->thread.ckpt_regs.gpr[1];\n\t}\n#endif\n\treturn regs->gpr[1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic const char fmt32[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx\\n\";\nstatic const char fmt64[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx\\n\";\n\nint handle_rt_signal64(struct ksignal *ksig, sigset_t *set, struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *frame;\n\tunsigned long newsp = 0;\n\tlong err = 0;\n\n\tframe = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*frame), 0);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\n\terr |= __put_user(&frame->info, &frame->pinfo);\n\terr |= __put_user(&frame->uc, &frame->puc);\n\terr |= copy_siginfo_to_user(&frame->info, &ksig->info);\n\tif (err)\n\t\tgoto badframe;\n\n\t/* Create the ucontext.  */\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\terr |= __save_altstack(&frame->uc.uc_stack, regs->gpr[1]);\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\t/* The ucontext_t passed to userland points to the second\n\t\t * ucontext_t (for transactional state) with its uc_link ptr.\n\t\t */\n\t\terr |= __put_user(&frame->uc_transact, &frame->uc.uc_link);\n\t\terr |= setup_tm_sigcontexts(&frame->uc.uc_mcontext,\n\t\t\t\t\t    &frame->uc_transact.uc_mcontext,\n\t\t\t\t\t    regs, ksig->sig,\n\t\t\t\t\t    NULL,\n\t\t\t\t\t    (unsigned long)ksig->ka.sa.sa_handler);\n\t} else\n#endif\n\t{\n\t\terr |= __put_user(0, &frame->uc.uc_link);\n\t\terr |= setup_sigcontext(&frame->uc.uc_mcontext, regs, ksig->sig,\n\t\t\t\t\tNULL, (unsigned long)ksig->ka.sa.sa_handler,\n\t\t\t\t\t1);\n\t}\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\tif (err)\n\t\tgoto badframe;\n\n\t/* Make sure signal handler doesn't get spurious FP exceptions */\n\tcurrent->thread.fp_state.fpscr = 0;\n\n\t/* Set up to return from userspace. */\n\tif (vdso64_rt_sigtramp && current->mm->context.vdso_base) {\n\t\tregs->link = current->mm->context.vdso_base + vdso64_rt_sigtramp;\n\t} else {\n\t\terr |= setup_trampoline(__NR_rt_sigreturn, &frame->tramp[0]);\n\t\tif (err)\n\t\t\tgoto badframe;\n\t\tregs->link = (unsigned long) &frame->tramp[0];\n\t}\n\n\t/* Allocate a dummy caller frame for the signal handler. */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\terr |= put_user(regs->gpr[1], (unsigned long __user *)newsp);\n\n\t/* Set up \"regs\" so we \"return\" to the signal handler. */\n\tif (is_elf2_task()) {\n\t\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t\tregs->gpr[12] = regs->nip;\n\t} else {\n\t\t/* Handler is *really* a pointer to the function descriptor for\n\t\t * the signal routine.  The first entry in the function\n\t\t * descriptor is the entry address of signal and the second\n\t\t * entry is the TOC value we need to use.\n\t\t */\n\t\tfunc_descr_t __user *funct_desc_ptr =\n\t\t\t(func_descr_t __user *) ksig->ka.sa.sa_handler;\n\n\t\terr |= get_user(regs->nip, &funct_desc_ptr->entry);\n\t\terr |= get_user(regs->gpr[2], &funct_desc_ptr->toc);\n\t}\n\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->result = 0;\n\tif (ksig->ka.sa.sa_flags & SA_SIGINFO) {\n\t\terr |= get_user(regs->gpr[4], (unsigned long __user *)&frame->pinfo);\n\t\terr |= get_user(regs->gpr[5], (unsigned long __user *)&frame->puc);\n\t\tregs->gpr[6] = (unsigned long) frame;\n\t} else {\n\t\tregs->gpr[4] = (unsigned long)&frame->uc.uc_mcontext;\n\t}\n\tif (err)\n\t\tgoto badframe;\n\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, \"setup_rt_frame\",\n\t\t\t\t   (long)frame, regs->nip, regs->link);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "sys_rt_sigreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "673-724",
    "snippet": "int sys_rt_sigreturn(unsigned long r3, unsigned long r4, unsigned long r5,\n\t\t     unsigned long r6, unsigned long r7, unsigned long r8,\n\t\t     struct pt_regs *regs)\n{\n\tstruct ucontext __user *uc = (struct ucontext __user *)regs->gpr[1];\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tunsigned long msr;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tif (!access_ok(VERIFY_READ, uc, sizeof(*uc)))\n\t\tgoto badframe;\n\n\tif (__copy_from_user(&set, &uc->uc_sigmask, sizeof(set)))\n\t\tgoto badframe;\n\tset_current_blocked(&set);\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (__get_user(msr, &uc->uc_mcontext.gp_regs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\t/* We recheckpoint on return. */\n\t\tstruct ucontext __user *uc_transact;\n\t\tif (__get_user(uc_transact, &uc->uc_link))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_sigcontexts(regs, &uc->uc_mcontext,\n\t\t\t\t\t   &uc_transact->uc_mcontext))\n\t\t\tgoto badframe;\n\t}\n\telse\n\t/* Fall through, for non-TM restore */\n#endif\n\tif (restore_sigcontext(regs, NULL, 1, &uc->uc_mcontext))\n\t\tgoto badframe;\n\n\tif (restore_altstack(&uc->uc_stack))\n\t\tgoto badframe;\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, \"rt_sigreturn\",\n\t\t\t\t   (long)uc, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV, current);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char fmt32[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx\\n\";",
      "static const char fmt64[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx\\n\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGSEGV",
            "current"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "regs->msr & MSR_64BIT ? fmt64 : fmt32",
            "current->comm",
            "current->pid",
            "\"rt_sigreturn\"",
            "(long)uc",
            "regs->nip",
            "regs->link"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTOREALL"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_altstack",
          "args": [
            "&uc->uc_stack"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_sigcontext",
          "args": [
            "regs",
            "NULL",
            "1",
            "&uc->uc_mcontext"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "restore_sigcontext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "312-404",
          "snippet": "static long restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,\n\t\t\t      struct sigcontext __user *sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long save_r13 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/* If this is not a signal return, we preserve the TLS in r13 */\n\tif (!sig)\n\t\tsave_r13 = regs->gpr[13];\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, sc->gp_regs, sizeof(regs->gpr));\n\terr |= __get_user(regs->nip, &sc->gp_regs[PT_NIP]);\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\terr |= __get_user(regs->orig_gpr3, &sc->gp_regs[PT_ORIG_R3]);\n\terr |= __get_user(regs->ctr, &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &sc->gp_regs[PT_CCR]);\n\t/* skip SOFTE */\n\tregs->trap = 0;\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\tif (!sig)\n\t\tregs->gpr[13] = save_r13;\n\tif (set != NULL)\n\t\terr |=  __get_user(set->sig[0], &sc->oldmask);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && (msr & MSR_VEC) != 0)\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\telse if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL)\n\t\terr |= __get_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\telse\n\t\tcurrent->thread.vrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tv_regs += ELF_NVRREG;\n\tif ((msr & MSR_VSX) != 0)\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\telse\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic long restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,\n\t\t\t      struct sigcontext __user *sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long save_r13 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/* If this is not a signal return, we preserve the TLS in r13 */\n\tif (!sig)\n\t\tsave_r13 = regs->gpr[13];\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, sc->gp_regs, sizeof(regs->gpr));\n\terr |= __get_user(regs->nip, &sc->gp_regs[PT_NIP]);\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\terr |= __get_user(regs->orig_gpr3, &sc->gp_regs[PT_ORIG_R3]);\n\terr |= __get_user(regs->ctr, &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &sc->gp_regs[PT_CCR]);\n\t/* skip SOFTE */\n\tregs->trap = 0;\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\tif (!sig)\n\t\tregs->gpr[13] = save_r13;\n\tif (set != NULL)\n\t\terr |=  __get_user(set->sig[0], &sc->oldmask);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && (msr & MSR_VEC) != 0)\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\telse if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL)\n\t\terr |= __get_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\telse\n\t\tcurrent->thread.vrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tv_regs += ELF_NVRREG;\n\tif ((msr & MSR_VSX) != 0)\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\telse\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_tm_sigcontexts",
          "args": [
            "regs",
            "&uc->uc_mcontext",
            "&uc_transact->uc_mcontext"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "restore_tm_sigcontexts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "411-562",
          "snippet": "static long restore_tm_sigcontexts(struct pt_regs *regs,\n\t\t\t\t   struct sigcontext __user *sc,\n\t\t\t\t   struct sigcontext __user *tm_sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs, *tm_v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr));\n\terr |= __copy_from_user(&current->thread.ckpt_regs, sc->gp_regs,\n\t\t\t\tsizeof(regs->gpr));\n\n\t/*\n\t * TFHAR is restored from the checkpointed 'wound-back' ucontext's NIP.\n\t * TEXASR was set by the signal delivery reclaim, as was TFIAR.\n\t * Users doing anything abhorrent like thread-switching w/ signals for\n\t * TM-Suspended code will have to back TEXASR/TFIAR up themselves.\n\t * For the case of getting a signal and simply returning from it,\n\t * we don't need to re-copy them here.\n\t */\n\terr |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]);\n\terr |= __get_user(current->thread.tm_tfhar, &sc->gp_regs[PT_NIP]);\n\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\t/* Don't allow reserved mode. */\n\tif (MSR_TM_RESV(msr))\n\t\treturn -EINVAL;\n\n\t/* pull in MSR TM from user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);\n\n\t/* pull in MSR LE from user context */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/* The following non-GPR non-FPR non-VR state is also checkpointed: */\n\terr |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]);\n\terr |= __get_user(current->thread.ckpt_regs.ctr,\n\t\t\t  &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(current->thread.ckpt_regs.link,\n\t\t\t  &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(current->thread.ckpt_regs.xer,\n\t\t\t  &sc->gp_regs[PT_XER]);\n\terr |= __get_user(current->thread.ckpt_regs.ccr,\n\t\t\t  &sc->gp_regs[PT_CCR]);\n\n\t/* These regs are not checkpointed; they can go in 'regs'. */\n\terr |= __get_user(regs->trap, &sc->gp_regs[PT_TRAP]);\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\terr |= __get_user(tm_v_regs, &tm_sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\tif (tm_v_regs && !access_ok(VERIFY_READ,\n\t\t\t\t    tm_v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) {\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\terr |= __copy_from_user(&current->thread.transact_vr, tm_v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t}\n\telse if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0, 33 * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL && tm_v_regs != NULL) {\n\t\terr |= __get_user(current->thread.vrsave,\n\t\t\t\t  (u32 __user *)&v_regs[33]);\n\t\terr |= __get_user(current->thread.transact_vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\t}\n\telse {\n\t\tcurrent->thread.vrsave = 0;\n\t\tcurrent->thread.transact_vrsave = 0;\n\t}\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n\terr |= copy_transact_fpr_from_user(current, &tm_sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tif (v_regs && ((msr & MSR_VSX) != 0)) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\t\terr |= copy_transact_vsx_from_user(current, tm_v_regs);\n\t} else {\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n\t}\n#endif\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic long restore_tm_sigcontexts(struct pt_regs *regs,\n\t\t\t\t   struct sigcontext __user *sc,\n\t\t\t\t   struct sigcontext __user *tm_sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs, *tm_v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr));\n\terr |= __copy_from_user(&current->thread.ckpt_regs, sc->gp_regs,\n\t\t\t\tsizeof(regs->gpr));\n\n\t/*\n\t * TFHAR is restored from the checkpointed 'wound-back' ucontext's NIP.\n\t * TEXASR was set by the signal delivery reclaim, as was TFIAR.\n\t * Users doing anything abhorrent like thread-switching w/ signals for\n\t * TM-Suspended code will have to back TEXASR/TFIAR up themselves.\n\t * For the case of getting a signal and simply returning from it,\n\t * we don't need to re-copy them here.\n\t */\n\terr |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]);\n\terr |= __get_user(current->thread.tm_tfhar, &sc->gp_regs[PT_NIP]);\n\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\t/* Don't allow reserved mode. */\n\tif (MSR_TM_RESV(msr))\n\t\treturn -EINVAL;\n\n\t/* pull in MSR TM from user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);\n\n\t/* pull in MSR LE from user context */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/* The following non-GPR non-FPR non-VR state is also checkpointed: */\n\terr |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]);\n\terr |= __get_user(current->thread.ckpt_regs.ctr,\n\t\t\t  &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(current->thread.ckpt_regs.link,\n\t\t\t  &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(current->thread.ckpt_regs.xer,\n\t\t\t  &sc->gp_regs[PT_XER]);\n\terr |= __get_user(current->thread.ckpt_regs.ccr,\n\t\t\t  &sc->gp_regs[PT_CCR]);\n\n\t/* These regs are not checkpointed; they can go in 'regs'. */\n\terr |= __get_user(regs->trap, &sc->gp_regs[PT_TRAP]);\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\terr |= __get_user(tm_v_regs, &tm_sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\tif (tm_v_regs && !access_ok(VERIFY_READ,\n\t\t\t\t    tm_v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) {\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\terr |= __copy_from_user(&current->thread.transact_vr, tm_v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t}\n\telse if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0, 33 * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL && tm_v_regs != NULL) {\n\t\terr |= __get_user(current->thread.vrsave,\n\t\t\t\t  (u32 __user *)&v_regs[33]);\n\t\terr |= __get_user(current->thread.transact_vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\t}\n\telse {\n\t\tcurrent->thread.vrsave = 0;\n\t\tcurrent->thread.transact_vrsave = 0;\n\t}\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n\terr |= copy_transact_fpr_from_user(current, &tm_sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tif (v_regs && ((msr & MSR_VSX) != 0)) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\t\terr |= copy_transact_vsx_from_user(current, tm_v_regs);\n\t} else {\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n\t}\n#endif\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "uc_transact",
            "&uc->uc_link"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "msr"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&uc->uc_mcontext.gp_regs[PT_MSR]"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&set"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&set",
            "&uc->uc_sigmask",
            "sizeof(set)"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "uc",
            "sizeof(*uc)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic const char fmt32[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %08lx nip %08lx lr %08lx\\n\";\nstatic const char fmt64[] = KERN_INFO \\\n\t\"%s[%d]: bad frame in %s: %016lx nip %016lx lr %016lx\\n\";\n\nint sys_rt_sigreturn(unsigned long r3, unsigned long r4, unsigned long r5,\n\t\t     unsigned long r6, unsigned long r7, unsigned long r8,\n\t\t     struct pt_regs *regs)\n{\n\tstruct ucontext __user *uc = (struct ucontext __user *)regs->gpr[1];\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tunsigned long msr;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tif (!access_ok(VERIFY_READ, uc, sizeof(*uc)))\n\t\tgoto badframe;\n\n\tif (__copy_from_user(&set, &uc->uc_sigmask, sizeof(set)))\n\t\tgoto badframe;\n\tset_current_blocked(&set);\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (__get_user(msr, &uc->uc_mcontext.gp_regs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr)) {\n\t\t/* We recheckpoint on return. */\n\t\tstruct ucontext __user *uc_transact;\n\t\tif (__get_user(uc_transact, &uc->uc_link))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_sigcontexts(regs, &uc->uc_mcontext,\n\t\t\t\t\t   &uc_transact->uc_mcontext))\n\t\t\tgoto badframe;\n\t}\n\telse\n\t/* Fall through, for non-TM restore */\n#endif\n\tif (restore_sigcontext(regs, NULL, 1, &uc->uc_mcontext))\n\t\tgoto badframe;\n\n\tif (restore_altstack(&uc->uc_stack))\n\t\tgoto badframe;\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(regs->msr & MSR_64BIT ? fmt64 : fmt32,\n\t\t\t\t   current->comm, current->pid, \"rt_sigreturn\",\n\t\t\t\t   (long)uc, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV, current);\n\treturn 0;\n}"
  },
  {
    "function_name": "sys_swapcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "601-666",
    "snippet": "int sys_swapcontext(struct ucontext __user *old_ctx,\n\t\t    struct ucontext __user *new_ctx,\n\t\t    long ctx_size, long r6, long r7, long r8, struct pt_regs *regs)\n{\n\tunsigned char tmp;\n\tsigset_t set;\n\tunsigned long new_msr = 0;\n\tint ctx_has_vsx_region = 0;\n\n\tif (new_ctx &&\n\t    get_user(new_msr, &new_ctx->uc_mcontext.gp_regs[PT_MSR]))\n\t\treturn -EFAULT;\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n\n\tif (old_ctx != NULL) {\n\t\tif (!access_ok(VERIFY_WRITE, old_ctx, ctx_size)\n\t\t    || setup_sigcontext(&old_ctx->uc_mcontext, regs, 0, NULL, 0,\n\t\t\t\t\tctx_has_vsx_region)\n\t\t    || __copy_to_user(&old_ctx->uc_sigmask,\n\t\t\t\t      &current->blocked, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(VERIFY_READ, new_ctx, ctx_size)\n\t    || __get_user(tmp, (u8 __user *) new_ctx)\n\t    || __get_user(tmp, (u8 __user *) new_ctx + ctx_size - 1))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\n\tif (__copy_from_user(&set, &new_ctx->uc_sigmask, sizeof(set)))\n\t\tdo_exit(SIGSEGV);\n\tset_current_blocked(&set);\n\tif (restore_sigcontext(regs, NULL, 0, &new_ctx->uc_mcontext))\n\t\tdo_exit(SIGSEGV);\n\n\t/* This returns like rt_sigreturn */\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - 32*sizeof(long))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTOREALL"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "SIGSEGV"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_sigcontext",
          "args": [
            "regs",
            "NULL",
            "0",
            "&new_ctx->uc_mcontext"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "restore_sigcontext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "312-404",
          "snippet": "static long restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,\n\t\t\t      struct sigcontext __user *sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long save_r13 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/* If this is not a signal return, we preserve the TLS in r13 */\n\tif (!sig)\n\t\tsave_r13 = regs->gpr[13];\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, sc->gp_regs, sizeof(regs->gpr));\n\terr |= __get_user(regs->nip, &sc->gp_regs[PT_NIP]);\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\terr |= __get_user(regs->orig_gpr3, &sc->gp_regs[PT_ORIG_R3]);\n\terr |= __get_user(regs->ctr, &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &sc->gp_regs[PT_CCR]);\n\t/* skip SOFTE */\n\tregs->trap = 0;\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\tif (!sig)\n\t\tregs->gpr[13] = save_r13;\n\tif (set != NULL)\n\t\terr |=  __get_user(set->sig[0], &sc->oldmask);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && (msr & MSR_VEC) != 0)\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\telse if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL)\n\t\terr |= __get_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\telse\n\t\tcurrent->thread.vrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tv_regs += ELF_NVRREG;\n\tif ((msr & MSR_VSX) != 0)\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\telse\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic long restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,\n\t\t\t      struct sigcontext __user *sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long save_r13 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/* If this is not a signal return, we preserve the TLS in r13 */\n\tif (!sig)\n\t\tsave_r13 = regs->gpr[13];\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, sc->gp_regs, sizeof(regs->gpr));\n\terr |= __get_user(regs->nip, &sc->gp_regs[PT_NIP]);\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\terr |= __get_user(regs->orig_gpr3, &sc->gp_regs[PT_ORIG_R3]);\n\terr |= __get_user(regs->ctr, &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &sc->gp_regs[PT_CCR]);\n\t/* skip SOFTE */\n\tregs->trap = 0;\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\tif (!sig)\n\t\tregs->gpr[13] = save_r13;\n\tif (set != NULL)\n\t\terr |=  __get_user(set->sig[0], &sc->oldmask);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && (msr & MSR_VEC) != 0)\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\telse if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL)\n\t\terr |= __get_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\telse\n\t\tcurrent->thread.vrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tv_regs += ELF_NVRREG;\n\tif ((msr & MSR_VSX) != 0)\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\telse\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&set"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "SIGSEGV"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&set",
            "&new_ctx->uc_sigmask",
            "sizeof(set)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tmp",
            "(u8 __user *) new_ctx + ctx_size - 1"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tmp",
            "(u8 __user *) new_ctx"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "new_ctx",
            "ctx_size"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&old_ctx->uc_sigmask",
            "&current->blocked",
            "sizeof(sigset_t)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_sigcontext",
          "args": [
            "&old_ctx->uc_mcontext",
            "regs",
            "0",
            "NULL",
            "0",
            "ctx_has_vsx_region"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "setup_sigcontext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "93-169",
          "snippet": "static long setup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\n\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(current);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\n\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(current);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "old_ctx",
            "ctx_size"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "new_msr",
            "&new_ctx->uc_mcontext.gp_regs[PT_MSR]"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "197-200",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - 32*sizeof(long))\n\nint sys_swapcontext(struct ucontext __user *old_ctx,\n\t\t    struct ucontext __user *new_ctx,\n\t\t    long ctx_size, long r6, long r7, long r8, struct pt_regs *regs)\n{\n\tunsigned char tmp;\n\tsigset_t set;\n\tunsigned long new_msr = 0;\n\tint ctx_has_vsx_region = 0;\n\n\tif (new_ctx &&\n\t    get_user(new_msr, &new_ctx->uc_mcontext.gp_regs[PT_MSR]))\n\t\treturn -EFAULT;\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n\n\tif (old_ctx != NULL) {\n\t\tif (!access_ok(VERIFY_WRITE, old_ctx, ctx_size)\n\t\t    || setup_sigcontext(&old_ctx->uc_mcontext, regs, 0, NULL, 0,\n\t\t\t\t\tctx_has_vsx_region)\n\t\t    || __copy_to_user(&old_ctx->uc_sigmask,\n\t\t\t\t      &current->blocked, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(VERIFY_READ, new_ctx, ctx_size)\n\t    || __get_user(tmp, (u8 __user *) new_ctx)\n\t    || __get_user(tmp, (u8 __user *) new_ctx + ctx_size - 1))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\n\tif (__copy_from_user(&set, &new_ctx->uc_sigmask, sizeof(set)))\n\t\tdo_exit(SIGSEGV);\n\tset_current_blocked(&set);\n\tif (restore_sigcontext(regs, NULL, 0, &new_ctx->uc_mcontext))\n\t\tdo_exit(SIGSEGV);\n\n\t/* This returns like rt_sigreturn */\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_trampoline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "568-589",
    "snippet": "static long setup_trampoline(unsigned int syscall, unsigned int __user *tramp)\n{\n\tint i;\n\tlong err = 0;\n\n\t/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */\n\terr |= __put_user(0x38210000UL | (__SIGNAL_FRAMESIZE & 0xffff), &tramp[0]);\n\t/* li r0, __NR_[rt_]sigreturn| */\n\terr |= __put_user(0x38000000UL | (syscall & 0xffff), &tramp[1]);\n\t/* sc */\n\terr |= __put_user(0x44000002UL, &tramp[2]);\n\n\t/* Minimal traceback info */\n\tfor (i=TRAMP_TRACEBACK; i < TRAMP_SIZE ;i++)\n\t\terr |= __put_user(0, &tramp[i]);\n\n\tif (!err)\n\t\tflush_icache_range((unsigned long) &tramp[0],\n\t\t\t   (unsigned long) &tramp[TRAMP_SIZE]);\n\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define TRAMP_SIZE\t6",
      "#define TRAMP_TRACEBACK\t3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long) &tramp[0]",
            "(unsigned long) &tramp[TRAMP_SIZE]"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&tramp[i]"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0x44000002UL",
            "&tramp[2]"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0x38000000UL | (syscall & 0xffff)",
            "&tramp[1]"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0x38210000UL | (__SIGNAL_FRAMESIZE & 0xffff)",
            "&tramp[0]"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define TRAMP_SIZE\t6\n#define TRAMP_TRACEBACK\t3\n\nstatic long setup_trampoline(unsigned int syscall, unsigned int __user *tramp)\n{\n\tint i;\n\tlong err = 0;\n\n\t/* addi r1, r1, __SIGNAL_FRAMESIZE  # Pop the dummy stackframe */\n\terr |= __put_user(0x38210000UL | (__SIGNAL_FRAMESIZE & 0xffff), &tramp[0]);\n\t/* li r0, __NR_[rt_]sigreturn| */\n\terr |= __put_user(0x38000000UL | (syscall & 0xffff), &tramp[1]);\n\t/* sc */\n\terr |= __put_user(0x44000002UL, &tramp[2]);\n\n\t/* Minimal traceback info */\n\tfor (i=TRAMP_TRACEBACK; i < TRAMP_SIZE ;i++)\n\t\terr |= __put_user(0, &tramp[i]);\n\n\tif (!err)\n\t\tflush_icache_range((unsigned long) &tramp[0],\n\t\t\t   (unsigned long) &tramp[TRAMP_SIZE]);\n\n\treturn err;\n}"
  },
  {
    "function_name": "restore_tm_sigcontexts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "411-562",
    "snippet": "static long restore_tm_sigcontexts(struct pt_regs *regs,\n\t\t\t\t   struct sigcontext __user *sc,\n\t\t\t\t   struct sigcontext __user *tm_sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs, *tm_v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr));\n\terr |= __copy_from_user(&current->thread.ckpt_regs, sc->gp_regs,\n\t\t\t\tsizeof(regs->gpr));\n\n\t/*\n\t * TFHAR is restored from the checkpointed 'wound-back' ucontext's NIP.\n\t * TEXASR was set by the signal delivery reclaim, as was TFIAR.\n\t * Users doing anything abhorrent like thread-switching w/ signals for\n\t * TM-Suspended code will have to back TEXASR/TFIAR up themselves.\n\t * For the case of getting a signal and simply returning from it,\n\t * we don't need to re-copy them here.\n\t */\n\terr |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]);\n\terr |= __get_user(current->thread.tm_tfhar, &sc->gp_regs[PT_NIP]);\n\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\t/* Don't allow reserved mode. */\n\tif (MSR_TM_RESV(msr))\n\t\treturn -EINVAL;\n\n\t/* pull in MSR TM from user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);\n\n\t/* pull in MSR LE from user context */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/* The following non-GPR non-FPR non-VR state is also checkpointed: */\n\terr |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]);\n\terr |= __get_user(current->thread.ckpt_regs.ctr,\n\t\t\t  &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(current->thread.ckpt_regs.link,\n\t\t\t  &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(current->thread.ckpt_regs.xer,\n\t\t\t  &sc->gp_regs[PT_XER]);\n\terr |= __get_user(current->thread.ckpt_regs.ccr,\n\t\t\t  &sc->gp_regs[PT_CCR]);\n\n\t/* These regs are not checkpointed; they can go in 'regs'. */\n\terr |= __get_user(regs->trap, &sc->gp_regs[PT_TRAP]);\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\terr |= __get_user(tm_v_regs, &tm_sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\tif (tm_v_regs && !access_ok(VERIFY_READ,\n\t\t\t\t    tm_v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) {\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\terr |= __copy_from_user(&current->thread.transact_vr, tm_v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t}\n\telse if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0, 33 * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL && tm_v_regs != NULL) {\n\t\terr |= __get_user(current->thread.vrsave,\n\t\t\t\t  (u32 __user *)&v_regs[33]);\n\t\terr |= __get_user(current->thread.transact_vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\t}\n\telse {\n\t\tcurrent->thread.vrsave = 0;\n\t\tcurrent->thread.transact_vrsave = 0;\n\t}\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n\terr |= copy_transact_fpr_from_user(current, &tm_sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tif (v_regs && ((msr & MSR_VSX) != 0)) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\t\terr |= copy_transact_vsx_from_user(current, tm_v_regs);\n\t} else {\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n\t}\n#endif\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_load_up_transact_altivec",
          "args": [
            "&current->thread"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_load_up_transact_fpu",
          "args": [
            "&current->thread"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread",
            "msr"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "622-642",
          "snippet": "void tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_transact_vsx_from_user",
          "args": [
            "current",
            "tm_v_regs"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "copy_transact_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "358-369",
          "snippet": "unsigned long copy_transact_vsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_transact_vsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_from_user",
          "args": [
            "current",
            "v_regs"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "304-315",
          "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_transact_fpr_from_user",
          "args": [
            "current",
            "&tm_sc->fp_regs"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "copy_transact_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "394-399",
          "snippet": "inline unsigned long copy_transact_fpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.transact_fp.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_transact_fpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.transact_fp.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_from_user",
          "args": [
            "current",
            "&sc->fp_regs"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "379-384",
          "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_VRSAVE",
            "current->thread.vrsave"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.transact_vrsave",
            "(u32 __user *)&tm_v_regs[33]"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&v_regs[33]"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&current->thread.transact_vr",
            "0",
            "33 * sizeof(vector128)"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.transact_vr",
            "tm_v_regs",
            "33 * sizeof(vector128)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.vr_state",
            "v_regs",
            "33 * sizeof(vector128)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "tm_v_regs",
            "34 * sizeof(vector128)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "v_regs",
            "34 * sizeof(vector128)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tm_v_regs",
            "&tm_sc->v_regs"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "v_regs",
            "&sc->v_regs"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_lazy_cpu_state",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "discard_lazy_cpu_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "284-302",
          "snippet": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->result",
            "&sc->gp_regs[PT_RESULT]"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->dsisr",
            "&sc->gp_regs[PT_DSISR]"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->dar",
            "&sc->gp_regs[PT_DAR]"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->trap",
            "&sc->gp_regs[PT_TRAP]"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.ckpt_regs.ccr",
            "&sc->gp_regs[PT_CCR]"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.ckpt_regs.xer",
            "&sc->gp_regs[PT_XER]"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.ckpt_regs.link",
            "&sc->gp_regs[PT_LNK]"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.ckpt_regs.ctr",
            "&sc->gp_regs[PT_CTR]"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->ccr",
            "&tm_sc->gp_regs[PT_CCR]"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->xer",
            "&tm_sc->gp_regs[PT_XER]"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->link",
            "&tm_sc->gp_regs[PT_LNK]"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->ctr",
            "&tm_sc->gp_regs[PT_CTR]"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_RESV",
          "args": [
            "msr"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&sc->gp_regs[PT_MSR]"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.tm_tfhar",
            "&sc->gp_regs[PT_NIP]"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->nip",
            "&tm_sc->gp_regs[PT_NIP]"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.ckpt_regs",
            "sc->gp_regs",
            "sizeof(regs->gpr)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "regs->gpr",
            "tm_sc->gp_regs",
            "sizeof(regs->gpr)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic long restore_tm_sigcontexts(struct pt_regs *regs,\n\t\t\t\t   struct sigcontext __user *sc,\n\t\t\t\t   struct sigcontext __user *tm_sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs, *tm_v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr));\n\terr |= __copy_from_user(&current->thread.ckpt_regs, sc->gp_regs,\n\t\t\t\tsizeof(regs->gpr));\n\n\t/*\n\t * TFHAR is restored from the checkpointed 'wound-back' ucontext's NIP.\n\t * TEXASR was set by the signal delivery reclaim, as was TFIAR.\n\t * Users doing anything abhorrent like thread-switching w/ signals for\n\t * TM-Suspended code will have to back TEXASR/TFIAR up themselves.\n\t * For the case of getting a signal and simply returning from it,\n\t * we don't need to re-copy them here.\n\t */\n\terr |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]);\n\terr |= __get_user(current->thread.tm_tfhar, &sc->gp_regs[PT_NIP]);\n\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\t/* Don't allow reserved mode. */\n\tif (MSR_TM_RESV(msr))\n\t\treturn -EINVAL;\n\n\t/* pull in MSR TM from user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);\n\n\t/* pull in MSR LE from user context */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/* The following non-GPR non-FPR non-VR state is also checkpointed: */\n\terr |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]);\n\terr |= __get_user(current->thread.ckpt_regs.ctr,\n\t\t\t  &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(current->thread.ckpt_regs.link,\n\t\t\t  &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(current->thread.ckpt_regs.xer,\n\t\t\t  &sc->gp_regs[PT_XER]);\n\terr |= __get_user(current->thread.ckpt_regs.ccr,\n\t\t\t  &sc->gp_regs[PT_CCR]);\n\n\t/* These regs are not checkpointed; they can go in 'regs'. */\n\terr |= __get_user(regs->trap, &sc->gp_regs[PT_TRAP]);\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\terr |= __get_user(tm_v_regs, &tm_sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\tif (tm_v_regs && !access_ok(VERIFY_READ,\n\t\t\t\t    tm_v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) {\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t\terr |= __copy_from_user(&current->thread.transact_vr, tm_v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\t}\n\telse if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0, 33 * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL && tm_v_regs != NULL) {\n\t\terr |= __get_user(current->thread.vrsave,\n\t\t\t\t  (u32 __user *)&v_regs[33]);\n\t\terr |= __get_user(current->thread.transact_vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\t}\n\telse {\n\t\tcurrent->thread.vrsave = 0;\n\t\tcurrent->thread.transact_vrsave = 0;\n\t}\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n\terr |= copy_transact_fpr_from_user(current, &tm_sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tif (v_regs && ((msr & MSR_VSX) != 0)) {\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\t\terr |= copy_transact_vsx_from_user(current, tm_v_regs);\n\t} else {\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n\t}\n#endif\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn err;\n}"
  },
  {
    "function_name": "restore_sigcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "312-404",
    "snippet": "static long restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,\n\t\t\t      struct sigcontext __user *sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long save_r13 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/* If this is not a signal return, we preserve the TLS in r13 */\n\tif (!sig)\n\t\tsave_r13 = regs->gpr[13];\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, sc->gp_regs, sizeof(regs->gpr));\n\terr |= __get_user(regs->nip, &sc->gp_regs[PT_NIP]);\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\terr |= __get_user(regs->orig_gpr3, &sc->gp_regs[PT_ORIG_R3]);\n\terr |= __get_user(regs->ctr, &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &sc->gp_regs[PT_CCR]);\n\t/* skip SOFTE */\n\tregs->trap = 0;\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\tif (!sig)\n\t\tregs->gpr[13] = save_r13;\n\tif (set != NULL)\n\t\terr |=  __get_user(set->sig[0], &sc->oldmask);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && (msr & MSR_VEC) != 0)\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\telse if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL)\n\t\terr |= __get_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\telse\n\t\tcurrent->thread.vrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tv_regs += ELF_NVRREG;\n\tif ((msr & MSR_VSX) != 0)\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\telse\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_vsx_from_user",
          "args": [
            "current",
            "v_regs"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "304-315",
          "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_from_user",
          "args": [
            "current",
            "&sc->fp_regs"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "379-384",
          "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_VRSAVE",
            "current->thread.vrsave"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&v_regs[33]"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&current->thread.vr_state",
            "0",
            "33 * sizeof(vector128)"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.vr_state",
            "v_regs",
            "33 * sizeof(vector128)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "v_regs",
            "34 * sizeof(vector128)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "v_regs",
            "&sc->v_regs"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_lazy_cpu_state",
          "args": [],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "discard_lazy_cpu_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "284-302",
          "snippet": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "set->sig[0]",
            "&sc->oldmask"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->result",
            "&sc->gp_regs[PT_RESULT]"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->dsisr",
            "&sc->gp_regs[PT_DSISR]"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->dar",
            "&sc->gp_regs[PT_DAR]"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->ccr",
            "&sc->gp_regs[PT_CCR]"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->xer",
            "&sc->gp_regs[PT_XER]"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->link",
            "&sc->gp_regs[PT_LNK]"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->ctr",
            "&sc->gp_regs[PT_CTR]"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->orig_gpr3",
            "&sc->gp_regs[PT_ORIG_R3]"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&sc->gp_regs[PT_MSR]"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "regs->nip",
            "&sc->gp_regs[PT_NIP]"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "regs->gpr",
            "sc->gp_regs",
            "sizeof(regs->gpr)"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic long restore_sigcontext(struct pt_regs *regs, sigset_t *set, int sig,\n\t\t\t      struct sigcontext __user *sc)\n{\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs;\n#endif\n\tunsigned long err = 0;\n\tunsigned long save_r13 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/* If this is not a signal return, we preserve the TLS in r13 */\n\tif (!sig)\n\t\tsave_r13 = regs->gpr[13];\n\n\t/* copy the GPRs */\n\terr |= __copy_from_user(regs->gpr, sc->gp_regs, sizeof(regs->gpr));\n\terr |= __get_user(regs->nip, &sc->gp_regs[PT_NIP]);\n\t/* get MSR separately, transfer the LE bit if doing signal return */\n\terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\terr |= __get_user(regs->orig_gpr3, &sc->gp_regs[PT_ORIG_R3]);\n\terr |= __get_user(regs->ctr, &sc->gp_regs[PT_CTR]);\n\terr |= __get_user(regs->link, &sc->gp_regs[PT_LNK]);\n\terr |= __get_user(regs->xer, &sc->gp_regs[PT_XER]);\n\terr |= __get_user(regs->ccr, &sc->gp_regs[PT_CCR]);\n\t/* skip SOFTE */\n\tregs->trap = 0;\n\terr |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]);\n\terr |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]);\n\terr |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]);\n\n\tif (!sig)\n\t\tregs->gpr[13] = save_r13;\n\tif (set != NULL)\n\t\terr |=  __get_user(set->sig[0], &sc->oldmask);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n\t/*\n\t * Force reload of FP/VEC.\n\t * This has to be done before copying stuff into current->thread.fpr/vr\n\t * for the reasons explained in the previous comment.\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __get_user(v_regs, &sc->v_regs);\n\tif (err)\n\t\treturn err;\n\tif (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128)))\n\t\treturn -EFAULT;\n\t/* Copy 33 vec registers (vr0..31 and vscr) from the stack */\n\tif (v_regs != NULL && (msr & MSR_VEC) != 0)\n\t\terr |= __copy_from_user(&current->thread.vr_state, v_regs,\n\t\t\t\t\t33 * sizeof(vector128));\n\telse if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0, 33 * sizeof(vector128));\n\t/* Always get VRSAVE back */\n\tif (v_regs != NULL)\n\t\terr |= __get_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\telse\n\t\tcurrent->thread.vrsave = 0;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\t/* restore floating point */\n\terr |= copy_fpr_from_user(current, &sc->fp_regs);\n#ifdef CONFIG_VSX\n\t/*\n\t * Get additional VSX data. Update v_regs to point after the\n\t * VMX data.  Copy VSX low doubleword from userspace to local\n\t * buffer for formatting, then into the taskstruct.\n\t */\n\tv_regs += ELF_NVRREG;\n\tif ((msr & MSR_VSX) != 0)\n\t\terr |= copy_vsx_from_user(current, v_regs);\n\telse\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif\n\treturn err;\n}"
  },
  {
    "function_name": "setup_tm_sigcontexts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "183-305",
    "snippet": "static long setup_tm_sigcontexts(struct sigcontext __user *sc,\n\t\t\t\t struct sigcontext __user *tm_sc,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t int signr, sigset_t *set, unsigned long handler)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know wether it can rely on the\n\t * v_regs pointer or not.\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\telf_vrreg_t __user *tm_v_regs = sigcontext_vmx_regs(tm_sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n\tBUG_ON(!MSR_TM_ACTIVE(regs->msr));\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\tflush_fp_to_thread(current);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\terr |= __put_user(tm_v_regs, &tm_sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* If VEC was enabled there are transactional VRs valid too,\n\t\t * else they're a copy of the checkpointed VRs.\n\t\t */\n\t\tif (msr & MSR_VEC)\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &current->thread.transact_vr,\n\t\t\t\t\t      33 * sizeof(vector128));\n\t\telse\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &current->thread.vr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate\n\t\t * that sc->v_reg contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\tif (msr & MSR_VEC)\n\t\terr |= __put_user(current->thread.transact_vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\telse\n\t\terr |= __put_user(current->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n\terr |= __put_user(0, &tm_sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\tif (msr & MSR_FP)\n\t\terr |= copy_transact_fpr_to_user(&tm_sc->fp_regs, current);\n\telse\n\t\terr |= copy_fpr_to_user(&tm_sc->fp_regs, current);\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\n\t\tif (msr & MSR_VSX)\n\t\t\terr |= copy_transact_vsx_to_user(tm_v_regs, current);\n\t\telse\n\t\t\terr |= copy_vsx_to_user(tm_v_regs, current);\n\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\terr |= __put_user(&tm_sc->gp_regs, &tm_sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&tm_sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __copy_to_user(&sc->gp_regs,\n\t\t\t      &current->thread.ckpt_regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &tm_sc->gp_regs[PT_MSR]);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "set->sig[0]",
            "&sc->oldmask"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "handler",
            "&sc->handler"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "signr",
            "&sc->signal"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&sc->gp_regs[PT_MSR]"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&tm_sc->gp_regs[PT_MSR]"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&sc->gp_regs",
            "&current->thread.ckpt_regs",
            "GP_REGS_SIZE"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&tm_sc->gp_regs",
            "regs",
            "GP_REGS_SIZE"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&tm_sc->gp_regs",
            "&tm_sc->regs"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&sc->gp_regs",
            "&sc->regs"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_vsx_to_user",
          "args": [
            "tm_v_regs",
            "current"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "292-302",
          "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_transact_vsx_to_user",
          "args": [
            "tm_v_regs",
            "current"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "copy_transact_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "346-356",
          "snippet": "unsigned long copy_transact_vsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_transact_vsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__giveup_vsx",
          "args": [
            "current"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_fpr_to_user",
          "args": [
            "&tm_sc->fp_regs",
            "current"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "372-377",
          "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_transact_fpr_to_user",
          "args": [
            "&tm_sc->fp_regs",
            "current"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "copy_transact_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "387-392",
          "snippet": "inline unsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.transact_fp.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.transact_fp.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&tm_sc->v_regs"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&sc->v_regs"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&tm_v_regs[33]"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.transact_vrsave",
            "(u32 __user *)&tm_v_regs[33]"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&v_regs[33]"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_VRSAVE"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "tm_v_regs",
            "&current->thread.vr_state",
            "33 * sizeof(vector128)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "tm_v_regs",
            "&current->thread.transact_vr",
            "33 * sizeof(vector128)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "v_regs",
            "&current->thread.vr_state",
            "33 * sizeof(vector128)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "current"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "tm_v_regs",
            "&tm_sc->v_regs"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "v_regs",
            "&sc->v_regs"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "current"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!MSR_TM_ACTIVE(regs->msr)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "regs->msr"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigcontext_vmx_regs",
          "args": [
            "tm_sc"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "sigcontext_vmx_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "83-86",
          "snippet": "static elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_tm_sigcontexts(struct sigcontext __user *sc,\n\t\t\t\t struct sigcontext __user *tm_sc,\n\t\t\t\t struct pt_regs *regs,\n\t\t\t\t int signr, sigset_t *set, unsigned long handler)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know wether it can rely on the\n\t * v_regs pointer or not.\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n\telf_vrreg_t __user *tm_v_regs = sigcontext_vmx_regs(tm_sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n\tBUG_ON(!MSR_TM_ACTIVE(regs->msr));\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\tflush_fp_to_thread(current);\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\terr |= __put_user(tm_v_regs, &tm_sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* If VEC was enabled there are transactional VRs valid too,\n\t\t * else they're a copy of the checkpointed VRs.\n\t\t */\n\t\tif (msr & MSR_VEC)\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &current->thread.transact_vr,\n\t\t\t\t\t      33 * sizeof(vector128));\n\t\telse\n\t\t\terr |= __copy_to_user(tm_v_regs,\n\t\t\t\t\t      &current->thread.vr_state,\n\t\t\t\t\t      33 * sizeof(vector128));\n\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate\n\t\t * that sc->v_reg contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n\tif (msr & MSR_VEC)\n\t\terr |= __put_user(current->thread.transact_vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\telse\n\t\terr |= __put_user(current->thread.vrsave,\n\t\t\t\t  (u32 __user *)&tm_v_regs[33]);\n\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n\terr |= __put_user(0, &tm_sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\tif (msr & MSR_FP)\n\t\terr |= copy_transact_fpr_to_user(&tm_sc->fp_regs, current);\n\telse\n\t\terr |= copy_fpr_to_user(&tm_sc->fp_regs, current);\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\ttm_v_regs += ELF_NVRREG;\n\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\n\t\tif (msr & MSR_VSX)\n\t\t\terr |= copy_transact_vsx_to_user(tm_v_regs, current);\n\t\telse\n\t\t\terr |= copy_vsx_to_user(tm_v_regs, current);\n\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\terr |= __put_user(&tm_sc->gp_regs, &tm_sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&tm_sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __copy_to_user(&sc->gp_regs,\n\t\t\t      &current->thread.ckpt_regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &tm_sc->gp_regs[PT_MSR]);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
  },
  {
    "function_name": "setup_sigcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "93-169",
    "snippet": "static long setup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\n\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(current);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "set->sig[0]",
            "&sc->oldmask"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "handler",
            "&sc->handler"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "signr",
            "&sc->signal"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&sc->gp_regs[PT_MSR]"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&sc->gp_regs",
            "regs",
            "GP_REGS_SIZE"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "&sc->gp_regs",
            "&sc->regs"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_vsx_to_user",
          "args": [
            "v_regs",
            "current"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "292-302",
          "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__giveup_vsx",
          "args": [
            "current"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_fpr_to_user",
          "args": [
            "&sc->fp_regs",
            "current"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "372-377",
          "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "current"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&sc->v_regs"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&v_regs[33]"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_VRSAVE"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "v_regs",
            "&current->thread.vr_state",
            "33 * sizeof(vector128)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "current"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "v_regs",
            "&sc->v_regs"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigcontext_vmx_regs",
          "args": [
            "sc"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "sigcontext_vmx_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
          "lines": "83-86",
          "snippet": "static elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/unistd.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/sigcontext.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n\nstatic long setup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,\n\t\t int signr, sigset_t *set, unsigned long handler,\n\t\t int ctx_has_vsx_region)\n{\n\t/* When CONFIG_ALTIVEC is set, we _always_ setup v_regs even if the\n\t * process never used altivec yet (MSR_VEC is zero in pt_regs of\n\t * the context). This is very important because we must ensure we\n\t * don't lose the VRSAVE content that may have been set prior to\n\t * the process doing its first vector operation\n\t * Userland shall check AT_HWCAP to know whether it can rely on the\n\t * v_regs pointer or not\n\t */\n#ifdef CONFIG_ALTIVEC\n\telf_vrreg_t __user *v_regs = sigcontext_vmx_regs(sc);\n#endif\n\tunsigned long msr = regs->msr;\n\tlong err = 0;\n\n#ifdef CONFIG_ALTIVEC\n\terr |= __put_user(v_regs, &sc->v_regs);\n\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\t/* Copy 33 vec registers (vr0..31 and vscr) to the stack */\n\t\terr |= __copy_to_user(v_regs, &current->thread.vr_state,\n\t\t\t\t      33 * sizeof(vector128));\n\t\t/* set MSR_VEC in the MSR value in the frame to indicate that sc->v_reg)\n\t\t * contains valid data.\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\terr |= __put_user(current->thread.vrsave, (u32 __user *)&v_regs[33]);\n#else /* CONFIG_ALTIVEC */\n\terr |= __put_user(0, &sc->v_regs);\n#endif /* CONFIG_ALTIVEC */\n\tflush_fp_to_thread(current);\n\t/* copy fpr regs and fpscr */\n\terr |= copy_fpr_to_user(&sc->fp_regs, current);\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSX low doubleword to local buffer for formatting,\n\t * then out to userspace.  Update v_regs to point after the\n\t * VMX data.\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tv_regs += ELF_NVRREG;\n\t\terr |= copy_vsx_to_user(v_regs, current);\n\t\t/* set MSR_VSX in the MSR value in the frame to\n\t\t * indicate that sc->vs_reg) contains valid data.\n\t\t */\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n\terr |= __put_user(&sc->gp_regs, &sc->regs);\n\tWARN_ON(!FULL_REGS(regs));\n\terr |= __copy_to_user(&sc->gp_regs, regs, GP_REGS_SIZE);\n\terr |= __put_user(msr, &sc->gp_regs[PT_MSR]);\n\terr |= __put_user(signr, &sc->signal);\n\terr |= __put_user(handler, &sc->handler);\n\tif (set != NULL)\n\t\terr |=  __put_user(set->sig[0], &sc->oldmask);\n\n\treturn err;\n}"
  },
  {
    "function_name": "sigcontext_vmx_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_64.c",
    "lines": "83-86",
    "snippet": "static elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/unistd.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/sigcontext.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/uaccess.h>\n#include <asm/ucontext.h>\n#include <asm/sigcontext.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic elf_vrreg_t __user *sigcontext_vmx_regs(struct sigcontext __user *sc)\n{\n\treturn (elf_vrreg_t __user *) (((unsigned long)sc->vmx_reserve + 15) & ~0xful);\n}"
  }
]