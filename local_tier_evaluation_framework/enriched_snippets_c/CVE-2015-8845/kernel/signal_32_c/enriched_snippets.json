[
  {
    "function_name": "sys_sigreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1499-1567",
    "snippet": "long sys_sigreturn(int r3, int r4, int r5, int r6, int r7, int r8,\n\t\t       struct pt_regs *regs)\n{\n\tstruct sigframe __user *sf;\n\tstruct sigcontext __user *sc;\n\tstruct sigcontext sigctx;\n\tstruct mcontext __user *sr;\n\tvoid __user *addr;\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct mcontext __user *mcp, *tm_mcp;\n\tunsigned long msr_hi;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tsf = (struct sigframe __user *)(regs->gpr[1] + __SIGNAL_FRAMESIZE);\n\tsc = &sf->sctx;\n\taddr = sc;\n\tif (copy_from_user(&sigctx, sc, sizeof(sigctx)))\n\t\tgoto badframe;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Note that PPC32 puts the upper 32 bits of the sigmask in the\n\t * unused part of the signal stackframe\n\t */\n\tset.sig[0] = sigctx.oldmask + ((long)(sigctx._unused[3]) << 32);\n#else\n\tset.sig[0] = sigctx.oldmask;\n\tset.sig[1] = sigctx._unused[3];\n#endif\n\tset_current_blocked(&set);\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tmcp = (struct mcontext __user *)&sf->mctx;\n\ttm_mcp = (struct mcontext __user *)&sf->mctx_transact;\n\tif (__get_user(msr_hi, &tm_mcp->mc_gregs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\t\tgoto badframe;\n\t} else\n#endif\n\t{\n\t\tsr = (struct mcontext __user *)from_user_ptr(sigctx.regs);\n\t\taddr = sr;\n\t\tif (!access_ok(VERIFY_READ, sr, sizeof(*sr))\n\t\t    || restore_user_regs(regs, sr, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV, current);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define mcontext\tmcontext32",
      "#define sigcontext\tsigcontext32",
      "#define sys_sigreturn\tcompat_sys_sigreturn"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGSEGV",
            "current"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\"",
            "current->comm",
            "current->pid",
            "addr",
            "regs->nip",
            "regs->link"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTOREALL"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_user_regs",
          "args": [
            "regs",
            "sr",
            "1"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "restore_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "662-764",
          "snippet": "static long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tregs->trap = 0;\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tregs->trap = 0;\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "sr",
            "sizeof(*sr)"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_user_ptr",
          "args": [
            "sigctx.regs"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_tm_user_regs",
          "args": [
            "regs",
            "mcp",
            "tm_mcp"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "restore_tm_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "772-910",
          "snippet": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\t/* Pull in the MSR TM bits from the user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\t/* Pull in the MSR TM bits from the user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "msr_hi<<32"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr_hi",
            "&tm_mcp->mc_gregs[PT_MSR]"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&set"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&sigctx",
            "sc",
            "sizeof(sigctx)"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n#define sys_sigreturn\tcompat_sys_sigreturn\n\nlong sys_sigreturn(int r3, int r4, int r5, int r6, int r7, int r8,\n\t\t       struct pt_regs *regs)\n{\n\tstruct sigframe __user *sf;\n\tstruct sigcontext __user *sc;\n\tstruct sigcontext sigctx;\n\tstruct mcontext __user *sr;\n\tvoid __user *addr;\n\tsigset_t set;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct mcontext __user *mcp, *tm_mcp;\n\tunsigned long msr_hi;\n#endif\n\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\tsf = (struct sigframe __user *)(regs->gpr[1] + __SIGNAL_FRAMESIZE);\n\tsc = &sf->sctx;\n\taddr = sc;\n\tif (copy_from_user(&sigctx, sc, sizeof(sigctx)))\n\t\tgoto badframe;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Note that PPC32 puts the upper 32 bits of the sigmask in the\n\t * unused part of the signal stackframe\n\t */\n\tset.sig[0] = sigctx.oldmask + ((long)(sigctx._unused[3]) << 32);\n#else\n\tset.sig[0] = sigctx.oldmask;\n\tset.sig[1] = sigctx._unused[3];\n#endif\n\tset_current_blocked(&set);\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tmcp = (struct mcontext __user *)&sf->mctx;\n\ttm_mcp = (struct mcontext __user *)&sf->mctx_transact;\n\tif (__get_user(msr_hi, &tm_mcp->mc_gregs[PT_MSR]))\n\t\tgoto badframe;\n\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\t\tgoto badframe;\n\t\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\t\tgoto badframe;\n\t} else\n#endif\n\t{\n\t\tsr = (struct mcontext __user *)from_user_ptr(sigctx.regs);\n\t\taddr = sr;\n\t\tif (!access_ok(VERIFY_READ, sr, sizeof(*sr))\n\t\t    || restore_user_regs(regs, sr, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV, current);\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_signal32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1417-1494",
    "snippet": "int handle_signal32(struct ksignal *ksig, sigset_t *oldset, struct pt_regs *regs)\n{\n\tstruct sigcontext __user *sc;\n\tstruct sigframe __user *frame;\n\tstruct mcontext __user *tm_mctx = NULL;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\tframe = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*frame), 1);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\tsc = (struct sigcontext __user *) &frame->sctx;\n\n#if _NSIG != 64\n#error \"Please adjust handle_signal()\"\n#endif\n\tif (__put_user(to_user_ptr(ksig->ka.sa.sa_handler), &sc->handler)\n\t    || __put_user(oldset->sig[0], &sc->oldmask)\n#ifdef CONFIG_PPC64\n\t    || __put_user((oldset->sig[0] >> 32), &sc->_unused[3])\n#else\n\t    || __put_user(oldset->sig[1], &sc->_unused[3])\n#endif\n\t    || __put_user(to_user_ptr(&frame->mctx), &sc->regs)\n\t    || __put_user(ksig->sig, &sc->signal))\n\t\tgoto badframe;\n\n\tif (vdso32_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_sigtramp;\n\t} else {\n\t\tsigret = __NR_sigreturn;\n\t\ttramp = (unsigned long) frame->mctx.tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_mctx = &frame->mctx_transact;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (save_tm_user_regs(regs, &frame->mctx, &frame->mctx_transact,\n\t\t\t\t      sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (save_user_regs(regs, &frame->mctx, tm_mctx, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) sc;\n\tregs->nip = (unsigned long) (unsigned long)ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in big-endian mode */\n\tregs->msr &= ~MSR_LE;\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   frame, regs->nip, regs->link);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define tramp\tmc_pad",
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define mcontext\tmcontext32",
      "#define sigcontext\tsigcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\"",
            "current->comm",
            "current->pid",
            "frame",
            "regs->nip",
            "regs->link"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "regs->gpr[1]",
            "(u32 __user *)newsp"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_user_regs",
          "args": [
            "regs",
            "&frame->mctx",
            "tm_mctx",
            "sigret",
            "1"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "save_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "408-503",
          "snippet": "static int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_tm_user_regs",
          "args": [
            "regs",
            "&frame->mctx",
            "&frame->mctx_transact",
            "sigret"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "save_tm_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "515-655",
          "snippet": "static int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.transact_vr,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.transact_vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_transact_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_transact_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32",
            "#define sigcontext\tsigcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nstatic int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.transact_vr,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.transact_vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_transact_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_transact_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "regs->msr"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ksig->sig",
            "&sc->signal"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "to_user_ptr(&frame->mctx)",
            "&sc->regs"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_user_ptr",
          "args": [
            "&frame->mctx"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "oldset->sig[1]",
            "&sc->_unused[3]"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(oldset->sig[0] >> 32)",
            "&sc->_unused[3]"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "oldset->sig[0]",
            "&sc->oldmask"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "to_user_ptr(ksig->ka.sa.sa_handler)",
            "&sc->handler"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_user_ptr",
          "args": [
            "ksig->ka.sa.sa_handler"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "frame == NULL"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigframe",
          "args": [
            "ksig",
            "get_tm_stackpointer(regs)",
            "sizeof(*frame)",
            "1"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
          "lines": "34-49",
          "snippet": "void __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok(VERIFY_WRITE, (void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok(VERIFY_WRITE, (void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tm_stackpointer",
          "args": [
            "regs"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "get_tm_stackpointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
          "lines": "165-197",
          "snippet": "unsigned long get_tm_stackpointer(struct pt_regs *regs)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted becuase of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(regs->msr))\n\t\t\treturn current->thread.ckpt_regs.gpr[1];\n\t}\n#endif\n\treturn regs->gpr[1];\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long get_tm_stackpointer(struct pt_regs *regs)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted becuase of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(regs->msr))\n\t\t\treturn current->thread.ckpt_regs.gpr[1];\n\t}\n#endif\n\treturn regs->gpr[1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nint handle_signal32(struct ksignal *ksig, sigset_t *oldset, struct pt_regs *regs)\n{\n\tstruct sigcontext __user *sc;\n\tstruct sigframe __user *frame;\n\tstruct mcontext __user *tm_mctx = NULL;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\tframe = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*frame), 1);\n\tif (unlikely(frame == NULL))\n\t\tgoto badframe;\n\tsc = (struct sigcontext __user *) &frame->sctx;\n\n#if _NSIG != 64\n#error \"Please adjust handle_signal()\"\n#endif\n\tif (__put_user(to_user_ptr(ksig->ka.sa.sa_handler), &sc->handler)\n\t    || __put_user(oldset->sig[0], &sc->oldmask)\n#ifdef CONFIG_PPC64\n\t    || __put_user((oldset->sig[0] >> 32), &sc->_unused[3])\n#else\n\t    || __put_user(oldset->sig[1], &sc->_unused[3])\n#endif\n\t    || __put_user(to_user_ptr(&frame->mctx), &sc->regs)\n\t    || __put_user(ksig->sig, &sc->signal))\n\t\tgoto badframe;\n\n\tif (vdso32_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_sigtramp;\n\t} else {\n\t\tsigret = __NR_sigreturn;\n\t\ttramp = (unsigned long) frame->mctx.tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_mctx = &frame->mctx_transact;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (save_tm_user_regs(regs, &frame->mctx, &frame->mctx_transact,\n\t\t\t\t      sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (save_user_regs(regs, &frame->mctx, tm_mctx, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)frame) - __SIGNAL_FRAMESIZE;\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) sc;\n\tregs->nip = (unsigned long) (unsigned long)ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in big-endian mode */\n\tregs->msr &= ~MSR_LE;\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   frame, regs->nip, regs->link);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "sys_debug_setcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1308-1411",
    "snippet": "int sys_debug_setcontext(struct ucontext __user *ctx,\n\t\t\t int ndbg, struct sig_dbg_op __user *dbg,\n\t\t\t int r6, int r7, int r8,\n\t\t\t struct pt_regs *regs)\n{\n\tstruct sig_dbg_op op;\n\tint i;\n\tunsigned char tmp;\n\tunsigned long new_msr = regs->msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tunsigned long new_dbcr0 = current->thread.debug.dbcr0;\n#endif\n\n\tfor (i=0; i<ndbg; i++) {\n\t\tif (copy_from_user(&op, dbg + i, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tswitch (op.dbg_type) {\n\t\tcase SIG_DBG_SINGLE_STEPPING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\tif (op.dbg_value) {\n\t\t\t\tnew_msr |= MSR_DE;\n\t\t\t\tnew_dbcr0 |= (DBCR0_IDM | DBCR0_IC);\n\t\t\t} else {\n\t\t\t\tnew_dbcr0 &= ~DBCR0_IC;\n\t\t\t\tif (!DBCR_ACTIVE_EVENTS(new_dbcr0,\n\t\t\t\t\t\tcurrent->thread.debug.dbcr1)) {\n\t\t\t\t\tnew_msr &= ~MSR_DE;\n\t\t\t\t\tnew_dbcr0 &= ~DBCR0_IDM;\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_SE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_SE;\n#endif\n\t\t\tbreak;\n\t\tcase SIG_DBG_BRANCH_TRACING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\treturn -EINVAL;\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_BE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_BE;\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* We wait until here to actually install the values in the\n\t   registers so if we fail in the above loop, it will not\n\t   affect the contents of these registers.  After this point,\n\t   failure is a problem, anyway, and it's very unlikely unless\n\t   the user is really doing something wrong. */\n\tregs->msr = new_msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tcurrent->thread.debug.dbcr0 = new_dbcr0;\n#endif\n\n\tif (!access_ok(VERIFY_READ, ctx, sizeof(*ctx))\n\t    || __get_user(tmp, (u8 __user *) ctx)\n\t    || __get_user(tmp, (u8 __user *) (ctx + 1) - 1))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(ctx, regs, 1)) {\n\t\tif (show_unhandled_signals)\n\t\t\tprintk_ratelimited(KERN_INFO \"%s[%d]: bad frame in \"\n\t\t\t\t\t   \"sys_debug_setcontext: %p nip %08lx \"\n\t\t\t\t\t   \"lr %08lx\\n\",\n\t\t\t\t\t   current->comm, current->pid,\n\t\t\t\t\t   ctx, regs->nip, regs->link);\n\n\t\tforce_sig(SIGSEGV, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n\trestore_altstack(&ctx->uc_stack);\n\n\tset_thread_flag(TIF_RESTOREALL);\n out:\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ucontext\tucontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTOREALL"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_altstack",
          "args": [
            "&ctx->uc_stack"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGSEGV",
            "current"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO \"%s[%d]: bad frame in \"\n\t\t\t\t\t   \"sys_debug_setcontext: %p nip %08lx \"\n\t\t\t\t\t   \"lr %08lx\\n\"",
            "current->comm",
            "current->pid",
            "ctx",
            "regs->nip",
            "regs->link"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_setcontext",
          "args": [
            "ctx",
            "regs",
            "1"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "do_setcontext_tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "1111-1136",
          "snippet": "static int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ucontext\tucontext32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nstatic int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tmp",
            "(u8 __user *) (ctx + 1) - 1"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tmp",
            "(u8 __user *) ctx"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "ctx",
            "sizeof(*ctx)"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBCR_ACTIVE_EVENTS",
          "args": [
            "new_dbcr0",
            "current->thread.debug.dbcr1"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&op",
            "dbg + i",
            "sizeof(op)"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n\nint sys_debug_setcontext(struct ucontext __user *ctx,\n\t\t\t int ndbg, struct sig_dbg_op __user *dbg,\n\t\t\t int r6, int r7, int r8,\n\t\t\t struct pt_regs *regs)\n{\n\tstruct sig_dbg_op op;\n\tint i;\n\tunsigned char tmp;\n\tunsigned long new_msr = regs->msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tunsigned long new_dbcr0 = current->thread.debug.dbcr0;\n#endif\n\n\tfor (i=0; i<ndbg; i++) {\n\t\tif (copy_from_user(&op, dbg + i, sizeof(op)))\n\t\t\treturn -EFAULT;\n\t\tswitch (op.dbg_type) {\n\t\tcase SIG_DBG_SINGLE_STEPPING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\tif (op.dbg_value) {\n\t\t\t\tnew_msr |= MSR_DE;\n\t\t\t\tnew_dbcr0 |= (DBCR0_IDM | DBCR0_IC);\n\t\t\t} else {\n\t\t\t\tnew_dbcr0 &= ~DBCR0_IC;\n\t\t\t\tif (!DBCR_ACTIVE_EVENTS(new_dbcr0,\n\t\t\t\t\t\tcurrent->thread.debug.dbcr1)) {\n\t\t\t\t\tnew_msr &= ~MSR_DE;\n\t\t\t\t\tnew_dbcr0 &= ~DBCR0_IDM;\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_SE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_SE;\n#endif\n\t\t\tbreak;\n\t\tcase SIG_DBG_BRANCH_TRACING:\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t\treturn -EINVAL;\n#else\n\t\t\tif (op.dbg_value)\n\t\t\t\tnew_msr |= MSR_BE;\n\t\t\telse\n\t\t\t\tnew_msr &= ~MSR_BE;\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/* We wait until here to actually install the values in the\n\t   registers so if we fail in the above loop, it will not\n\t   affect the contents of these registers.  After this point,\n\t   failure is a problem, anyway, and it's very unlikely unless\n\t   the user is really doing something wrong. */\n\tregs->msr = new_msr;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tcurrent->thread.debug.dbcr0 = new_dbcr0;\n#endif\n\n\tif (!access_ok(VERIFY_READ, ctx, sizeof(*ctx))\n\t    || __get_user(tmp, (u8 __user *) ctx)\n\t    || __get_user(tmp, (u8 __user *) (ctx + 1) - 1))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(ctx, regs, 1)) {\n\t\tif (show_unhandled_signals)\n\t\t\tprintk_ratelimited(KERN_INFO \"%s[%d]: bad frame in \"\n\t\t\t\t\t   \"sys_debug_setcontext: %p nip %08lx \"\n\t\t\t\t\t   \"lr %08lx\\n\",\n\t\t\t\t\t   current->comm, current->pid,\n\t\t\t\t\t   ctx, regs->nip, regs->link);\n\n\t\tforce_sig(SIGSEGV, current);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n\trestore_altstack(&ctx->uc_stack);\n\n\tset_thread_flag(TIF_RESTOREALL);\n out:\n\treturn 0;\n}"
  },
  {
    "function_name": "sys_rt_sigreturn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1230-1305",
    "snippet": "long sys_rt_sigreturn(int r3, int r4, int r5, int r6, int r7, int r8,\n\t\t     struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *rt_sf;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct ucontext __user *uc_transact;\n\tunsigned long msr_hi;\n\tunsigned long tmp;\n\tint tm_restore = 0;\n#endif\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\trt_sf = (struct rt_sigframe __user *)\n\t\t(regs->gpr[1] + __SIGNAL_FRAMESIZE + 16);\n\tif (!access_ok(VERIFY_READ, rt_sf, sizeof(*rt_sf)))\n\t\tgoto bad;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (__get_user(tmp, &rt_sf->uc.uc_link))\n\t\tgoto bad;\n\tuc_transact = (struct ucontext __user *)(uintptr_t)tmp;\n\tif (uc_transact) {\n\t\tu32 cmcp;\n\t\tstruct mcontext __user *mcp;\n\n\t\tif (__get_user(cmcp, &uc_transact->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* The top 32 bits of the MSR are stashed in the transactional\n\t\t * ucontext. */\n\t\tif (__get_user(msr_hi, &mcp->mc_gregs[PT_MSR]))\n\t\t\tgoto bad;\n\n\t\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\t\t/* We only recheckpoint on return if we're\n\t\t\t * transaction.\n\t\t\t */\n\t\t\ttm_restore = 1;\n\t\t\tif (do_setcontext_tm(&rt_sf->uc, uc_transact, regs))\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (!tm_restore)\n\t\t/* Fall through, for non-TM restore */\n#endif\n\tif (do_setcontext(&rt_sf->uc, regs, 1))\n\t\tgoto bad;\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n#ifdef CONFIG_PPC64\n\tif (compat_restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#else\n\tif (restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#endif\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\n bad:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_rt_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   rt_sf, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV, current);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32",
      "#define sys_rt_sigreturn\tcompat_sys_rt_sigreturn"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGSEGV",
            "current"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_rt_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\"",
            "current->comm",
            "current->pid",
            "rt_sf",
            "regs->nip",
            "regs->link"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTOREALL"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_altstack",
          "args": [
            "&rt_sf->uc.uc_stack"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_restore_altstack",
          "args": [
            "&rt_sf->uc.uc_stack"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_setcontext",
          "args": [
            "&rt_sf->uc",
            "regs",
            "1"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "do_setcontext_tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "1111-1136",
          "snippet": "static int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ucontext\tucontext32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nstatic int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "msr_hi<<32"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr_hi",
            "&mcp->mc_gregs[PT_MSR]"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "cmcp",
            "&uc_transact->uc_regs"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tmp",
            "&rt_sf->uc.uc_link"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "rt_sf",
            "sizeof(*rt_sf)"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n#define sys_rt_sigreturn\tcompat_sys_rt_sigreturn\n\nlong sys_rt_sigreturn(int r3, int r4, int r5, int r6, int r7, int r8,\n\t\t     struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *rt_sf;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tstruct ucontext __user *uc_transact;\n\tunsigned long msr_hi;\n\tunsigned long tmp;\n\tint tm_restore = 0;\n#endif\n\t/* Always make any pending restarted system calls return -EINTR */\n\tcurrent->restart_block.fn = do_no_restart_syscall;\n\n\trt_sf = (struct rt_sigframe __user *)\n\t\t(regs->gpr[1] + __SIGNAL_FRAMESIZE + 16);\n\tif (!access_ok(VERIFY_READ, rt_sf, sizeof(*rt_sf)))\n\t\tgoto bad;\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (__get_user(tmp, &rt_sf->uc.uc_link))\n\t\tgoto bad;\n\tuc_transact = (struct ucontext __user *)(uintptr_t)tmp;\n\tif (uc_transact) {\n\t\tu32 cmcp;\n\t\tstruct mcontext __user *mcp;\n\n\t\tif (__get_user(cmcp, &uc_transact->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* The top 32 bits of the MSR are stashed in the transactional\n\t\t * ucontext. */\n\t\tif (__get_user(msr_hi, &mcp->mc_gregs[PT_MSR]))\n\t\t\tgoto bad;\n\n\t\tif (MSR_TM_ACTIVE(msr_hi<<32)) {\n\t\t\t/* We only recheckpoint on return if we're\n\t\t\t * transaction.\n\t\t\t */\n\t\t\ttm_restore = 1;\n\t\t\tif (do_setcontext_tm(&rt_sf->uc, uc_transact, regs))\n\t\t\t\tgoto bad;\n\t\t}\n\t}\n\tif (!tm_restore)\n\t\t/* Fall through, for non-TM restore */\n#endif\n\tif (do_setcontext(&rt_sf->uc, regs, 1))\n\t\tgoto bad;\n\n\t/*\n\t * It's not clear whether or why it is desirable to save the\n\t * sigaltstack setting on signal delivery and restore it on\n\t * signal return.  But other architectures do this and we have\n\t * always done it up until now so it is probably better not to\n\t * change it.  -- paulus\n\t */\n#ifdef CONFIG_PPC64\n\tif (compat_restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#else\n\tif (restore_altstack(&rt_sf->uc.uc_stack))\n\t\tgoto bad;\n#endif\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n\n bad:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in sys_rt_sigreturn: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   rt_sf, regs->nip, regs->link);\n\n\tforce_sig(SIGSEGV, current);\n\treturn 0;\n}"
  },
  {
    "function_name": "sys_swapcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1139-1228",
    "snippet": "long sys_swapcontext(struct ucontext __user *old_ctx,\n\t\t     struct ucontext __user *new_ctx,\n\t\t     int ctx_size, int r6, int r7, int r8, struct pt_regs *regs)\n{\n\tunsigned char tmp;\n\tint ctx_has_vsx_region = 0;\n\n#ifdef CONFIG_PPC64\n\tunsigned long new_msr = 0;\n\n\tif (new_ctx) {\n\t\tstruct mcontext __user *mcp;\n\t\tu32 cmcp;\n\n\t\t/*\n\t\t * Get pointer to the real mcontext.  No need for\n\t\t * access_ok since we are dealing with compat\n\t\t * pointers.\n\t\t */\n\t\tif (__get_user(cmcp, &new_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\tif (__get_user(new_msr, &mcp->mc_gregs[PT_MSR]))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n#else\n\t/* Context size is for future use. Right now, we only make sure\n\t * we are passed something we understand\n\t */\n\tif (ctx_size < sizeof(struct ucontext))\n\t\treturn -EINVAL;\n#endif\n\tif (old_ctx != NULL) {\n\t\tstruct mcontext __user *mctx;\n\n\t\t/*\n\t\t * old_ctx might not be 16-byte aligned, in which\n\t\t * case old_ctx->uc_mcontext won't be either.\n\t\t * Because we have the old_ctx->uc_pad2 field\n\t\t * before old_ctx->uc_mcontext, we need to round down\n\t\t * from &old_ctx->uc_mcontext to a 16-byte boundary.\n\t\t */\n\t\tmctx = (struct mcontext __user *)\n\t\t\t((unsigned long) &old_ctx->uc_mcontext & ~0xfUL);\n\t\tif (!access_ok(VERIFY_WRITE, old_ctx, ctx_size)\n\t\t    || save_user_regs(regs, mctx, NULL, 0, ctx_has_vsx_region)\n\t\t    || put_sigset_t(&old_ctx->uc_sigmask, &current->blocked)\n\t\t    || __put_user(to_user_ptr(mctx), &old_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(VERIFY_READ, new_ctx, ctx_size)\n\t    || __get_user(tmp, (u8 __user *) new_ctx)\n\t    || __get_user(tmp, (u8 __user *) new_ctx + ctx_size - 1))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(new_ctx, regs, 0))\n\t\tdo_exit(SIGSEGV);\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - sizeof(elf_vsrreghalf_t32))",
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32",
      "#define sys_swapcontext\tcompat_sys_swapcontext"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTOREALL"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "SIGSEGV"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_setcontext",
          "args": [
            "new_ctx",
            "regs",
            "0"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "do_setcontext_tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "1111-1136",
          "snippet": "static int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ucontext\tucontext32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nstatic int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tmp",
            "(u8 __user *) new_ctx + ctx_size - 1"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tmp",
            "(u8 __user *) new_ctx"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "new_ctx",
            "ctx_size"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "to_user_ptr(mctx)",
            "&old_ctx->uc_regs"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_user_ptr",
          "args": [
            "mctx"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_sigset_t",
          "args": [
            "&old_ctx->uc_sigmask",
            "&current->blocked"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "put_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "171-174",
          "snippet": "static inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_user_regs",
          "args": [
            "regs",
            "mctx",
            "NULL",
            "0",
            "ctx_has_vsx_region"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "save_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "408-503",
          "snippet": "static int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "old_ctx",
            "ctx_size"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "new_msr",
            "&mcp->mc_gregs[PT_MSR]"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "cmcp",
            "&new_ctx->uc_regs"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define UCONTEXTSIZEWITHOUTVSX \\\n\t\t(sizeof(struct ucontext) - sizeof(elf_vsrreghalf_t32))\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n#define sys_swapcontext\tcompat_sys_swapcontext\n\nlong sys_swapcontext(struct ucontext __user *old_ctx,\n\t\t     struct ucontext __user *new_ctx,\n\t\t     int ctx_size, int r6, int r7, int r8, struct pt_regs *regs)\n{\n\tunsigned char tmp;\n\tint ctx_has_vsx_region = 0;\n\n#ifdef CONFIG_PPC64\n\tunsigned long new_msr = 0;\n\n\tif (new_ctx) {\n\t\tstruct mcontext __user *mcp;\n\t\tu32 cmcp;\n\n\t\t/*\n\t\t * Get pointer to the real mcontext.  No need for\n\t\t * access_ok since we are dealing with compat\n\t\t * pointers.\n\t\t */\n\t\tif (__get_user(cmcp, &new_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\tif (__get_user(new_msr, &mcp->mc_gregs[PT_MSR]))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t * Check that the context is not smaller than the original\n\t * size (with VMX but without VSX)\n\t */\n\tif (ctx_size < UCONTEXTSIZEWITHOUTVSX)\n\t\treturn -EINVAL;\n\t/*\n\t * If the new context state sets the MSR VSX bits but\n\t * it doesn't provide VSX state.\n\t */\n\tif ((ctx_size < sizeof(struct ucontext)) &&\n\t    (new_msr & MSR_VSX))\n\t\treturn -EINVAL;\n\t/* Does the context have enough room to store VSX data? */\n\tif (ctx_size >= sizeof(struct ucontext))\n\t\tctx_has_vsx_region = 1;\n#else\n\t/* Context size is for future use. Right now, we only make sure\n\t * we are passed something we understand\n\t */\n\tif (ctx_size < sizeof(struct ucontext))\n\t\treturn -EINVAL;\n#endif\n\tif (old_ctx != NULL) {\n\t\tstruct mcontext __user *mctx;\n\n\t\t/*\n\t\t * old_ctx might not be 16-byte aligned, in which\n\t\t * case old_ctx->uc_mcontext won't be either.\n\t\t * Because we have the old_ctx->uc_pad2 field\n\t\t * before old_ctx->uc_mcontext, we need to round down\n\t\t * from &old_ctx->uc_mcontext to a 16-byte boundary.\n\t\t */\n\t\tmctx = (struct mcontext __user *)\n\t\t\t((unsigned long) &old_ctx->uc_mcontext & ~0xfUL);\n\t\tif (!access_ok(VERIFY_WRITE, old_ctx, ctx_size)\n\t\t    || save_user_regs(regs, mctx, NULL, 0, ctx_has_vsx_region)\n\t\t    || put_sigset_t(&old_ctx->uc_sigmask, &current->blocked)\n\t\t    || __put_user(to_user_ptr(mctx), &old_ctx->uc_regs))\n\t\t\treturn -EFAULT;\n\t}\n\tif (new_ctx == NULL)\n\t\treturn 0;\n\tif (!access_ok(VERIFY_READ, new_ctx, ctx_size)\n\t    || __get_user(tmp, (u8 __user *) new_ctx)\n\t    || __get_user(tmp, (u8 __user *) new_ctx + ctx_size - 1))\n\t\treturn -EFAULT;\n\n\t/*\n\t * If we get a fault copying the context into the kernel's\n\t * image of the user's registers, we can't just return -EFAULT\n\t * because the user's registers will be corrupted.  For instance\n\t * the NIP value may have been updated but not some of the\n\t * other registers.  Given that we have done the access_ok\n\t * and successfully read the first and last bytes of the region\n\t * above, this should only happen in an out-of-memory situation\n\t * or if another thread unmaps the region containing the context.\n\t * We kill the task with a SIGSEGV in this situation.\n\t */\n\tif (do_setcontext(new_ctx, regs, 0))\n\t\tdo_exit(SIGSEGV);\n\n\tset_thread_flag(TIF_RESTOREALL);\n\treturn 0;\n}"
  },
  {
    "function_name": "do_setcontext_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1111-1136",
    "snippet": "static int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_tm_user_regs",
          "args": [
            "regs",
            "mcp",
            "tm_mcp"
          ],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "restore_tm_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "772-910",
          "snippet": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\t/* Pull in the MSR TM bits from the user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\t/* Pull in the MSR TM bits from the user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&set"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tm_cmcp",
            "&tm_ucp->uc_regs"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "cmcp",
            "&ucp->uc_regs"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigset_t",
          "args": [
            "&set",
            "&ucp->uc_sigmask"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "176-179",
          "snippet": "static inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nstatic int do_setcontext_tm(struct ucontext __user *ucp,\n\t\t\t    struct ucontext __user *tm_ucp,\n\t\t\t    struct pt_regs *regs)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\tstruct mcontext __user *tm_mcp;\n\tu32 cmcp;\n\tu32 tm_cmcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n\n\tif (__get_user(cmcp, &ucp->uc_regs) ||\n\t    __get_user(tm_cmcp, &tm_ucp->uc_regs))\n\t\treturn -EFAULT;\n\tmcp = (struct mcontext __user *)(u64)cmcp;\n\ttm_mcp = (struct mcontext __user *)(u64)tm_cmcp;\n\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\n\tset_current_blocked(&set);\n\tif (restore_tm_user_regs(regs, mcp, tm_mcp))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_setcontext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "1081-1108",
    "snippet": "static int do_setcontext(struct ucontext __user *ucp, struct pt_regs *regs, int sig)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n#ifdef CONFIG_PPC64\n\t{\n\t\tu32 cmcp;\n\n\t\tif (__get_user(cmcp, &ucp->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\t}\n#else\n\tif (__get_user(mcp, &ucp->uc_regs))\n\t\treturn -EFAULT;\n\tif (!access_ok(VERIFY_READ, mcp, sizeof(*mcp)))\n\t\treturn -EFAULT;\n#endif\n\tset_current_blocked(&set);\n\tif (restore_user_regs(regs, mcp, sig))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "restore_user_regs",
          "args": [
            "regs",
            "mcp",
            "sig"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "restore_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "662-764",
          "snippet": "static long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tregs->trap = 0;\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tregs->trap = 0;\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&set"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "mcp",
            "sizeof(*mcp)"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "mcp",
            "&ucp->uc_regs"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "cmcp",
            "&ucp->uc_regs"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigset_t",
          "args": [
            "&set",
            "&ucp->uc_sigmask"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "176-179",
          "snippet": "static inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nstatic int do_setcontext(struct ucontext __user *ucp, struct pt_regs *regs, int sig)\n{\n\tsigset_t set;\n\tstruct mcontext __user *mcp;\n\n\tif (get_sigset_t(&set, &ucp->uc_sigmask))\n\t\treturn -EFAULT;\n#ifdef CONFIG_PPC64\n\t{\n\t\tu32 cmcp;\n\n\t\tif (__get_user(cmcp, &ucp->uc_regs))\n\t\t\treturn -EFAULT;\n\t\tmcp = (struct mcontext __user *)(u64)cmcp;\n\t\t/* no need to check access_ok(mcp), since mcp < 4GB */\n\t}\n#else\n\tif (__get_user(mcp, &ucp->uc_regs))\n\t\treturn -EFAULT;\n\tif (!access_ok(VERIFY_READ, mcp, sizeof(*mcp)))\n\t\treturn -EFAULT;\n#endif\n\tset_current_blocked(&set);\n\tif (restore_user_regs(regs, mcp, sig))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_rt_signal32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "991-1079",
    "snippet": "int handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define copy_siginfo_to_user\tcopy_siginfo_to_user32",
      "#define tramp\tmc_pad",
      "#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32",
      "#define __save_altstack __compat_save_altstack",
      "#define ucontext\tucontext32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\"",
            "current->comm",
            "current->pid",
            "addr",
            "regs->nip",
            "regs->link"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "regs->gpr[1]",
            "(u32 __user *)newsp"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_user_regs",
          "args": [
            "regs",
            "frame",
            "tm_frame",
            "sigret",
            "1"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "save_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "408-503",
          "snippet": "static int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&rt_sf->uc.uc_link"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_tm_user_regs",
          "args": [
            "regs",
            "frame",
            "tm_frame",
            "sigret"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "save_tm_user_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "515-655",
          "snippet": "static int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.transact_vr,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.transact_vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_transact_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_transact_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define tramp\tmc_pad",
            "#define ELF_NVRREG\tELF_NVRREG32",
            "#define mcontext\tmcontext32",
            "#define sigcontext\tsigcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nstatic int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.transact_vr,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.transact_vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_transact_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_transact_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(unsigned long)tm_frame",
            "&rt_sf->uc_transact.uc_regs"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(unsigned long)&rt_sf->uc_transact",
            "&rt_sf->uc.uc_link"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "regs->msr"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_sigset_t",
          "args": [
            "&rt_sf->uc.uc_sigmask",
            "oldset"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "put_sigset_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "171-174",
          "snippet": "static inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "to_user_ptr(&rt_sf->uc.uc_mcontext)",
            "&rt_sf->uc.uc_regs"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_user_ptr",
          "args": [
            "&rt_sf->uc.uc_mcontext"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__save_altstack",
          "args": [
            "&rt_sf->uc.uc_stack",
            "regs->gpr[1]"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&rt_sf->uc.uc_flags"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_siginfo_to_user",
          "args": [
            "&rt_sf->info",
            "&ksig->info"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_to_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "914-972",
          "snippet": "int copy_siginfo_to_user32(struct compat_siginfo __user *d, const siginfo_t *s)\n{\n\tint err;\n\n\tif (!access_ok (VERIFY_WRITE, d, sizeof(*d)))\n\t\treturn -EFAULT;\n\n\t/* If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t * It should never copy any pad contained in the structure\n\t * to avoid security leaks, but must copy the generic\n\t * 3 ints plus the relevant union member.\n\t * This routine must convert siginfo from 64bit to 32bit as well\n\t * at the same time.\n\t */\n\terr = __put_user(s->si_signo, &d->si_signo);\n\terr |= __put_user(s->si_errno, &d->si_errno);\n\terr |= __put_user((short)s->si_code, &d->si_code);\n\tif (s->si_code < 0)\n\t\terr |= __copy_to_user(&d->_sifields._pad, &s->_sifields._pad,\n\t\t\t\t      SI_PAD_SIZE32);\n\telse switch(s->si_code >> 16) {\n\tcase __SI_CHLD >> 16:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\terr |= __put_user(s->si_utime, &d->si_utime);\n\t\terr |= __put_user(s->si_stime, &d->si_stime);\n\t\terr |= __put_user(s->si_status, &d->si_status);\n\t\tbreak;\n\tcase __SI_FAULT >> 16:\n\t\terr |= __put_user((unsigned int)(unsigned long)s->si_addr,\n\t\t\t\t  &d->si_addr);\n\t\tbreak;\n\tcase __SI_POLL >> 16:\n\t\terr |= __put_user(s->si_band, &d->si_band);\n\t\terr |= __put_user(s->si_fd, &d->si_fd);\n\t\tbreak;\n\tcase __SI_TIMER >> 16:\n\t\terr |= __put_user(s->si_tid, &d->si_tid);\n\t\terr |= __put_user(s->si_overrun, &d->si_overrun);\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\tbreak;\n\tcase __SI_SYS >> 16:\n\t\terr |= __put_user(ptr_to_compat(s->si_call_addr), &d->si_call_addr);\n\t\terr |= __put_user(s->si_syscall, &d->si_syscall);\n\t\terr |= __put_user(s->si_arch, &d->si_arch);\n\t\tbreak;\n\tcase __SI_RT >> 16: /* This is not generated by the kernel as of now.  */\n\tcase __SI_MESGQ >> 16:\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\t/* fallthrough */\n\tcase __SI_KILL >> 16:\n\tdefault:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nint copy_siginfo_to_user32(struct compat_siginfo __user *d, const siginfo_t *s)\n{\n\tint err;\n\n\tif (!access_ok (VERIFY_WRITE, d, sizeof(*d)))\n\t\treturn -EFAULT;\n\n\t/* If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t * It should never copy any pad contained in the structure\n\t * to avoid security leaks, but must copy the generic\n\t * 3 ints plus the relevant union member.\n\t * This routine must convert siginfo from 64bit to 32bit as well\n\t * at the same time.\n\t */\n\terr = __put_user(s->si_signo, &d->si_signo);\n\terr |= __put_user(s->si_errno, &d->si_errno);\n\terr |= __put_user((short)s->si_code, &d->si_code);\n\tif (s->si_code < 0)\n\t\terr |= __copy_to_user(&d->_sifields._pad, &s->_sifields._pad,\n\t\t\t\t      SI_PAD_SIZE32);\n\telse switch(s->si_code >> 16) {\n\tcase __SI_CHLD >> 16:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\terr |= __put_user(s->si_utime, &d->si_utime);\n\t\terr |= __put_user(s->si_stime, &d->si_stime);\n\t\terr |= __put_user(s->si_status, &d->si_status);\n\t\tbreak;\n\tcase __SI_FAULT >> 16:\n\t\terr |= __put_user((unsigned int)(unsigned long)s->si_addr,\n\t\t\t\t  &d->si_addr);\n\t\tbreak;\n\tcase __SI_POLL >> 16:\n\t\terr |= __put_user(s->si_band, &d->si_band);\n\t\terr |= __put_user(s->si_fd, &d->si_fd);\n\t\tbreak;\n\tcase __SI_TIMER >> 16:\n\t\terr |= __put_user(s->si_tid, &d->si_tid);\n\t\terr |= __put_user(s->si_overrun, &d->si_overrun);\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\tbreak;\n\tcase __SI_SYS >> 16:\n\t\terr |= __put_user(ptr_to_compat(s->si_call_addr), &d->si_call_addr);\n\t\terr |= __put_user(s->si_syscall, &d->si_syscall);\n\t\terr |= __put_user(s->si_arch, &d->si_arch);\n\t\tbreak;\n\tcase __SI_RT >> 16: /* This is not generated by the kernel as of now.  */\n\tcase __SI_MESGQ >> 16:\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\t/* fallthrough */\n\tcase __SI_KILL >> 16:\n\tdefault:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rt_sf == NULL"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sigframe",
          "args": [
            "ksig",
            "get_tm_stackpointer(regs)",
            "sizeof(*rt_sf)",
            "1"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "get_sigframe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
          "lines": "34-49",
          "snippet": "void __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok(VERIFY_WRITE, (void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nvoid __user *get_sigframe(struct ksignal *ksig, unsigned long sp,\n\t\t\t   size_t frame_size, int is_32)\n{\n        unsigned long oldsp, newsp;\n\n        /* Default to using normal stack */\n        oldsp = get_clean_sp(sp, is_32);\n\toldsp = sigsp(oldsp, ksig);\n\tnewsp = (oldsp - frame_size) & ~0xFUL;\n\n\t/* Check access */\n\tif (!access_ok(VERIFY_WRITE, (void __user *)newsp, oldsp - newsp))\n\t\treturn NULL;\n\n        return (void __user *)newsp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_tm_stackpointer",
          "args": [
            "regs"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "get_tm_stackpointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal.c",
          "lines": "165-197",
          "snippet": "unsigned long get_tm_stackpointer(struct pt_regs *regs)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted becuase of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(regs->msr))\n\t\t\treturn current->thread.ckpt_regs.gpr[1];\n\t}\n#endif\n\treturn regs->gpr[1];\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/tm.h>",
            "#include <asm/debug.h>",
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/key.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signal.h>",
            "#include <linux/tracehook.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/tm.h>\n#include <asm/debug.h>\n#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/context_tracking.h>\n#include <linux/key.h>\n#include <linux/uprobes.h>\n#include <linux/signal.h>\n#include <linux/tracehook.h>\n\nunsigned long get_tm_stackpointer(struct pt_regs *regs)\n{\n\t/* When in an active transaction that takes a signal, we need to be\n\t * careful with the stack.  It's possible that the stack has moved back\n\t * up after the tbegin.  The obvious case here is when the tbegin is\n\t * called inside a function that returns before a tend.  In this case,\n\t * the stack is part of the checkpointed transactional memory state.\n\t * If we write over this non transactionally or in suspend, we are in\n\t * trouble because if we get a tm abort, the program counter and stack\n\t * pointer will be back at the tbegin but our in memory stack won't be\n\t * valid anymore.\n\t *\n\t * To avoid this, when taking a signal in an active transaction, we\n\t * need to use the stack pointer from the checkpointed state, rather\n\t * than the speculated state.  This ensures that the signal context\n\t * (written tm suspended) will be written below the stack required for\n\t * the rollback.  The transaction is aborted becuase of the treclaim,\n\t * so any memory written between the tbegin and the signal will be\n\t * rolled back anyway.\n\t *\n\t * For signals taken in non-TM or suspended mode, we use the\n\t * normal/non-checkpointed stack pointer.\n\t */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t\tif (MSR_TM_TRANSACTIONAL(regs->msr))\n\t\t\treturn current->thread.ckpt_regs.gpr[1];\n\t}\n#endif\n\treturn regs->gpr[1];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define copy_siginfo_to_user\tcopy_siginfo_to_user32\n#define tramp\tmc_pad\n#define __SIGNAL_FRAMESIZE\t__SIGNAL_FRAMESIZE32\n#define __save_altstack __compat_save_altstack\n#define ucontext\tucontext32\n#define mcontext\tmcontext32\n\nint handle_rt_signal32(struct ksignal *ksig, sigset_t *oldset,\n\t\t       struct pt_regs *regs)\n{\n\tstruct rt_sigframe __user *rt_sf;\n\tstruct mcontext __user *frame;\n\tstruct mcontext __user *tm_frame = NULL;\n\tvoid __user *addr;\n\tunsigned long newsp = 0;\n\tint sigret;\n\tunsigned long tramp;\n\n\t/* Set up Signal Frame */\n\t/* Put a Real Time Context onto stack */\n\trt_sf = get_sigframe(ksig, get_tm_stackpointer(regs), sizeof(*rt_sf), 1);\n\taddr = rt_sf;\n\tif (unlikely(rt_sf == NULL))\n\t\tgoto badframe;\n\n\t/* Put the siginfo & fill in most of the ucontext */\n\tif (copy_siginfo_to_user(&rt_sf->info, &ksig->info)\n\t    || __put_user(0, &rt_sf->uc.uc_flags)\n\t    || __save_altstack(&rt_sf->uc.uc_stack, regs->gpr[1])\n\t    || __put_user(to_user_ptr(&rt_sf->uc.uc_mcontext),\n\t\t    &rt_sf->uc.uc_regs)\n\t    || put_sigset_t(&rt_sf->uc.uc_sigmask, oldset))\n\t\tgoto badframe;\n\n\t/* Save user registers on the stack */\n\tframe = &rt_sf->uc.uc_mcontext;\n\taddr = frame;\n\tif (vdso32_rt_sigtramp && current->mm->context.vdso_base) {\n\t\tsigret = 0;\n\t\ttramp = current->mm->context.vdso_base + vdso32_rt_sigtramp;\n\t} else {\n\t\tsigret = __NR_rt_sigreturn;\n\t\ttramp = (unsigned long) frame->tramp;\n\t}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\ttm_frame = &rt_sf->uc_transact.uc_mcontext;\n\tif (MSR_TM_ACTIVE(regs->msr)) {\n\t\tif (__put_user((unsigned long)&rt_sf->uc_transact,\n\t\t\t       &rt_sf->uc.uc_link) ||\n\t\t    __put_user((unsigned long)tm_frame,\n\t\t\t       &rt_sf->uc_transact.uc_regs))\n\t\t\tgoto badframe;\n\t\tif (save_tm_user_regs(regs, frame, tm_frame, sigret))\n\t\t\tgoto badframe;\n\t}\n\telse\n#endif\n\t{\n\t\tif (__put_user(0, &rt_sf->uc.uc_link))\n\t\t\tgoto badframe;\n\t\tif (save_user_regs(regs, frame, tm_frame, sigret, 1))\n\t\t\tgoto badframe;\n\t}\n\tregs->link = tramp;\n\n\tcurrent->thread.fp_state.fpscr = 0;\t/* turn off all fp exceptions */\n\n\t/* create a stack frame for the caller of the handler */\n\tnewsp = ((unsigned long)rt_sf) - (__SIGNAL_FRAMESIZE + 16);\n\taddr = (void __user *)regs->gpr[1];\n\tif (put_user(regs->gpr[1], (u32 __user *)newsp))\n\t\tgoto badframe;\n\n\t/* Fill registers for signal handler */\n\tregs->gpr[1] = newsp;\n\tregs->gpr[3] = ksig->sig;\n\tregs->gpr[4] = (unsigned long) &rt_sf->info;\n\tregs->gpr[5] = (unsigned long) &rt_sf->uc;\n\tregs->gpr[6] = (unsigned long) rt_sf;\n\tregs->nip = (unsigned long) ksig->ka.sa.sa_handler;\n\t/* enter the signal handler in native-endian mode */\n\tregs->msr &= ~MSR_LE;\n\tregs->msr |= (MSR_KERNEL & MSR_LE);\n\treturn 0;\n\nbadframe:\n\tif (show_unhandled_signals)\n\t\tprintk_ratelimited(KERN_INFO\n\t\t\t\t   \"%s[%d]: bad frame in handle_rt_signal32: \"\n\t\t\t\t   \"%p nip %08lx lr %08lx\\n\",\n\t\t\t\t   current->comm, current->pid,\n\t\t\t\t   addr, regs->nip, regs->link);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "copy_siginfo_from_user32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "976-984",
    "snippet": "int copy_siginfo_from_user32(siginfo_t *to, struct compat_siginfo __user *from)\n{\n\tif (copy_from_user(to, from, 3*sizeof(int)) ||\n\t    copy_from_user(to->_sifields._pad,\n\t\t\t   from->_sifields._pad, SI_PAD_SIZE32))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "to->_sifields._pad",
            "from->_sifields._pad",
            "SI_PAD_SIZE32"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "to",
            "from",
            "3*sizeof(int)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nint copy_siginfo_from_user32(siginfo_t *to, struct compat_siginfo __user *from)\n{\n\tif (copy_from_user(to, from, 3*sizeof(int)) ||\n\t    copy_from_user(to->_sifields._pad,\n\t\t\t   from->_sifields._pad, SI_PAD_SIZE32))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_siginfo_to_user32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "914-972",
    "snippet": "int copy_siginfo_to_user32(struct compat_siginfo __user *d, const siginfo_t *s)\n{\n\tint err;\n\n\tif (!access_ok (VERIFY_WRITE, d, sizeof(*d)))\n\t\treturn -EFAULT;\n\n\t/* If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t * It should never copy any pad contained in the structure\n\t * to avoid security leaks, but must copy the generic\n\t * 3 ints plus the relevant union member.\n\t * This routine must convert siginfo from 64bit to 32bit as well\n\t * at the same time.\n\t */\n\terr = __put_user(s->si_signo, &d->si_signo);\n\terr |= __put_user(s->si_errno, &d->si_errno);\n\terr |= __put_user((short)s->si_code, &d->si_code);\n\tif (s->si_code < 0)\n\t\terr |= __copy_to_user(&d->_sifields._pad, &s->_sifields._pad,\n\t\t\t\t      SI_PAD_SIZE32);\n\telse switch(s->si_code >> 16) {\n\tcase __SI_CHLD >> 16:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\terr |= __put_user(s->si_utime, &d->si_utime);\n\t\terr |= __put_user(s->si_stime, &d->si_stime);\n\t\terr |= __put_user(s->si_status, &d->si_status);\n\t\tbreak;\n\tcase __SI_FAULT >> 16:\n\t\terr |= __put_user((unsigned int)(unsigned long)s->si_addr,\n\t\t\t\t  &d->si_addr);\n\t\tbreak;\n\tcase __SI_POLL >> 16:\n\t\terr |= __put_user(s->si_band, &d->si_band);\n\t\terr |= __put_user(s->si_fd, &d->si_fd);\n\t\tbreak;\n\tcase __SI_TIMER >> 16:\n\t\terr |= __put_user(s->si_tid, &d->si_tid);\n\t\terr |= __put_user(s->si_overrun, &d->si_overrun);\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\tbreak;\n\tcase __SI_SYS >> 16:\n\t\terr |= __put_user(ptr_to_compat(s->si_call_addr), &d->si_call_addr);\n\t\terr |= __put_user(s->si_syscall, &d->si_syscall);\n\t\terr |= __put_user(s->si_arch, &d->si_arch);\n\t\tbreak;\n\tcase __SI_RT >> 16: /* This is not generated by the kernel as of now.  */\n\tcase __SI_MESGQ >> 16:\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\t/* fallthrough */\n\tcase __SI_KILL >> 16:\n\tdefault:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_uid",
            "&d->si_uid"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_pid",
            "&d->si_pid"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_int",
            "&d->si_int"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_arch",
            "&d->si_arch"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_syscall",
            "&d->si_syscall"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ptr_to_compat(s->si_call_addr)",
            "&d->si_call_addr"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "s->si_call_addr"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_int",
            "&d->si_int"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_overrun",
            "&d->si_overrun"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_tid",
            "&d->si_tid"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_fd",
            "&d->si_fd"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_band",
            "&d->si_band"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(unsigned int)(unsigned long)s->si_addr",
            "&d->si_addr"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_status",
            "&d->si_status"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_stime",
            "&d->si_stime"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_utime",
            "&d->si_utime"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_uid",
            "&d->si_uid"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_pid",
            "&d->si_pid"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&d->_sifields._pad",
            "&s->_sifields._pad",
            "SI_PAD_SIZE32"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(short)s->si_code",
            "&d->si_code"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_errno",
            "&d->si_errno"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "s->si_signo",
            "&d->si_signo"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "d",
            "sizeof(*d)"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nint copy_siginfo_to_user32(struct compat_siginfo __user *d, const siginfo_t *s)\n{\n\tint err;\n\n\tif (!access_ok (VERIFY_WRITE, d, sizeof(*d)))\n\t\treturn -EFAULT;\n\n\t/* If you change siginfo_t structure, please be sure\n\t * this code is fixed accordingly.\n\t * It should never copy any pad contained in the structure\n\t * to avoid security leaks, but must copy the generic\n\t * 3 ints plus the relevant union member.\n\t * This routine must convert siginfo from 64bit to 32bit as well\n\t * at the same time.\n\t */\n\terr = __put_user(s->si_signo, &d->si_signo);\n\terr |= __put_user(s->si_errno, &d->si_errno);\n\terr |= __put_user((short)s->si_code, &d->si_code);\n\tif (s->si_code < 0)\n\t\terr |= __copy_to_user(&d->_sifields._pad, &s->_sifields._pad,\n\t\t\t\t      SI_PAD_SIZE32);\n\telse switch(s->si_code >> 16) {\n\tcase __SI_CHLD >> 16:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\terr |= __put_user(s->si_utime, &d->si_utime);\n\t\terr |= __put_user(s->si_stime, &d->si_stime);\n\t\terr |= __put_user(s->si_status, &d->si_status);\n\t\tbreak;\n\tcase __SI_FAULT >> 16:\n\t\terr |= __put_user((unsigned int)(unsigned long)s->si_addr,\n\t\t\t\t  &d->si_addr);\n\t\tbreak;\n\tcase __SI_POLL >> 16:\n\t\terr |= __put_user(s->si_band, &d->si_band);\n\t\terr |= __put_user(s->si_fd, &d->si_fd);\n\t\tbreak;\n\tcase __SI_TIMER >> 16:\n\t\terr |= __put_user(s->si_tid, &d->si_tid);\n\t\terr |= __put_user(s->si_overrun, &d->si_overrun);\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\tbreak;\n\tcase __SI_SYS >> 16:\n\t\terr |= __put_user(ptr_to_compat(s->si_call_addr), &d->si_call_addr);\n\t\terr |= __put_user(s->si_syscall, &d->si_syscall);\n\t\terr |= __put_user(s->si_arch, &d->si_arch);\n\t\tbreak;\n\tcase __SI_RT >> 16: /* This is not generated by the kernel as of now.  */\n\tcase __SI_MESGQ >> 16:\n\t\terr |= __put_user(s->si_int, &d->si_int);\n\t\t/* fallthrough */\n\tcase __SI_KILL >> 16:\n\tdefault:\n\t\terr |= __put_user(s->si_pid, &d->si_pid);\n\t\terr |= __put_user(s->si_uid, &d->si_uid);\n\t\tbreak;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "restore_tm_user_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "772-910",
    "snippet": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\t/* Pull in the MSR TM bits from the user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ELF_NVRREG\tELF_NVRREG32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_load_up_transact_altivec",
          "args": [
            "&current->thread"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_load_up_transact_fpu",
          "args": [
            "&current->thread"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&current->thread",
            "msr"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "622-642",
          "snippet": "void tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_RESV",
          "args": [
            "msr_hi"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr_hi",
            "&tm_sr->mc_gregs[PT_MSR]"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.spefscr",
            "(u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "current->thread.evr",
            "0",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "current->thread.evr",
            "&sr->mc_vregs",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_transact_vsx_from_user",
          "args": [
            "current",
            "&tm_sr->mc_vsregs"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "copy_transact_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "358-369",
          "snippet": "unsigned long copy_transact_vsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_transact_vsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_from_user",
          "args": [
            "current",
            "&sr->mc_vsregs"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "304-315",
          "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_transact_fpr_from_user",
          "args": [
            "current",
            "&tm_sr->mc_fregs"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "copy_transact_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "394-399",
          "snippet": "inline unsigned long copy_transact_fpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.transact_fp.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_transact_fpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.transact_fp.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_from_user",
          "args": [
            "current",
            "&sr->mc_fregs"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "379-384",
          "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_VRSAVE",
            "current->thread.vrsave"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.transact_vrsave",
            "(u32 __user *)&tm_sr->mc_vregs[32]"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&sr->mc_vregs[32]"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.transact_vr",
            "&tm_sr->mc_vregs",
            "sizeof(sr->mc_vregs)"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.vr_state",
            "&sr->mc_vregs",
            "sizeof(sr->mc_vregs)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_lazy_cpu_state",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "discard_lazy_cpu_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "284-302",
          "snippet": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&sr->mc_gregs[PT_MSR]"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.tm_tfhar",
            "&sr->mc_gregs[PT_NIP]"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_general_regs",
          "args": [
            "&current->thread.ckpt_regs",
            "sr"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "restore_general_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "191-203",
          "snippet": "static inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\t/* Pull in the MSR TM bits from the user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&current->thread);\n\t\tregs->msr |= (MSR_FP | current->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&current->thread);\n\t\tregs->msr |= MSR_VEC;\n\t}\n#endif\n\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_user_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "662-764",
    "snippet": "static long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tregs->trap = 0;\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ELF_NVRREG\tELF_NVRREG32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.spefscr",
            "(u32 __user *)&sr->mc_vregs + ELF_NEVRREG"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "current->thread.evr",
            "0",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "current->thread.evr",
            "&sr->mc_vregs",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_vsx_from_user",
          "args": [
            "current",
            "&sr->mc_vsregs"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "304-315",
          "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_fpr_from_user",
          "args": [
            "current",
            "&sr->mc_fregs"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "379-384",
          "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_VRSAVE",
            "current->thread.vrsave"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&sr->mc_vregs[32]"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&current->thread.vr_state",
            "&sr->mc_vregs",
            "sizeof(sr->mc_vregs)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "discard_lazy_cpu_state",
          "args": [],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "discard_lazy_cpu_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "284-302",
          "snippet": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "msr",
            "&sr->mc_gregs[PT_MSR]"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_general_regs",
          "args": [
            "regs",
            "sr"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "restore_general_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "191-203",
          "snippet": "static inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic long restore_user_regs(struct pt_regs *regs,\n\t\t\t      struct mcontext __user *sr, int sig)\n{\n\tlong err;\n\tunsigned int save_r2 = 0;\n\tunsigned long msr;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal\n\t */\n\tif (!sig)\n\t\tsave_r2 = (unsigned int)regs->gpr[2];\n\terr = restore_general_regs(regs, sr);\n\tregs->trap = 0;\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (!sig)\n\t\tregs->gpr[2] = (unsigned long) save_r2;\n\tif (err)\n\t\treturn 1;\n\n\t/* if doing signal return, restore the previous little-endian mode */\n\tif (sig)\n\t\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * Force the process to reload the altivec registers from\n\t * current->thread when it next does altivec instructions\n\t */\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr)\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave, (u32 __user *)&sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_from_user(current, &sr->mc_fregs))\n\t\treturn 1;\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Force the process to reload the VSX registers from\n\t * current->thread when it next does VSX instruction.\n\t */\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n#endif /* CONFIG_VSX */\n\t/*\n\t * force the process to reload the FP registers from\n\t * current->thread when it next does FP instructions\n\t */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\n#ifdef CONFIG_SPE\n\t/* force the process to reload the spe registers from\n\t   current->thread when it next does spe instructions */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\t/* restore spe registers from the stack */\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "save_tm_user_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "515-655",
    "snippet": "static int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.transact_vr,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.transact_vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_transact_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_transact_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define tramp\tmc_pad",
      "#define ELF_NVRREG\tELF_NVRREG32",
      "#define mcontext\tmcontext32",
      "#define sigcontext\tsigcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long) &frame->tramp[0]",
            "(unsigned long) &frame->tramp[2]"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0x44000002UL",
            "&frame->tramp[1]"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0x38000000UL + sigret",
            "&frame->tramp[0]"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&frame->mc_gregs[PT_MSR]"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.spefscr",
            "(u32 __user *)&frame->mc_vregs + ELF_NEVRREG"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_vregs",
            "current->thread.evr",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "current"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "263-276",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_to_user",
          "args": [
            "&tm_frame->mc_vsregs",
            "current"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "292-302",
          "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_transact_vsx_to_user",
          "args": [
            "&tm_frame->mc_vsregs",
            "current"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "copy_transact_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "346-356",
          "snippet": "unsigned long copy_transact_vsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_transact_vsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__giveup_vsx",
          "args": [
            "current"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_fpr_to_user",
          "args": [
            "&tm_frame->mc_fregs",
            "current"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "372-377",
          "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_transact_fpr_to_user",
          "args": [
            "&tm_frame->mc_fregs",
            "current"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "copy_transact_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "387-392",
          "snippet": "inline unsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.transact_fp.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.transact_fp.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&tm_frame->mc_vregs[32]"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.transact_vrsave",
            "(u32 __user *)&tm_frame->mc_vregs[32]"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&frame->mc_vregs[32]"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_VRSAVE"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&tm_frame->mc_vregs",
            "&current->thread.vr_state",
            "ELF_NVRREG * sizeof(vector128)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&tm_frame->mc_vregs",
            "&current->thread.transact_vr",
            "ELF_NVRREG * sizeof(vector128)"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_vregs",
            "&current->thread.vr_state",
            "ELF_NVRREG * sizeof(vector128)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "current"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(msr >> 32)",
            "&tm_frame->mc_gregs[PT_MSR]"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_general_regs",
          "args": [
            "regs",
            "tm_frame"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "save_general_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "184-189",
          "snippet": "static inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "current"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n#define sigcontext\tsigcontext32\n\nstatic int save_tm_user_regs(struct pt_regs *regs,\n\t\t\t     struct mcontext __user *frame,\n\t\t\t     struct mcontext __user *tm_frame, int sigret)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Remove TM bits from thread's MSR.  The MSR in the sigcontext\n\t * just indicates to userland that we were doing a transaction, but we\n\t * don't want to return in transactional state.  This also ensures\n\t * that flush_fp_to_thread won't set TIF_RESTORE_TM again.\n\t */\n\tregs->msr &= ~MSR_TS_MASK;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* Save both sets of general registers */\n\tif (save_general_regs(&current->thread.ckpt_regs, frame)\n\t    || save_general_regs(regs, tm_frame))\n\t\treturn 1;\n\n\t/* Stash the top half of the 64bit MSR into the 32bit MSR word\n\t * of the transactional mcontext.  This way we have a backward-compatible\n\t * MSR in the 'normal' (checkpointed) mcontext and additionally one can\n\t * also look at what type of transaction (T or S) was active at the\n\t * time of the signal.\n\t */\n\tif (__put_user((msr >> 32), &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VEC) {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.transact_vr,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (__copy_to_user(&tm_frame->mc_vregs,\n\t\t\t\t\t   &current->thread.vr_state,\n\t\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data\n\t\t */\n\t\tmsr |= MSR_VEC;\n\t}\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave,\n\t\t       (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n\tif (msr & MSR_VEC) {\n\t\tif (__put_user(current->thread.transact_vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t} else {\n\t\tif (__put_user(current->thread.vrsave,\n\t\t\t       (u32 __user *)&tm_frame->mc_vregs[32]))\n\t\t\treturn 1;\n\t}\n#endif /* CONFIG_ALTIVEC */\n\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\tif (msr & MSR_FP) {\n\t\tif (copy_transact_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t} else {\n\t\tif (copy_fpr_to_user(&tm_frame->mc_fregs, current))\n\t\t\treturn 1;\n\t}\n\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tif (msr & MSR_VSX) {\n\t\t\tif (copy_transact_vsx_to_user(&tm_frame->mc_vsregs,\n\t\t\t\t\t\t      current))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (copy_vsx_to_user(&tm_frame->mc_vsregs, current))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in save_user_regs().\n\t */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t * frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "save_user_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "408-503",
    "snippet": "static int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define tramp\tmc_pad",
      "#define ELF_NVRREG\tELF_NVRREG32",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "(unsigned long) &frame->tramp[0]",
            "(unsigned long) &frame->tramp[2]"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0x44000002UL",
            "&frame->tramp[1]"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0x38000000UL + sigret",
            "&frame->tramp[0]"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "0",
            "&tm_frame->mc_gregs[PT_MSR]"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "msr",
            "&frame->mc_gregs[PT_MSR]"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.spefscr",
            "(u32 __user *)&frame->mc_vregs + ELF_NEVRREG"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_vregs",
            "current->thread.evr",
            "ELF_NEVRREG * sizeof(u32)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "current"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "263-276",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_vsx_to_user",
          "args": [
            "&frame->mc_vsregs",
            "current"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "copy_vsx_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "292-302",
          "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__giveup_vsx",
          "args": [
            "current"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_fpr_to_user",
          "args": [
            "&frame->mc_fregs",
            "current"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fpr_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "372-377",
          "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "current->thread.vrsave",
            "(u32 __user *)&frame->mc_vregs[32]"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_VRSAVE"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_ALTIVEC"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_vregs",
            "&current->thread.vr_state",
            "ELF_NVRREG * sizeof(vector128)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "current"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_general_regs",
          "args": [
            "regs",
            "frame"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "save_general_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
          "lines": "184-189",
          "snippet": "static inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}",
          "includes": [
            "#include \"signal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/ucontext.h>",
            "#include <asm/unistd.h>",
            "#include \"ppc32.h\"",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/vdso.h>",
            "#include <asm/sigcontext.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/stddef.h>",
            "#include <linux/unistd.h>",
            "#include <linux/wait.h>",
            "#include <linux/compat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/elf.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
            "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
            "#define mcontext\tmcontext32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "current"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define tramp\tmc_pad\n#define ELF_NVRREG\tELF_NVRREG32\n#define mcontext\tmcontext32\n\nstatic int save_user_regs(struct pt_regs *regs, struct mcontext __user *frame,\n\t\t\t  struct mcontext __user *tm_frame, int sigret,\n\t\t\t  int ctx_has_vsx_region)\n{\n\tunsigned long msr = regs->msr;\n\n\t/* Make sure floating point registers are stored in regs */\n\tflush_fp_to_thread(current);\n\n\t/* save general registers */\n\tif (save_general_regs(regs, frame))\n\t\treturn 1;\n\n#ifdef CONFIG_ALTIVEC\n\t/* save altivec registers */\n\tif (current->thread.used_vr) {\n\t\tflush_altivec_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, &current->thread.vr_state,\n\t\t\t\t   ELF_NVRREG * sizeof(vector128)))\n\t\t\treturn 1;\n\t\t/* set MSR_VEC in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_VEC;\n\t}\n\t/* else assert((regs->msr & MSR_VEC) == 0) */\n\n\t/* We always copy to/from vrsave, it's 0 if we don't have or don't\n\t * use altivec. Since VSCR only contains 32 bits saved in the least\n\t * significant bits of a vector, we \"cheat\" and stuff VRSAVE in the\n\t * most significant bits of that same vector. --BenH\n\t * Note that the current VRSAVE value is in the SPR at this point.\n\t */\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tcurrent->thread.vrsave = mfspr(SPRN_VRSAVE);\n\tif (__put_user(current->thread.vrsave, (u32 __user *)&frame->mc_vregs[32]))\n\t\treturn 1;\n#endif /* CONFIG_ALTIVEC */\n\tif (copy_fpr_to_user(&frame->mc_fregs, current))\n\t\treturn 1;\n\n\t/*\n\t * Clear the MSR VSX bit to indicate there is no valid state attached\n\t * to this context, except in the specific case below where we set it.\n\t */\n\tmsr &= ~MSR_VSX;\n#ifdef CONFIG_VSX\n\t/*\n\t * Copy VSR 0-31 upper half from thread_struct to local\n\t * buffer, then write that to userspace.  Also set MSR_VSX in\n\t * the saved MSR value to indicate that frame->mc_vregs\n\t * contains valid data\n\t */\n\tif (current->thread.used_vsr && ctx_has_vsx_region) {\n\t\t__giveup_vsx(current);\n\t\tif (copy_vsx_to_user(&frame->mc_vsregs, current))\n\t\t\treturn 1;\n\t\tmsr |= MSR_VSX;\n\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* save spe registers */\n\tif (current->thread.used_spe) {\n\t\tflush_spe_to_thread(current);\n\t\tif (__copy_to_user(&frame->mc_vregs, current->thread.evr,\n\t\t\t\t   ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t\t/* set MSR_SPE in the saved MSR value to indicate that\n\t\t   frame->mc_vregs contains valid data */\n\t\tmsr |= MSR_SPE;\n\t}\n\t/* else assert((regs->msr & MSR_SPE) == 0) */\n\n\t/* We always copy to/from spefscr */\n\tif (__put_user(current->thread.spefscr, (u32 __user *)&frame->mc_vregs + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\n\tif (__put_user(msr, &frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* We need to write 0 the MSR top 32 bits in the tm frame so that we\n\t * can check it on the restore to see if TM is active\n\t */\n\tif (tm_frame && __put_user(0, &tm_frame->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\n\tif (sigret) {\n\t\t/* Set up the sigreturn trampoline: li r0,sigret; sc */\n\t\tif (__put_user(0x38000000UL + sigret, &frame->tramp[0])\n\t\t    || __put_user(0x44000002UL, &frame->tramp[1]))\n\t\t\treturn 1;\n\t\tflush_icache_range((unsigned long) &frame->tramp[0],\n\t\t\t\t   (unsigned long) &frame->tramp[2]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_transact_fpr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "394-399",
    "snippet": "inline unsigned long copy_transact_fpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.transact_fp.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "task->thread.transact_fp.fpr",
            "from",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_transact_fpr_from_user(struct task_struct *task,\n\t\t\t\t\t\t void __user *from)\n{\n\treturn __copy_from_user(task->thread.transact_fp.fpr, from,\n\t\t\t\tELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_transact_fpr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "387-392",
    "snippet": "inline unsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.transact_fp.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "task->thread.transact_fp.fpr",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t\t struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.transact_fp.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_fpr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "379-384",
    "snippet": "inline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "task->thread.fp_state.fpr",
            "from",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t\tvoid __user *from)\n{\n\treturn __copy_from_user(task->thread.fp_state.fpr, from,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_fpr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "372-377",
    "snippet": "inline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "task->thread.fp_state.fpr",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\ninline unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t\t      struct task_struct *task)\n{\n\treturn __copy_to_user(to, task->thread.fp_state.fpr,\n\t\t\t      ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_transact_vsx_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "358-369",
    "snippet": "unsigned long copy_transact_vsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buf",
            "from",
            "ELF_NVSRHALFREG * sizeof(double)"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_transact_vsx_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_transact_vsx_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "346-356",
    "snippet": "unsigned long copy_transact_vsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "buf",
            "ELF_NVSRHALFREG * sizeof(double)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_transact_vsx_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_transact_fpr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "331-344",
    "snippet": "unsigned long copy_transact_fpr_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NFPREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\ttask->thread.TS_TRANS_FPR(i) = buf[i];\n\ttask->thread.transact_fp.fpscr = buf[i];\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task->thread.TS_TRANS_FPR",
          "args": [
            "i"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buf",
            "from",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_transact_fpr_from_user(struct task_struct *task,\n\t\t\t\t\t  void __user *from)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NFPREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\ttask->thread.TS_TRANS_FPR(i) = buf[i];\n\ttask->thread.transact_fp.fpscr = buf[i];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_transact_fpr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "318-329",
    "snippet": "unsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_TRANS_FPR(i);\n\tbuf[i] = task->thread.transact_fp.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "buf",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task->thread.TS_TRANS_FPR",
          "args": [
            "i"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_transact_fpr_to_user(void __user *to,\n\t\t\t\t  struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_TRANS_FPR(i);\n\tbuf[i] = task->thread.transact_fp.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_vsx_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "304-315",
    "snippet": "unsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buf",
            "from",
            "ELF_NVSRHALFREG * sizeof(double)"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NVSRHALFREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < ELF_NVSRHALFREG ; i++)\n\t\ttask->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_vsx_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "292-302",
    "snippet": "unsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "buf",
            "ELF_NVSRHALFREG * sizeof(double)"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_vsx_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NVSRHALFREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < ELF_NVSRHALFREG; i++)\n\t\tbuf[i] = task->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\treturn __copy_to_user(to, buf, ELF_NVSRHALFREG * sizeof(double));\n}"
  },
  {
    "function_name": "copy_fpr_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "277-290",
    "snippet": "unsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NFPREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\ttask->thread.TS_FPR(i) = buf[i];\n\ttask->thread.fp_state.fpscr = buf[i];\n\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "buf",
            "from",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_fpr_from_user(struct task_struct *task,\n\t\t\t\t void __user *from)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\tif (__copy_from_user(buf, from, ELF_NFPREG * sizeof(double)))\n\t\treturn 1;\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\ttask->thread.TS_FPR(i) = buf[i];\n\ttask->thread.fp_state.fpscr = buf[i];\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_fpr_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "264-275",
    "snippet": "unsigned long copy_fpr_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_FPR(i);\n\tbuf[i] = task->thread.fp_state.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "to",
            "buf",
            "ELF_NFPREG * sizeof(double)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task->thread.TS_FPR",
          "args": [
            "i"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nunsigned long copy_fpr_to_user(void __user *to,\n\t\t\t       struct task_struct *task)\n{\n\tu64 buf[ELF_NFPREG];\n\tint i;\n\n\t/* save FPR copy to local buffer then write to the thread_struct */\n\tfor (i = 0; i < (ELF_NFPREG - 1) ; i++)\n\t\tbuf[i] = task->thread.TS_FPR(i);\n\tbuf[i] = task->thread.fp_state.fpscr;\n\treturn __copy_to_user(to, buf, ELF_NFPREG * sizeof(double));\n}"
  },
  {
    "function_name": "restore_general_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "191-203",
    "snippet": "static inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "&regs->orig_gpr3",
            "&sr->mc_gregs[PT_ORIG_R3]",
            "GP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "regs",
            "&sr->mc_gregs",
            "PT_MSR * sizeof(elf_greg_t)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\t/* copy up to but not including MSR */\n\tif (__copy_from_user(regs, &sr->mc_gregs,\n\t\t\t\tPT_MSR * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\t/* copy from orig_r3 (the word after the MSR) up to the end */\n\tif (__copy_from_user(&regs->orig_gpr3, &sr->mc_gregs[PT_ORIG_R3],\n\t\t\t\tGP_REGS_SIZE - PT_ORIG_R3 * sizeof(elf_greg_t)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "save_general_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "184-189",
    "snippet": "static inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))",
      "#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))",
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "&frame->mc_gregs",
            "regs",
            "GP_REGS_SIZE"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t), sizeof(struct pt_regs))\n#define GP_REGS_SIZE\tmin(sizeof(elf_gregset_t32), sizeof(struct pt_regs32))\n#define mcontext\tmcontext32\n\nstatic inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\tWARN_ON(!FULL_REGS(regs));\n\treturn __copy_to_user(&frame->mc_gregs, regs, GP_REGS_SIZE);\n}"
  },
  {
    "function_name": "get_sigset_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "176-179",
    "snippet": "static inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "set",
            "uset",
            "sizeof(*uset)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int get_sigset_t(sigset_t *set, const sigset_t __user *uset)\n{\n\treturn copy_from_user(set, uset, sizeof(*uset));\n}"
  },
  {
    "function_name": "put_sigset_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "171-174",
    "snippet": "static inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uset",
            "set",
            "sizeof(*uset)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int put_sigset_t(sigset_t __user *uset, sigset_t *set)\n{\n\treturn copy_to_user(uset, set, sizeof(*uset));\n}"
  },
  {
    "function_name": "restore_general_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "152-165",
    "snippet": "static inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\telf_greg_t64 *gregs = (elf_greg_t64 *)regs;\n\tint i;\n\n\tfor (i = 0; i <= PT_RESULT; i++) {\n\t\tif ((i == PT_MSR) || (i == PT_SOFTE))\n\t\t\tcontinue;\n\t\tif (__get_user(gregs[i], &sr->mc_gregs[i]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "gregs[i]",
            "&sr->mc_gregs[i]"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define mcontext\tmcontext32\n\nstatic inline int restore_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *sr)\n{\n\telf_greg_t64 *gregs = (elf_greg_t64 *)regs;\n\tint i;\n\n\tfor (i = 0; i <= PT_RESULT; i++) {\n\t\tif ((i == PT_MSR) || (i == PT_SOFTE))\n\t\t\tcontinue;\n\t\tif (__get_user(gregs[i], &sr->mc_gregs[i]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "save_general_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "135-150",
    "snippet": "static inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\telf_greg_t64 *gregs = (elf_greg_t64 *)regs;\n\tint i;\n\n\tWARN_ON(!FULL_REGS(regs));\n\n\tfor (i = 0; i <= PT_RESULT; i ++) {\n\t\tif (i == 14 && !FULL_REGS(regs))\n\t\t\ti = 32;\n\t\tif (__put_user((unsigned int)gregs[i], &frame->mc_gregs[i]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define mcontext\tmcontext32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(unsigned int)gregs[i]",
            "&frame->mc_gregs[i]"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!FULL_REGS(regs)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\n#define mcontext\tmcontext32\n\nstatic inline int save_general_regs(struct pt_regs *regs,\n\t\tstruct mcontext __user *frame)\n{\n\telf_greg_t64 *gregs = (elf_greg_t64 *)regs;\n\tint i;\n\n\tWARN_ON(!FULL_REGS(regs));\n\n\tfor (i = 0; i <= PT_RESULT; i ++) {\n\t\tif (i == 14 && !FULL_REGS(regs))\n\t\t\ti = 32;\n\t\tif (__put_user((unsigned int)gregs[i], &frame->mc_gregs[i]))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_sigset_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "111-130",
    "snippet": "static inline int get_sigset_t(sigset_t *set,\n\t\t\t       const compat_sigset_t __user *uset)\n{\n\tcompat_sigset_t s32;\n\n\tif (copy_from_user(&s32, uset, sizeof(*uset)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Swap the 2 words of the 64-bit sigset_t (they are stored\n\t * in the \"wrong\" endian in 32-bit user storage).\n\t */\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = s32.sig[6] | (((long)s32.sig[7]) << 32);\n\tcase 3: set->sig[2] = s32.sig[4] | (((long)s32.sig[5]) << 32);\n\tcase 2: set->sig[1] = s32.sig[2] | (((long)s32.sig[3]) << 32);\n\tcase 1: set->sig[0] = s32.sig[0] | (((long)s32.sig[1]) << 32);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&s32",
            "uset",
            "sizeof(*uset)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int get_sigset_t(sigset_t *set,\n\t\t\t       const compat_sigset_t __user *uset)\n{\n\tcompat_sigset_t s32;\n\n\tif (copy_from_user(&s32, uset, sizeof(*uset)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * Swap the 2 words of the 64-bit sigset_t (they are stored\n\t * in the \"wrong\" endian in 32-bit user storage).\n\t */\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = s32.sig[6] | (((long)s32.sig[7]) << 32);\n\tcase 3: set->sig[2] = s32.sig[4] | (((long)s32.sig[5]) << 32);\n\tcase 2: set->sig[1] = s32.sig[2] | (((long)s32.sig[3]) << 32);\n\tcase 1: set->sig[0] = s32.sig[0] | (((long)s32.sig[1]) << 32);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "put_sigset_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/signal_32.c",
    "lines": "94-109",
    "snippet": "static inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)\n{\n\tcompat_sigset_t\tcset;\n\n\tswitch (_NSIG_WORDS) {\n\tcase 4: cset.sig[6] = set->sig[3] & 0xffffffffull;\n\t\tcset.sig[7] = set->sig[3] >> 32;\n\tcase 3: cset.sig[4] = set->sig[2] & 0xffffffffull;\n\t\tcset.sig[5] = set->sig[2] >> 32;\n\tcase 2: cset.sig[2] = set->sig[1] & 0xffffffffull;\n\t\tcset.sig[3] = set->sig[1] >> 32;\n\tcase 1: cset.sig[0] = set->sig[0] & 0xffffffffull;\n\t\tcset.sig[1] = set->sig[0] >> 32;\n\t}\n\treturn copy_to_user(uset, &cset, sizeof(*uset));\n}",
    "includes": [
      "#include \"signal.h\"",
      "#include <asm/pgtable.h>",
      "#include <asm/ucontext.h>",
      "#include <asm/unistd.h>",
      "#include \"ppc32.h\"",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/vdso.h>",
      "#include <asm/sigcontext.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/cacheflush.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/stddef.h>",
      "#include <linux/unistd.h>",
      "#include <linux/wait.h>",
      "#include <linux/compat.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/elf.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/kernel.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uset",
            "&cset",
            "sizeof(*uset)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"signal.h\"\n#include <asm/pgtable.h>\n#include <asm/ucontext.h>\n#include <asm/unistd.h>\n#include \"ppc32.h\"\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/vdso.h>\n#include <asm/sigcontext.h>\n#include <asm/syscalls.h>\n#include <asm/cacheflush.h>\n#include <asm/uaccess.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/stddef.h>\n#include <linux/unistd.h>\n#include <linux/wait.h>\n#include <linux/compat.h>\n#include <linux/syscalls.h>\n#include <linux/ratelimit.h>\n#include <linux/ptrace.h>\n#include <linux/elf.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n\nstatic inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)\n{\n\tcompat_sigset_t\tcset;\n\n\tswitch (_NSIG_WORDS) {\n\tcase 4: cset.sig[6] = set->sig[3] & 0xffffffffull;\n\t\tcset.sig[7] = set->sig[3] >> 32;\n\tcase 3: cset.sig[4] = set->sig[2] & 0xffffffffull;\n\t\tcset.sig[5] = set->sig[2] >> 32;\n\tcase 2: cset.sig[2] = set->sig[1] & 0xffffffffull;\n\t\tcset.sig[3] = set->sig[1] >> 32;\n\tcase 1: cset.sig[0] = set->sig[0] & 0xffffffffull;\n\t\tcset.sig[1] = set->sig[0] >> 32;\n\t}\n\treturn copy_to_user(uset, &cset, sizeof(*uset));\n}"
  }
]