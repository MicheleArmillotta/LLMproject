[
  {
    "function_name": "default_machine_kexec_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_32.c",
    "lines": "66-69",
    "snippet": "int default_machine_kexec_prepare(struct kimage *image)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/io.h>\n#include <asm/hw_irq.h>\n#include <asm/cacheflush.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kexec.h>\n\nint default_machine_kexec_prepare(struct kimage *image)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "default_machine_kexec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec_32.c",
    "lines": "31-64",
    "snippet": "void default_machine_kexec(struct kimage *image)\n{\n\textern const unsigned char relocate_new_kernel[];\n\textern const unsigned int relocate_new_kernel_size;\n\tunsigned long page_list;\n\tunsigned long reboot_code_buffer, reboot_code_buffer_phys;\n\trelocate_new_kernel_t rnk;\n\n\t/* Interrupts aren't acceptable while we reboot */\n\tlocal_irq_disable();\n\n\t/* mask each interrupt so we are in a more sane state for the\n\t * kexec kernel */\n\tmachine_kexec_mask_interrupts();\n\n\tpage_list = image->head;\n\n\t/* we need both effective and real address here */\n\treboot_code_buffer =\n\t\t\t(unsigned long)page_address(image->control_code_page);\n\treboot_code_buffer_phys = virt_to_phys((void *)reboot_code_buffer);\n\n\t/* copy our kernel relocation code to the control code page */\n\tmemcpy((void *)reboot_code_buffer, relocate_new_kernel,\n\t\t\t\t\t\trelocate_new_kernel_size);\n\n\tflush_icache_range(reboot_code_buffer,\n\t\t\t\treboot_code_buffer + KEXEC_CONTROL_PAGE_SIZE);\n\tprintk(KERN_INFO \"Bye!\\n\");\n\n\t/* now call it */\n\trnk = (relocate_new_kernel_t) reboot_code_buffer;\n\t(*rnk)(page_list, reboot_code_buffer_phys, image->start);\n}",
    "includes": [
      "#include <asm/io.h>",
      "#include <asm/hw_irq.h>",
      "#include <asm/cacheflush.h>",
      "#include <linux/string.h>",
      "#include <linux/mm.h>",
      "#include <linux/kexec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "page_list",
            "reboot_code_buffer_phys",
            "image->start"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Bye!\\n\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "reboot_code_buffer",
            "reboot_code_buffer + KEXEC_CONTROL_PAGE_SIZE"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *)reboot_code_buffer",
            "relocate_new_kernel",
            "relocate_new_kernel_size"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_phys",
          "args": [
            "(void *)reboot_code_buffer"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "image->control_code_page"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_kexec_mask_interrupts",
          "args": [],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "machine_kexec_mask_interrupts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "25-45",
          "snippet": "void machine_kexec_mask_interrupts(void) {\n\tunsigned int i;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\tstruct irq_chip *chip;\n\n\t\tchip = irq_desc_get_chip(desc);\n\t\tif (!chip)\n\t\t\tcontinue;\n\n\t\tif (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))\n\t\t\tchip->irq_eoi(&desc->irq_data);\n\n\t\tif (chip->irq_mask)\n\t\t\tchip->irq_mask(&desc->irq_data);\n\n\t\tif (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))\n\t\t\tchip->irq_disable(&desc->irq_data);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/irq.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/threads.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid machine_kexec_mask_interrupts(void) {\n\tunsigned int i;\n\tstruct irq_desc *desc;\n\n\tfor_each_irq_desc(i, desc) {\n\t\tstruct irq_chip *chip;\n\n\t\tchip = irq_desc_get_chip(desc);\n\t\tif (!chip)\n\t\t\tcontinue;\n\n\t\tif (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))\n\t\t\tchip->irq_eoi(&desc->irq_data);\n\n\t\tif (chip->irq_mask)\n\t\t\tchip->irq_mask(&desc->irq_data);\n\n\t\tif (chip->irq_disable && !irqd_irq_disabled(&desc->irq_data))\n\t\t\tchip->irq_disable(&desc->irq_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/io.h>\n#include <asm/hw_irq.h>\n#include <asm/cacheflush.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kexec.h>\n\nvoid default_machine_kexec(struct kimage *image)\n{\n\textern const unsigned char relocate_new_kernel[];\n\textern const unsigned int relocate_new_kernel_size;\n\tunsigned long page_list;\n\tunsigned long reboot_code_buffer, reboot_code_buffer_phys;\n\trelocate_new_kernel_t rnk;\n\n\t/* Interrupts aren't acceptable while we reboot */\n\tlocal_irq_disable();\n\n\t/* mask each interrupt so we are in a more sane state for the\n\t * kexec kernel */\n\tmachine_kexec_mask_interrupts();\n\n\tpage_list = image->head;\n\n\t/* we need both effective and real address here */\n\treboot_code_buffer =\n\t\t\t(unsigned long)page_address(image->control_code_page);\n\treboot_code_buffer_phys = virt_to_phys((void *)reboot_code_buffer);\n\n\t/* copy our kernel relocation code to the control code page */\n\tmemcpy((void *)reboot_code_buffer, relocate_new_kernel,\n\t\t\t\t\t\trelocate_new_kernel_size);\n\n\tflush_icache_range(reboot_code_buffer,\n\t\t\t\treboot_code_buffer + KEXEC_CONTROL_PAGE_SIZE);\n\tprintk(KERN_INFO \"Bye!\\n\");\n\n\t/* now call it */\n\trnk = (relocate_new_kernel_t) reboot_code_buffer;\n\t(*rnk)(page_list, reboot_code_buffer_phys, image->start);\n}"
  }
]