[
  {
    "function_name": "sys_pciconfig_iobase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "283-306",
    "snippet": "long sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn)\n{\n\tstruct pci_controller* hose;\n\tlong result = -EOPNOTSUPP;\n\n\those = pci_bus_to_hose(bus);\n\tif (!hose)\n\t\treturn -ENODEV;\n\n\tswitch (which) {\n\tcase IOBASE_BRIDGE_NUMBER:\n\t\treturn (long)hose->first_busno;\n\tcase IOBASE_MEMORY:\n\t\treturn (long)hose->mem_offset[0];\n\tcase IOBASE_IO:\n\t\treturn (long)hose->io_base_phys;\n\tcase IOBASE_ISA_IO:\n\t\treturn (long)isa_io_base;\n\tcase IOBASE_ISA_MEM:\n\t\treturn (long)isa_mem_base;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long isa_io_base     = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_bus_to_hose",
          "args": [
            "bus"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "pci_bus_to_hose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "266-275",
          "snippet": "static struct pci_controller*\npci_bus_to_hose(int bus)\n{\n\tstruct pci_controller *hose, *tmp;\n\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tif (bus >= hose->first_busno && bus <= hose->last_busno)\n\t\t\treturn hose;\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/list.h>",
            "#include <linux/irq.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_controller*\npci_bus_to_hose(int bus)\n{\n\tstruct pci_controller *hose, *tmp;\n\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tif (bus >= hose->first_busno && bus <= hose->last_busno)\n\t\t\treturn hose;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nunsigned long isa_io_base     = 0;\n\nlong sys_pciconfig_iobase(long which, unsigned long bus, unsigned long devfn)\n{\n\tstruct pci_controller* hose;\n\tlong result = -EOPNOTSUPP;\n\n\those = pci_bus_to_hose(bus);\n\tif (!hose)\n\t\treturn -ENODEV;\n\n\tswitch (which) {\n\tcase IOBASE_BRIDGE_NUMBER:\n\t\treturn (long)hose->first_busno;\n\tcase IOBASE_MEMORY:\n\t\treturn (long)hose->mem_offset[0];\n\tcase IOBASE_IO:\n\t\treturn (long)hose->io_base_phys;\n\tcase IOBASE_ISA_IO:\n\t\treturn (long)isa_io_base;\n\tcase IOBASE_ISA_MEM:\n\t\treturn (long)isa_mem_base;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "pci_bus_to_hose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "266-275",
    "snippet": "static struct pci_controller*\npci_bus_to_hose(int bus)\n{\n\tstruct pci_controller *hose, *tmp;\n\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tif (bus >= hose->first_busno && bus <= hose->last_busno)\n\t\t\treturn hose;\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic struct pci_controller*\npci_bus_to_hose(int bus)\n{\n\tstruct pci_controller *hose, *tmp;\n\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\tif (bus >= hose->first_busno && bus <= hose->last_busno)\n\t\t\treturn hose;\n\treturn NULL;\n}"
  },
  {
    "function_name": "pcibios_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "225-262",
    "snippet": "static int __init pcibios_init(void)\n{\n\tstruct pci_controller *hose, *tmp;\n\tint next_busno = 0;\n\n\tprintk(KERN_INFO \"PCI: Probing PCI hardware\\n\");\n\n\tif (pci_has_flag(PCI_REASSIGN_ALL_BUS))\n\t\tpci_assign_all_buses = 1;\n\n\t/* Scan all of the recorded PCI controllers.  */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tif (pci_assign_all_buses)\n\t\t\those->first_busno = next_busno;\n\t\those->last_busno = 0xff;\n\t\tpcibios_scan_phb(hose);\n\t\tpci_bus_add_devices(hose->bus);\n\t\tif (pci_assign_all_buses || next_busno <= hose->last_busno)\n\t\t\tnext_busno = hose->last_busno + pcibios_assign_bus_offset;\n\t}\n\tpci_bus_count = next_busno;\n\n\t/* OpenFirmware based machines need a map of OF bus\n\t * numbers vs. kernel bus numbers since we may have to\n\t * remap them.\n\t */\n\tif (pci_assign_all_buses)\n\t\tpcibios_make_OF_bus_map();\n\n\t/* Call common code to handle resource allocation */\n\tpcibios_resource_survey();\n\n\t/* Call machine dependent post-init code */\n\tif (ppc_md.pcibios_after_init)\n\t\tppc_md.pcibios_after_init();\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int pcibios_assign_bus_offset = 1;",
      "void pcibios_make_OF_bus_map(void);",
      "static int pci_assign_all_buses;",
      "static int pci_bus_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_md.pcibios_after_init",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_resource_survey",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_resource_survey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1358-1388",
          "snippet": "void __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tpcibios_allocate_resources(0);\n\tpcibios_allocate_resources(1);\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n\n\t/* Call machine dependent fixup */\n\tif (ppc_md.pcibios_fixup)\n\t\tppc_md.pcibios_fixup();\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __init pcibios_resource_survey(void)\n{\n\tstruct pci_bus *b;\n\n\t/* Allocate and assign resources */\n\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\tpcibios_allocate_bus_resources(b);\n\tpcibios_allocate_resources(0);\n\tpcibios_allocate_resources(1);\n\n\t/* Before we start assigning unassigned resource, we try to reserve\n\t * the low IO area and the VGA memory area if they intersect the\n\t * bus available resources to avoid allocating things on top of them\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tlist_for_each_entry(b, &pci_root_buses, node)\n\t\t\tpcibios_reserve_legacy_regions(b);\n\t}\n\n\t/* Now, if the platform didn't decide to blindly trust the firmware,\n\t * we proceed to assigning things that were left unassigned\n\t */\n\tif (!pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tpr_debug(\"PCI: Assigning unassigned resources...\\n\");\n\t\tpci_assign_unassigned_resources();\n\t}\n\n\t/* Call machine dependent fixup */\n\tif (ppc_md.pcibios_fixup)\n\t\tppc_md.pcibios_fixup();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_make_OF_bus_map",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_make_OF_bus_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "107-150",
          "snippet": "void\npcibios_make_OF_bus_map(void)\n{\n\tint i;\n\tstruct pci_controller *hose, *tmp;\n\tstruct property *map_prop;\n\tstruct device_node *dn;\n\n\tpci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\n\tif (!pci_to_OF_bus_map) {\n\t\tprintk(KERN_ERR \"Can't allocate OF bus map !\\n\");\n\t\treturn;\n\t}\n\n\t/* We fill the bus map with invalid values, that helps\n\t * debugging.\n\t */\n\tfor (i=0; i<pci_bus_count; i++)\n\t\tpci_to_OF_bus_map[i] = 0xff;\n\n\t/* For each hose, we begin searching bridges */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tstruct device_node* node = hose->dn;\n\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tmake_one_node_map(node, hose->first_busno);\n\t}\n\tdn = of_find_node_by_path(\"/\");\n\tmap_prop = of_find_property(dn, \"pci-OF-bus-map\", NULL);\n\tif (map_prop) {\n\t\tBUG_ON(pci_bus_count > map_prop->length);\n\t\tmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\n\t}\n\tof_node_put(dn);\n#ifdef DEBUG\n\tprintk(\"PCI->OF bus map:\\n\");\n\tfor (i=0; i<pci_bus_count; i++) {\n\t\tif (pci_to_OF_bus_map[i] == 0xff)\n\t\t\tcontinue;\n\t\tprintk(\"%d -> %d\\n\", i, pci_to_OF_bus_map[i]);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/list.h>",
            "#include <linux/irq.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void pcibios_make_OF_bus_map(void);",
            "static u8* pci_to_OF_bus_map;",
            "static int pci_bus_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_make_OF_bus_map(void);\nstatic u8* pci_to_OF_bus_map;\nstatic int pci_bus_count;\n\nvoid\npcibios_make_OF_bus_map(void)\n{\n\tint i;\n\tstruct pci_controller *hose, *tmp;\n\tstruct property *map_prop;\n\tstruct device_node *dn;\n\n\tpci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\n\tif (!pci_to_OF_bus_map) {\n\t\tprintk(KERN_ERR \"Can't allocate OF bus map !\\n\");\n\t\treturn;\n\t}\n\n\t/* We fill the bus map with invalid values, that helps\n\t * debugging.\n\t */\n\tfor (i=0; i<pci_bus_count; i++)\n\t\tpci_to_OF_bus_map[i] = 0xff;\n\n\t/* For each hose, we begin searching bridges */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tstruct device_node* node = hose->dn;\n\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tmake_one_node_map(node, hose->first_busno);\n\t}\n\tdn = of_find_node_by_path(\"/\");\n\tmap_prop = of_find_property(dn, \"pci-OF-bus-map\", NULL);\n\tif (map_prop) {\n\t\tBUG_ON(pci_bus_count > map_prop->length);\n\t\tmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\n\t}\n\tof_node_put(dn);\n#ifdef DEBUG\n\tprintk(\"PCI->OF bus map:\\n\");\n\tfor (i=0; i<pci_bus_count; i++) {\n\t\tif (pci_to_OF_bus_map[i] == 0xff)\n\t\t\tcontinue;\n\t\tprintk(\"%d -> %d\\n\", i, pci_to_OF_bus_map[i]);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_add_devices",
          "args": [
            "hose->bus"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_scan_phb",
          "args": [
            "hose"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_scan_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1600-1657",
          "snippet": "void pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %s\\n\", of_node_full_name(node));\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %s\\n\", of_node_full_name(node));\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_has_flag",
          "args": [
            "PCI_REASSIGN_ALL_BUS"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"PCI: Probing PCI hardware\\n\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nint pcibios_assign_bus_offset = 1;\nvoid pcibios_make_OF_bus_map(void);\nstatic int pci_assign_all_buses;\nstatic int pci_bus_count;\n\nstatic int __init pcibios_init(void)\n{\n\tstruct pci_controller *hose, *tmp;\n\tint next_busno = 0;\n\n\tprintk(KERN_INFO \"PCI: Probing PCI hardware\\n\");\n\n\tif (pci_has_flag(PCI_REASSIGN_ALL_BUS))\n\t\tpci_assign_all_buses = 1;\n\n\t/* Scan all of the recorded PCI controllers.  */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tif (pci_assign_all_buses)\n\t\t\those->first_busno = next_busno;\n\t\those->last_busno = 0xff;\n\t\tpcibios_scan_phb(hose);\n\t\tpci_bus_add_devices(hose->bus);\n\t\tif (pci_assign_all_buses || next_busno <= hose->last_busno)\n\t\t\tnext_busno = hose->last_busno + pcibios_assign_bus_offset;\n\t}\n\tpci_bus_count = next_busno;\n\n\t/* OpenFirmware based machines need a map of OF bus\n\t * numbers vs. kernel bus numbers since we may have to\n\t * remap them.\n\t */\n\tif (pci_assign_all_buses)\n\t\tpcibios_make_OF_bus_map();\n\n\t/* Call common code to handle resource allocation */\n\tpcibios_resource_survey();\n\n\t/* Call machine dependent post-init code */\n\tif (ppc_md.pcibios_after_init)\n\t\tppc_md.pcibios_after_init();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pcibios_setup_phb_io_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "214-223",
    "snippet": "void pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long io_offset;\n\tstruct resource *res = &hose->io_resource;\n\n\t/* Fixup IO space offset */\n\tio_offset = pcibios_io_space_offset(hose);\n\tres->start += io_offset;\n\tres->end += io_offset;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcibios_io_space_offset",
          "args": [
            "hose"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_io_space_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1472-1475",
          "snippet": "resource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t pcibios_io_space_offset(struct pci_controller *hose)\n{\n\treturn (unsigned long) hose->io_base_virt - _IO_BASE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_setup_phb_io_space(struct pci_controller *hose)\n{\n\tunsigned long io_offset;\n\tstruct resource *res = &hose->io_resource;\n\n\t/* Fixup IO space offset */\n\tio_offset = pcibios_io_space_offset(hose);\n\tres->start += io_offset;\n\tres->end += io_offset;\n}"
  },
  {
    "function_name": "pci_create_OF_bus_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "196-212",
    "snippet": "void __init\npci_create_OF_bus_map(void)\n{\n\tstruct property* of_prop;\n\tstruct device_node *dn;\n\n\tof_prop = memblock_virt_alloc(sizeof(struct property) + 256, 0);\n\tdn = of_find_node_by_path(\"/\");\n\tif (dn) {\n\t\tmemset(of_prop, -1, sizeof(struct property) + 256);\n\t\tof_prop->name = \"pci-OF-bus-map\";\n\t\tof_prop->length = 256;\n\t\tof_prop->value = &of_prop[1];\n\t\tof_add_property(dn, of_prop);\n\t\tof_node_put(dn);\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "dn"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_add_property",
          "args": [
            "dn",
            "of_prop"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "of_prop",
            "-1",
            "sizeof(struct property) + 256"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "\"/\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_virt_alloc",
          "args": [
            "sizeof(struct property) + 256",
            "0"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid __init\npci_create_OF_bus_map(void)\n{\n\tstruct property* of_prop;\n\tstruct device_node *dn;\n\n\tof_prop = memblock_virt_alloc(sizeof(struct property) + 256, 0);\n\tdn = of_find_node_by_path(\"/\");\n\tif (dn) {\n\t\tmemset(of_prop, -1, sizeof(struct property) + 256);\n\t\tof_prop->name = \"pci-OF-bus-map\";\n\t\tof_prop->length = 256;\n\t\tof_prop->value = &of_prop[1];\n\t\tof_add_property(dn, of_prop);\n\t\tof_node_put(dn);\n\t}\n}"
  },
  {
    "function_name": "pci_device_from_OF_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "156-190",
    "snippet": "int pci_device_from_OF_node(struct device_node *node, u8 *bus, u8 *devfn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint size;\n\n\t/* Check if it might have a chance to be a PCI device */\n\tif (!pci_find_hose_for_OF_device(node))\n\t\treturn -ENODEV;\n\n\treg = of_get_property(node, \"reg\", &size);\n\tif (!reg || size < 5 * sizeof(u32))\n\t\treturn -ENODEV;\n\n\t*bus = (be32_to_cpup(&reg[0]) >> 16) & 0xff;\n\t*devfn = (be32_to_cpup(&reg[0]) >> 8) & 0xff;\n\n\t/* Ok, here we need some tweak. If we have already renumbered\n\t * all busses, we can't rely on the OF bus number any more.\n\t * the pci_to_OF_bus_map is not enough as several PCI busses\n\t * may match the same OF bus number.\n\t */\n\tif (!pci_to_OF_bus_map)\n\t\treturn 0;\n\n\tfor_each_pci_dev(dev)\n\t\tif (pci_to_OF_bus_map[dev->bus->number] == *bus &&\n\t\t\t\tdev->devfn == *devfn) {\n\t\t\t*bus = dev->bus->number;\n\t\t\tpci_dev_put(dev);\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENODEV;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void fixup_cpc710_pci64(struct pci_dev* dev);",
      "static u8* pci_to_OF_bus_map;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "&reg[0]"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "&reg[0]"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"reg\"",
            "&size"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_find_hose_for_OF_device",
          "args": [
            "node"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "pci_find_hose_for_OF_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "218-228",
          "snippet": "struct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstruct pci_controller* pci_find_hose_for_OF_device(struct device_node* node)\n{\n\twhile(node) {\n\t\tstruct pci_controller *hose, *tmp;\n\t\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node)\n\t\t\tif (hose->dn == node)\n\t\t\t\treturn hose;\n\t\tnode = node->parent;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_cpc710_pci64(struct pci_dev* dev);\nstatic u8* pci_to_OF_bus_map;\n\nint pci_device_from_OF_node(struct device_node *node, u8 *bus, u8 *devfn)\n{\n\tstruct pci_dev *dev = NULL;\n\tconst __be32 *reg;\n\tint size;\n\n\t/* Check if it might have a chance to be a PCI device */\n\tif (!pci_find_hose_for_OF_device(node))\n\t\treturn -ENODEV;\n\n\treg = of_get_property(node, \"reg\", &size);\n\tif (!reg || size < 5 * sizeof(u32))\n\t\treturn -ENODEV;\n\n\t*bus = (be32_to_cpup(&reg[0]) >> 16) & 0xff;\n\t*devfn = (be32_to_cpup(&reg[0]) >> 8) & 0xff;\n\n\t/* Ok, here we need some tweak. If we have already renumbered\n\t * all busses, we can't rely on the OF bus number any more.\n\t * the pci_to_OF_bus_map is not enough as several PCI busses\n\t * may match the same OF bus number.\n\t */\n\tif (!pci_to_OF_bus_map)\n\t\treturn 0;\n\n\tfor_each_pci_dev(dev)\n\t\tif (pci_to_OF_bus_map[dev->bus->number] == *bus &&\n\t\t\t\tdev->devfn == *devfn) {\n\t\t\t*bus = dev->bus->number;\n\t\t\tpci_dev_put(dev);\n\t\t\treturn 0;\n\t\t}\n\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "pcibios_make_OF_bus_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "107-150",
    "snippet": "void\npcibios_make_OF_bus_map(void)\n{\n\tint i;\n\tstruct pci_controller *hose, *tmp;\n\tstruct property *map_prop;\n\tstruct device_node *dn;\n\n\tpci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\n\tif (!pci_to_OF_bus_map) {\n\t\tprintk(KERN_ERR \"Can't allocate OF bus map !\\n\");\n\t\treturn;\n\t}\n\n\t/* We fill the bus map with invalid values, that helps\n\t * debugging.\n\t */\n\tfor (i=0; i<pci_bus_count; i++)\n\t\tpci_to_OF_bus_map[i] = 0xff;\n\n\t/* For each hose, we begin searching bridges */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tstruct device_node* node = hose->dn;\n\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tmake_one_node_map(node, hose->first_busno);\n\t}\n\tdn = of_find_node_by_path(\"/\");\n\tmap_prop = of_find_property(dn, \"pci-OF-bus-map\", NULL);\n\tif (map_prop) {\n\t\tBUG_ON(pci_bus_count > map_prop->length);\n\t\tmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\n\t}\n\tof_node_put(dn);\n#ifdef DEBUG\n\tprintk(\"PCI->OF bus map:\\n\");\n\tfor (i=0; i<pci_bus_count; i++) {\n\t\tif (pci_to_OF_bus_map[i] == 0xff)\n\t\t\tcontinue;\n\t\tprintk(\"%d -> %d\\n\", i, pci_to_OF_bus_map[i]);\n\t}\n#endif\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void pcibios_make_OF_bus_map(void);",
      "static u8* pci_to_OF_bus_map;",
      "static int pci_bus_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%d -> %d\\n\"",
            "i",
            "pci_to_OF_bus_map[i]"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"PCI->OF bus map:\\n\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "dn"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "map_prop->value",
            "pci_to_OF_bus_map",
            "pci_bus_count"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pci_bus_count > map_prop->length"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_property",
          "args": [
            "dn",
            "\"pci-OF-bus-map\"",
            "NULL"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_find_node_by_path",
          "args": [
            "\"/\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_one_node_map",
          "args": [
            "node",
            "hose->first_busno"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "make_one_node_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "70-105",
          "snippet": "static void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %s, \"\n\t\t       \"assuming it starts at 0\\n\", node->full_name);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_bus_and_slot(pci_bus, ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}",
          "includes": [
            "#include <asm/machdep.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/of.h>",
            "#include <linux/list.h>",
            "#include <linux/irq.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/delay.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void fixup_cpc710_pci64(struct pci_dev* dev);",
            "static u8* pci_to_OF_bus_map;",
            "static int pci_bus_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_cpc710_pci64(struct pci_dev* dev);\nstatic u8* pci_to_OF_bus_map;\nstatic int pci_bus_count;\n\nstatic void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %s, \"\n\t\t       \"assuming it starts at 0\\n\", node->full_name);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_bus_and_slot(pci_bus, ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "hose",
            "tmp",
            "&hose_list",
            "list_node"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Can't allocate OF bus map !\\n\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "pci_bus_count",
            "GFP_KERNEL"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_make_OF_bus_map(void);\nstatic u8* pci_to_OF_bus_map;\nstatic int pci_bus_count;\n\nvoid\npcibios_make_OF_bus_map(void)\n{\n\tint i;\n\tstruct pci_controller *hose, *tmp;\n\tstruct property *map_prop;\n\tstruct device_node *dn;\n\n\tpci_to_OF_bus_map = kmalloc(pci_bus_count, GFP_KERNEL);\n\tif (!pci_to_OF_bus_map) {\n\t\tprintk(KERN_ERR \"Can't allocate OF bus map !\\n\");\n\t\treturn;\n\t}\n\n\t/* We fill the bus map with invalid values, that helps\n\t * debugging.\n\t */\n\tfor (i=0; i<pci_bus_count; i++)\n\t\tpci_to_OF_bus_map[i] = 0xff;\n\n\t/* For each hose, we begin searching bridges */\n\tlist_for_each_entry_safe(hose, tmp, &hose_list, list_node) {\n\t\tstruct device_node* node = hose->dn;\n\n\t\tif (!node)\n\t\t\tcontinue;\n\t\tmake_one_node_map(node, hose->first_busno);\n\t}\n\tdn = of_find_node_by_path(\"/\");\n\tmap_prop = of_find_property(dn, \"pci-OF-bus-map\", NULL);\n\tif (map_prop) {\n\t\tBUG_ON(pci_bus_count > map_prop->length);\n\t\tmemcpy(map_prop->value, pci_to_OF_bus_map, pci_bus_count);\n\t}\n\tof_node_put(dn);\n#ifdef DEBUG\n\tprintk(\"PCI->OF bus map:\\n\");\n\tfor (i=0; i<pci_bus_count; i++) {\n\t\tif (pci_to_OF_bus_map[i] == 0xff)\n\t\t\tcontinue;\n\t\tprintk(\"%d -> %d\\n\", i, pci_to_OF_bus_map[i]);\n\t}\n#endif\n}"
  },
  {
    "function_name": "make_one_node_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "70-105",
    "snippet": "static void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %s, \"\n\t\t       \"assuming it starts at 0\\n\", node->full_name);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_bus_and_slot(pci_bus, ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void fixup_cpc710_pci64(struct pci_dev* dev);",
      "static u8* pci_to_OF_bus_map;",
      "static int pci_bus_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_one_node_map",
          "args": [
            "node",
            "dev->subordinate->number"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "make_one_node_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
          "lines": "70-105",
          "snippet": "static void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %s, \"\n\t\t       \"assuming it starts at 0\\n\", node->full_name);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_bus_and_slot(pci_bus, ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pci_dev_put",
          "args": [
            "dev"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pci_get_bus_and_slot",
          "args": [
            "pci_bus",
            "((reg[0] >> 8) & 0xff)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"reg\"",
            "NULL"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"class-code\"",
            "NULL"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_child_of_node",
          "args": [
            "node",
            "node"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Can't get bus-range for %s, \"\n\t\t       \"assuming it starts at 0\\n\"",
            "node->full_name"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_get_property",
          "args": [
            "node",
            "\"bus-range\"",
            "&len"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_cpc710_pci64(struct pci_dev* dev);\nstatic u8* pci_to_OF_bus_map;\nstatic int pci_bus_count;\n\nstatic void\nmake_one_node_map(struct device_node* node, u8 pci_bus)\n{\n\tconst int *bus_range;\n\tint len;\n\n\tif (pci_bus >= pci_bus_count)\n\t\treturn;\n\tbus_range = of_get_property(node, \"bus-range\", &len);\n\tif (bus_range == NULL || len < 2 * sizeof(int)) {\n\t\tprintk(KERN_WARNING \"Can't get bus-range for %s, \"\n\t\t       \"assuming it starts at 0\\n\", node->full_name);\n\t\tpci_to_OF_bus_map[pci_bus] = 0;\n\t} else\n\t\tpci_to_OF_bus_map[pci_bus] = bus_range[0];\n\n\tfor_each_child_of_node(node, node) {\n\t\tstruct pci_dev* dev;\n\t\tconst unsigned int *class_code, *reg;\n\t\n\t\tclass_code = of_get_property(node, \"class-code\", NULL);\n\t\tif (!class_code || ((*class_code >> 8) != PCI_CLASS_BRIDGE_PCI &&\n\t\t\t(*class_code >> 8) != PCI_CLASS_BRIDGE_CARDBUS))\n\t\t\tcontinue;\n\t\treg = of_get_property(node, \"reg\", NULL);\n\t\tif (!reg)\n\t\t\tcontinue;\n\t\tdev = pci_get_bus_and_slot(pci_bus, ((reg[0] >> 8) & 0xff));\n\t\tif (!dev || !dev->subordinate) {\n\t\t\tpci_dev_put(dev);\n\t\t\tcontinue;\n\t\t}\n\t\tmake_one_node_map(node, dev->subordinate->number);\n\t\tpci_dev_put(dev);\n\t}\n}"
  },
  {
    "function_name": "fixup_cpc710_pci64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_32.c",
    "lines": "54-64",
    "snippet": "static void\nfixup_cpc710_pci64(struct pci_dev* dev)\n{\n\t/* Hide the PCI64 BARs from the kernel as their content doesn't\n\t * fit well in the resource management\n\t */\n\tdev->resource[0].start = dev->resource[0].end = 0;\n\tdev->resource[0].flags = 0;\n\tdev->resource[1].start = dev->resource[1].end = 0;\n\tdev->resource[1].flags = 0;\n}",
    "includes": [
      "#include <asm/machdep.h>",
      "#include <asm/uaccess.h>",
      "#include <asm/byteorder.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/sections.h>",
      "#include <asm/prom.h>",
      "#include <asm/io.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/of.h>",
      "#include <linux/list.h>",
      "#include <linux/irq.h>",
      "#include <linux/bootmem.h>",
      "#include <linux/errno.h>",
      "#include <linux/sched.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/delay.h>",
      "#include <linux/pci.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void fixup_cpc710_pci64(struct pci_dev* dev);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/machdep.h>\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/list.h>\n#include <linux/irq.h>\n#include <linux/bootmem.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic void fixup_cpc710_pci64(struct pci_dev* dev);\n\nstatic void\nfixup_cpc710_pci64(struct pci_dev* dev)\n{\n\t/* Hide the PCI64 BARs from the kernel as their content doesn't\n\t * fit well in the resource management\n\t */\n\tdev->resource[0].start = dev->resource[0].end = 0;\n\tdev->resource[0].flags = 0;\n\tdev->resource[1].start = dev->resource[1].end = 0;\n\tdev->resource[1].flags = 0;\n}"
  }
]