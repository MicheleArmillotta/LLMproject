[
  {
    "function_name": "apply_relocate_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
    "lines": "212-304",
    "snippet": "int apply_relocate_add(Elf32_Shdr *sechdrs,\n\t\t       const char *strtab,\n\t\t       unsigned int symindex,\n\t\t       unsigned int relsec,\n\t\t       struct module *module)\n{\n\tunsigned int i;\n\tElf32_Rela *rela = (void *)sechdrs[relsec].sh_addr;\n\tElf32_Sym *sym;\n\tuint32_t *location;\n\tuint32_t value;\n\n\tpr_debug(\"Applying ADD relocate section %u to %u\\n\", relsec,\n\t       sechdrs[relsec].sh_info);\n\tfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\n\t\t/* This is where to make the change */\n\t\tlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\n\t\t\t+ rela[i].r_offset;\n\t\t/* This is the symbol it is referring to.  Note that all\n\t\t   undefined symbols have been resolved.  */\n\t\tsym = (Elf32_Sym *)sechdrs[symindex].sh_addr\n\t\t\t+ ELF32_R_SYM(rela[i].r_info);\n\t\t/* `Everything is relative'. */\n\t\tvalue = sym->st_value + rela[i].r_addend;\n\n\t\tswitch (ELF32_R_TYPE(rela[i].r_info)) {\n\t\tcase R_PPC_ADDR32:\n\t\t\t/* Simply set it */\n\t\t\t*(uint32_t *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC_ADDR16_LO:\n\t\t\t/* Low half of the symbol */\n\t\t\t*(uint16_t *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC_ADDR16_HI:\n\t\t\t/* Higher half of the symbol */\n\t\t\t*(uint16_t *)location = (value >> 16);\n\t\t\tbreak;\n\n\t\tcase R_PPC_ADDR16_HA:\n\t\t\t/* Sign-adjusted lower 16 bits: PPC ELF ABI says:\n\t\t\t   (((x >> 16) + ((x & 0x8000) ? 1 : 0))) & 0xFFFF.\n\t\t\t   This is the same, only sane.\n\t\t\t */\n\t\t\t*(uint16_t *)location = (value + 0x8000) >> 16;\n\t\t\tbreak;\n\n\t\tcase R_PPC_REL24:\n\t\t\tif ((int)(value - (uint32_t)location) < -0x02000000\n\t\t\t    || (int)(value - (uint32_t)location) >= 0x02000000)\n\t\t\t\tvalue = do_plt_call(location, value,\n\t\t\t\t\t\t    sechdrs, module);\n\n\t\t\t/* Only replace bits 2 through 26 */\n\t\t\tpr_debug(\"REL24 value = %08X. location = %08X\\n\",\n\t\t\t       value, (uint32_t)location);\n\t\t\tpr_debug(\"Location before: %08X.\\n\",\n\t\t\t       *(uint32_t *)location);\n\t\t\t*(uint32_t *)location\n\t\t\t\t= (*(uint32_t *)location & ~0x03fffffc)\n\t\t\t\t| ((value - (uint32_t)location)\n\t\t\t\t   & 0x03fffffc);\n\t\t\tpr_debug(\"Location after: %08X.\\n\",\n\t\t\t       *(uint32_t *)location);\n\t\t\tpr_debug(\"ie. jump to %08X+%08X = %08X\\n\",\n\t\t\t       *(uint32_t *)location & 0x03fffffc,\n\t\t\t       (uint32_t)location,\n\t\t\t       (*(uint32_t *)location & 0x03fffffc)\n\t\t\t       + (uint32_t)location);\n\t\t\tbreak;\n\n\t\tcase R_PPC_REL32:\n\t\t\t/* 32-bit relative jump. */\n\t\t\t*(uint32_t *)location = value - (uint32_t)location;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: unknown ADD relocation: %u\\n\",\n\t\t\t       module->name,\n\t\t\t       ELF32_R_TYPE(rela[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tmodule->arch.tramp =\n\t\tdo_plt_call(module->module_core,\n\t\t\t    (unsigned long)ftrace_caller,\n\t\t\t    sechdrs, module);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/elf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_plt_call",
          "args": [
            "module->module_core",
            "(unsigned long)ftrace_caller",
            "sechdrs",
            "module"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "do_plt_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
          "lines": "182-210",
          "snippet": "static uint32_t do_plt_call(void *location,\n\t\t\t    Elf32_Addr val,\n\t\t\t    Elf32_Shdr *sechdrs,\n\t\t\t    struct module *mod)\n{\n\tstruct ppc_plt_entry *entry;\n\n\tpr_debug(\"Doing plt for call to 0x%x at 0x%x\\n\", val, (unsigned int)location);\n\t/* Init, or core PLT? */\n\tif (location >= mod->module_core\n\t    && location < mod->module_core + mod->core_size)\n\t\tentry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;\n\telse\n\t\tentry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;\n\n\t/* Find this entry, or if that fails, the next avail. entry */\n\twhile (entry->jump[0]) {\n\t\tif (entry_matches(entry, val)) return (uint32_t)entry;\n\t\tentry++;\n\t}\n\n\tentry->jump[0] = 0x3d800000+((val+0x8000)>>16); /* lis r12,sym@ha */\n\tentry->jump[1] = 0x398c0000 + (val&0xffff);     /* addi r12,r12,sym@l*/\n\tentry->jump[2] = 0x7d8903a6;                    /* mtctr r12 */\n\tentry->jump[3] = 0x4e800420;\t\t\t/* bctr */\n\n\tpr_debug(\"Initialized plt for 0x%x at %p\\n\", val, entry);\n\treturn (uint32_t)entry;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/elf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic uint32_t do_plt_call(void *location,\n\t\t\t    Elf32_Addr val,\n\t\t\t    Elf32_Shdr *sechdrs,\n\t\t\t    struct module *mod)\n{\n\tstruct ppc_plt_entry *entry;\n\n\tpr_debug(\"Doing plt for call to 0x%x at 0x%x\\n\", val, (unsigned int)location);\n\t/* Init, or core PLT? */\n\tif (location >= mod->module_core\n\t    && location < mod->module_core + mod->core_size)\n\t\tentry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;\n\telse\n\t\tentry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;\n\n\t/* Find this entry, or if that fails, the next avail. entry */\n\twhile (entry->jump[0]) {\n\t\tif (entry_matches(entry, val)) return (uint32_t)entry;\n\t\tentry++;\n\t}\n\n\tentry->jump[0] = 0x3d800000+((val+0x8000)>>16); /* lis r12,sym@ha */\n\tentry->jump[1] = 0x398c0000 + (val&0xffff);     /* addi r12,r12,sym@l*/\n\tentry->jump[2] = 0x7d8903a6;                    /* mtctr r12 */\n\tentry->jump[3] = 0x4e800420;\t\t\t/* bctr */\n\n\tpr_debug(\"Initialized plt for 0x%x at %p\\n\", val, entry);\n\treturn (uint32_t)entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: unknown ADD relocation: %u\\n\"",
            "module->name",
            "ELF32_R_TYPE(rela[i].r_info)"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF32_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ie. jump to %08X+%08X = %08X\\n\"",
            "*(uint32_t *)location & 0x03fffffc",
            "(uint32_t)location",
            "(*(uint32_t *)location & 0x03fffffc)\n\t\t\t       + (uint32_t)location"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Location after: %08X.\\n\"",
            "*(uint32_t *)location"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Location before: %08X.\\n\"",
            "*(uint32_t *)location"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"REL24 value = %08X. location = %08X\\n\"",
            "value",
            "(uint32_t)location"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF32_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF32_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Applying ADD relocate section %u to %u\\n\"",
            "relsec",
            "sechdrs[relsec].sh_info"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nint apply_relocate_add(Elf32_Shdr *sechdrs,\n\t\t       const char *strtab,\n\t\t       unsigned int symindex,\n\t\t       unsigned int relsec,\n\t\t       struct module *module)\n{\n\tunsigned int i;\n\tElf32_Rela *rela = (void *)sechdrs[relsec].sh_addr;\n\tElf32_Sym *sym;\n\tuint32_t *location;\n\tuint32_t value;\n\n\tpr_debug(\"Applying ADD relocate section %u to %u\\n\", relsec,\n\t       sechdrs[relsec].sh_info);\n\tfor (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rela); i++) {\n\t\t/* This is where to make the change */\n\t\tlocation = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr\n\t\t\t+ rela[i].r_offset;\n\t\t/* This is the symbol it is referring to.  Note that all\n\t\t   undefined symbols have been resolved.  */\n\t\tsym = (Elf32_Sym *)sechdrs[symindex].sh_addr\n\t\t\t+ ELF32_R_SYM(rela[i].r_info);\n\t\t/* `Everything is relative'. */\n\t\tvalue = sym->st_value + rela[i].r_addend;\n\n\t\tswitch (ELF32_R_TYPE(rela[i].r_info)) {\n\t\tcase R_PPC_ADDR32:\n\t\t\t/* Simply set it */\n\t\t\t*(uint32_t *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC_ADDR16_LO:\n\t\t\t/* Low half of the symbol */\n\t\t\t*(uint16_t *)location = value;\n\t\t\tbreak;\n\n\t\tcase R_PPC_ADDR16_HI:\n\t\t\t/* Higher half of the symbol */\n\t\t\t*(uint16_t *)location = (value >> 16);\n\t\t\tbreak;\n\n\t\tcase R_PPC_ADDR16_HA:\n\t\t\t/* Sign-adjusted lower 16 bits: PPC ELF ABI says:\n\t\t\t   (((x >> 16) + ((x & 0x8000) ? 1 : 0))) & 0xFFFF.\n\t\t\t   This is the same, only sane.\n\t\t\t */\n\t\t\t*(uint16_t *)location = (value + 0x8000) >> 16;\n\t\t\tbreak;\n\n\t\tcase R_PPC_REL24:\n\t\t\tif ((int)(value - (uint32_t)location) < -0x02000000\n\t\t\t    || (int)(value - (uint32_t)location) >= 0x02000000)\n\t\t\t\tvalue = do_plt_call(location, value,\n\t\t\t\t\t\t    sechdrs, module);\n\n\t\t\t/* Only replace bits 2 through 26 */\n\t\t\tpr_debug(\"REL24 value = %08X. location = %08X\\n\",\n\t\t\t       value, (uint32_t)location);\n\t\t\tpr_debug(\"Location before: %08X.\\n\",\n\t\t\t       *(uint32_t *)location);\n\t\t\t*(uint32_t *)location\n\t\t\t\t= (*(uint32_t *)location & ~0x03fffffc)\n\t\t\t\t| ((value - (uint32_t)location)\n\t\t\t\t   & 0x03fffffc);\n\t\t\tpr_debug(\"Location after: %08X.\\n\",\n\t\t\t       *(uint32_t *)location);\n\t\t\tpr_debug(\"ie. jump to %08X+%08X = %08X\\n\",\n\t\t\t       *(uint32_t *)location & 0x03fffffc,\n\t\t\t       (uint32_t)location,\n\t\t\t       (*(uint32_t *)location & 0x03fffffc)\n\t\t\t       + (uint32_t)location);\n\t\t\tbreak;\n\n\t\tcase R_PPC_REL32:\n\t\t\t/* 32-bit relative jump. */\n\t\t\t*(uint32_t *)location = value - (uint32_t)location;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: unknown ADD relocation: %u\\n\",\n\t\t\t       module->name,\n\t\t\t       ELF32_R_TYPE(rela[i].r_info));\n\t\t\treturn -ENOEXEC;\n\t\t}\n\t}\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tmodule->arch.tramp =\n\t\tdo_plt_call(module->module_core,\n\t\t\t    (unsigned long)ftrace_caller,\n\t\t\t    sechdrs, module);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "do_plt_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
    "lines": "182-210",
    "snippet": "static uint32_t do_plt_call(void *location,\n\t\t\t    Elf32_Addr val,\n\t\t\t    Elf32_Shdr *sechdrs,\n\t\t\t    struct module *mod)\n{\n\tstruct ppc_plt_entry *entry;\n\n\tpr_debug(\"Doing plt for call to 0x%x at 0x%x\\n\", val, (unsigned int)location);\n\t/* Init, or core PLT? */\n\tif (location >= mod->module_core\n\t    && location < mod->module_core + mod->core_size)\n\t\tentry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;\n\telse\n\t\tentry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;\n\n\t/* Find this entry, or if that fails, the next avail. entry */\n\twhile (entry->jump[0]) {\n\t\tif (entry_matches(entry, val)) return (uint32_t)entry;\n\t\tentry++;\n\t}\n\n\tentry->jump[0] = 0x3d800000+((val+0x8000)>>16); /* lis r12,sym@ha */\n\tentry->jump[1] = 0x398c0000 + (val&0xffff);     /* addi r12,r12,sym@l*/\n\tentry->jump[2] = 0x7d8903a6;                    /* mtctr r12 */\n\tentry->jump[3] = 0x4e800420;\t\t\t/* bctr */\n\n\tpr_debug(\"Initialized plt for 0x%x at %p\\n\", val, entry);\n\treturn (uint32_t)entry;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/elf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Initialized plt for 0x%x at %p\\n\"",
            "val",
            "entry"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry_matches",
          "args": [
            "entry",
            "val"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "entry_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
          "lines": "173-179",
          "snippet": "static inline int entry_matches(struct ppc_plt_entry *entry, Elf32_Addr val)\n{\n\tif (entry->jump[0] == 0x3d800000 + ((val + 0x8000) >> 16)\n\t    && entry->jump[1] == 0x398c0000 + (val & 0xffff))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/elf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic inline int entry_matches(struct ppc_plt_entry *entry, Elf32_Addr val)\n{\n\tif (entry->jump[0] == 0x3d800000 + ((val + 0x8000) >> 16)\n\t    && entry->jump[1] == 0x398c0000 + (val & 0xffff))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Doing plt for call to 0x%x at 0x%x\\n\"",
            "val",
            "(unsigned int)location"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic uint32_t do_plt_call(void *location,\n\t\t\t    Elf32_Addr val,\n\t\t\t    Elf32_Shdr *sechdrs,\n\t\t\t    struct module *mod)\n{\n\tstruct ppc_plt_entry *entry;\n\n\tpr_debug(\"Doing plt for call to 0x%x at 0x%x\\n\", val, (unsigned int)location);\n\t/* Init, or core PLT? */\n\tif (location >= mod->module_core\n\t    && location < mod->module_core + mod->core_size)\n\t\tentry = (void *)sechdrs[mod->arch.core_plt_section].sh_addr;\n\telse\n\t\tentry = (void *)sechdrs[mod->arch.init_plt_section].sh_addr;\n\n\t/* Find this entry, or if that fails, the next avail. entry */\n\twhile (entry->jump[0]) {\n\t\tif (entry_matches(entry, val)) return (uint32_t)entry;\n\t\tentry++;\n\t}\n\n\tentry->jump[0] = 0x3d800000+((val+0x8000)>>16); /* lis r12,sym@ha */\n\tentry->jump[1] = 0x398c0000 + (val&0xffff);     /* addi r12,r12,sym@l*/\n\tentry->jump[2] = 0x7d8903a6;                    /* mtctr r12 */\n\tentry->jump[3] = 0x4e800420;\t\t\t/* bctr */\n\n\tpr_debug(\"Initialized plt for 0x%x at %p\\n\", val, entry);\n\treturn (uint32_t)entry;\n}"
  },
  {
    "function_name": "entry_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
    "lines": "173-179",
    "snippet": "static inline int entry_matches(struct ppc_plt_entry *entry, Elf32_Addr val)\n{\n\tif (entry->jump[0] == 0x3d800000 + ((val + 0x8000) >> 16)\n\t    && entry->jump[1] == 0x398c0000 + (val & 0xffff))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/elf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic inline int entry_matches(struct ppc_plt_entry *entry, Elf32_Addr val)\n{\n\tif (entry->jump[0] == 0x3d800000 + ((val + 0x8000) >> 16)\n\t    && entry->jump[1] == 0x398c0000 + (val & 0xffff))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "module_frob_arch_sections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
    "lines": "146-171",
    "snippet": "int module_frob_arch_sections(Elf32_Ehdr *hdr,\n\t\t\t      Elf32_Shdr *sechdrs,\n\t\t\t      char *secstrings,\n\t\t\t      struct module *me)\n{\n\tunsigned int i;\n\n\t/* Find .plt and .init.plt sections */\n\tfor (i = 0; i < hdr->e_shnum; i++) {\n\t\tif (strcmp(secstrings + sechdrs[i].sh_name, \".init.plt\") == 0)\n\t\t\tme->arch.init_plt_section = i;\n\t\telse if (strcmp(secstrings + sechdrs[i].sh_name, \".plt\") == 0)\n\t\t\tme->arch.core_plt_section = i;\n\t}\n\tif (!me->arch.core_plt_section || !me->arch.init_plt_section) {\n\t\tpr_err(\"Module doesn't contain .plt or .init.plt sections.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* Override their sizes */\n\tsechdrs[me->arch.core_plt_section].sh_size\n\t\t= get_plt_size(hdr, sechdrs, secstrings, 0);\n\tsechdrs[me->arch.init_plt_section].sh_size\n\t\t= get_plt_size(hdr, sechdrs, secstrings, 1);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/elf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_plt_size",
          "args": [
            "hdr",
            "sechdrs",
            "secstrings",
            "1"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "get_plt_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
          "lines": "99-144",
          "snippet": "static unsigned long get_plt_size(const Elf32_Ehdr *hdr,\n\t\t\t\t  const Elf32_Shdr *sechdrs,\n\t\t\t\t  const char *secstrings,\n\t\t\t\t  int is_init)\n{\n\tunsigned long ret = 0;\n\tunsigned i;\n\n\t/* Everything marked ALLOC (this includes the exported\n           symbols) */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\t/* If it's called *.init*, and we're not init, we're\n                   not interested */\n\t\tif ((strstr(secstrings + sechdrs[i].sh_name, \".init\") != 0)\n\t\t    != is_init)\n\t\t\tcontinue;\n\n\t\t/* We don't want to look at debug sections. */\n\t\tif (strstr(secstrings + sechdrs[i].sh_name, \".debug\") != 0)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %u\\n\",\n\t\t\t       (void *)hdr + sechdrs[i].sh_offset,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf32_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf32_Rela),\n\t\t\t     sizeof(Elf32_Rela), relacmp, relaswap);\n\n\t\t\tret += count_relocs((void *)hdr\n\t\t\t\t\t     + sechdrs[i].sh_offset,\n\t\t\t\t\t     sechdrs[i].sh_size\n\t\t\t\t\t     / sizeof(Elf32_Rela))\n\t\t\t\t* sizeof(struct ppc_plt_entry);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/elf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic unsigned long get_plt_size(const Elf32_Ehdr *hdr,\n\t\t\t\t  const Elf32_Shdr *sechdrs,\n\t\t\t\t  const char *secstrings,\n\t\t\t\t  int is_init)\n{\n\tunsigned long ret = 0;\n\tunsigned i;\n\n\t/* Everything marked ALLOC (this includes the exported\n           symbols) */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\t/* If it's called *.init*, and we're not init, we're\n                   not interested */\n\t\tif ((strstr(secstrings + sechdrs[i].sh_name, \".init\") != 0)\n\t\t    != is_init)\n\t\t\tcontinue;\n\n\t\t/* We don't want to look at debug sections. */\n\t\tif (strstr(secstrings + sechdrs[i].sh_name, \".debug\") != 0)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %u\\n\",\n\t\t\t       (void *)hdr + sechdrs[i].sh_offset,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf32_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf32_Rela),\n\t\t\t     sizeof(Elf32_Rela), relacmp, relaswap);\n\n\t\t\tret += count_relocs((void *)hdr\n\t\t\t\t\t     + sechdrs[i].sh_offset,\n\t\t\t\t\t     sechdrs[i].sh_size\n\t\t\t\t\t     / sizeof(Elf32_Rela))\n\t\t\t\t* sizeof(struct ppc_plt_entry);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Module doesn't contain .plt or .init.plt sections.\\n\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "secstrings + sechdrs[i].sh_name",
            "\".plt\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "secstrings + sechdrs[i].sh_name",
            "\".init.plt\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nint module_frob_arch_sections(Elf32_Ehdr *hdr,\n\t\t\t      Elf32_Shdr *sechdrs,\n\t\t\t      char *secstrings,\n\t\t\t      struct module *me)\n{\n\tunsigned int i;\n\n\t/* Find .plt and .init.plt sections */\n\tfor (i = 0; i < hdr->e_shnum; i++) {\n\t\tif (strcmp(secstrings + sechdrs[i].sh_name, \".init.plt\") == 0)\n\t\t\tme->arch.init_plt_section = i;\n\t\telse if (strcmp(secstrings + sechdrs[i].sh_name, \".plt\") == 0)\n\t\t\tme->arch.core_plt_section = i;\n\t}\n\tif (!me->arch.core_plt_section || !me->arch.init_plt_section) {\n\t\tpr_err(\"Module doesn't contain .plt or .init.plt sections.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\t/* Override their sizes */\n\tsechdrs[me->arch.core_plt_section].sh_size\n\t\t= get_plt_size(hdr, sechdrs, secstrings, 0);\n\tsechdrs[me->arch.init_plt_section].sh_size\n\t\t= get_plt_size(hdr, sechdrs, secstrings, 1);\n\treturn 0;\n}"
  },
  {
    "function_name": "get_plt_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
    "lines": "99-144",
    "snippet": "static unsigned long get_plt_size(const Elf32_Ehdr *hdr,\n\t\t\t\t  const Elf32_Shdr *sechdrs,\n\t\t\t\t  const char *secstrings,\n\t\t\t\t  int is_init)\n{\n\tunsigned long ret = 0;\n\tunsigned i;\n\n\t/* Everything marked ALLOC (this includes the exported\n           symbols) */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\t/* If it's called *.init*, and we're not init, we're\n                   not interested */\n\t\tif ((strstr(secstrings + sechdrs[i].sh_name, \".init\") != 0)\n\t\t    != is_init)\n\t\t\tcontinue;\n\n\t\t/* We don't want to look at debug sections. */\n\t\tif (strstr(secstrings + sechdrs[i].sh_name, \".debug\") != 0)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %u\\n\",\n\t\t\t       (void *)hdr + sechdrs[i].sh_offset,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf32_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf32_Rela),\n\t\t\t     sizeof(Elf32_Rela), relacmp, relaswap);\n\n\t\t\tret += count_relocs((void *)hdr\n\t\t\t\t\t     + sechdrs[i].sh_offset,\n\t\t\t\t\t     sechdrs[i].sh_size\n\t\t\t\t\t     / sizeof(Elf32_Rela))\n\t\t\t\t* sizeof(struct ppc_plt_entry);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/elf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_relocs",
          "args": [
            "(void *)hdr\n\t\t\t\t\t     + sechdrs[i].sh_offset",
            "sechdrs[i].sh_size\n\t\t\t\t\t     / sizeof(Elf32_Rela)"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "count_relocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
          "lines": "36-57",
          "snippet": "static unsigned int count_relocs(const Elf32_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF32_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF32_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF32_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t_count_relocs++;\t/* add one for ftrace_caller */\n#endif\n\treturn _count_relocs;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <linux/sort.h>",
            "#include <linux/bug.h>",
            "#include <linux/cache.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/elf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic unsigned int count_relocs(const Elf32_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF32_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF32_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF32_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t_count_relocs++;\t/* add one for ftrace_caller */\n#endif\n\treturn _count_relocs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "(void *)hdr + sechdrs[i].sh_offset",
            "sechdrs[i].sh_size / sizeof(Elf32_Rela)",
            "sizeof(Elf32_Rela)",
            "relacmp",
            "relaswap"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Ptr: %p.  Number: %u\\n\"",
            "(void *)hdr + sechdrs[i].sh_offset",
            "sechdrs[i].sh_size / sizeof(Elf32_Rela)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Found relocations in section %u\\n\"",
            "i"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "secstrings + sechdrs[i].sh_name",
            "\".debug\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "secstrings + sechdrs[i].sh_name",
            "\".init\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic unsigned long get_plt_size(const Elf32_Ehdr *hdr,\n\t\t\t\t  const Elf32_Shdr *sechdrs,\n\t\t\t\t  const char *secstrings,\n\t\t\t\t  int is_init)\n{\n\tunsigned long ret = 0;\n\tunsigned i;\n\n\t/* Everything marked ALLOC (this includes the exported\n           symbols) */\n\tfor (i = 1; i < hdr->e_shnum; i++) {\n\t\t/* If it's called *.init*, and we're not init, we're\n                   not interested */\n\t\tif ((strstr(secstrings + sechdrs[i].sh_name, \".init\") != 0)\n\t\t    != is_init)\n\t\t\tcontinue;\n\n\t\t/* We don't want to look at debug sections. */\n\t\tif (strstr(secstrings + sechdrs[i].sh_name, \".debug\") != 0)\n\t\t\tcontinue;\n\n\t\tif (sechdrs[i].sh_type == SHT_RELA) {\n\t\t\tpr_debug(\"Found relocations in section %u\\n\", i);\n\t\t\tpr_debug(\"Ptr: %p.  Number: %u\\n\",\n\t\t\t       (void *)hdr + sechdrs[i].sh_offset,\n\t\t\t       sechdrs[i].sh_size / sizeof(Elf32_Rela));\n\n\t\t\t/* Sort the relocation information based on a symbol and\n\t\t\t * addend key. This is a stable O(n*log n) complexity\n\t\t\t * alogrithm but it will reduce the complexity of\n\t\t\t * count_relocs() to linear complexity O(n)\n\t\t\t */\n\t\t\tsort((void *)hdr + sechdrs[i].sh_offset,\n\t\t\t     sechdrs[i].sh_size / sizeof(Elf32_Rela),\n\t\t\t     sizeof(Elf32_Rela), relacmp, relaswap);\n\n\t\t\tret += count_relocs((void *)hdr\n\t\t\t\t\t     + sechdrs[i].sh_offset,\n\t\t\t\t\t     sechdrs[i].sh_size\n\t\t\t\t\t     / sizeof(Elf32_Rela))\n\t\t\t\t* sizeof(struct ppc_plt_entry);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "relaswap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
    "lines": "82-95",
    "snippet": "static void relaswap(void *_x, void *_y, int size)\n{\n\tuint32_t *x, *y, tmp;\n\tint i;\n\n\ty = (uint32_t *)_x;\n\tx = (uint32_t *)_y;\n\n\tfor (i = 0; i < sizeof(Elf32_Rela) / sizeof(uint32_t); i++) {\n\t\ttmp = x[i];\n\t\tx[i] = y[i];\n\t\ty[i] = tmp;\n\t}\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/elf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic void relaswap(void *_x, void *_y, int size)\n{\n\tuint32_t *x, *y, tmp;\n\tint i;\n\n\ty = (uint32_t *)_x;\n\tx = (uint32_t *)_y;\n\n\tfor (i = 0; i < sizeof(Elf32_Rela) / sizeof(uint32_t); i++) {\n\t\ttmp = x[i];\n\t\tx[i] = y[i];\n\t\ty[i] = tmp;\n\t}\n}"
  },
  {
    "function_name": "relacmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
    "lines": "59-80",
    "snippet": "static int relacmp(const void *_x, const void *_y)\n{\n\tconst Elf32_Rela *x, *y;\n\n\ty = (Elf32_Rela *)_x;\n\tx = (Elf32_Rela *)_y;\n\n\t/* Compare the entire r_info (as opposed to ELF32_R_SYM(r_info) only) to\n\t * make the comparison cheaper/faster. It won't affect the sorting or\n\t * the counting algorithms' performance\n\t */\n\tif (x->r_info < y->r_info)\n\t\treturn -1;\n\telse if (x->r_info > y->r_info)\n\t\treturn 1;\n\telse if (x->r_addend < y->r_addend)\n\t\treturn -1;\n\telse if (x->r_addend > y->r_addend)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/elf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic int relacmp(const void *_x, const void *_y)\n{\n\tconst Elf32_Rela *x, *y;\n\n\ty = (Elf32_Rela *)_x;\n\tx = (Elf32_Rela *)_y;\n\n\t/* Compare the entire r_info (as opposed to ELF32_R_SYM(r_info) only) to\n\t * make the comparison cheaper/faster. It won't affect the sorting or\n\t * the counting algorithms' performance\n\t */\n\tif (x->r_info < y->r_info)\n\t\treturn -1;\n\telse if (x->r_info > y->r_info)\n\t\treturn 1;\n\telse if (x->r_addend < y->r_addend)\n\t\treturn -1;\n\telse if (x->r_addend > y->r_addend)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}"
  },
  {
    "function_name": "count_relocs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/module_32.c",
    "lines": "36-57",
    "snippet": "static unsigned int count_relocs(const Elf32_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF32_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF32_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF32_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t_count_relocs++;\t/* add one for ftrace_caller */\n#endif\n\treturn _count_relocs;\n}",
    "includes": [
      "#include <asm/setup.h>",
      "#include <linux/sort.h>",
      "#include <linux/bug.h>",
      "#include <linux/cache.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/fs.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/elf.h>",
      "#include <linux/moduleloader.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ELF32_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF32_R_SYM",
          "args": [
            "rela[i].r_info"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ELF32_R_TYPE",
          "args": [
            "rela[i].r_info"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/setup.h>\n#include <linux/sort.h>\n#include <linux/bug.h>\n#include <linux/cache.h>\n#include <linux/ftrace.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/elf.h>\n#include <linux/moduleloader.h>\n#include <linux/module.h>\n\nstatic unsigned int count_relocs(const Elf32_Rela *rela, unsigned int num)\n{\n\tunsigned int i, r_info, r_addend, _count_relocs;\n\n\t_count_relocs = 0;\n\tr_info = 0;\n\tr_addend = 0;\n\tfor (i = 0; i < num; i++)\n\t\t/* Only count 24-bit relocs, others don't need stubs */\n\t\tif (ELF32_R_TYPE(rela[i].r_info) == R_PPC_REL24 &&\n\t\t    (r_info != ELF32_R_SYM(rela[i].r_info) ||\n\t\t     r_addend != rela[i].r_addend)) {\n\t\t\t_count_relocs++;\n\t\t\tr_info = ELF32_R_SYM(rela[i].r_info);\n\t\t\tr_addend = rela[i].r_addend;\n\t\t}\n\n#ifdef CONFIG_DYNAMIC_FTRACE\n\t_count_relocs++;\t/* add one for ftrace_caller */\n#endif\n\treturn _count_relocs;\n}"
  }
]