[
  {
    "function_name": "dma_iommu_get_required_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
    "lines": "95-106",
    "snippet": "static u64 dma_iommu_get_required_mask(struct device *dev)\n{\n\tstruct iommu_table *tbl = get_iommu_table_base(dev);\n\tu64 mask;\n\tif (!tbl)\n\t\treturn 0;\n\n\tmask = 1ULL < (fls_long(tbl->it_offset + tbl->it_size) - 1);\n\tmask += mask - 1;\n\n\treturn mask;\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fls_long",
          "args": [
            "tbl->it_offset + tbl->it_size"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <linux/export.h>\n\nstatic u64 dma_iommu_get_required_mask(struct device *dev)\n{\n\tstruct iommu_table *tbl = get_iommu_table_base(dev);\n\tu64 mask;\n\tif (!tbl)\n\t\treturn 0;\n\n\tmask = 1ULL < (fls_long(tbl->it_offset + tbl->it_size) - 1);\n\tmask += mask - 1;\n\n\treturn mask;\n}"
  },
  {
    "function_name": "dma_iommu_dma_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
    "lines": "76-93",
    "snippet": "int dma_iommu_dma_supported(struct device *dev, u64 mask)\n{\n\tstruct iommu_table *tbl = get_iommu_table_base(dev);\n\n\tif (!tbl) {\n\t\tdev_info(dev, \"Warning: IOMMU dma not supported: mask 0x%08llx\"\n\t\t\t\", table unavailable\\n\", mask);\n\t\treturn 0;\n\t}\n\n\tif (tbl->it_offset > (mask >> tbl->it_page_shift)) {\n\t\tdev_info(dev, \"Warning: IOMMU offset too big for device mask\\n\");\n\t\tdev_info(dev, \"mask: 0x%08llx, table offset: 0x%08lx\\n\",\n\t\t\t\tmask, tbl->it_offset << tbl->it_page_shift);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"mask: 0x%08llx, table offset: 0x%08lx\\n\"",
            "mask",
            "tbl->it_offset << tbl->it_page_shift"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"Warning: IOMMU offset too big for device mask\\n\""
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_info",
          "args": [
            "dev",
            "\"Warning: IOMMU dma not supported: mask 0x%08llx\"\n\t\t\t\", table unavailable\\n\"",
            "mask"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <linux/export.h>\n\nint dma_iommu_dma_supported(struct device *dev, u64 mask)\n{\n\tstruct iommu_table *tbl = get_iommu_table_base(dev);\n\n\tif (!tbl) {\n\t\tdev_info(dev, \"Warning: IOMMU dma not supported: mask 0x%08llx\"\n\t\t\t\", table unavailable\\n\", mask);\n\t\treturn 0;\n\t}\n\n\tif (tbl->it_offset > (mask >> tbl->it_page_shift)) {\n\t\tdev_info(dev, \"Warning: IOMMU offset too big for device mask\\n\");\n\t\tdev_info(dev, \"mask: 0x%08llx, table offset: 0x%08lx\\n\",\n\t\t\t\tmask, tbl->it_offset << tbl->it_page_shift);\n\t\treturn 0;\n\t} else\n\t\treturn 1;\n}"
  },
  {
    "function_name": "dma_iommu_unmap_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
    "lines": "67-73",
    "snippet": "static void dma_iommu_unmap_sg(struct device *dev, struct scatterlist *sglist,\n\t\tint nelems, enum dma_data_direction direction,\n\t\tstruct dma_attrs *attrs)\n{\n\tppc_iommu_unmap_sg(get_iommu_table_base(dev), sglist, nelems,\n\t\t\t   direction, attrs);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_iommu_unmap_sg",
          "args": [
            "get_iommu_table_base(dev)",
            "sglist",
            "nelems",
            "direction",
            "attrs"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_iommu_unmap_sg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "575-605",
          "snippet": "void ppc_iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,\n\t\t\tint nelems, enum dma_data_direction direction,\n\t\t\tstruct dma_attrs *attrs)\n{\n\tstruct scatterlist *sg;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (!tbl)\n\t\treturn;\n\n\tsg = sglist;\n\twhile (nelems--) {\n\t\tunsigned int npages;\n\t\tdma_addr_t dma_handle = sg->dma_address;\n\n\t\tif (sg->dma_length == 0)\n\t\t\tbreak;\n\t\tnpages = iommu_num_pages(dma_handle, sg->dma_length,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t__iommu_free(tbl, dma_handle, npages);\n\t\tsg = sg_next(sg);\n\t}\n\n\t/* Flush/invalidate TLBs if necessary. As for iommu_free(), we\n\t * do not do an mb() here, the affected platforms do not need it\n\t * when freeing.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid ppc_iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,\n\t\t\tint nelems, enum dma_data_direction direction,\n\t\t\tstruct dma_attrs *attrs)\n{\n\tstruct scatterlist *sg;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif (!tbl)\n\t\treturn;\n\n\tsg = sglist;\n\twhile (nelems--) {\n\t\tunsigned int npages;\n\t\tdma_addr_t dma_handle = sg->dma_address;\n\n\t\tif (sg->dma_length == 0)\n\t\t\tbreak;\n\t\tnpages = iommu_num_pages(dma_handle, sg->dma_length,\n\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t__iommu_free(tbl, dma_handle, npages);\n\t\tsg = sg_next(sg);\n\t}\n\n\t/* Flush/invalidate TLBs if necessary. As for iommu_free(), we\n\t * do not do an mb() here, the affected platforms do not need it\n\t * when freeing.\n\t */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <linux/export.h>\n\nstatic void dma_iommu_unmap_sg(struct device *dev, struct scatterlist *sglist,\n\t\tint nelems, enum dma_data_direction direction,\n\t\tstruct dma_attrs *attrs)\n{\n\tppc_iommu_unmap_sg(get_iommu_table_base(dev), sglist, nelems,\n\t\t\t   direction, attrs);\n}"
  },
  {
    "function_name": "dma_iommu_map_sg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
    "lines": "59-65",
    "snippet": "static int dma_iommu_map_sg(struct device *dev, struct scatterlist *sglist,\n\t\t\t    int nelems, enum dma_data_direction direction,\n\t\t\t    struct dma_attrs *attrs)\n{\n\treturn ppc_iommu_map_sg(dev, get_iommu_table_base(dev), sglist, nelems,\n\t\t\t\tdevice_to_mask(dev), direction, attrs);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_iommu_map_sg",
          "args": [
            "dev",
            "get_iommu_table_base(dev)",
            "sglist",
            "nelems",
            "device_to_mask(dev)",
            "direction",
            "attrs"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ppc_iommu_map_sg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "431-572",
          "snippet": "int ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,\n\t\t     struct scatterlist *sglist, int nelems,\n\t\t     unsigned long mask, enum dma_data_direction direction,\n\t\t     struct dma_attrs *attrs)\n{\n\tdma_addr_t dma_next = 0, dma_addr;\n\tstruct scatterlist *s, *outs, *segstart;\n\tint outcount, incount, i, build_fail = 0;\n\tunsigned int align;\n\tunsigned long handle;\n\tunsigned int max_seg_size;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif ((nelems == 0) || !tbl)\n\t\treturn 0;\n\n\touts = s = segstart = &sglist[0];\n\toutcount = 1;\n\tincount = nelems;\n\thandle = 0;\n\n\t/* Init first segment length for backout at failure */\n\touts->dma_length = 0;\n\n\tDBG(\"sg mapping %d elements:\\n\", nelems);\n\n\tmax_seg_size = dma_get_max_seg_size(dev);\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tunsigned long vaddr, npages, entry, slen;\n\n\t\tslen = s->length;\n\t\t/* Sanity check */\n\t\tif (slen == 0) {\n\t\t\tdma_next = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Allocate iommu entries for that segment */\n\t\tvaddr = (unsigned long) sg_virt(s);\n\t\tnpages = iommu_num_pages(vaddr, slen, IOMMU_PAGE_SIZE(tbl));\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && slen >= PAGE_SIZE &&\n\t\t    (vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\t\tentry = iommu_range_alloc(dev, tbl, npages, &handle,\n\t\t\t\t\t  mask >> tbl->it_page_shift, align);\n\n\t\tDBG(\"  - vaddr: %lx, size: %lx\\n\", vaddr, slen);\n\n\t\t/* Handle failure */\n\t\tif (unlikely(entry == DMA_ERROR_CODE)) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %lx npages %lu\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\tgoto failure;\n\t\t}\n\n\t\t/* Convert entry to a dma_addr_t */\n\t\tentry += tbl->it_offset;\n\t\tdma_addr = entry << tbl->it_page_shift;\n\t\tdma_addr |= (s->offset & ~IOMMU_PAGE_MASK(tbl));\n\n\t\tDBG(\"  - %lu pages, entry: %lx, dma_addr: %lx\\n\",\n\t\t\t    npages, entry, dma_addr);\n\n\t\t/* Insert into HW table */\n\t\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t\t      vaddr & IOMMU_PAGE_MASK(tbl),\n\t\t\t\t\t      direction, attrs);\n\t\tif(unlikely(build_fail))\n\t\t\tgoto failure;\n\n\t\t/* If we are in an open segment, try merging */\n\t\tif (segstart != s) {\n\t\t\tDBG(\"  - trying merge...\\n\");\n\t\t\t/* We cannot merge if:\n\t\t\t * - allocated dma_addr isn't contiguous to previous allocation\n\t\t\t */\n\t\t\tif (novmerge || (dma_addr != dma_next) ||\n\t\t\t    (outs->dma_length + s->length > max_seg_size)) {\n\t\t\t\t/* Can't merge: create a new segment */\n\t\t\t\tsegstart = s;\n\t\t\t\toutcount++;\n\t\t\t\touts = sg_next(outs);\n\t\t\t\tDBG(\"    can't merge, new segment.\\n\");\n\t\t\t} else {\n\t\t\t\touts->dma_length += s->length;\n\t\t\t\tDBG(\"    merged, new len: %ux\\n\", outs->dma_length);\n\t\t\t}\n\t\t}\n\n\t\tif (segstart == s) {\n\t\t\t/* This is a new segment, fill entries */\n\t\t\tDBG(\"  - filling new segment.\\n\");\n\t\t\touts->dma_address = dma_addr;\n\t\t\touts->dma_length = slen;\n\t\t}\n\n\t\t/* Calculate next page pointer for contiguous check */\n\t\tdma_next = dma_addr + slen;\n\n\t\tDBG(\"  - dma next is: %lx\\n\", dma_next);\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\tDBG(\"mapped %d elements:\\n\", outcount);\n\n\t/* For the sake of ppc_iommu_unmap_sg, we clear out the length in the\n\t * next entry of the sglist if we didn't fill the list completely\n\t */\n\tif (outcount < incount) {\n\t\touts = sg_next(outs);\n\t\touts->dma_address = DMA_ERROR_CODE;\n\t\touts->dma_length = 0;\n\t}\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn outcount;\n\n failure:\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tif (s->dma_length != 0) {\n\t\t\tunsigned long vaddr, npages;\n\n\t\t\tvaddr = s->dma_address & IOMMU_PAGE_MASK(tbl);\n\t\t\tnpages = iommu_num_pages(s->dma_address, s->dma_length,\n\t\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t\t__iommu_free(tbl, vaddr, npages);\n\t\t\ts->dma_address = DMA_ERROR_CODE;\n\t\t\ts->dma_length = 0;\n\t\t}\n\t\tif (s == outs)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int novmerge;",
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int novmerge;\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nint ppc_iommu_map_sg(struct device *dev, struct iommu_table *tbl,\n\t\t     struct scatterlist *sglist, int nelems,\n\t\t     unsigned long mask, enum dma_data_direction direction,\n\t\t     struct dma_attrs *attrs)\n{\n\tdma_addr_t dma_next = 0, dma_addr;\n\tstruct scatterlist *s, *outs, *segstart;\n\tint outcount, incount, i, build_fail = 0;\n\tunsigned int align;\n\tunsigned long handle;\n\tunsigned int max_seg_size;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tif ((nelems == 0) || !tbl)\n\t\treturn 0;\n\n\touts = s = segstart = &sglist[0];\n\toutcount = 1;\n\tincount = nelems;\n\thandle = 0;\n\n\t/* Init first segment length for backout at failure */\n\touts->dma_length = 0;\n\n\tDBG(\"sg mapping %d elements:\\n\", nelems);\n\n\tmax_seg_size = dma_get_max_seg_size(dev);\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tunsigned long vaddr, npages, entry, slen;\n\n\t\tslen = s->length;\n\t\t/* Sanity check */\n\t\tif (slen == 0) {\n\t\t\tdma_next = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Allocate iommu entries for that segment */\n\t\tvaddr = (unsigned long) sg_virt(s);\n\t\tnpages = iommu_num_pages(vaddr, slen, IOMMU_PAGE_SIZE(tbl));\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && slen >= PAGE_SIZE &&\n\t\t    (vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\t\tentry = iommu_range_alloc(dev, tbl, npages, &handle,\n\t\t\t\t\t  mask >> tbl->it_page_shift, align);\n\n\t\tDBG(\"  - vaddr: %lx, size: %lx\\n\", vaddr, slen);\n\n\t\t/* Handle failure */\n\t\tif (unlikely(entry == DMA_ERROR_CODE)) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %lx npages %lu\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\tgoto failure;\n\t\t}\n\n\t\t/* Convert entry to a dma_addr_t */\n\t\tentry += tbl->it_offset;\n\t\tdma_addr = entry << tbl->it_page_shift;\n\t\tdma_addr |= (s->offset & ~IOMMU_PAGE_MASK(tbl));\n\n\t\tDBG(\"  - %lu pages, entry: %lx, dma_addr: %lx\\n\",\n\t\t\t    npages, entry, dma_addr);\n\n\t\t/* Insert into HW table */\n\t\tbuild_fail = tbl->it_ops->set(tbl, entry, npages,\n\t\t\t\t\t      vaddr & IOMMU_PAGE_MASK(tbl),\n\t\t\t\t\t      direction, attrs);\n\t\tif(unlikely(build_fail))\n\t\t\tgoto failure;\n\n\t\t/* If we are in an open segment, try merging */\n\t\tif (segstart != s) {\n\t\t\tDBG(\"  - trying merge...\\n\");\n\t\t\t/* We cannot merge if:\n\t\t\t * - allocated dma_addr isn't contiguous to previous allocation\n\t\t\t */\n\t\t\tif (novmerge || (dma_addr != dma_next) ||\n\t\t\t    (outs->dma_length + s->length > max_seg_size)) {\n\t\t\t\t/* Can't merge: create a new segment */\n\t\t\t\tsegstart = s;\n\t\t\t\toutcount++;\n\t\t\t\touts = sg_next(outs);\n\t\t\t\tDBG(\"    can't merge, new segment.\\n\");\n\t\t\t} else {\n\t\t\t\touts->dma_length += s->length;\n\t\t\t\tDBG(\"    merged, new len: %ux\\n\", outs->dma_length);\n\t\t\t}\n\t\t}\n\n\t\tif (segstart == s) {\n\t\t\t/* This is a new segment, fill entries */\n\t\t\tDBG(\"  - filling new segment.\\n\");\n\t\t\touts->dma_address = dma_addr;\n\t\t\touts->dma_length = slen;\n\t\t}\n\n\t\t/* Calculate next page pointer for contiguous check */\n\t\tdma_next = dma_addr + slen;\n\n\t\tDBG(\"  - dma next is: %lx\\n\", dma_next);\n\t}\n\n\t/* Flush/invalidate TLB caches if necessary */\n\tif (tbl->it_ops->flush)\n\t\ttbl->it_ops->flush(tbl);\n\n\tDBG(\"mapped %d elements:\\n\", outcount);\n\n\t/* For the sake of ppc_iommu_unmap_sg, we clear out the length in the\n\t * next entry of the sglist if we didn't fill the list completely\n\t */\n\tif (outcount < incount) {\n\t\touts = sg_next(outs);\n\t\touts->dma_address = DMA_ERROR_CODE;\n\t\touts->dma_length = 0;\n\t}\n\n\t/* Make sure updates are seen by hardware */\n\tmb();\n\n\treturn outcount;\n\n failure:\n\tfor_each_sg(sglist, s, nelems, i) {\n\t\tif (s->dma_length != 0) {\n\t\t\tunsigned long vaddr, npages;\n\n\t\t\tvaddr = s->dma_address & IOMMU_PAGE_MASK(tbl);\n\t\t\tnpages = iommu_num_pages(s->dma_address, s->dma_length,\n\t\t\t\t\t\t IOMMU_PAGE_SIZE(tbl));\n\t\t\t__iommu_free(tbl, vaddr, npages);\n\t\t\ts->dma_address = DMA_ERROR_CODE;\n\t\t\ts->dma_length = 0;\n\t\t}\n\t\tif (s == outs)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_to_mask",
          "args": [
            "dev"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <linux/export.h>\n\nstatic int dma_iommu_map_sg(struct device *dev, struct scatterlist *sglist,\n\t\t\t    int nelems, enum dma_data_direction direction,\n\t\t\t    struct dma_attrs *attrs)\n{\n\treturn ppc_iommu_map_sg(dev, get_iommu_table_base(dev), sglist, nelems,\n\t\t\t\tdevice_to_mask(dev), direction, attrs);\n}"
  },
  {
    "function_name": "dma_iommu_unmap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
    "lines": "50-56",
    "snippet": "static void dma_iommu_unmap_page(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t size_t size, enum dma_data_direction direction,\n\t\t\t\t struct dma_attrs *attrs)\n{\n\tiommu_unmap_page(get_iommu_table_base(dev), dma_handle, size, direction,\n\t\t\t attrs);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_unmap_page",
          "args": [
            "get_iommu_table_base(dev)",
            "dma_handle",
            "size",
            "direction",
            "attrs"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "dma_iommu_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
          "lines": "50-56",
          "snippet": "static void dma_iommu_unmap_page(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t size_t size, enum dma_data_direction direction,\n\t\t\t\t struct dma_attrs *attrs)\n{\n\tiommu_unmap_page(get_iommu_table_base(dev), dma_handle, size, direction,\n\t\t\t attrs);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <linux/export.h>\n\nstatic void dma_iommu_unmap_page(struct device *dev, dma_addr_t dma_handle,\n\t\t\t\t size_t size, enum dma_data_direction direction,\n\t\t\t\t struct dma_attrs *attrs)\n{\n\tiommu_unmap_page(get_iommu_table_base(dev), dma_handle, size, direction,\n\t\t\t attrs);\n}"
  },
  {
    "function_name": "dma_iommu_map_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
    "lines": "40-47",
    "snippet": "static dma_addr_t dma_iommu_map_page(struct device *dev, struct page *page,\n\t\t\t\t     unsigned long offset, size_t size,\n\t\t\t\t     enum dma_data_direction direction,\n\t\t\t\t     struct dma_attrs *attrs)\n{\n\treturn iommu_map_page(dev, get_iommu_table_base(dev), page, offset,\n\t\t\t      size, device_to_mask(dev), direction, attrs);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_map_page",
          "args": [
            "dev",
            "get_iommu_table_base(dev)",
            "page",
            "offset",
            "size",
            "device_to_mask(dev)",
            "direction",
            "attrs"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "753-789",
          "snippet": "dma_addr_t iommu_map_page(struct device *dev, struct iommu_table *tbl,\n\t\t\t  struct page *page, unsigned long offset, size_t size,\n\t\t\t  unsigned long mask, enum dma_data_direction direction,\n\t\t\t  struct dma_attrs *attrs)\n{\n\tdma_addr_t dma_handle = DMA_ERROR_CODE;\n\tvoid *vaddr;\n\tunsigned long uaddr;\n\tunsigned int npages, align;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tvaddr = page_address(page) + offset;\n\tuaddr = (unsigned long)vaddr;\n\tnpages = iommu_num_pages(uaddr, size, IOMMU_PAGE_SIZE(tbl));\n\n\tif (tbl) {\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && size >= PAGE_SIZE &&\n\t\t    ((unsigned long)vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\n\t\tdma_handle = iommu_alloc(dev, tbl, vaddr, npages, direction,\n\t\t\t\t\t mask >> tbl->it_page_shift, align,\n\t\t\t\t\t attrs);\n\t\tif (dma_handle == DMA_ERROR_CODE) {\n\t\t\tif (printk_ratelimit())  {\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %p npages %d\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\t}\n\t\t} else\n\t\t\tdma_handle |= (uaddr & ~IOMMU_PAGE_MASK(tbl));\n\t}\n\n\treturn dma_handle;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\ndma_addr_t iommu_map_page(struct device *dev, struct iommu_table *tbl,\n\t\t\t  struct page *page, unsigned long offset, size_t size,\n\t\t\t  unsigned long mask, enum dma_data_direction direction,\n\t\t\t  struct dma_attrs *attrs)\n{\n\tdma_addr_t dma_handle = DMA_ERROR_CODE;\n\tvoid *vaddr;\n\tunsigned long uaddr;\n\tunsigned int npages, align;\n\n\tBUG_ON(direction == DMA_NONE);\n\n\tvaddr = page_address(page) + offset;\n\tuaddr = (unsigned long)vaddr;\n\tnpages = iommu_num_pages(uaddr, size, IOMMU_PAGE_SIZE(tbl));\n\n\tif (tbl) {\n\t\talign = 0;\n\t\tif (tbl->it_page_shift < PAGE_SHIFT && size >= PAGE_SIZE &&\n\t\t    ((unsigned long)vaddr & ~PAGE_MASK) == 0)\n\t\t\talign = PAGE_SHIFT - tbl->it_page_shift;\n\n\t\tdma_handle = iommu_alloc(dev, tbl, vaddr, npages, direction,\n\t\t\t\t\t mask >> tbl->it_page_shift, align,\n\t\t\t\t\t attrs);\n\t\tif (dma_handle == DMA_ERROR_CODE) {\n\t\t\tif (printk_ratelimit())  {\n\t\t\t\tdev_info(dev, \"iommu_alloc failed, tbl %p \"\n\t\t\t\t\t \"vaddr %p npages %d\\n\", tbl, vaddr,\n\t\t\t\t\t npages);\n\t\t\t}\n\t\t} else\n\t\t\tdma_handle |= (uaddr & ~IOMMU_PAGE_MASK(tbl));\n\t}\n\n\treturn dma_handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_to_mask",
          "args": [
            "dev"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <linux/export.h>\n\nstatic dma_addr_t dma_iommu_map_page(struct device *dev, struct page *page,\n\t\t\t\t     unsigned long offset, size_t size,\n\t\t\t\t     enum dma_data_direction direction,\n\t\t\t\t     struct dma_attrs *attrs)\n{\n\treturn iommu_map_page(dev, get_iommu_table_base(dev), page, offset,\n\t\t\t      size, device_to_mask(dev), direction, attrs);\n}"
  },
  {
    "function_name": "dma_iommu_free_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
    "lines": "28-33",
    "snippet": "static void dma_iommu_free_coherent(struct device *dev, size_t size,\n\t\t\t\t    void *vaddr, dma_addr_t dma_handle,\n\t\t\t\t    struct dma_attrs *attrs)\n{\n\tiommu_free_coherent(get_iommu_table_base(dev), size, vaddr, dma_handle);\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_free_coherent",
          "args": [
            "get_iommu_table_base(dev)",
            "size",
            "vaddr",
            "dma_handle"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_free_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "857-869",
          "snippet": "void iommu_free_coherent(struct iommu_table *tbl, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma_handle)\n{\n\tif (tbl) {\n\t\tunsigned int nio_pages;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tnio_pages = size >> tbl->it_page_shift;\n\t\tiommu_free(tbl, dma_handle, nio_pages);\n\t\tsize = PAGE_ALIGN(size);\n\t\tfree_pages((unsigned long)vaddr, get_order(size));\n\t}\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid iommu_free_coherent(struct iommu_table *tbl, size_t size,\n\t\t\t void *vaddr, dma_addr_t dma_handle)\n{\n\tif (tbl) {\n\t\tunsigned int nio_pages;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tnio_pages = size >> tbl->it_page_shift;\n\t\tiommu_free(tbl, dma_handle, nio_pages);\n\t\tsize = PAGE_ALIGN(size);\n\t\tfree_pages((unsigned long)vaddr, get_order(size));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <linux/export.h>\n\nstatic void dma_iommu_free_coherent(struct device *dev, size_t size,\n\t\t\t\t    void *vaddr, dma_addr_t dma_handle,\n\t\t\t\t    struct dma_attrs *attrs)\n{\n\tiommu_free_coherent(get_iommu_table_base(dev), size, vaddr, dma_handle);\n}"
  },
  {
    "function_name": "dma_iommu_alloc_coherent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/dma-iommu.c",
    "lines": "19-26",
    "snippet": "static void *dma_iommu_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t      dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t      struct dma_attrs *attrs)\n{\n\treturn iommu_alloc_coherent(dev, get_iommu_table_base(dev), size,\n\t\t\t\t    dma_handle, dev->coherent_dma_mask, flag,\n\t\t\t\t    dev_to_node(dev));\n}",
    "includes": [
      "#include <asm/iommu.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iommu_alloc_coherent",
          "args": [
            "dev",
            "get_iommu_table_base(dev)",
            "size",
            "dma_handle",
            "dev->coherent_dma_mask",
            "flag",
            "dev_to_node(dev)"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "iommu_alloc_coherent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/iommu.c",
          "lines": "810-855",
          "snippet": "void *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,\n\t\t\t   size_t size,\tdma_addr_t *dma_handle,\n\t\t\t   unsigned long mask, gfp_t flag, int node)\n{\n\tvoid *ret = NULL;\n\tdma_addr_t mapping;\n\tunsigned int order;\n\tunsigned int nio_pages, io_order;\n\tstruct page *page;\n\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\n \t/*\n\t * Client asked for way too much space.  This is checked later\n\t * anyway.  It is easier to debug here for the drivers than in\n\t * the tce tables.\n\t */\n\tif (order >= IOMAP_MAX_ORDER) {\n\t\tdev_info(dev, \"iommu_alloc_consistent size too large: 0x%lx\\n\",\n\t\t\t size);\n\t\treturn NULL;\n\t}\n\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* Alloc enough pages (and possibly more) */\n\tpage = alloc_pages_node(node, flag, order);\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\n\t/* Set up tces to cover the allocated range */\n\tnio_pages = size >> tbl->it_page_shift;\n\tio_order = get_iommu_order(size, tbl);\n\tmapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,\n\t\t\t      mask >> tbl->it_page_shift, io_order, NULL);\n\tif (mapping == DMA_ERROR_CODE) {\n\t\tfree_pages((unsigned long)ret, order);\n\t\treturn NULL;\n\t}\n\t*dma_handle = mapping;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/tce.h>",
            "#include <asm/vio.h>",
            "#include <asm/fadump.h>",
            "#include <asm/kdump.h>",
            "#include <asm/machdep.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/iommu.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/sched.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/fault-inject.h>",
            "#include <linux/hash.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/iommu-helper.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/dma-mapping.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/tce.h>\n#include <asm/vio.h>\n#include <asm/fadump.h>\n#include <asm/kdump.h>\n#include <asm/machdep.h>\n#include <asm/pci-bridge.h>\n#include <asm/iommu.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/sched.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/fault-inject.h>\n#include <linux/hash.h>\n#include <linux/crash_dump.h>\n#include <linux/iommu-helper.h>\n#include <linux/bitmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic void __iommu_free(struct iommu_table *, dma_addr_t, unsigned int);\n\nvoid *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,\n\t\t\t   size_t size,\tdma_addr_t *dma_handle,\n\t\t\t   unsigned long mask, gfp_t flag, int node)\n{\n\tvoid *ret = NULL;\n\tdma_addr_t mapping;\n\tunsigned int order;\n\tunsigned int nio_pages, io_order;\n\tstruct page *page;\n\n\tsize = PAGE_ALIGN(size);\n\torder = get_order(size);\n\n \t/*\n\t * Client asked for way too much space.  This is checked later\n\t * anyway.  It is easier to debug here for the drivers than in\n\t * the tce tables.\n\t */\n\tif (order >= IOMAP_MAX_ORDER) {\n\t\tdev_info(dev, \"iommu_alloc_consistent size too large: 0x%lx\\n\",\n\t\t\t size);\n\t\treturn NULL;\n\t}\n\n\tif (!tbl)\n\t\treturn NULL;\n\n\t/* Alloc enough pages (and possibly more) */\n\tpage = alloc_pages_node(node, flag, order);\n\tif (!page)\n\t\treturn NULL;\n\tret = page_address(page);\n\tmemset(ret, 0, size);\n\n\t/* Set up tces to cover the allocated range */\n\tnio_pages = size >> tbl->it_page_shift;\n\tio_order = get_iommu_order(size, tbl);\n\tmapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,\n\t\t\t      mask >> tbl->it_page_shift, io_order, NULL);\n\tif (mapping == DMA_ERROR_CODE) {\n\t\tfree_pages((unsigned long)ret, order);\n\t\treturn NULL;\n\t}\n\t*dma_handle = mapping;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_node",
          "args": [
            "dev"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_iommu_table_base",
          "args": [
            "dev"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/iommu.h>\n#include <linux/export.h>\n\nstatic void *dma_iommu_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t      dma_addr_t *dma_handle, gfp_t flag,\n\t\t\t\t      struct dma_attrs *attrs)\n{\n\treturn iommu_alloc_coherent(dev, get_iommu_table_base(dev), size,\n\t\t\t\t    dma_handle, dev->coherent_dma_mask, flag,\n\t\t\t\t    dev_to_node(dev));\n}"
  }
]