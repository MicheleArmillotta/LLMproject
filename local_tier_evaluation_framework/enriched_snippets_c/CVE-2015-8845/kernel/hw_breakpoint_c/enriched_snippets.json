[
  {
    "function_name": "hw_breakpoint_pmu_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "363-366",
    "snippet": "void hw_breakpoint_pmu_read(struct perf_event *bp)\n{\n\t/* TODO */\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid hw_breakpoint_pmu_read(struct perf_event *bp)\n{\n\t/* TODO */\n}"
  },
  {
    "function_name": "flush_ptrace_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "355-361",
    "snippet": "void flush_ptrace_hw_breakpoint(struct task_struct *tsk)\n{\n\tstruct thread_struct *t = &tsk->thread;\n\n\tunregister_hw_breakpoint(t->ptrace_bps[0]);\n\tt->ptrace_bps[0] = NULL;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_hw_breakpoint",
          "args": [
            "t->ptrace_bps[0]"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "arch_unregister_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "106-115",
          "snippet": "void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t */\n\tif (bp->ctx && bp->ctx->task)\n\t\tbp->ctx->task->thread.last_hit_ubp = NULL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t */\n\tif (bp->ctx && bp->ctx->task)\n\t\tbp->ctx->task->thread.last_hit_ubp = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid flush_ptrace_hw_breakpoint(struct task_struct *tsk)\n{\n\tstruct thread_struct *t = &tsk->thread;\n\n\tunregister_hw_breakpoint(t->ptrace_bps[0]);\n\tt->ptrace_bps[0] = NULL;\n}"
  },
  {
    "function_name": "hw_breakpoint_exceptions_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "335-350",
    "snippet": "int __kprobes hw_breakpoint_exceptions_notify(\n\t\tstruct notifier_block *unused, unsigned long val, void *data)\n{\n\tint ret = NOTIFY_DONE;\n\n\tswitch (val) {\n\tcase DIE_DABR_MATCH:\n\t\tret = hw_breakpoint_handler(data);\n\t\tbreak;\n\tcase DIE_SSTEP:\n\t\tret = single_step_dabr_instruction(data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_step_dabr_instruction",
          "args": [
            "data"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "single_step_dabr_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "296-330",
          "snippet": "static int __kprobes single_step_dabr_instruction(struct die_args *args)\n{\n\tstruct pt_regs *regs = args->regs;\n\tstruct perf_event *bp = NULL;\n\tstruct arch_hw_breakpoint *info;\n\n\tbp = current->thread.last_hit_ubp;\n\t/*\n\t * Check if we are single-stepping as a result of a\n\t * previous HW Breakpoint exception\n\t */\n\tif (!bp)\n\t\treturn NOTIFY_DONE;\n\n\tinfo = counter_arch_bp(bp);\n\n\t/*\n\t * We shall invoke the user-defined callback function in the single\n\t * stepping handler to confirm to 'trigger-after-execute' semantics\n\t */\n\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\tperf_bp_event(bp, regs);\n\n\t__set_breakpoint(info);\n\tcurrent->thread.last_hit_ubp = NULL;\n\n\t/*\n\t * If the process was being single-stepped by ptrace, let the\n\t * other single-step actions occur (e.g. generate SIGTRAP).\n\t */\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\treturn NOTIFY_DONE;\n\n\treturn NOTIFY_STOP;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic int __kprobes single_step_dabr_instruction(struct die_args *args)\n{\n\tstruct pt_regs *regs = args->regs;\n\tstruct perf_event *bp = NULL;\n\tstruct arch_hw_breakpoint *info;\n\n\tbp = current->thread.last_hit_ubp;\n\t/*\n\t * Check if we are single-stepping as a result of a\n\t * previous HW Breakpoint exception\n\t */\n\tif (!bp)\n\t\treturn NOTIFY_DONE;\n\n\tinfo = counter_arch_bp(bp);\n\n\t/*\n\t * We shall invoke the user-defined callback function in the single\n\t * stepping handler to confirm to 'trigger-after-execute' semantics\n\t */\n\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\tperf_bp_event(bp, regs);\n\n\t__set_breakpoint(info);\n\tcurrent->thread.last_hit_ubp = NULL;\n\n\t/*\n\t * If the process was being single-stepped by ptrace, let the\n\t * other single-step actions occur (e.g. generate SIGTRAP).\n\t */\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\treturn NOTIFY_DONE;\n\n\treturn NOTIFY_STOP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_handler",
          "args": [
            "data"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "hw_breakpoint_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "208-291",
          "snippet": "int __kprobes hw_breakpoint_handler(struct die_args *args)\n{\n\tint rc = NOTIFY_STOP;\n\tstruct perf_event *bp;\n\tstruct pt_regs *regs = args->regs;\n\tint stepped = 1;\n\tstruct arch_hw_breakpoint *info;\n\tunsigned int instr;\n\tunsigned long dar = regs->dar;\n\n\t/* Disable breakpoints during exception handling */\n\thw_breakpoint_disable();\n\n\t/*\n\t * The counter may be concurrently released but that can only\n\t * occur from a call_rcu() path. We can then safely fetch\n\t * the breakpoint, use its callback, touch its counter\n\t * while we are in an rcu_read_lock() path.\n\t */\n\trcu_read_lock();\n\n\tbp = __this_cpu_read(bp_per_reg);\n\tif (!bp)\n\t\tgoto out;\n\tinfo = counter_arch_bp(bp);\n\n\t/*\n\t * Return early after invoking user-callback function without restoring\n\t * DABR if the breakpoint is from ptrace which always operates in\n\t * one-shot mode. The ptrace-ed process will receive the SIGTRAP signal\n\t * generated in do_dabr().\n\t */\n\tif (bp->overflow_handler == ptrace_triggered) {\n\t\tperf_bp_event(bp, regs);\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Verify if dar lies within the address range occupied by the symbol\n\t * being watched to filter extraneous exceptions.  If it doesn't,\n\t * we still need to single-step the instruction, but we don't\n\t * generate an event.\n\t */\n\tinfo->type &= ~HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\tif (!((bp->attr.bp_addr <= dar) &&\n\t      (dar - bp->attr.bp_addr < bp->attr.bp_len)))\n\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\n\t/* Do not emulate user-space instructions, instead single-step them */\n\tif (user_mode(regs)) {\n\t\tcurrent->thread.last_hit_ubp = bp;\n\t\tregs->msr |= MSR_SE;\n\t\tgoto out;\n\t}\n\n\tstepped = 0;\n\tinstr = 0;\n\tif (!__get_user_inatomic(instr, (unsigned int *) regs->nip))\n\t\tstepped = emulate_step(regs, instr);\n\n\t/*\n\t * emulate_step() could not execute it. We've failed in reliably\n\t * handling the hw-breakpoint. Unregister it and throw a warning\n\t * message to let the user know about it.\n\t */\n\tif (!stepped) {\n\t\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at \"\n\t\t\t\"0x%lx will be disabled.\", info->address);\n\t\tperf_event_disable(bp);\n\t\tgoto out;\n\t}\n\t/*\n\t * As a policy, the callback is invoked in a 'trigger-after-execute'\n\t * fashion\n\t */\n\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\tperf_bp_event(bp, regs);\n\n\t__set_breakpoint(info);\nout:\n\trcu_read_unlock();\n\treturn rc;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg);\n\nint __kprobes hw_breakpoint_handler(struct die_args *args)\n{\n\tint rc = NOTIFY_STOP;\n\tstruct perf_event *bp;\n\tstruct pt_regs *regs = args->regs;\n\tint stepped = 1;\n\tstruct arch_hw_breakpoint *info;\n\tunsigned int instr;\n\tunsigned long dar = regs->dar;\n\n\t/* Disable breakpoints during exception handling */\n\thw_breakpoint_disable();\n\n\t/*\n\t * The counter may be concurrently released but that can only\n\t * occur from a call_rcu() path. We can then safely fetch\n\t * the breakpoint, use its callback, touch its counter\n\t * while we are in an rcu_read_lock() path.\n\t */\n\trcu_read_lock();\n\n\tbp = __this_cpu_read(bp_per_reg);\n\tif (!bp)\n\t\tgoto out;\n\tinfo = counter_arch_bp(bp);\n\n\t/*\n\t * Return early after invoking user-callback function without restoring\n\t * DABR if the breakpoint is from ptrace which always operates in\n\t * one-shot mode. The ptrace-ed process will receive the SIGTRAP signal\n\t * generated in do_dabr().\n\t */\n\tif (bp->overflow_handler == ptrace_triggered) {\n\t\tperf_bp_event(bp, regs);\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Verify if dar lies within the address range occupied by the symbol\n\t * being watched to filter extraneous exceptions.  If it doesn't,\n\t * we still need to single-step the instruction, but we don't\n\t * generate an event.\n\t */\n\tinfo->type &= ~HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\tif (!((bp->attr.bp_addr <= dar) &&\n\t      (dar - bp->attr.bp_addr < bp->attr.bp_len)))\n\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\n\t/* Do not emulate user-space instructions, instead single-step them */\n\tif (user_mode(regs)) {\n\t\tcurrent->thread.last_hit_ubp = bp;\n\t\tregs->msr |= MSR_SE;\n\t\tgoto out;\n\t}\n\n\tstepped = 0;\n\tinstr = 0;\n\tif (!__get_user_inatomic(instr, (unsigned int *) regs->nip))\n\t\tstepped = emulate_step(regs, instr);\n\n\t/*\n\t * emulate_step() could not execute it. We've failed in reliably\n\t * handling the hw-breakpoint. Unregister it and throw a warning\n\t * message to let the user know about it.\n\t */\n\tif (!stepped) {\n\t\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at \"\n\t\t\t\"0x%lx will be disabled.\", info->address);\n\t\tperf_event_disable(bp);\n\t\tgoto out;\n\t}\n\t/*\n\t * As a policy, the callback is invoked in a 'trigger-after-execute'\n\t * fashion\n\t */\n\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\tperf_bp_event(bp, regs);\n\n\t__set_breakpoint(info);\nout:\n\trcu_read_unlock();\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint __kprobes hw_breakpoint_exceptions_notify(\n\t\tstruct notifier_block *unused, unsigned long val, void *data)\n{\n\tint ret = NOTIFY_DONE;\n\n\tswitch (val) {\n\tcase DIE_DABR_MATCH:\n\t\tret = hw_breakpoint_handler(data);\n\t\tbreak;\n\tcase DIE_SSTEP:\n\t\tret = single_step_dabr_instruction(data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "single_step_dabr_instruction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "296-330",
    "snippet": "static int __kprobes single_step_dabr_instruction(struct die_args *args)\n{\n\tstruct pt_regs *regs = args->regs;\n\tstruct perf_event *bp = NULL;\n\tstruct arch_hw_breakpoint *info;\n\n\tbp = current->thread.last_hit_ubp;\n\t/*\n\t * Check if we are single-stepping as a result of a\n\t * previous HW Breakpoint exception\n\t */\n\tif (!bp)\n\t\treturn NOTIFY_DONE;\n\n\tinfo = counter_arch_bp(bp);\n\n\t/*\n\t * We shall invoke the user-defined callback function in the single\n\t * stepping handler to confirm to 'trigger-after-execute' semantics\n\t */\n\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\tperf_bp_event(bp, regs);\n\n\t__set_breakpoint(info);\n\tcurrent->thread.last_hit_ubp = NULL;\n\n\t/*\n\t * If the process was being single-stepped by ptrace, let the\n\t * other single-step actions occur (e.g. generate SIGTRAP).\n\t */\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\treturn NOTIFY_DONE;\n\n\treturn NOTIFY_STOP;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_SINGLESTEP"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "info"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "497-505",
          "snippet": "void __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nvoid __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_bp_event",
          "args": [
            "bp",
            "regs"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic int __kprobes single_step_dabr_instruction(struct die_args *args)\n{\n\tstruct pt_regs *regs = args->regs;\n\tstruct perf_event *bp = NULL;\n\tstruct arch_hw_breakpoint *info;\n\n\tbp = current->thread.last_hit_ubp;\n\t/*\n\t * Check if we are single-stepping as a result of a\n\t * previous HW Breakpoint exception\n\t */\n\tif (!bp)\n\t\treturn NOTIFY_DONE;\n\n\tinfo = counter_arch_bp(bp);\n\n\t/*\n\t * We shall invoke the user-defined callback function in the single\n\t * stepping handler to confirm to 'trigger-after-execute' semantics\n\t */\n\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\tperf_bp_event(bp, regs);\n\n\t__set_breakpoint(info);\n\tcurrent->thread.last_hit_ubp = NULL;\n\n\t/*\n\t * If the process was being single-stepped by ptrace, let the\n\t * other single-step actions occur (e.g. generate SIGTRAP).\n\t */\n\tif (test_thread_flag(TIF_SINGLESTEP))\n\t\treturn NOTIFY_DONE;\n\n\treturn NOTIFY_STOP;\n}"
  },
  {
    "function_name": "hw_breakpoint_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "208-291",
    "snippet": "int __kprobes hw_breakpoint_handler(struct die_args *args)\n{\n\tint rc = NOTIFY_STOP;\n\tstruct perf_event *bp;\n\tstruct pt_regs *regs = args->regs;\n\tint stepped = 1;\n\tstruct arch_hw_breakpoint *info;\n\tunsigned int instr;\n\tunsigned long dar = regs->dar;\n\n\t/* Disable breakpoints during exception handling */\n\thw_breakpoint_disable();\n\n\t/*\n\t * The counter may be concurrently released but that can only\n\t * occur from a call_rcu() path. We can then safely fetch\n\t * the breakpoint, use its callback, touch its counter\n\t * while we are in an rcu_read_lock() path.\n\t */\n\trcu_read_lock();\n\n\tbp = __this_cpu_read(bp_per_reg);\n\tif (!bp)\n\t\tgoto out;\n\tinfo = counter_arch_bp(bp);\n\n\t/*\n\t * Return early after invoking user-callback function without restoring\n\t * DABR if the breakpoint is from ptrace which always operates in\n\t * one-shot mode. The ptrace-ed process will receive the SIGTRAP signal\n\t * generated in do_dabr().\n\t */\n\tif (bp->overflow_handler == ptrace_triggered) {\n\t\tperf_bp_event(bp, regs);\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Verify if dar lies within the address range occupied by the symbol\n\t * being watched to filter extraneous exceptions.  If it doesn't,\n\t * we still need to single-step the instruction, but we don't\n\t * generate an event.\n\t */\n\tinfo->type &= ~HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\tif (!((bp->attr.bp_addr <= dar) &&\n\t      (dar - bp->attr.bp_addr < bp->attr.bp_len)))\n\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\n\t/* Do not emulate user-space instructions, instead single-step them */\n\tif (user_mode(regs)) {\n\t\tcurrent->thread.last_hit_ubp = bp;\n\t\tregs->msr |= MSR_SE;\n\t\tgoto out;\n\t}\n\n\tstepped = 0;\n\tinstr = 0;\n\tif (!__get_user_inatomic(instr, (unsigned int *) regs->nip))\n\t\tstepped = emulate_step(regs, instr);\n\n\t/*\n\t * emulate_step() could not execute it. We've failed in reliably\n\t * handling the hw-breakpoint. Unregister it and throw a warning\n\t * message to let the user know about it.\n\t */\n\tif (!stepped) {\n\t\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at \"\n\t\t\t\"0x%lx will be disabled.\", info->address);\n\t\tperf_event_disable(bp);\n\t\tgoto out;\n\t}\n\t/*\n\t * As a policy, the callback is invoked in a 'trigger-after-execute'\n\t * fashion\n\t */\n\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\tperf_bp_event(bp, regs);\n\n\t__set_breakpoint(info);\nout:\n\trcu_read_unlock();\n\treturn rc;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "info"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "497-505",
          "snippet": "void __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nvoid __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_bp_event",
          "args": [
            "bp",
            "regs"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_disable",
          "args": [
            "bp"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Unable to handle hardware breakpoint. Breakpoint at \"\n\t\t\t\"0x%lx will be disabled.\"",
            "info->address"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emulate_step",
          "args": [
            "regs",
            "instr"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user_inatomic",
          "args": [
            "instr",
            "(unsigned int *) regs->nip"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_bp_event",
          "args": [
            "bp",
            "regs"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "bp_per_reg"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_disable",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg);\n\nint __kprobes hw_breakpoint_handler(struct die_args *args)\n{\n\tint rc = NOTIFY_STOP;\n\tstruct perf_event *bp;\n\tstruct pt_regs *regs = args->regs;\n\tint stepped = 1;\n\tstruct arch_hw_breakpoint *info;\n\tunsigned int instr;\n\tunsigned long dar = regs->dar;\n\n\t/* Disable breakpoints during exception handling */\n\thw_breakpoint_disable();\n\n\t/*\n\t * The counter may be concurrently released but that can only\n\t * occur from a call_rcu() path. We can then safely fetch\n\t * the breakpoint, use its callback, touch its counter\n\t * while we are in an rcu_read_lock() path.\n\t */\n\trcu_read_lock();\n\n\tbp = __this_cpu_read(bp_per_reg);\n\tif (!bp)\n\t\tgoto out;\n\tinfo = counter_arch_bp(bp);\n\n\t/*\n\t * Return early after invoking user-callback function without restoring\n\t * DABR if the breakpoint is from ptrace which always operates in\n\t * one-shot mode. The ptrace-ed process will receive the SIGTRAP signal\n\t * generated in do_dabr().\n\t */\n\tif (bp->overflow_handler == ptrace_triggered) {\n\t\tperf_bp_event(bp, regs);\n\t\trc = NOTIFY_DONE;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Verify if dar lies within the address range occupied by the symbol\n\t * being watched to filter extraneous exceptions.  If it doesn't,\n\t * we still need to single-step the instruction, but we don't\n\t * generate an event.\n\t */\n\tinfo->type &= ~HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\tif (!((bp->attr.bp_addr <= dar) &&\n\t      (dar - bp->attr.bp_addr < bp->attr.bp_len)))\n\t\tinfo->type |= HW_BRK_TYPE_EXTRANEOUS_IRQ;\n\n\t/* Do not emulate user-space instructions, instead single-step them */\n\tif (user_mode(regs)) {\n\t\tcurrent->thread.last_hit_ubp = bp;\n\t\tregs->msr |= MSR_SE;\n\t\tgoto out;\n\t}\n\n\tstepped = 0;\n\tinstr = 0;\n\tif (!__get_user_inatomic(instr, (unsigned int *) regs->nip))\n\t\tstepped = emulate_step(regs, instr);\n\n\t/*\n\t * emulate_step() could not execute it. We've failed in reliably\n\t * handling the hw-breakpoint. Unregister it and throw a warning\n\t * message to let the user know about it.\n\t */\n\tif (!stepped) {\n\t\tWARN(1, \"Unable to handle hardware breakpoint. Breakpoint at \"\n\t\t\t\"0x%lx will be disabled.\", info->address);\n\t\tperf_event_disable(bp);\n\t\tgoto out;\n\t}\n\t/*\n\t * As a policy, the callback is invoked in a 'trigger-after-execute'\n\t * fashion\n\t */\n\tif (!(info->type & HW_BRK_TYPE_EXTRANEOUS_IRQ))\n\t\tperf_bp_event(bp, regs);\n\n\t__set_breakpoint(info);\nout:\n\trcu_read_unlock();\n\treturn rc;\n}"
  },
  {
    "function_name": "thread_change_pc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "192-203",
    "snippet": "void thread_change_pc(struct task_struct *tsk, struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *info;\n\n\tif (likely(!tsk->thread.last_hit_ubp))\n\t\treturn;\n\n\tinfo = counter_arch_bp(tsk->thread.last_hit_ubp);\n\tregs->msr &= ~MSR_SE;\n\t__set_breakpoint(info);\n\ttsk->thread.last_hit_ubp = NULL;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "info"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "497-505",
          "snippet": "void __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nvoid __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "tsk->thread.last_hit_ubp"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!tsk->thread.last_hit_ubp"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid thread_change_pc(struct task_struct *tsk, struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *info;\n\n\tif (likely(!tsk->thread.last_hit_ubp))\n\t\treturn;\n\n\tinfo = counter_arch_bp(tsk->thread.last_hit_ubp);\n\tregs->msr &= ~MSR_SE;\n\t__set_breakpoint(info);\n\ttsk->thread.last_hit_ubp = NULL;\n}"
  },
  {
    "function_name": "arch_validate_hwbkpt_settings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "142-185",
    "snippet": "int arch_validate_hwbkpt_settings(struct perf_event *bp)\n{\n\tint ret = -EINVAL, length_max;\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\n\tif (!bp)\n\t\treturn ret;\n\n\tinfo->type = HW_BRK_TYPE_TRANSLATE;\n\tif (bp->attr.bp_type & HW_BREAKPOINT_R)\n\t\tinfo->type |= HW_BRK_TYPE_READ;\n\tif (bp->attr.bp_type & HW_BREAKPOINT_W)\n\t\tinfo->type |= HW_BRK_TYPE_WRITE;\n\tif (info->type == HW_BRK_TYPE_TRANSLATE)\n\t\t/* must set alteast read or write */\n\t\treturn ret;\n\tif (!(bp->attr.exclude_user))\n\t\tinfo->type |= HW_BRK_TYPE_USER;\n\tif (!(bp->attr.exclude_kernel))\n\t\tinfo->type |= HW_BRK_TYPE_KERNEL;\n\tif (!(bp->attr.exclude_hv))\n\t\tinfo->type |= HW_BRK_TYPE_HYP;\n\tinfo->address = bp->attr.bp_addr;\n\tinfo->len = bp->attr.bp_len;\n\n\t/*\n\t * Since breakpoint length can be a maximum of HW_BREAKPOINT_LEN(8)\n\t * and breakpoint addresses are aligned to nearest double-word\n\t * HW_BREAKPOINT_ALIGN by rounding off to the lower address, the\n\t * 'symbolsize' should satisfy the check below.\n\t */\n\tlength_max = 8; /* DABR */\n\tif (cpu_has_feature(CPU_FTR_DAWR)) {\n\t\tlength_max = 512 ; /* 64 doublewords */\n\t\t/* DAWR region can't cross 512 boundary */\n\t\tif ((bp->attr.bp_addr >> 10) != \n\t\t    ((bp->attr.bp_addr + bp->attr.bp_len - 1) >> 10))\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->len >\n\t    (length_max - (info->address & HW_BREAKPOINT_ALIGN)))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DAWR"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_validate_hwbkpt_settings(struct perf_event *bp)\n{\n\tint ret = -EINVAL, length_max;\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\n\tif (!bp)\n\t\treturn ret;\n\n\tinfo->type = HW_BRK_TYPE_TRANSLATE;\n\tif (bp->attr.bp_type & HW_BREAKPOINT_R)\n\t\tinfo->type |= HW_BRK_TYPE_READ;\n\tif (bp->attr.bp_type & HW_BREAKPOINT_W)\n\t\tinfo->type |= HW_BRK_TYPE_WRITE;\n\tif (info->type == HW_BRK_TYPE_TRANSLATE)\n\t\t/* must set alteast read or write */\n\t\treturn ret;\n\tif (!(bp->attr.exclude_user))\n\t\tinfo->type |= HW_BRK_TYPE_USER;\n\tif (!(bp->attr.exclude_kernel))\n\t\tinfo->type |= HW_BRK_TYPE_KERNEL;\n\tif (!(bp->attr.exclude_hv))\n\t\tinfo->type |= HW_BRK_TYPE_HYP;\n\tinfo->address = bp->attr.bp_addr;\n\tinfo->len = bp->attr.bp_len;\n\n\t/*\n\t * Since breakpoint length can be a maximum of HW_BREAKPOINT_LEN(8)\n\t * and breakpoint addresses are aligned to nearest double-word\n\t * HW_BREAKPOINT_ALIGN by rounding off to the lower address, the\n\t * 'symbolsize' should satisfy the check below.\n\t */\n\tlength_max = 8; /* DABR */\n\tif (cpu_has_feature(CPU_FTR_DAWR)) {\n\t\tlength_max = 512 ; /* 64 doublewords */\n\t\t/* DAWR region can't cross 512 boundary */\n\t\tif ((bp->attr.bp_addr >> 10) != \n\t\t    ((bp->attr.bp_addr + bp->attr.bp_len - 1) >> 10))\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->len >\n\t    (length_max - (info->address & HW_BREAKPOINT_ALIGN)))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_bp_generic_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "127-137",
    "snippet": "int arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_bp_generic_fields(int type, int *gen_bp_type)\n{\n\t*gen_bp_type = 0;\n\tif (type & HW_BRK_TYPE_READ)\n\t\t*gen_bp_type |= HW_BREAKPOINT_R;\n\tif (type & HW_BRK_TYPE_WRITE)\n\t\t*gen_bp_type |= HW_BREAKPOINT_W;\n\tif (*gen_bp_type == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "arch_check_bp_in_kernelspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "120-125",
    "snippet": "int arch_check_bp_in_kernelspace(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\n\treturn is_kernel_addr(info->address);\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_kernel_addr",
          "args": [
            "info->address"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint arch_check_bp_in_kernelspace(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\n\treturn is_kernel_addr(info->address);\n}"
  },
  {
    "function_name": "arch_unregister_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "106-115",
    "snippet": "void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t */\n\tif (bp->ctx && bp->ctx->task)\n\t\tbp->ctx->task->thread.last_hit_ubp = NULL;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t/*\n\t * If the breakpoint is unregistered between a hw_breakpoint_handler()\n\t * and the single_step_dabr_instruction(), then cleanup the breakpoint\n\t * restoration variables to prevent dangling pointers.\n\t */\n\tif (bp->ctx && bp->ctx->task)\n\t\tbp->ctx->task->thread.last_hit_ubp = NULL;\n}"
  },
  {
    "function_name": "arch_uninstall_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "89-100",
    "snippet": "void arch_uninstall_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct perf_event **slot = this_cpu_ptr(&bp_per_reg);\n\n\tif (*slot != bp) {\n\t\tWARN_ONCE(1, \"Can't find the breakpoint\");\n\t\treturn;\n\t}\n\n\t*slot = NULL;\n\thw_breakpoint_disable();\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hw_breakpoint_disable",
          "args": [],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Can't find the breakpoint\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bp_per_reg"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg);\n\nvoid arch_uninstall_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct perf_event **slot = this_cpu_ptr(&bp_per_reg);\n\n\tif (*slot != bp) {\n\t\tWARN_ONCE(1, \"Can't find the breakpoint\");\n\t\treturn;\n\t}\n\n\t*slot = NULL;\n\thw_breakpoint_disable();\n}"
  },
  {
    "function_name": "arch_install_hw_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "63-78",
    "snippet": "int arch_install_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\tstruct perf_event **slot = this_cpu_ptr(&bp_per_reg);\n\n\t*slot = bp;\n\n\t/*\n\t * Do not install DABR values if the instruction must be single-stepped.\n\t * If so, DABR will be populated in single_step_dabr_instruction().\n\t */\n\tif (current->thread.last_hit_ubp != bp)\n\t\t__set_breakpoint(info);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct perf_event *, bp_per_reg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "info"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "497-505",
          "snippet": "void __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nvoid __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&bp_per_reg"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "counter_arch_bp",
          "args": [
            "bp"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nstatic DEFINE_PER_CPU(struct perf_event *, bp_per_reg);\n\nint arch_install_hw_breakpoint(struct perf_event *bp)\n{\n\tstruct arch_hw_breakpoint *info = counter_arch_bp(bp);\n\tstruct perf_event **slot = this_cpu_ptr(&bp_per_reg);\n\n\t*slot = bp;\n\n\t/*\n\t * Do not install DABR values if the instruction must be single-stepped.\n\t * If so, DABR will be populated in single_step_dabr_instruction().\n\t */\n\tif (current->thread.last_hit_ubp != bp)\n\t\t__set_breakpoint(info);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hw_breakpoint_slots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
    "lines": "47-52",
    "snippet": "int hw_breakpoint_slots(int type)\n{\n\tif (type == TYPE_DATA)\n\t\treturn HBP_NUM;\n\treturn 0;\t\t/* no instruction breakpoints available */\n}",
    "includes": [
      "#include <asm/uaccess.h>",
      "#include <asm/sstep.h>",
      "#include <asm/processor.h>",
      "#include <asm/hw_breakpoint.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/percpu.h>",
      "#include <linux/kprobes.h>",
      "#include <linux/notifier.h>",
      "#include <linux/hw_breakpoint.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nint hw_breakpoint_slots(int type)\n{\n\tif (type == TYPE_DATA)\n\t\treturn HBP_NUM;\n\treturn 0;\t\t/* no instruction breakpoints available */\n}"
  }
]