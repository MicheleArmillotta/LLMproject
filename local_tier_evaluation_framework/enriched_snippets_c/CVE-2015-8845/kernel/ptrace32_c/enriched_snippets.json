[
  {
    "function_name": "compat_arch_ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace32.c",
    "lines": "47-317",
    "snippet": "long compat_arch_ptrace(struct task_struct *child, compat_long_t request,\n\t\t\tcompat_ulong_t caddr, compat_ulong_t cdata)\n{\n\tunsigned long addr = caddr;\n\tunsigned long data = cdata;\n\tint ret;\n\n\tswitch (request) {\n\t/*\n\t * Read 4 bytes of the other process' storage\n\t *  data is a pointer specifying where the user wants the\n\t *\t4 bytes copied into\n\t *  addr is a pointer in the user's storage that contains an 8 byte\n\t *\taddress in the other process of the 4 bytes that is to be read\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t * when I and D space are separate, these will need to be fixed.\n\t */\n\tcase PPC_PTRACE_PEEKTEXT_3264:\n\tcase PPC_PTRACE_PEEKDATA_3264: {\n\t\tu32 tmp;\n\t\tint copied;\n\t\tu32 __user * addrOthers;\n\n\t\tret = -EIO;\n\n\t\t/* Get the addr in the other process that we want to read */\n\t\tif (get_user(addrOthers, (u32 __user * __user *)addr) != 0)\n\t\t\tbreak;\n\n\t\tcopied = access_process_vm(child, (u64)addrOthers, &tmp,\n\t\t\t\tsizeof(tmp), 0);\n\t\tif (copied != sizeof(tmp))\n\t\t\tbreak;\n\t\tret = put_user(tmp, (u32 __user *)data);\n\t\tbreak;\n\t}\n\n\t/* Read a register (specified by ADDR) out of the \"user area\" */\n\tcase PTRACE_PEEKUSR: {\n\t\tint index;\n\t\tunsigned long tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n\t\tindex = (unsigned long) addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR32))\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/*\n\t\t\t * the user space code considers the floating point\n\t\t\t * to be an array of unsigned int (32 bits) - the\n\t\t\t * index passed in is based on this assumption.\n\t\t\t */\n\t\t\ttmp = ((unsigned int *)child->thread.fp_state.fpr)\n\t\t\t\t[FPRINDEX(index)];\n\t\t}\n\t\tret = put_user((unsigned int)tmp, (u32 __user *)data);\n\t\tbreak;\n\t}\n  \n\t/*\n\t * Read 4 bytes out of the other process' pt_regs area\n\t *  data is a pointer specifying where the user wants the\n\t *\t4 bytes copied into\n\t *  addr is the offset into the other process' pt_regs structure\n\t *\tthat is to be read\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t */\n\tcase PPC_PTRACE_PEEKUSR_3264: {\n\t\tu32 index;\n\t\tu32 reg32bits;\n\t\tu64 tmp;\n\t\tu32 numReg;\n\t\tu32 part;\n\n\t\tret = -EIO;\n\t\t/* Determine which register the user wants */\n\t\tindex = (u64)addr >> 2;\n\t\tnumReg = index / 2;\n\t\t/* Determine which part of the register the user wants */\n\t\tif (index % 2)\n\t\t\tpart = 1;  /* want the 2nd half of the register (right-most). */\n\t\telse\n\t\t\tpart = 0;  /* want the 1st half of the register (left-most). */\n\n\t\t/* Validate the input - check to see if address is on the wrong boundary\n\t\t * or beyond the end of the user area\n\t\t */\n\t\tif ((addr & 3) || numReg > PT_FPSCR)\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (numReg >= PT_FPR0) {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/* get 64 bit FPR */\n\t\t\ttmp = child->thread.fp_state.fpr[numReg - PT_FPR0][0];\n\t\t} else { /* register within PT_REGS struct */\n\t\t\tunsigned long tmp2;\n\t\t\tret = ptrace_get_reg(child, numReg, &tmp2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\ttmp = tmp2;\n\t\t} \n\t\treg32bits = ((u32*)&tmp)[part];\n\t\tret = put_user(reg32bits, (u32 __user *)data);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Write 4 bytes into the other process' storage\n\t *  data is the 4 bytes that the user wants written\n\t *  addr is a pointer in the user's storage that contains an\n\t *\t8 byte address in the other process where the 4 bytes\n\t *\tthat is to be written\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t * when I and D space are separate, these will need to be fixed.\n\t */\n\tcase PPC_PTRACE_POKETEXT_3264:\n\tcase PPC_PTRACE_POKEDATA_3264: {\n\t\tu32 tmp = data;\n\t\tu32 __user * addrOthers;\n\n\t\t/* Get the addr in the other process that we want to write into */\n\t\tret = -EIO;\n\t\tif (get_user(addrOthers, (u32 __user * __user *)addr) != 0)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (access_process_vm(child, (u64)addrOthers, &tmp,\n\t\t\t\t\tsizeof(tmp), 1) == sizeof(tmp))\n\t\t\tbreak;\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n\t\tindex = (unsigned long) addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR32))\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/*\n\t\t\t * the user space code considers the floating point\n\t\t\t * to be an array of unsigned int (32 bits) - the\n\t\t\t * index passed in is based on this assumption.\n\t\t\t */\n\t\t\t((unsigned int *)child->thread.fp_state.fpr)\n\t\t\t\t[FPRINDEX(index)] = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Write 4 bytes into the other process' pt_regs area\n\t *  data is the 4 bytes that the user wants written\n\t *  addr is the offset into the other process' pt_regs structure\n\t *\tthat is to be written into\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t */\n\tcase PPC_PTRACE_POKEUSR_3264: {\n\t\tu32 index;\n\t\tu32 numReg;\n\n\t\tret = -EIO;\n\t\t/* Determine which register the user wants */\n\t\tindex = (u64)addr >> 2;\n\t\tnumReg = index / 2;\n\n\t\t/*\n\t\t * Validate the input - check to see if address is on the\n\t\t * wrong boundary or beyond the end of the user area\n\t\t */\n\t\tif ((addr & 3) || (numReg > PT_FPSCR))\n\t\t\tbreak;\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (numReg < PT_FPR0) {\n\t\t\tunsigned long freg;\n\t\t\tret = ptrace_get_reg(child, numReg, &freg);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (index % 2)\n\t\t\t\tfreg = (freg & ~0xfffffffful) | (data & 0xfffffffful);\n\t\t\telse\n\t\t\t\tfreg = (freg & 0xfffffffful) | (data << 32);\n\t\t\tret = ptrace_put_reg(child, numReg, freg);\n\t\t} else {\n\t\t\tu64 *tmp;\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/* get 64 bit FPR ... */\n\t\t\ttmp = &child->thread.fp_state.fpr[numReg - PT_FPR0][0];\n\t\t\t/* ... write the 32 bit part we want */\n\t\t\t((u32 *)tmp)[index % 2] = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG: {\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tunsigned long dabr_fake;\n#endif\n\t\tret = -EINVAL;\n\t\t/* We only support one DABR and no IABRS at the moment */\n\t\tif (addr > 0)\n\t\t\tbreak;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tret = put_user(child->thread.debug.dac1, (u32 __user *)data);\n#else\n\t\tdabr_fake = (\n\t\t\t(child->thread.hw_brk.address & (~HW_BRK_TYPE_DABR)) |\n\t\t\t(child->thread.hw_brk.type & HW_BRK_TYPE_DABR));\n\t\tret = put_user(dabr_fake, (u32 __user *)data);\n#endif\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(\n\t\t\tchild, task_user_regset_view(current), 0,\n\t\t\t0, PT_REGS_COUNT * sizeof(compat_long_t),\n\t\t\tcompat_ptr(data));\n\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(\n\t\t\tchild, task_user_regset_view(current), 0,\n\t\t\t0, PT_REGS_COUNT * sizeof(compat_long_t),\n\t\t\tcompat_ptr(data));\n\n\tcase PTRACE_GETFPREGS:\n\tcase PTRACE_SETFPREGS:\n\tcase PTRACE_GETVRREGS:\n\tcase PTRACE_SETVRREGS:\n\tcase PTRACE_GETVSRREGS:\n\tcase PTRACE_SETVSRREGS:\n\tcase PTRACE_GETREGS64:\n\tcase PTRACE_SETREGS64:\n\tcase PTRACE_KILL:\n\tcase PTRACE_SINGLESTEP:\n\tcase PTRACE_DETACH:\n\tcase PTRACE_SET_DEBUGREG:\n\tcase PTRACE_SYSCALL:\n\tcase PTRACE_CONT:\n\tcase PPC_PTRACE_GETHWDBGINFO:\n\tcase PPC_PTRACE_SETHWDEBUG:\n\tcase PPC_PTRACE_DELHWDEBUG:\n\t\tret = arch_ptrace(child, request, addr, data);\n\t\tbreak;\n\n\tdefault:\n\t\tret = compat_ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/switch_to.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/signal.h>",
      "#include <linux/security.h>",
      "#include <linux/user.h>",
      "#include <linux/regset.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/errno.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_ptrace_request",
          "args": [
            "child",
            "request",
            "addr",
            "data"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_ptrace",
          "args": [
            "child",
            "request",
            "addr",
            "data"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "compat_arch_ptrace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace32.c",
          "lines": "47-317",
          "snippet": "long compat_arch_ptrace(struct task_struct *child, compat_long_t request,\n\t\t\tcompat_ulong_t caddr, compat_ulong_t cdata)\n{\n\tunsigned long addr = caddr;\n\tunsigned long data = cdata;\n\tint ret;\n\n\tswitch (request) {\n\t/*\n\t * Read 4 bytes of the other process' storage\n\t *  data is a pointer specifying where the user wants the\n\t *\t4 bytes copied into\n\t *  addr is a pointer in the user's storage that contains an 8 byte\n\t *\taddress in the other process of the 4 bytes that is to be read\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t * when I and D space are separate, these will need to be fixed.\n\t */\n\tcase PPC_PTRACE_PEEKTEXT_3264:\n\tcase PPC_PTRACE_PEEKDATA_3264: {\n\t\tu32 tmp;\n\t\tint copied;\n\t\tu32 __user * addrOthers;\n\n\t\tret = -EIO;\n\n\t\t/* Get the addr in the other process that we want to read */\n\t\tif (get_user(addrOthers, (u32 __user * __user *)addr) != 0)\n\t\t\tbreak;\n\n\t\tcopied = access_process_vm(child, (u64)addrOthers, &tmp,\n\t\t\t\tsizeof(tmp), 0);\n\t\tif (copied != sizeof(tmp))\n\t\t\tbreak;\n\t\tret = put_user(tmp, (u32 __user *)data);\n\t\tbreak;\n\t}\n\n\t/* Read a register (specified by ADDR) out of the \"user area\" */\n\tcase PTRACE_PEEKUSR: {\n\t\tint index;\n\t\tunsigned long tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n\t\tindex = (unsigned long) addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR32))\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/*\n\t\t\t * the user space code considers the floating point\n\t\t\t * to be an array of unsigned int (32 bits) - the\n\t\t\t * index passed in is based on this assumption.\n\t\t\t */\n\t\t\ttmp = ((unsigned int *)child->thread.fp_state.fpr)\n\t\t\t\t[FPRINDEX(index)];\n\t\t}\n\t\tret = put_user((unsigned int)tmp, (u32 __user *)data);\n\t\tbreak;\n\t}\n  \n\t/*\n\t * Read 4 bytes out of the other process' pt_regs area\n\t *  data is a pointer specifying where the user wants the\n\t *\t4 bytes copied into\n\t *  addr is the offset into the other process' pt_regs structure\n\t *\tthat is to be read\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t */\n\tcase PPC_PTRACE_PEEKUSR_3264: {\n\t\tu32 index;\n\t\tu32 reg32bits;\n\t\tu64 tmp;\n\t\tu32 numReg;\n\t\tu32 part;\n\n\t\tret = -EIO;\n\t\t/* Determine which register the user wants */\n\t\tindex = (u64)addr >> 2;\n\t\tnumReg = index / 2;\n\t\t/* Determine which part of the register the user wants */\n\t\tif (index % 2)\n\t\t\tpart = 1;  /* want the 2nd half of the register (right-most). */\n\t\telse\n\t\t\tpart = 0;  /* want the 1st half of the register (left-most). */\n\n\t\t/* Validate the input - check to see if address is on the wrong boundary\n\t\t * or beyond the end of the user area\n\t\t */\n\t\tif ((addr & 3) || numReg > PT_FPSCR)\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (numReg >= PT_FPR0) {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/* get 64 bit FPR */\n\t\t\ttmp = child->thread.fp_state.fpr[numReg - PT_FPR0][0];\n\t\t} else { /* register within PT_REGS struct */\n\t\t\tunsigned long tmp2;\n\t\t\tret = ptrace_get_reg(child, numReg, &tmp2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\ttmp = tmp2;\n\t\t} \n\t\treg32bits = ((u32*)&tmp)[part];\n\t\tret = put_user(reg32bits, (u32 __user *)data);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Write 4 bytes into the other process' storage\n\t *  data is the 4 bytes that the user wants written\n\t *  addr is a pointer in the user's storage that contains an\n\t *\t8 byte address in the other process where the 4 bytes\n\t *\tthat is to be written\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t * when I and D space are separate, these will need to be fixed.\n\t */\n\tcase PPC_PTRACE_POKETEXT_3264:\n\tcase PPC_PTRACE_POKEDATA_3264: {\n\t\tu32 tmp = data;\n\t\tu32 __user * addrOthers;\n\n\t\t/* Get the addr in the other process that we want to write into */\n\t\tret = -EIO;\n\t\tif (get_user(addrOthers, (u32 __user * __user *)addr) != 0)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (access_process_vm(child, (u64)addrOthers, &tmp,\n\t\t\t\t\tsizeof(tmp), 1) == sizeof(tmp))\n\t\t\tbreak;\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n\t\tindex = (unsigned long) addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR32))\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/*\n\t\t\t * the user space code considers the floating point\n\t\t\t * to be an array of unsigned int (32 bits) - the\n\t\t\t * index passed in is based on this assumption.\n\t\t\t */\n\t\t\t((unsigned int *)child->thread.fp_state.fpr)\n\t\t\t\t[FPRINDEX(index)] = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Write 4 bytes into the other process' pt_regs area\n\t *  data is the 4 bytes that the user wants written\n\t *  addr is the offset into the other process' pt_regs structure\n\t *\tthat is to be written into\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t */\n\tcase PPC_PTRACE_POKEUSR_3264: {\n\t\tu32 index;\n\t\tu32 numReg;\n\n\t\tret = -EIO;\n\t\t/* Determine which register the user wants */\n\t\tindex = (u64)addr >> 2;\n\t\tnumReg = index / 2;\n\n\t\t/*\n\t\t * Validate the input - check to see if address is on the\n\t\t * wrong boundary or beyond the end of the user area\n\t\t */\n\t\tif ((addr & 3) || (numReg > PT_FPSCR))\n\t\t\tbreak;\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (numReg < PT_FPR0) {\n\t\t\tunsigned long freg;\n\t\t\tret = ptrace_get_reg(child, numReg, &freg);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (index % 2)\n\t\t\t\tfreg = (freg & ~0xfffffffful) | (data & 0xfffffffful);\n\t\t\telse\n\t\t\t\tfreg = (freg & 0xfffffffful) | (data << 32);\n\t\t\tret = ptrace_put_reg(child, numReg, freg);\n\t\t} else {\n\t\t\tu64 *tmp;\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/* get 64 bit FPR ... */\n\t\t\ttmp = &child->thread.fp_state.fpr[numReg - PT_FPR0][0];\n\t\t\t/* ... write the 32 bit part we want */\n\t\t\t((u32 *)tmp)[index % 2] = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG: {\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tunsigned long dabr_fake;\n#endif\n\t\tret = -EINVAL;\n\t\t/* We only support one DABR and no IABRS at the moment */\n\t\tif (addr > 0)\n\t\t\tbreak;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tret = put_user(child->thread.debug.dac1, (u32 __user *)data);\n#else\n\t\tdabr_fake = (\n\t\t\t(child->thread.hw_brk.address & (~HW_BRK_TYPE_DABR)) |\n\t\t\t(child->thread.hw_brk.type & HW_BRK_TYPE_DABR));\n\t\tret = put_user(dabr_fake, (u32 __user *)data);\n#endif\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(\n\t\t\tchild, task_user_regset_view(current), 0,\n\t\t\t0, PT_REGS_COUNT * sizeof(compat_long_t),\n\t\t\tcompat_ptr(data));\n\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(\n\t\t\tchild, task_user_regset_view(current), 0,\n\t\t\t0, PT_REGS_COUNT * sizeof(compat_long_t),\n\t\t\tcompat_ptr(data));\n\n\tcase PTRACE_GETFPREGS:\n\tcase PTRACE_SETFPREGS:\n\tcase PTRACE_GETVRREGS:\n\tcase PTRACE_SETVRREGS:\n\tcase PTRACE_GETVSRREGS:\n\tcase PTRACE_SETVSRREGS:\n\tcase PTRACE_GETREGS64:\n\tcase PTRACE_SETREGS64:\n\tcase PTRACE_KILL:\n\tcase PTRACE_SINGLESTEP:\n\tcase PTRACE_DETACH:\n\tcase PTRACE_SET_DEBUGREG:\n\tcase PTRACE_SYSCALL:\n\tcase PTRACE_CONT:\n\tcase PPC_PTRACE_GETHWDBGINFO:\n\tcase PPC_PTRACE_SETHWDEBUG:\n\tcase PPC_PTRACE_DELHWDEBUG:\n\t\tret = arch_ptrace(child, request, addr, data);\n\t\tbreak;\n\n\tdefault:\n\t\tret = compat_ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "copy_regset_from_user",
          "args": [
            "child",
            "task_user_regset_view(current)",
            "0",
            "0",
            "PT_REGS_COUNT * sizeof(compat_long_t)",
            "compat_ptr(data)"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "data"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_user_regset_view",
          "args": [
            "current"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "task_user_regset_view",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "842-849",
          "snippet": "const struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_PPC64\n\tif (test_tsk_thread_flag(task, TIF_32BIT))\n\t\treturn &user_ppc_compat_view;\n#endif\n\treturn &user_ppc_native_view;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};\n\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_PPC64\n\tif (test_tsk_thread_flag(task, TIF_32BIT))\n\t\treturn &user_ppc_compat_view;\n#endif\n\treturn &user_ppc_native_view;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_regset_to_user",
          "args": [
            "child",
            "task_user_regset_view(current)",
            "0",
            "0",
            "PT_REGS_COUNT * sizeof(compat_long_t)",
            "compat_ptr(data)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "data"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "dabr_fake",
            "(u32 __user *)data"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "child->thread.debug.dac1",
            "(u32 __user *)data"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "child"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_put_reg",
          "args": [
            "child",
            "numReg",
            "freg"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_put_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "245-262",
          "snippet": "int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define PT_MAX_PUT_REG\tPT_CCR",
            "#define PT_MAX_PUT_REG\tPT_MQ"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#define PT_MAX_PUT_REG\tPT_CCR\n#define PT_MAX_PUT_REG\tPT_MQ\n\nint ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_get_reg",
          "args": [
            "child",
            "numReg",
            "&freg"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "221-240",
          "snippet": "int ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "child->thread.regs"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPRINDEX",
          "args": [
            "index"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "child->thread.regs"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_process_vm",
          "args": [
            "child",
            "(u64)addrOthers",
            "&tmp",
            "sizeof(tmp)",
            "1"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "addrOthers",
            "(u32 __user * __user *)addr) != 0"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_dscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/ptrace.c",
          "lines": "197-200",
          "snippet": "static int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <trace/events/syscalls.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/syscall.h>",
            "#include <linux/audit.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/signal.h>",
            "#include <linux/security.h>",
            "#include <linux/user.h>",
            "#include <linux/elf.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/regset.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/errno.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <trace/events/syscalls.h>\n#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/context_tracking.h>\n#include <linux/perf_event.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/syscall.h>\n#include <linux/audit.h>\n#include <linux/seccomp.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/elf.h>\n#include <linux/tracehook.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "reg32bits",
            "(u32 __user *)data"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "child->thread.regs"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(unsigned int)tmp",
            "(u32 __user *)data"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FPRINDEX",
          "args": [
            "index"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "child->thread.regs"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "tmp",
            "(u32 __user *)data"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_process_vm",
          "args": [
            "child",
            "(u64)addrOthers",
            "&tmp",
            "sizeof(tmp)",
            "0"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/switch_to.h>\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/user.h>\n#include <linux/regset.h>\n#include <linux/ptrace.h>\n#include <linux/errno.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nlong compat_arch_ptrace(struct task_struct *child, compat_long_t request,\n\t\t\tcompat_ulong_t caddr, compat_ulong_t cdata)\n{\n\tunsigned long addr = caddr;\n\tunsigned long data = cdata;\n\tint ret;\n\n\tswitch (request) {\n\t/*\n\t * Read 4 bytes of the other process' storage\n\t *  data is a pointer specifying where the user wants the\n\t *\t4 bytes copied into\n\t *  addr is a pointer in the user's storage that contains an 8 byte\n\t *\taddress in the other process of the 4 bytes that is to be read\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t * when I and D space are separate, these will need to be fixed.\n\t */\n\tcase PPC_PTRACE_PEEKTEXT_3264:\n\tcase PPC_PTRACE_PEEKDATA_3264: {\n\t\tu32 tmp;\n\t\tint copied;\n\t\tu32 __user * addrOthers;\n\n\t\tret = -EIO;\n\n\t\t/* Get the addr in the other process that we want to read */\n\t\tif (get_user(addrOthers, (u32 __user * __user *)addr) != 0)\n\t\t\tbreak;\n\n\t\tcopied = access_process_vm(child, (u64)addrOthers, &tmp,\n\t\t\t\tsizeof(tmp), 0);\n\t\tif (copied != sizeof(tmp))\n\t\t\tbreak;\n\t\tret = put_user(tmp, (u32 __user *)data);\n\t\tbreak;\n\t}\n\n\t/* Read a register (specified by ADDR) out of the \"user area\" */\n\tcase PTRACE_PEEKUSR: {\n\t\tint index;\n\t\tunsigned long tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n\t\tindex = (unsigned long) addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR32))\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/*\n\t\t\t * the user space code considers the floating point\n\t\t\t * to be an array of unsigned int (32 bits) - the\n\t\t\t * index passed in is based on this assumption.\n\t\t\t */\n\t\t\ttmp = ((unsigned int *)child->thread.fp_state.fpr)\n\t\t\t\t[FPRINDEX(index)];\n\t\t}\n\t\tret = put_user((unsigned int)tmp, (u32 __user *)data);\n\t\tbreak;\n\t}\n  \n\t/*\n\t * Read 4 bytes out of the other process' pt_regs area\n\t *  data is a pointer specifying where the user wants the\n\t *\t4 bytes copied into\n\t *  addr is the offset into the other process' pt_regs structure\n\t *\tthat is to be read\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t */\n\tcase PPC_PTRACE_PEEKUSR_3264: {\n\t\tu32 index;\n\t\tu32 reg32bits;\n\t\tu64 tmp;\n\t\tu32 numReg;\n\t\tu32 part;\n\n\t\tret = -EIO;\n\t\t/* Determine which register the user wants */\n\t\tindex = (u64)addr >> 2;\n\t\tnumReg = index / 2;\n\t\t/* Determine which part of the register the user wants */\n\t\tif (index % 2)\n\t\t\tpart = 1;  /* want the 2nd half of the register (right-most). */\n\t\telse\n\t\t\tpart = 0;  /* want the 1st half of the register (left-most). */\n\n\t\t/* Validate the input - check to see if address is on the wrong boundary\n\t\t * or beyond the end of the user area\n\t\t */\n\t\tif ((addr & 3) || numReg > PT_FPSCR)\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (numReg >= PT_FPR0) {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/* get 64 bit FPR */\n\t\t\ttmp = child->thread.fp_state.fpr[numReg - PT_FPR0][0];\n\t\t} else { /* register within PT_REGS struct */\n\t\t\tunsigned long tmp2;\n\t\t\tret = ptrace_get_reg(child, numReg, &tmp2);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\ttmp = tmp2;\n\t\t} \n\t\treg32bits = ((u32*)&tmp)[part];\n\t\tret = put_user(reg32bits, (u32 __user *)data);\n\t\tbreak;\n\t}\n\n\t/*\n\t * Write 4 bytes into the other process' storage\n\t *  data is the 4 bytes that the user wants written\n\t *  addr is a pointer in the user's storage that contains an\n\t *\t8 byte address in the other process where the 4 bytes\n\t *\tthat is to be written\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t * when I and D space are separate, these will need to be fixed.\n\t */\n\tcase PPC_PTRACE_POKETEXT_3264:\n\tcase PPC_PTRACE_POKEDATA_3264: {\n\t\tu32 tmp = data;\n\t\tu32 __user * addrOthers;\n\n\t\t/* Get the addr in the other process that we want to write into */\n\t\tret = -EIO;\n\t\tif (get_user(addrOthers, (u32 __user * __user *)addr) != 0)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (access_process_vm(child, (u64)addrOthers, &tmp,\n\t\t\t\t\tsizeof(tmp), 1) == sizeof(tmp))\n\t\t\tbreak;\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n\t\tindex = (unsigned long) addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR32))\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/*\n\t\t\t * the user space code considers the floating point\n\t\t\t * to be an array of unsigned int (32 bits) - the\n\t\t\t * index passed in is based on this assumption.\n\t\t\t */\n\t\t\t((unsigned int *)child->thread.fp_state.fpr)\n\t\t\t\t[FPRINDEX(index)] = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\t/*\n\t * Write 4 bytes into the other process' pt_regs area\n\t *  data is the 4 bytes that the user wants written\n\t *  addr is the offset into the other process' pt_regs structure\n\t *\tthat is to be written into\n\t * (this is run in a 32-bit process looking at a 64-bit process)\n\t */\n\tcase PPC_PTRACE_POKEUSR_3264: {\n\t\tu32 index;\n\t\tu32 numReg;\n\n\t\tret = -EIO;\n\t\t/* Determine which register the user wants */\n\t\tindex = (u64)addr >> 2;\n\t\tnumReg = index / 2;\n\n\t\t/*\n\t\t * Validate the input - check to see if address is on the\n\t\t * wrong boundary or beyond the end of the user area\n\t\t */\n\t\tif ((addr & 3) || (numReg > PT_FPSCR))\n\t\t\tbreak;\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (numReg < PT_FPR0) {\n\t\t\tunsigned long freg;\n\t\t\tret = ptrace_get_reg(child, numReg, &freg);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (index % 2)\n\t\t\t\tfreg = (freg & ~0xfffffffful) | (data & 0xfffffffful);\n\t\t\telse\n\t\t\t\tfreg = (freg & 0xfffffffful) | (data << 32);\n\t\t\tret = ptrace_put_reg(child, numReg, freg);\n\t\t} else {\n\t\t\tu64 *tmp;\n\t\t\tflush_fp_to_thread(child);\n\t\t\t/* get 64 bit FPR ... */\n\t\t\ttmp = &child->thread.fp_state.fpr[numReg - PT_FPR0][0];\n\t\t\t/* ... write the 32 bit part we want */\n\t\t\t((u32 *)tmp)[index % 2] = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG: {\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tunsigned long dabr_fake;\n#endif\n\t\tret = -EINVAL;\n\t\t/* We only support one DABR and no IABRS at the moment */\n\t\tif (addr > 0)\n\t\t\tbreak;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tret = put_user(child->thread.debug.dac1, (u32 __user *)data);\n#else\n\t\tdabr_fake = (\n\t\t\t(child->thread.hw_brk.address & (~HW_BRK_TYPE_DABR)) |\n\t\t\t(child->thread.hw_brk.type & HW_BRK_TYPE_DABR));\n\t\tret = put_user(dabr_fake, (u32 __user *)data);\n#endif\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(\n\t\t\tchild, task_user_regset_view(current), 0,\n\t\t\t0, PT_REGS_COUNT * sizeof(compat_long_t),\n\t\t\tcompat_ptr(data));\n\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(\n\t\t\tchild, task_user_regset_view(current), 0,\n\t\t\t0, PT_REGS_COUNT * sizeof(compat_long_t),\n\t\t\tcompat_ptr(data));\n\n\tcase PTRACE_GETFPREGS:\n\tcase PTRACE_SETFPREGS:\n\tcase PTRACE_GETVRREGS:\n\tcase PTRACE_SETVRREGS:\n\tcase PTRACE_GETVSRREGS:\n\tcase PTRACE_SETVSRREGS:\n\tcase PTRACE_GETREGS64:\n\tcase PTRACE_SETREGS64:\n\tcase PTRACE_KILL:\n\tcase PTRACE_SINGLESTEP:\n\tcase PTRACE_DETACH:\n\tcase PTRACE_SET_DEBUGREG:\n\tcase PTRACE_SYSCALL:\n\tcase PTRACE_CONT:\n\tcase PPC_PTRACE_GETHWDBGINFO:\n\tcase PPC_PTRACE_SETHWDEBUG:\n\tcase PPC_PTRACE_DELHWDEBUG:\n\t\tret = arch_ptrace(child, request, addr, data);\n\t\tbreak;\n\n\tdefault:\n\t\tret = compat_ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  }
]