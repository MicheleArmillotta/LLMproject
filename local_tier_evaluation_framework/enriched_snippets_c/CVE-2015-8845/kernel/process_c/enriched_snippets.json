[
  {
    "function_name": "arch_randomize_brk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1633-1656",
    "snippet": "unsigned long arch_randomize_brk(struct mm_struct *mm)\n{\n\tunsigned long base = mm->brk;\n\tunsigned long ret;\n\n#ifdef CONFIG_PPC_STD_MMU_64\n\t/*\n\t * If we are using 1TB segments and we are allowed to randomise\n\t * the heap, we can put it above 1TB so it is backed by a 1TB\n\t * segment. Otherwise the heap will be in the bottom 1TB\n\t * which always uses 256MB segments and this may result in a\n\t * performance penalty.\n\t */\n\tif (!is_32bit_task() && (mmu_highuser_ssize == MMU_SEGSIZE_1T))\n\t\tbase = max_t(unsigned long, mm->brk, 1UL << SID_SHIFT_1T);\n#endif\n\n\tret = PAGE_ALIGN(base + brk_rnd());\n\n\tif (ret < mm->brk)\n\t\treturn mm->brk;\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "base + brk_rnd()"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brk_rnd",
          "args": [],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "brk_rnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "1620-1631",
          "snippet": "static inline unsigned long brk_rnd(void)\n{\n        unsigned long rnd = 0;\n\n\t/* 8MB for 32bit, 1GB for 64bit */\n\tif (is_32bit_task())\n\t\trnd = (long)(get_random_int() % (1<<(23-PAGE_SHIFT)));\n\telse\n\t\trnd = (long)(get_random_int() % (1<<(30-PAGE_SHIFT)));\n\n\treturn rnd << PAGE_SHIFT;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline unsigned long brk_rnd(void)\n{\n        unsigned long rnd = 0;\n\n\t/* 8MB for 32bit, 1GB for 64bit */\n\tif (is_32bit_task())\n\t\trnd = (long)(get_random_int() % (1<<(23-PAGE_SHIFT)));\n\telse\n\t\trnd = (long)(get_random_int() % (1<<(30-PAGE_SHIFT)));\n\n\treturn rnd << PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "unsignedlong",
            "mm->brk",
            "1UL << SID_SHIFT_1T"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nunsigned long arch_randomize_brk(struct mm_struct *mm)\n{\n\tunsigned long base = mm->brk;\n\tunsigned long ret;\n\n#ifdef CONFIG_PPC_STD_MMU_64\n\t/*\n\t * If we are using 1TB segments and we are allowed to randomise\n\t * the heap, we can put it above 1TB so it is backed by a 1TB\n\t * segment. Otherwise the heap will be in the bottom 1TB\n\t * which always uses 256MB segments and this may result in a\n\t * performance penalty.\n\t */\n\tif (!is_32bit_task() && (mmu_highuser_ssize == MMU_SEGSIZE_1T))\n\t\tbase = max_t(unsigned long, mm->brk, 1UL << SID_SHIFT_1T);\n#endif\n\n\tret = PAGE_ALIGN(base + brk_rnd());\n\n\tif (ret < mm->brk)\n\t\treturn mm->brk;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "brk_rnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1620-1631",
    "snippet": "static inline unsigned long brk_rnd(void)\n{\n        unsigned long rnd = 0;\n\n\t/* 8MB for 32bit, 1GB for 64bit */\n\tif (is_32bit_task())\n\t\trnd = (long)(get_random_int() % (1<<(23-PAGE_SHIFT)));\n\telse\n\t\trnd = (long)(get_random_int() % (1<<(30-PAGE_SHIFT)));\n\n\treturn rnd << PAGE_SHIFT;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline unsigned long brk_rnd(void)\n{\n        unsigned long rnd = 0;\n\n\t/* 8MB for 32bit, 1GB for 64bit */\n\tif (is_32bit_task())\n\t\trnd = (long)(get_random_int() % (1<<(23-PAGE_SHIFT)));\n\telse\n\t\trnd = (long)(get_random_int() % (1<<(30-PAGE_SHIFT)));\n\n\treturn rnd << PAGE_SHIFT;\n}"
  },
  {
    "function_name": "arch_align_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1613-1618",
    "snippet": "unsigned long arch_align_stack(unsigned long sp)\n{\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tsp -= get_random_int() & ~PAGE_MASK;\n\treturn sp & ~0xf;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nunsigned long arch_align_stack(unsigned long sp)\n{\n\tif (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)\n\t\tsp -= get_random_int() & ~PAGE_MASK;\n\treturn sp & ~0xf;\n}"
  },
  {
    "function_name": "__ppc64_runlatch_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1600-1610",
    "snippet": "void notrace __ppc64_runlatch_off(void)\n{\n\tstruct thread_info *ti = current_thread_info();\n\tunsigned long ctrl;\n\n\tti->local_flags &= ~_TLF_RUNLATCH;\n\n\tctrl = mfspr(SPRN_CTRLF);\n\tctrl &= ~CTRL_RUNLATCH;\n\tmtspr(SPRN_CTRLT, ctrl);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_CTRLT",
            "ctrl"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_CTRLF"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid notrace __ppc64_runlatch_off(void)\n{\n\tstruct thread_info *ti = current_thread_info();\n\tunsigned long ctrl;\n\n\tti->local_flags &= ~_TLF_RUNLATCH;\n\n\tctrl = mfspr(SPRN_CTRLF);\n\tctrl &= ~CTRL_RUNLATCH;\n\tmtspr(SPRN_CTRLT, ctrl);\n}"
  },
  {
    "function_name": "__ppc64_runlatch_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1587-1597",
    "snippet": "void notrace __ppc64_runlatch_on(void)\n{\n\tstruct thread_info *ti = current_thread_info();\n\tunsigned long ctrl;\n\n\tctrl = mfspr(SPRN_CTRLF);\n\tctrl |= CTRL_RUNLATCH;\n\tmtspr(SPRN_CTRLT, ctrl);\n\n\tti->local_flags |= _TLF_RUNLATCH;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_CTRLT",
            "ctrl"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_CTRLF"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid notrace __ppc64_runlatch_on(void)\n{\n\tstruct thread_info *ti = current_thread_info();\n\tunsigned long ctrl;\n\n\tctrl = mfspr(SPRN_CTRLF);\n\tctrl |= CTRL_RUNLATCH;\n\tmtspr(SPRN_CTRLT, ctrl);\n\n\tti->local_flags |= _TLF_RUNLATCH;\n}"
  },
  {
    "function_name": "show_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1522-1583",
    "snippet": "void show_stack(struct task_struct *tsk, unsigned long *stack)\n{\n\tunsigned long sp, ip, lr, newsp;\n\tint count = 0;\n\tint firstframe = 1;\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tint curr_frame = current->curr_ret_stack;\n\textern void return_to_handler(void);\n\tunsigned long rth = (unsigned long)return_to_handler;\n#endif\n\n\tsp = (unsigned long) stack;\n\tif (tsk == NULL)\n\t\ttsk = current;\n\tif (sp == 0) {\n\t\tif (tsk == current)\n\t\t\tsp = current_stack_pointer();\n\t\telse\n\t\t\tsp = tsk->thread.ksp;\n\t}\n\n\tlr = 0;\n\tprintk(\"Call Trace:\\n\");\n\tdo {\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tstack = (unsigned long *) sp;\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!firstframe || ip != lr) {\n\t\t\tprintk(\"[\"REG\"] [\"REG\"] %pS\", sp, ip, (void *)ip);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\t\t\tif ((ip == rth) && curr_frame >= 0) {\n\t\t\t\tprintk(\" (%pS)\",\n\t\t\t\t       (void *)current->ret_stack[curr_frame].ret);\n\t\t\t\tcurr_frame--;\n\t\t\t}\n#endif\n\t\t\tif (firstframe)\n\t\t\t\tprintk(\" (unreliable)\");\n\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tfirstframe = 0;\n\n\t\t/*\n\t\t * See if this is an exception frame.\n\t\t * We look for the \"regshere\" marker in the current frame.\n\t\t */\n\t\tif (validate_sp(sp, tsk, STACK_INT_FRAME_SIZE)\n\t\t    && stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\tstruct pt_regs *regs = (struct pt_regs *)\n\t\t\t\t(sp + STACK_FRAME_OVERHEAD);\n\t\t\tlr = regs->link;\n\t\t\tprintk(\"--- interrupt: %lx at %pS\\n    LR = %pS\\n\",\n\t\t\t       regs->trap, (void *)regs->nip, (void *)lr);\n\t\t\tfirstframe = 1;\n\t\t}\n\n\t\tsp = newsp;\n\t} while (count++ < kstack_depth_to_print);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define REG\t\t\"%08lx\"",
      "#define REG\t\t\"%016lx\""
    ],
    "globals_used": [
      "static int kstack_depth_to_print = CONFIG_PRINT_STACK_DEPTH;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"--- interrupt: %lx at %pS\\n    LR = %pS\\n\"",
            "regs->trap",
            "(void *)regs->nip",
            "(void *)lr"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_sp",
          "args": [
            "sp",
            "tsk",
            "STACK_INT_FRAME_SIZE"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "validate_sp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "1481-1491",
          "snippet": "int validate_sp(unsigned long sp, struct task_struct *p,\n\t\t       unsigned long nbytes)\n{\n\tunsigned long stack_page = (unsigned long)task_stack_page(p);\n\n\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\treturn 1;\n\n\treturn valid_irq_stack(sp, p, nbytes);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint validate_sp(unsigned long sp, struct task_struct *p,\n\t\t       unsigned long nbytes)\n{\n\tunsigned long stack_page = (unsigned long)task_stack_page(p);\n\n\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\treturn 1;\n\n\treturn valid_irq_stack(sp, p, nbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" (unreliable)\""
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\" (%pS)\"",
            "(void *)current->ret_stack[curr_frame].ret"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"[\"REG\"] [\"REG\"] %pS\"",
            "sp",
            "ip",
            "(void *)ip"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Call Trace:\\n\""
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_stack_pointer",
          "args": [],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REG\t\t\"%08lx\"\n#define REG\t\t\"%016lx\"\n\nstatic int kstack_depth_to_print = CONFIG_PRINT_STACK_DEPTH;\n\nvoid show_stack(struct task_struct *tsk, unsigned long *stack)\n{\n\tunsigned long sp, ip, lr, newsp;\n\tint count = 0;\n\tint firstframe = 1;\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tint curr_frame = current->curr_ret_stack;\n\textern void return_to_handler(void);\n\tunsigned long rth = (unsigned long)return_to_handler;\n#endif\n\n\tsp = (unsigned long) stack;\n\tif (tsk == NULL)\n\t\ttsk = current;\n\tif (sp == 0) {\n\t\tif (tsk == current)\n\t\t\tsp = current_stack_pointer();\n\t\telse\n\t\t\tsp = tsk->thread.ksp;\n\t}\n\n\tlr = 0;\n\tprintk(\"Call Trace:\\n\");\n\tdo {\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tstack = (unsigned long *) sp;\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!firstframe || ip != lr) {\n\t\t\tprintk(\"[\"REG\"] [\"REG\"] %pS\", sp, ip, (void *)ip);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\t\t\tif ((ip == rth) && curr_frame >= 0) {\n\t\t\t\tprintk(\" (%pS)\",\n\t\t\t\t       (void *)current->ret_stack[curr_frame].ret);\n\t\t\t\tcurr_frame--;\n\t\t\t}\n#endif\n\t\t\tif (firstframe)\n\t\t\t\tprintk(\" (unreliable)\");\n\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tfirstframe = 0;\n\n\t\t/*\n\t\t * See if this is an exception frame.\n\t\t * We look for the \"regshere\" marker in the current frame.\n\t\t */\n\t\tif (validate_sp(sp, tsk, STACK_INT_FRAME_SIZE)\n\t\t    && stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\tstruct pt_regs *regs = (struct pt_regs *)\n\t\t\t\t(sp + STACK_FRAME_OVERHEAD);\n\t\t\tlr = regs->link;\n\t\t\tprintk(\"--- interrupt: %lx at %pS\\n    LR = %pS\\n\",\n\t\t\t       regs->trap, (void *)regs->nip, (void *)lr);\n\t\t\tfirstframe = 1;\n\t\t}\n\n\t\tsp = newsp;\n\t} while (count++ < kstack_depth_to_print);\n}"
  },
  {
    "function_name": "get_wchan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1495-1518",
    "snippet": "unsigned long get_wchan(struct task_struct *p)\n{\n\tunsigned long ip, sp;\n\tint count = 0;\n\n\tif (!p || p == current || p->state == TASK_RUNNING)\n\t\treturn 0;\n\n\tsp = p->thread.ksp;\n\tif (!validate_sp(sp, p, STACK_FRAME_OVERHEAD))\n\t\treturn 0;\n\n\tdo {\n\t\tsp = *(unsigned long *)sp;\n\t\tif (!validate_sp(sp, p, STACK_FRAME_OVERHEAD))\n\t\t\treturn 0;\n\t\tif (count > 0) {\n\t\t\tip = ((unsigned long *)sp)[STACK_FRAME_LR_SAVE];\n\t\t\tif (!in_sched_functions(ip))\n\t\t\t\treturn ip;\n\t\t}\n\t} while (count++ < 16);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_sched_functions",
          "args": [
            "ip"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_sp",
          "args": [
            "sp",
            "p",
            "STACK_FRAME_OVERHEAD"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "validate_sp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "1481-1491",
          "snippet": "int validate_sp(unsigned long sp, struct task_struct *p,\n\t\t       unsigned long nbytes)\n{\n\tunsigned long stack_page = (unsigned long)task_stack_page(p);\n\n\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\treturn 1;\n\n\treturn valid_irq_stack(sp, p, nbytes);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint validate_sp(unsigned long sp, struct task_struct *p,\n\t\t       unsigned long nbytes)\n{\n\tunsigned long stack_page = (unsigned long)task_stack_page(p);\n\n\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\treturn 1;\n\n\treturn valid_irq_stack(sp, p, nbytes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nunsigned long get_wchan(struct task_struct *p)\n{\n\tunsigned long ip, sp;\n\tint count = 0;\n\n\tif (!p || p == current || p->state == TASK_RUNNING)\n\t\treturn 0;\n\n\tsp = p->thread.ksp;\n\tif (!validate_sp(sp, p, STACK_FRAME_OVERHEAD))\n\t\treturn 0;\n\n\tdo {\n\t\tsp = *(unsigned long *)sp;\n\t\tif (!validate_sp(sp, p, STACK_FRAME_OVERHEAD))\n\t\t\treturn 0;\n\t\tif (count > 0) {\n\t\t\tip = ((unsigned long *)sp)[STACK_FRAME_LR_SAVE];\n\t\t\tif (!in_sched_functions(ip))\n\t\t\t\treturn ip;\n\t\t}\n\t} while (count++ < 16);\n\treturn 0;\n}"
  },
  {
    "function_name": "validate_sp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1481-1491",
    "snippet": "int validate_sp(unsigned long sp, struct task_struct *p,\n\t\t       unsigned long nbytes)\n{\n\tunsigned long stack_page = (unsigned long)task_stack_page(p);\n\n\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\treturn 1;\n\n\treturn valid_irq_stack(sp, p, nbytes);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "valid_irq_stack",
          "args": [
            "sp",
            "p",
            "nbytes"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "valid_irq_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "1457-1479",
          "snippet": "static inline int valid_irq_stack(unsigned long sp, struct task_struct *p,\n\t\t\t\t  unsigned long nbytes)\n{\n\tunsigned long stack_page;\n\tunsigned long cpu = task_cpu(p);\n\n\t/*\n\t * Avoid crashing if the stack has overflowed and corrupted\n\t * task_cpu(p), which is in the thread_info struct.\n\t */\n\tif (cpu < NR_CPUS && cpu_possible(cpu)) {\n\t\tstack_page = (unsigned long) hardirq_ctx[cpu];\n\t\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\t\treturn 1;\n\n\t\tstack_page = (unsigned long) softirq_ctx[cpu];\n\t\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int valid_irq_stack(unsigned long sp, struct task_struct *p,\n\t\t\t\t  unsigned long nbytes)\n{\n\tunsigned long stack_page;\n\tunsigned long cpu = task_cpu(p);\n\n\t/*\n\t * Avoid crashing if the stack has overflowed and corrupted\n\t * task_cpu(p), which is in the thread_info struct.\n\t */\n\tif (cpu < NR_CPUS && cpu_possible(cpu)) {\n\t\tstack_page = (unsigned long) hardirq_ctx[cpu];\n\t\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\t\treturn 1;\n\n\t\tstack_page = (unsigned long) softirq_ctx[cpu];\n\t\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_stack_page",
          "args": [
            "p"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint validate_sp(unsigned long sp, struct task_struct *p,\n\t\t       unsigned long nbytes)\n{\n\tunsigned long stack_page = (unsigned long)task_stack_page(p);\n\n\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\treturn 1;\n\n\treturn valid_irq_stack(sp, p, nbytes);\n}"
  },
  {
    "function_name": "valid_irq_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1457-1479",
    "snippet": "static inline int valid_irq_stack(unsigned long sp, struct task_struct *p,\n\t\t\t\t  unsigned long nbytes)\n{\n\tunsigned long stack_page;\n\tunsigned long cpu = task_cpu(p);\n\n\t/*\n\t * Avoid crashing if the stack has overflowed and corrupted\n\t * task_cpu(p), which is in the thread_info struct.\n\t */\n\tif (cpu < NR_CPUS && cpu_possible(cpu)) {\n\t\tstack_page = (unsigned long) hardirq_ctx[cpu];\n\t\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\t\treturn 1;\n\n\t\tstack_page = (unsigned long) softirq_ctx[cpu];\n\t\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_possible",
          "args": [
            "cpu"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int valid_irq_stack(unsigned long sp, struct task_struct *p,\n\t\t\t\t  unsigned long nbytes)\n{\n\tunsigned long stack_page;\n\tunsigned long cpu = task_cpu(p);\n\n\t/*\n\t * Avoid crashing if the stack has overflowed and corrupted\n\t * task_cpu(p), which is in the thread_info struct.\n\t */\n\tif (cpu < NR_CPUS && cpu_possible(cpu)) {\n\t\tstack_page = (unsigned long) hardirq_ctx[cpu];\n\t\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\t\treturn 1;\n\n\t\tstack_page = (unsigned long) softirq_ctx[cpu];\n\t\tif (sp >= stack_page + sizeof(struct thread_struct)\n\t\t    && sp <= stack_page + THREAD_SIZE - nbytes)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_unalign_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1452-1455",
    "snippet": "int get_unalign_ctl(struct task_struct *tsk, unsigned long adr)\n{\n\treturn put_user(tsk->thread.align_ctl, (unsigned int __user *)adr);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "tsk->thread.align_ctl",
            "(unsigned int __user *)adr"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint get_unalign_ctl(struct task_struct *tsk, unsigned long adr)\n{\n\treturn put_user(tsk->thread.align_ctl, (unsigned int __user *)adr);\n}"
  },
  {
    "function_name": "set_unalign_ctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1446-1450",
    "snippet": "int set_unalign_ctl(struct task_struct *tsk, unsigned int val)\n{\n\ttsk->thread.align_ctl = val;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint set_unalign_ctl(struct task_struct *tsk, unsigned int val)\n{\n\ttsk->thread.align_ctl = val;\n\treturn 0;\n}"
  },
  {
    "function_name": "get_endian",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1423-1444",
    "snippet": "int get_endian(struct task_struct *tsk, unsigned long adr)\n{\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tunsigned int val;\n\n\tif (!cpu_has_feature(CPU_FTR_PPC_LE) &&\n\t    !cpu_has_feature(CPU_FTR_REAL_LE))\n\t\treturn -EINVAL;\n\n\tif (regs == NULL)\n\t\treturn -EINVAL;\n\n\tif (regs->msr & MSR_LE) {\n\t\tif (cpu_has_feature(CPU_FTR_REAL_LE))\n\t\t\tval = PR_ENDIAN_LITTLE;\n\t\telse\n\t\t\tval = PR_ENDIAN_PPC_LITTLE;\n\t} else\n\t\tval = PR_ENDIAN_BIG;\n\n\treturn put_user(val, (unsigned int __user *)adr);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "val",
            "(unsigned int __user *)adr"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_REAL_LE"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_REAL_LE"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_PPC_LE"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint get_endian(struct task_struct *tsk, unsigned long adr)\n{\n\tstruct pt_regs *regs = tsk->thread.regs;\n\tunsigned int val;\n\n\tif (!cpu_has_feature(CPU_FTR_PPC_LE) &&\n\t    !cpu_has_feature(CPU_FTR_REAL_LE))\n\t\treturn -EINVAL;\n\n\tif (regs == NULL)\n\t\treturn -EINVAL;\n\n\tif (regs->msr & MSR_LE) {\n\t\tif (cpu_has_feature(CPU_FTR_REAL_LE))\n\t\t\tval = PR_ENDIAN_LITTLE;\n\t\telse\n\t\t\tval = PR_ENDIAN_PPC_LITTLE;\n\t} else\n\t\tval = PR_ENDIAN_BIG;\n\n\treturn put_user(val, (unsigned int __user *)adr);\n}"
  },
  {
    "function_name": "set_endian",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1402-1421",
    "snippet": "int set_endian(struct task_struct *tsk, unsigned int val)\n{\n\tstruct pt_regs *regs = tsk->thread.regs;\n\n\tif ((val == PR_ENDIAN_LITTLE && !cpu_has_feature(CPU_FTR_REAL_LE)) ||\n\t    (val == PR_ENDIAN_PPC_LITTLE && !cpu_has_feature(CPU_FTR_PPC_LE)))\n\t\treturn -EINVAL;\n\n\tif (regs == NULL)\n\t\treturn -EINVAL;\n\n\tif (val == PR_ENDIAN_BIG)\n\t\tregs->msr &= ~MSR_LE;\n\telse if (val == PR_ENDIAN_LITTLE || val == PR_ENDIAN_PPC_LITTLE)\n\t\tregs->msr |= MSR_LE;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_PPC_LE"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_REAL_LE"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint set_endian(struct task_struct *tsk, unsigned int val)\n{\n\tstruct pt_regs *regs = tsk->thread.regs;\n\n\tif ((val == PR_ENDIAN_LITTLE && !cpu_has_feature(CPU_FTR_REAL_LE)) ||\n\t    (val == PR_ENDIAN_PPC_LITTLE && !cpu_has_feature(CPU_FTR_PPC_LE)))\n\t\treturn -EINVAL;\n\n\tif (regs == NULL)\n\t\treturn -EINVAL;\n\n\tif (val == PR_ENDIAN_BIG)\n\t\tregs->msr &= ~MSR_LE;\n\telse if (val == PR_ENDIAN_LITTLE || val == PR_ENDIAN_PPC_LITTLE)\n\t\tregs->msr |= MSR_LE;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "get_fpexc_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1371-1400",
    "snippet": "int get_fpexc_mode(struct task_struct *tsk, unsigned long adr)\n{\n\tunsigned int val;\n\n\tif (tsk->thread.fpexc_mode & PR_FP_EXC_SW_ENABLE)\n#ifdef CONFIG_SPE\n\t\tif (cpu_has_feature(CPU_FTR_SPE)) {\n\t\t\t/*\n\t\t\t * When the sticky exception bits are set\n\t\t\t * directly by userspace, it must call prctl\n\t\t\t * with PR_GET_FPEXC (with PR_FP_EXC_SW_ENABLE\n\t\t\t * in the existing prctl settings) or\n\t\t\t * PR_SET_FPEXC (with PR_FP_EXC_SW_ENABLE in\n\t\t\t * the bits being set).  <fenv.h> functions\n\t\t\t * saving and restoring the whole\n\t\t\t * floating-point environment need to do so\n\t\t\t * anyway to restore the prctl settings from\n\t\t\t * the saved environment.\n\t\t\t */\n\t\t\ttsk->thread.spefscr_last = mfspr(SPRN_SPEFSCR);\n\t\t\tval = tsk->thread.fpexc_mode;\n\t\t} else\n\t\t\treturn -EINVAL;\n#else\n\t\treturn -EINVAL;\n#endif\n\telse\n\t\tval = __unpack_fe01(tsk->thread.fpexc_mode);\n\treturn put_user(val, (unsigned int __user *) adr);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "val",
            "(unsigned int __user *) adr"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unpack_fe01",
          "args": [
            "tsk->thread.fpexc_mode"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_SPEFSCR"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_SPE"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint get_fpexc_mode(struct task_struct *tsk, unsigned long adr)\n{\n\tunsigned int val;\n\n\tif (tsk->thread.fpexc_mode & PR_FP_EXC_SW_ENABLE)\n#ifdef CONFIG_SPE\n\t\tif (cpu_has_feature(CPU_FTR_SPE)) {\n\t\t\t/*\n\t\t\t * When the sticky exception bits are set\n\t\t\t * directly by userspace, it must call prctl\n\t\t\t * with PR_GET_FPEXC (with PR_FP_EXC_SW_ENABLE\n\t\t\t * in the existing prctl settings) or\n\t\t\t * PR_SET_FPEXC (with PR_FP_EXC_SW_ENABLE in\n\t\t\t * the bits being set).  <fenv.h> functions\n\t\t\t * saving and restoring the whole\n\t\t\t * floating-point environment need to do so\n\t\t\t * anyway to restore the prctl settings from\n\t\t\t * the saved environment.\n\t\t\t */\n\t\t\ttsk->thread.spefscr_last = mfspr(SPRN_SPEFSCR);\n\t\t\tval = tsk->thread.fpexc_mode;\n\t\t} else\n\t\t\treturn -EINVAL;\n#else\n\t\treturn -EINVAL;\n#endif\n\telse\n\t\tval = __unpack_fe01(tsk->thread.fpexc_mode);\n\treturn put_user(val, (unsigned int __user *) adr);\n}"
  },
  {
    "function_name": "set_fpexc_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1322-1369",
    "snippet": "int set_fpexc_mode(struct task_struct *tsk, unsigned int val)\n{\n\tstruct pt_regs *regs = tsk->thread.regs;\n\n\t/* This is a bit hairy.  If we are an SPE enabled  processor\n\t * (have embedded fp) we store the IEEE exception enable flags in\n\t * fpexc_mode.  fpexc_mode is also used for setting FP exception\n\t * mode (asyn, precise, disabled) for 'Classic' FP. */\n\tif (val & PR_FP_EXC_SW_ENABLE) {\n#ifdef CONFIG_SPE\n\t\tif (cpu_has_feature(CPU_FTR_SPE)) {\n\t\t\t/*\n\t\t\t * When the sticky exception bits are set\n\t\t\t * directly by userspace, it must call prctl\n\t\t\t * with PR_GET_FPEXC (with PR_FP_EXC_SW_ENABLE\n\t\t\t * in the existing prctl settings) or\n\t\t\t * PR_SET_FPEXC (with PR_FP_EXC_SW_ENABLE in\n\t\t\t * the bits being set).  <fenv.h> functions\n\t\t\t * saving and restoring the whole\n\t\t\t * floating-point environment need to do so\n\t\t\t * anyway to restore the prctl settings from\n\t\t\t * the saved environment.\n\t\t\t */\n\t\t\ttsk->thread.spefscr_last = mfspr(SPRN_SPEFSCR);\n\t\t\ttsk->thread.fpexc_mode = val &\n\t\t\t\t(PR_FP_EXC_SW_ENABLE | PR_FP_ALL_EXCEPT);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\n\t/* on a CONFIG_SPE this does not hurt us.  The bits that\n\t * __pack_fe01 use do not overlap with bits used for\n\t * PR_FP_EXC_SW_ENABLE.  Additionally, the MSR[FE0,FE1] bits\n\t * on CONFIG_SPE implementations are reserved so writing to\n\t * them does not change anything */\n\tif (val > PR_FP_EXC_PRECISE)\n\t\treturn -EINVAL;\n\ttsk->thread.fpexc_mode = __pack_fe01(val);\n\tif (regs != NULL && (regs->msr & MSR_FP) != 0)\n\t\tregs->msr = (regs->msr & ~(MSR_FE0|MSR_FE1))\n\t\t\t| tsk->thread.fpexc_mode;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define PR_FP_ALL_EXCEPT (PR_FP_EXC_DIV | PR_FP_EXC_OVF | PR_FP_EXC_UND \\\n\t\t| PR_FP_EXC_RES | PR_FP_EXC_INV)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pack_fe01",
          "args": [
            "val"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_SPEFSCR"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_SPE"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define PR_FP_ALL_EXCEPT (PR_FP_EXC_DIV | PR_FP_EXC_OVF | PR_FP_EXC_UND \\\n\t\t| PR_FP_EXC_RES | PR_FP_EXC_INV)\n\nint set_fpexc_mode(struct task_struct *tsk, unsigned int val)\n{\n\tstruct pt_regs *regs = tsk->thread.regs;\n\n\t/* This is a bit hairy.  If we are an SPE enabled  processor\n\t * (have embedded fp) we store the IEEE exception enable flags in\n\t * fpexc_mode.  fpexc_mode is also used for setting FP exception\n\t * mode (asyn, precise, disabled) for 'Classic' FP. */\n\tif (val & PR_FP_EXC_SW_ENABLE) {\n#ifdef CONFIG_SPE\n\t\tif (cpu_has_feature(CPU_FTR_SPE)) {\n\t\t\t/*\n\t\t\t * When the sticky exception bits are set\n\t\t\t * directly by userspace, it must call prctl\n\t\t\t * with PR_GET_FPEXC (with PR_FP_EXC_SW_ENABLE\n\t\t\t * in the existing prctl settings) or\n\t\t\t * PR_SET_FPEXC (with PR_FP_EXC_SW_ENABLE in\n\t\t\t * the bits being set).  <fenv.h> functions\n\t\t\t * saving and restoring the whole\n\t\t\t * floating-point environment need to do so\n\t\t\t * anyway to restore the prctl settings from\n\t\t\t * the saved environment.\n\t\t\t */\n\t\t\ttsk->thread.spefscr_last = mfspr(SPRN_SPEFSCR);\n\t\t\ttsk->thread.fpexc_mode = val &\n\t\t\t\t(PR_FP_EXC_SW_ENABLE | PR_FP_ALL_EXCEPT);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n#else\n\t\treturn -EINVAL;\n#endif\n\t}\n\n\t/* on a CONFIG_SPE this does not hurt us.  The bits that\n\t * __pack_fe01 use do not overlap with bits used for\n\t * PR_FP_EXC_SW_ENABLE.  Additionally, the MSR[FE0,FE1] bits\n\t * on CONFIG_SPE implementations are reserved so writing to\n\t * them does not change anything */\n\tif (val > PR_FP_EXC_PRECISE)\n\t\treturn -EINVAL;\n\ttsk->thread.fpexc_mode = __pack_fe01(val);\n\tif (regs != NULL && (regs->msr & MSR_FP) != 0)\n\t\tregs->msr = (regs->msr & ~(MSR_FE0|MSR_FE1))\n\t\t\t| tsk->thread.fpexc_mode;\n\treturn 0;\n}"
  },
  {
    "function_name": "start_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1209-1316",
    "snippet": "void start_thread(struct pt_regs *regs, unsigned long start, unsigned long sp)\n{\n#ifdef CONFIG_PPC64\n\tunsigned long load_addr = regs->gpr[2];\t/* saved by ELF_PLAT_INIT */\n#endif\n\n\t/*\n\t * If we exec out of a kernel thread then thread.regs will not be\n\t * set.  Do it now.\n\t */\n\tif (!current->thread.regs) {\n\t\tstruct pt_regs *regs = task_stack_page(current) + THREAD_SIZE;\n\t\tcurrent->thread.regs = regs - 1;\n\t}\n\n\tmemset(regs->gpr, 0, sizeof(regs->gpr));\n\tregs->ctr = 0;\n\tregs->link = 0;\n\tregs->xer = 0;\n\tregs->ccr = 0;\n\tregs->gpr[1] = sp;\n\n\t/*\n\t * We have just cleared all the nonvolatile GPRs, so make\n\t * FULL_REGS(regs) return true.  This is necessary to allow\n\t * ptrace to examine the thread immediately after exec.\n\t */\n\tregs->trap &= ~1UL;\n\n#ifdef CONFIG_PPC32\n\tregs->mq = 0;\n\tregs->nip = start;\n\tregs->msr = MSR_USER;\n#else\n\tif (!is_32bit_task()) {\n\t\tunsigned long entry;\n\n\t\tif (is_elf2_task()) {\n\t\t\t/* Look ma, no function descriptors! */\n\t\t\tentry = start;\n\n\t\t\t/*\n\t\t\t * Ulrich says:\n\t\t\t *   The latest iteration of the ABI requires that when\n\t\t\t *   calling a function (at its global entry point),\n\t\t\t *   the caller must ensure r12 holds the entry point\n\t\t\t *   address (so that the function can quickly\n\t\t\t *   establish addressability).\n\t\t\t */\n\t\t\tregs->gpr[12] = start;\n\t\t\t/* Make sure that's restored on entry to userspace. */\n\t\t\tset_thread_flag(TIF_RESTOREALL);\n\t\t} else {\n\t\t\tunsigned long toc;\n\n\t\t\t/* start is a relocated pointer to the function\n\t\t\t * descriptor for the elf _start routine.  The first\n\t\t\t * entry in the function descriptor is the entry\n\t\t\t * address of _start and the second entry is the TOC\n\t\t\t * value we need to use.\n\t\t\t */\n\t\t\t__get_user(entry, (unsigned long __user *)start);\n\t\t\t__get_user(toc, (unsigned long __user *)start+1);\n\n\t\t\t/* Check whether the e_entry function descriptor entries\n\t\t\t * need to be relocated before we can use them.\n\t\t\t */\n\t\t\tif (load_addr != 0) {\n\t\t\t\tentry += load_addr;\n\t\t\t\ttoc   += load_addr;\n\t\t\t}\n\t\t\tregs->gpr[2] = toc;\n\t\t}\n\t\tregs->nip = entry;\n\t\tregs->msr = MSR_USER64;\n\t} else {\n\t\tregs->nip = start;\n\t\tregs->gpr[2] = 0;\n\t\tregs->msr = MSR_USER32;\n\t}\n#endif\n\tdiscard_lazy_cpu_state();\n#ifdef CONFIG_VSX\n\tcurrent->thread.used_vsr = 0;\n#endif\n\tmemset(&current->thread.fp_state, 0, sizeof(current->thread.fp_state));\n\tcurrent->thread.fp_save_area = NULL;\n#ifdef CONFIG_ALTIVEC\n\tmemset(&current->thread.vr_state, 0, sizeof(current->thread.vr_state));\n\tcurrent->thread.vr_state.vscr.u[3] = 0x00010000; /* Java mode disabled */\n\tcurrent->thread.vr_save_area = NULL;\n\tcurrent->thread.vrsave = 0;\n\tcurrent->thread.used_vr = 0;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_SPE\n\tmemset(current->thread.evr, 0, sizeof(current->thread.evr));\n\tcurrent->thread.acc = 0;\n\tcurrent->thread.spefscr = 0;\n\tcurrent->thread.used_spe = 0;\n#endif /* CONFIG_SPE */\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (cpu_has_feature(CPU_FTR_TM))\n\t\tregs->msr |= MSR_TM;\n\tcurrent->thread.tm_tfhar = 0;\n\tcurrent->thread.tm_texasr = 0;\n\tcurrent->thread.tm_tfiar = 0;\n#endif /* CONFIG_PPC_TRANSACTIONAL_MEM */\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "current->thread.evr",
            "0",
            "sizeof(current->thread.evr)"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_lazy_cpu_state",
          "args": [],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "discard_lazy_cpu_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "284-302",
          "snippet": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "toc",
            "(unsigned long __user *)start+1"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "entry",
            "(unsigned long __user *)start"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTOREALL"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_elf2_task",
          "args": [],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stack_page",
          "args": [
            "current"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid start_thread(struct pt_regs *regs, unsigned long start, unsigned long sp)\n{\n#ifdef CONFIG_PPC64\n\tunsigned long load_addr = regs->gpr[2];\t/* saved by ELF_PLAT_INIT */\n#endif\n\n\t/*\n\t * If we exec out of a kernel thread then thread.regs will not be\n\t * set.  Do it now.\n\t */\n\tif (!current->thread.regs) {\n\t\tstruct pt_regs *regs = task_stack_page(current) + THREAD_SIZE;\n\t\tcurrent->thread.regs = regs - 1;\n\t}\n\n\tmemset(regs->gpr, 0, sizeof(regs->gpr));\n\tregs->ctr = 0;\n\tregs->link = 0;\n\tregs->xer = 0;\n\tregs->ccr = 0;\n\tregs->gpr[1] = sp;\n\n\t/*\n\t * We have just cleared all the nonvolatile GPRs, so make\n\t * FULL_REGS(regs) return true.  This is necessary to allow\n\t * ptrace to examine the thread immediately after exec.\n\t */\n\tregs->trap &= ~1UL;\n\n#ifdef CONFIG_PPC32\n\tregs->mq = 0;\n\tregs->nip = start;\n\tregs->msr = MSR_USER;\n#else\n\tif (!is_32bit_task()) {\n\t\tunsigned long entry;\n\n\t\tif (is_elf2_task()) {\n\t\t\t/* Look ma, no function descriptors! */\n\t\t\tentry = start;\n\n\t\t\t/*\n\t\t\t * Ulrich says:\n\t\t\t *   The latest iteration of the ABI requires that when\n\t\t\t *   calling a function (at its global entry point),\n\t\t\t *   the caller must ensure r12 holds the entry point\n\t\t\t *   address (so that the function can quickly\n\t\t\t *   establish addressability).\n\t\t\t */\n\t\t\tregs->gpr[12] = start;\n\t\t\t/* Make sure that's restored on entry to userspace. */\n\t\t\tset_thread_flag(TIF_RESTOREALL);\n\t\t} else {\n\t\t\tunsigned long toc;\n\n\t\t\t/* start is a relocated pointer to the function\n\t\t\t * descriptor for the elf _start routine.  The first\n\t\t\t * entry in the function descriptor is the entry\n\t\t\t * address of _start and the second entry is the TOC\n\t\t\t * value we need to use.\n\t\t\t */\n\t\t\t__get_user(entry, (unsigned long __user *)start);\n\t\t\t__get_user(toc, (unsigned long __user *)start+1);\n\n\t\t\t/* Check whether the e_entry function descriptor entries\n\t\t\t * need to be relocated before we can use them.\n\t\t\t */\n\t\t\tif (load_addr != 0) {\n\t\t\t\tentry += load_addr;\n\t\t\t\ttoc   += load_addr;\n\t\t\t}\n\t\t\tregs->gpr[2] = toc;\n\t\t}\n\t\tregs->nip = entry;\n\t\tregs->msr = MSR_USER64;\n\t} else {\n\t\tregs->nip = start;\n\t\tregs->gpr[2] = 0;\n\t\tregs->msr = MSR_USER32;\n\t}\n#endif\n\tdiscard_lazy_cpu_state();\n#ifdef CONFIG_VSX\n\tcurrent->thread.used_vsr = 0;\n#endif\n\tmemset(&current->thread.fp_state, 0, sizeof(current->thread.fp_state));\n\tcurrent->thread.fp_save_area = NULL;\n#ifdef CONFIG_ALTIVEC\n\tmemset(&current->thread.vr_state, 0, sizeof(current->thread.vr_state));\n\tcurrent->thread.vr_state.vscr.u[3] = 0x00010000; /* Java mode disabled */\n\tcurrent->thread.vr_save_area = NULL;\n\tcurrent->thread.vrsave = 0;\n\tcurrent->thread.used_vr = 0;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_SPE\n\tmemset(current->thread.evr, 0, sizeof(current->thread.evr));\n\tcurrent->thread.acc = 0;\n\tcurrent->thread.spefscr = 0;\n\tcurrent->thread.used_spe = 0;\n#endif /* CONFIG_SPE */\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (cpu_has_feature(CPU_FTR_TM))\n\t\tregs->msr |= MSR_TM;\n\tcurrent->thread.tm_tfhar = 0;\n\tcurrent->thread.tm_texasr = 0;\n\tcurrent->thread.tm_tfiar = 0;\n#endif /* CONFIG_PPC_TRANSACTIONAL_MEM */\n}"
  },
  {
    "function_name": "copy_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1116-1204",
    "snippet": "int copy_thread(unsigned long clone_flags, unsigned long usp,\n\t\tunsigned long kthread_arg, struct task_struct *p)\n{\n\tstruct pt_regs *childregs, *kregs;\n\textern void ret_from_fork(void);\n\textern void ret_from_kernel_thread(void);\n\tvoid (*f)(void);\n\tunsigned long sp = (unsigned long)task_stack_page(p) + THREAD_SIZE;\n\n\t/* Copy registers */\n\tsp -= sizeof(struct pt_regs);\n\tchildregs = (struct pt_regs *) sp;\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\t/* kernel thread */\n\t\tstruct thread_info *ti = (void *)task_stack_page(p);\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tchildregs->gpr[1] = sp + sizeof(struct pt_regs);\n\t\t/* function */\n\t\tif (usp)\n\t\t\tchildregs->gpr[14] = ppc_function_entry((void *)usp);\n#ifdef CONFIG_PPC64\n\t\tclear_tsk_thread_flag(p, TIF_32BIT);\n\t\tchildregs->softe = 1;\n#endif\n\t\tchildregs->gpr[15] = kthread_arg;\n\t\tp->thread.regs = NULL;\t/* no user register state */\n\t\tti->flags |= _TIF_RESTOREALL;\n\t\tf = ret_from_kernel_thread;\n\t} else {\n\t\t/* user thread */\n\t\tstruct pt_regs *regs = current_pt_regs();\n\t\tCHECK_FULL_REGS(regs);\n\t\t*childregs = *regs;\n\t\tif (usp)\n\t\t\tchildregs->gpr[1] = usp;\n\t\tp->thread.regs = childregs;\n\t\tchildregs->gpr[3] = 0;  /* Result from fork() */\n\t\tif (clone_flags & CLONE_SETTLS) {\n#ifdef CONFIG_PPC64\n\t\t\tif (!is_32bit_task())\n\t\t\t\tchildregs->gpr[13] = childregs->gpr[6];\n\t\t\telse\n#endif\n\t\t\t\tchildregs->gpr[2] = childregs->gpr[6];\n\t\t}\n\n\t\tf = ret_from_fork;\n\t}\n\tsp -= STACK_FRAME_OVERHEAD;\n\n\t/*\n\t * The way this works is that at some point in the future\n\t * some task will call _switch to switch to the new task.\n\t * That will pop off the stack frame created below and start\n\t * the new task running at ret_from_fork.  The new task will\n\t * do some house keeping and then return from the fork or clone\n\t * system call, using the stack frame created above.\n\t */\n\t((unsigned long *)sp)[0] = 0;\n\tsp -= sizeof(struct pt_regs);\n\tkregs = (struct pt_regs *) sp;\n\tsp -= STACK_FRAME_OVERHEAD;\n\tp->thread.ksp = sp;\n#ifdef CONFIG_PPC32\n\tp->thread.ksp_limit = (unsigned long)task_stack_page(p) +\n\t\t\t\t_ALIGN_UP(sizeof(struct thread_info), 16);\n#endif\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tp->thread.ptrace_bps[0] = NULL;\n#endif\n\n\tp->thread.fp_save_area = NULL;\n#ifdef CONFIG_ALTIVEC\n\tp->thread.vr_save_area = NULL;\n#endif\n\n\tsetup_ksp_vsid(p, sp);\n\n#ifdef CONFIG_PPC64 \n\tif (cpu_has_feature(CPU_FTR_DSCR)) {\n\t\tp->thread.dscr_inherit = current->thread.dscr_inherit;\n\t\tp->thread.dscr = current->thread.dscr;\n\t}\n\tif (cpu_has_feature(CPU_FTR_HAS_PPR))\n\t\tp->thread.ppr = INIT_PPR;\n#endif\n\tkregs->nip = ppc_function_entry(f);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "f"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_HAS_PPR"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DSCR"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_ksp_vsid",
          "args": [
            "p",
            "sp"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "setup_ksp_vsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "1092-1107",
          "snippet": "static void setup_ksp_vsid(struct task_struct *p, unsigned long sp)\n{\n#ifdef CONFIG_PPC_STD_MMU_64\n\tunsigned long sp_vsid;\n\tunsigned long llp = mmu_psize_defs[mmu_linear_psize].sllp;\n\n\tif (mmu_has_feature(MMU_FTR_1T_SEGMENT))\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_1T)\n\t\t\t<< SLB_VSID_SHIFT_1T;\n\telse\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_256M)\n\t\t\t<< SLB_VSID_SHIFT;\n\tsp_vsid |= SLB_VSID_KERNEL | llp;\n\tp->thread.ksp_vsid = sp_vsid;\n#endif\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void setup_ksp_vsid(struct task_struct *p, unsigned long sp)\n{\n#ifdef CONFIG_PPC_STD_MMU_64\n\tunsigned long sp_vsid;\n\tunsigned long llp = mmu_psize_defs[mmu_linear_psize].sllp;\n\n\tif (mmu_has_feature(MMU_FTR_1T_SEGMENT))\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_1T)\n\t\t\t<< SLB_VSID_SHIFT_1T;\n\telse\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_256M)\n\t\t\t<< SLB_VSID_SHIFT;\n\tsp_vsid |= SLB_VSID_KERNEL | llp;\n\tp->thread.ksp_vsid = sp_vsid;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "_ALIGN_UP",
          "args": [
            "sizeof(struct thread_info)",
            "16"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stack_page",
          "args": [
            "p"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_32bit_task",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_pt_regs",
          "args": [],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "p",
            "TIF_32BIT"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_function_entry",
          "args": [
            "(void *)usp"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "childregs",
            "0",
            "sizeof(struct pt_regs)"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "_memset_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "126-151",
          "snippet": "notrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nnotrace void\n_memset_io(volatile void __iomem *addr, int c, unsigned long n)\n{\n\tvoid *p = (void __force *)addr;\n\tu32 lc = c;\n\tlc |= lc << 8;\n\tlc |= lc << 16;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && !IO_CHECK_ALIGN(p, 4)) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)p) = lc;\n\t\tp += 4;\n\t\tn -= 4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)p) = c;\n\t\tp++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_stack_page",
          "args": [
            "p"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p->flags & PF_KTHREAD"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_stack_page",
          "args": [
            "p"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint copy_thread(unsigned long clone_flags, unsigned long usp,\n\t\tunsigned long kthread_arg, struct task_struct *p)\n{\n\tstruct pt_regs *childregs, *kregs;\n\textern void ret_from_fork(void);\n\textern void ret_from_kernel_thread(void);\n\tvoid (*f)(void);\n\tunsigned long sp = (unsigned long)task_stack_page(p) + THREAD_SIZE;\n\n\t/* Copy registers */\n\tsp -= sizeof(struct pt_regs);\n\tchildregs = (struct pt_regs *) sp;\n\tif (unlikely(p->flags & PF_KTHREAD)) {\n\t\t/* kernel thread */\n\t\tstruct thread_info *ti = (void *)task_stack_page(p);\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tchildregs->gpr[1] = sp + sizeof(struct pt_regs);\n\t\t/* function */\n\t\tif (usp)\n\t\t\tchildregs->gpr[14] = ppc_function_entry((void *)usp);\n#ifdef CONFIG_PPC64\n\t\tclear_tsk_thread_flag(p, TIF_32BIT);\n\t\tchildregs->softe = 1;\n#endif\n\t\tchildregs->gpr[15] = kthread_arg;\n\t\tp->thread.regs = NULL;\t/* no user register state */\n\t\tti->flags |= _TIF_RESTOREALL;\n\t\tf = ret_from_kernel_thread;\n\t} else {\n\t\t/* user thread */\n\t\tstruct pt_regs *regs = current_pt_regs();\n\t\tCHECK_FULL_REGS(regs);\n\t\t*childregs = *regs;\n\t\tif (usp)\n\t\t\tchildregs->gpr[1] = usp;\n\t\tp->thread.regs = childregs;\n\t\tchildregs->gpr[3] = 0;  /* Result from fork() */\n\t\tif (clone_flags & CLONE_SETTLS) {\n#ifdef CONFIG_PPC64\n\t\t\tif (!is_32bit_task())\n\t\t\t\tchildregs->gpr[13] = childregs->gpr[6];\n\t\t\telse\n#endif\n\t\t\t\tchildregs->gpr[2] = childregs->gpr[6];\n\t\t}\n\n\t\tf = ret_from_fork;\n\t}\n\tsp -= STACK_FRAME_OVERHEAD;\n\n\t/*\n\t * The way this works is that at some point in the future\n\t * some task will call _switch to switch to the new task.\n\t * That will pop off the stack frame created below and start\n\t * the new task running at ret_from_fork.  The new task will\n\t * do some house keeping and then return from the fork or clone\n\t * system call, using the stack frame created above.\n\t */\n\t((unsigned long *)sp)[0] = 0;\n\tsp -= sizeof(struct pt_regs);\n\tkregs = (struct pt_regs *) sp;\n\tsp -= STACK_FRAME_OVERHEAD;\n\tp->thread.ksp = sp;\n#ifdef CONFIG_PPC32\n\tp->thread.ksp_limit = (unsigned long)task_stack_page(p) +\n\t\t\t\t_ALIGN_UP(sizeof(struct thread_info), 16);\n#endif\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tp->thread.ptrace_bps[0] = NULL;\n#endif\n\n\tp->thread.fp_save_area = NULL;\n#ifdef CONFIG_ALTIVEC\n\tp->thread.vr_save_area = NULL;\n#endif\n\n\tsetup_ksp_vsid(p, sp);\n\n#ifdef CONFIG_PPC64 \n\tif (cpu_has_feature(CPU_FTR_DSCR)) {\n\t\tp->thread.dscr_inherit = current->thread.dscr_inherit;\n\t\tp->thread.dscr = current->thread.dscr;\n\t}\n\tif (cpu_has_feature(CPU_FTR_HAS_PPR))\n\t\tp->thread.ppr = INIT_PPR;\n#endif\n\tkregs->nip = ppc_function_entry(f);\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_ksp_vsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1092-1107",
    "snippet": "static void setup_ksp_vsid(struct task_struct *p, unsigned long sp)\n{\n#ifdef CONFIG_PPC_STD_MMU_64\n\tunsigned long sp_vsid;\n\tunsigned long llp = mmu_psize_defs[mmu_linear_psize].sllp;\n\n\tif (mmu_has_feature(MMU_FTR_1T_SEGMENT))\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_1T)\n\t\t\t<< SLB_VSID_SHIFT_1T;\n\telse\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_256M)\n\t\t\t<< SLB_VSID_SHIFT;\n\tsp_vsid |= SLB_VSID_KERNEL | llp;\n\tp->thread.ksp_vsid = sp_vsid;\n#endif\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_kernel_vsid",
          "args": [
            "sp",
            "MMU_SEGSIZE_256M"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kernel_vsid",
          "args": [
            "sp",
            "MMU_SEGSIZE_1T"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_has_feature",
          "args": [
            "MMU_FTR_1T_SEGMENT"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void setup_ksp_vsid(struct task_struct *p, unsigned long sp)\n{\n#ifdef CONFIG_PPC_STD_MMU_64\n\tunsigned long sp_vsid;\n\tunsigned long llp = mmu_psize_defs[mmu_linear_psize].sllp;\n\n\tif (mmu_has_feature(MMU_FTR_1T_SEGMENT))\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_1T)\n\t\t\t<< SLB_VSID_SHIFT_1T;\n\telse\n\t\tsp_vsid = get_kernel_vsid(sp, MMU_SEGSIZE_256M)\n\t\t\t<< SLB_VSID_SHIFT;\n\tsp_vsid |= SLB_VSID_KERNEL | llp;\n\tp->thread.ksp_vsid = sp_vsid;\n#endif\n}"
  },
  {
    "function_name": "arch_dup_task_struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1069-1090",
    "snippet": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\t/*\n\t * Flush TM state out so we can copy it.  __switch_to_tm() does this\n\t * flush but it removes the checkpointed state from the current CPU and\n\t * transitions the CPU out of TM mode.  Hence we need to call\n\t * tm_recheckpoint_new_task() (on the same task) to restore the\n\t * checkpointed state back and the TM mode.\n\t */\n\t__switch_to_tm(src);\n\ttm_recheckpoint_new_task(src);\n\n\t*dst = *src;\n\n\tclear_task_ebb(dst);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_task_ebb",
          "args": [
            "dst"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint_new_task",
          "args": [
            "src"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint_new_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "644-694",
          "snippet": "static inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tunsigned long msr;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavoidable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!new->thread.regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\tmsr = new->thread.ckpt_regs.msr;\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d \"\n\t\t \"(new->msr 0x%lx, new->origmsr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr, msr);\n\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&new->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&new->thread);\n\t\tnew->thread.regs->msr |=\n\t\t\t(MSR_FP | new->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&new->thread);\n\t\tnew->thread.regs->msr |= MSR_VEC;\n\t}\n#endif\n\t/* We may as well turn on VSX too since all the state is restored now */\n\tif (msr & MSR_VSX)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tunsigned long msr;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavoidable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!new->thread.regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\tmsr = new->thread.ckpt_regs.msr;\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d \"\n\t\t \"(new->msr 0x%lx, new->origmsr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr, msr);\n\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&new->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&new->thread);\n\t\tnew->thread.regs->msr |=\n\t\t\t(MSR_FP | new->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&new->thread);\n\t\tnew->thread.regs->msr |= MSR_VEC;\n\t}\n#endif\n\t/* We may as well turn on VSX too since all the state is restored now */\n\tif (msr & MSR_VSX)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}"
        }
      },
      {
        "call_info": {
          "callee": "__switch_to_tm",
          "args": [
            "src"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "__switch_to_tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "696-702",
          "snippet": "static inline void __switch_to_tm(struct task_struct *prev)\n{\n\tif (cpu_has_feature(CPU_FTR_TM)) {\n\t\ttm_enable();\n\t\ttm_reclaim_task(prev);\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void __switch_to_tm(struct task_struct *prev)\n{\n\tif (cpu_has_feature(CPU_FTR_TM)) {\n\t\ttm_enable();\n\t\ttm_reclaim_task(prev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_spe_to_thread",
          "args": [
            "src"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "flush_spe_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "263-276",
          "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_vsx_to_thread",
          "args": [
            "src"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "flush_vsx_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "230-242",
          "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_altivec_to_thread",
          "args": [
            "src"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "flush_altivec_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "190-202",
          "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_fp_to_thread",
          "args": [
            "src"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "flush_fp_to_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "124-151",
          "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nint arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\t/*\n\t * Flush TM state out so we can copy it.  __switch_to_tm() does this\n\t * flush but it removes the checkpointed state from the current CPU and\n\t * transitions the CPU out of TM mode.  Hence we need to call\n\t * tm_recheckpoint_new_task() (on the same task) to restore the\n\t * checkpointed state back and the TM mode.\n\t */\n\t__switch_to_tm(src);\n\ttm_recheckpoint_new_task(src);\n\n\t*dst = *src;\n\n\tclear_task_ebb(dst);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "release_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1060-1063",
    "snippet": "void\nrelease_thread(struct task_struct *t)\n{\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid\nrelease_thread(struct task_struct *t)\n{\n}"
  },
  {
    "function_name": "flush_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1049-1058",
    "snippet": "void flush_thread(void)\n{\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tflush_ptrace_hw_breakpoint(current);\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tset_debug_reg_defaults(&current->thread);\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_debug_reg_defaults",
          "args": [
            "&current->thread"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "set_debug_reg_defaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "423-428",
          "snippet": "static void set_debug_reg_defaults(struct thread_struct *thread)\n{\n\tthread->hw_brk.address = 0;\n\tthread->hw_brk.type = 0;\n\tset_breakpoint(&thread->hw_brk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void set_debug_reg_defaults(struct thread_struct *thread)\n{\n\tthread->hw_brk.address = 0;\n\tthread->hw_brk.type = 0;\n\tset_breakpoint(&thread->hw_brk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_ptrace_hw_breakpoint",
          "args": [
            "current"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "flush_ptrace_hw_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/hw_breakpoint.c",
          "lines": "355-361",
          "snippet": "void flush_ptrace_hw_breakpoint(struct task_struct *tsk)\n{\n\tstruct thread_struct *t = &tsk->thread;\n\n\tunregister_hw_breakpoint(t->ptrace_bps[0]);\n\tt->ptrace_bps[0] = NULL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/sstep.h>",
            "#include <asm/processor.h>",
            "#include <asm/hw_breakpoint.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hw_breakpoint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/sstep.h>\n#include <asm/processor.h>\n#include <asm/hw_breakpoint.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/percpu.h>\n#include <linux/kprobes.h>\n#include <linux/notifier.h>\n#include <linux/hw_breakpoint.h>\n\nvoid flush_ptrace_hw_breakpoint(struct task_struct *tsk)\n{\n\tstruct thread_struct *t = &tsk->thread;\n\n\tunregister_hw_breakpoint(t->ptrace_bps[0]);\n\tt->ptrace_bps[0] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "discard_lazy_cpu_state",
          "args": [],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "discard_lazy_cpu_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "284-302",
          "snippet": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_thread(void)\n{\n\tdiscard_lazy_cpu_state();\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tflush_ptrace_hw_breakpoint(current);\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tset_debug_reg_defaults(&current->thread);\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n}"
  },
  {
    "function_name": "exit_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "1044-1047",
    "snippet": "void exit_thread(void)\n{\n\tdiscard_lazy_cpu_state();\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "discard_lazy_cpu_state",
          "args": [],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "discard_lazy_cpu_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "284-302",
          "snippet": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid exit_thread(void)\n{\n\tdiscard_lazy_cpu_state();\n}"
  },
  {
    "function_name": "show_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "993-1042",
    "snippet": "void show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP: \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %p TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR: \"REG\" \", regs->msr);\n\tprintbits(regs->msr, msr_bits);\n\tprintk(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif ((regs->trap != 0xc00) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tprintk(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600)\n#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)\n\t\tprintk(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n#else\n\t\tprintk(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n#endif\n#ifdef CONFIG_PPC64\n\tprintk(\"SOFTE: %ld \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tprintk(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tprintk(\"\\nGPR%02d: \", i);\n\t\tprintk(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tprintk(\"\\n\");\n#ifdef CONFIG_KALLSYMS\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n#endif\n\tshow_stack(current, (unsigned long *) regs->gpr[1]);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define LAST_VOLATILE\t12",
      "#define REGS_PER_LINE\t8",
      "#define REG\t\t\"%08lx\"",
      "#define LAST_VOLATILE\t13",
      "#define REGS_PER_LINE\t4",
      "#define REG\t\t\"%016lx\""
    ],
    "globals_used": [
      "static struct regbit {\n\tunsigned long bit;\n\tconst char *name;\n} msr_bits[] = {\n#if defined(CONFIG_PPC64) && !defined(CONFIG_BOOKE)\n\t{MSR_SF,\t\"SF\"},\n\t{MSR_HV,\t\"HV\"},\n#endif\n\t{MSR_VEC,\t\"VEC\"},\n\t{MSR_VSX,\t\"VSX\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_CE,\t\"CE\"},\n#endif\n\t{MSR_EE,\t\"EE\"},\n\t{MSR_PR,\t\"PR\"},\n\t{MSR_FP,\t\"FP\"},\n\t{MSR_ME,\t\"ME\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_DE,\t\"DE\"},\n#else\n\t{MSR_SE,\t\"SE\"},\n\t{MSR_BE,\t\"BE\"},\n#endif\n\t{MSR_IR,\t\"IR\"},\n\t{MSR_DR,\t\"DR\"},\n\t{MSR_PMM,\t\"PMM\"},\n#ifndef CONFIG_BOOKE\n\t{MSR_RI,\t\"RI\"},\n\t{MSR_LE,\t\"LE\"},\n#endif\n\t{0,\t\tNULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_instructions",
          "args": [
            "regs"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "show_instructions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "899-935",
          "snippet": "static void show_instructions(struct pt_regs *regs)\n{\n\tint i;\n\tunsigned long pc = regs->nip - (instructions_to_print * 3 / 4 *\n\t\t\tsizeof(int));\n\n\tprintk(\"Instruction dump:\");\n\n\tfor (i = 0; i < instructions_to_print; i++) {\n\t\tint instr;\n\n\t\tif (!(i % 8))\n\t\t\tprintk(\"\\n\");\n\n#if !defined(CONFIG_BOOKE)\n\t\t/* If executing with the IMMU off, adjust pc rather\n\t\t * than print XXXXXXXX.\n\t\t */\n\t\tif (!(regs->msr & MSR_IR))\n\t\t\tpc = (unsigned long)phys_to_virt(pc);\n#endif\n\n\t\tif (!__kernel_text_address(pc) ||\n\t\t     probe_kernel_address((unsigned int __user *)pc, instr)) {\n\t\t\tprintk(KERN_CONT \"XXXXXXXX \");\n\t\t} else {\n\t\t\tif (regs->nip == pc)\n\t\t\t\tprintk(KERN_CONT \"<%08x> \", instr);\n\t\t\telse\n\t\t\t\tprintk(KERN_CONT \"%08x \", instr);\n\t\t}\n\n\t\tpc += sizeof(int);\n\t}\n\n\tprintk(\"\\n\");\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int instructions_to_print = 16;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int instructions_to_print = 16;\n\nstatic void show_instructions(struct pt_regs *regs)\n{\n\tint i;\n\tunsigned long pc = regs->nip - (instructions_to_print * 3 / 4 *\n\t\t\tsizeof(int));\n\n\tprintk(\"Instruction dump:\");\n\n\tfor (i = 0; i < instructions_to_print; i++) {\n\t\tint instr;\n\n\t\tif (!(i % 8))\n\t\t\tprintk(\"\\n\");\n\n#if !defined(CONFIG_BOOKE)\n\t\t/* If executing with the IMMU off, adjust pc rather\n\t\t * than print XXXXXXXX.\n\t\t */\n\t\tif (!(regs->msr & MSR_IR))\n\t\t\tpc = (unsigned long)phys_to_virt(pc);\n#endif\n\n\t\tif (!__kernel_text_address(pc) ||\n\t\t     probe_kernel_address((unsigned int __user *)pc, instr)) {\n\t\t\tprintk(KERN_CONT \"XXXXXXXX \");\n\t\t} else {\n\t\t\tif (regs->nip == pc)\n\t\t\t\tprintk(KERN_CONT \"<%08x> \", instr);\n\t\t\telse\n\t\t\t\tprintk(KERN_CONT \"%08x \", instr);\n\t\t}\n\n\t\tpc += sizeof(int);\n\t}\n\n\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_mode",
          "args": [
            "regs"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_stack",
          "args": [
            "current",
            "(unsigned long *) regs->gpr[1]"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "show_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "1522-1583",
          "snippet": "void show_stack(struct task_struct *tsk, unsigned long *stack)\n{\n\tunsigned long sp, ip, lr, newsp;\n\tint count = 0;\n\tint firstframe = 1;\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tint curr_frame = current->curr_ret_stack;\n\textern void return_to_handler(void);\n\tunsigned long rth = (unsigned long)return_to_handler;\n#endif\n\n\tsp = (unsigned long) stack;\n\tif (tsk == NULL)\n\t\ttsk = current;\n\tif (sp == 0) {\n\t\tif (tsk == current)\n\t\t\tsp = current_stack_pointer();\n\t\telse\n\t\t\tsp = tsk->thread.ksp;\n\t}\n\n\tlr = 0;\n\tprintk(\"Call Trace:\\n\");\n\tdo {\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tstack = (unsigned long *) sp;\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!firstframe || ip != lr) {\n\t\t\tprintk(\"[\"REG\"] [\"REG\"] %pS\", sp, ip, (void *)ip);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\t\t\tif ((ip == rth) && curr_frame >= 0) {\n\t\t\t\tprintk(\" (%pS)\",\n\t\t\t\t       (void *)current->ret_stack[curr_frame].ret);\n\t\t\t\tcurr_frame--;\n\t\t\t}\n#endif\n\t\t\tif (firstframe)\n\t\t\t\tprintk(\" (unreliable)\");\n\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tfirstframe = 0;\n\n\t\t/*\n\t\t * See if this is an exception frame.\n\t\t * We look for the \"regshere\" marker in the current frame.\n\t\t */\n\t\tif (validate_sp(sp, tsk, STACK_INT_FRAME_SIZE)\n\t\t    && stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\tstruct pt_regs *regs = (struct pt_regs *)\n\t\t\t\t(sp + STACK_FRAME_OVERHEAD);\n\t\t\tlr = regs->link;\n\t\t\tprintk(\"--- interrupt: %lx at %pS\\n    LR = %pS\\n\",\n\t\t\t       regs->trap, (void *)regs->nip, (void *)lr);\n\t\t\tfirstframe = 1;\n\t\t}\n\n\t\tsp = newsp;\n\t} while (count++ < kstack_depth_to_print);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [
            "#define REG\t\t\"%08lx\"",
            "#define REG\t\t\"%016lx\""
          ],
          "globals_used": [
            "static int kstack_depth_to_print = CONFIG_PRINT_STACK_DEPTH;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define REG\t\t\"%08lx\"\n#define REG\t\t\"%016lx\"\n\nstatic int kstack_depth_to_print = CONFIG_PRINT_STACK_DEPTH;\n\nvoid show_stack(struct task_struct *tsk, unsigned long *stack)\n{\n\tunsigned long sp, ip, lr, newsp;\n\tint count = 0;\n\tint firstframe = 1;\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\tint curr_frame = current->curr_ret_stack;\n\textern void return_to_handler(void);\n\tunsigned long rth = (unsigned long)return_to_handler;\n#endif\n\n\tsp = (unsigned long) stack;\n\tif (tsk == NULL)\n\t\ttsk = current;\n\tif (sp == 0) {\n\t\tif (tsk == current)\n\t\t\tsp = current_stack_pointer();\n\t\telse\n\t\t\tsp = tsk->thread.ksp;\n\t}\n\n\tlr = 0;\n\tprintk(\"Call Trace:\\n\");\n\tdo {\n\t\tif (!validate_sp(sp, tsk, STACK_FRAME_OVERHEAD))\n\t\t\treturn;\n\n\t\tstack = (unsigned long *) sp;\n\t\tnewsp = stack[0];\n\t\tip = stack[STACK_FRAME_LR_SAVE];\n\t\tif (!firstframe || ip != lr) {\n\t\t\tprintk(\"[\"REG\"] [\"REG\"] %pS\", sp, ip, (void *)ip);\n#ifdef CONFIG_FUNCTION_GRAPH_TRACER\n\t\t\tif ((ip == rth) && curr_frame >= 0) {\n\t\t\t\tprintk(\" (%pS)\",\n\t\t\t\t       (void *)current->ret_stack[curr_frame].ret);\n\t\t\t\tcurr_frame--;\n\t\t\t}\n#endif\n\t\t\tif (firstframe)\n\t\t\t\tprintk(\" (unreliable)\");\n\t\t\tprintk(\"\\n\");\n\t\t}\n\t\tfirstframe = 0;\n\n\t\t/*\n\t\t * See if this is an exception frame.\n\t\t * We look for the \"regshere\" marker in the current frame.\n\t\t */\n\t\tif (validate_sp(sp, tsk, STACK_INT_FRAME_SIZE)\n\t\t    && stack[STACK_FRAME_MARKER] == STACK_FRAME_REGS_MARKER) {\n\t\t\tstruct pt_regs *regs = (struct pt_regs *)\n\t\t\t\t(sp + STACK_FRAME_OVERHEAD);\n\t\t\tlr = regs->link;\n\t\t\tprintk(\"--- interrupt: %lx at %pS\\n    LR = %pS\\n\",\n\t\t\t       regs->trap, (void *)regs->nip, (void *)lr);\n\t\t\tfirstframe = 1;\n\t\t}\n\n\t\tsp = newsp;\n\t} while (count++ < kstack_depth_to_print);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"LR [\"REG\"] %pS\\n\"",
            "regs->link",
            "(void *)regs->link"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NIP [\"REG\"] %pS\\n\"",
            "regs->nip",
            "(void *)regs->nip"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FULL_REGS",
          "args": [
            "regs"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "REG \" \"",
            "regs->gpr[i]"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_paca",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "regs->msr"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"DAR: \"REG\" DSISR: %08lx \"",
            "regs->dar",
            "regs->dsisr"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"DEAR: \"REG\" ESR: \"REG\" \"",
            "regs->dar",
            "regs->dsisr"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_CFAR"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRAP",
          "args": [
            "regs"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"  CR: %08lx  XER: %08lx\\n\"",
            "regs->ccr",
            "regs->xer"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printbits",
          "args": [
            "regs->msr",
            "msr_bits"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "printbits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "970-981",
          "snippet": "static void printbits(unsigned long val, struct regbit *bits)\n{\n\tconst char *sep = \"\";\n\n\tprintk(\"<\");\n\tfor (; bits->bit; ++bits)\n\t\tif (val & bits->bit) {\n\t\t\tprintk(\"%s%s\", sep, bits->name);\n\t\t\tsep = \",\";\n\t\t}\n\tprintk(\">\");\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void printbits(unsigned long val, struct regbit *bits)\n{\n\tconst char *sep = \"\";\n\n\tprintk(\"<\");\n\tfor (; bits->bit; ++bits)\n\t\tif (val & bits->bit) {\n\t\t\tprintk(\"%s%s\", sep, bits->name);\n\t\t\tsep = \",\";\n\t\t}\n\tprintk(\">\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"REGS: %p TRAP: %04lx   %s  (%s)\\n\"",
            "regs",
            "regs->trap",
            "print_tainted()",
            "init_utsname()->release"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_utsname",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_tainted",
          "args": [],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NIP: \"REG\" LR: \"REG\" CTR: \"REG\"\\n\"",
            "regs->nip",
            "regs->link",
            "regs->ctr"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs_print_info",
          "args": [
            "KERN_DEFAULT"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\n#define LAST_VOLATILE\t12\n#define REGS_PER_LINE\t8\n#define REG\t\t\"%08lx\"\n#define LAST_VOLATILE\t13\n#define REGS_PER_LINE\t4\n#define REG\t\t\"%016lx\"\n\nstatic struct regbit {\n\tunsigned long bit;\n\tconst char *name;\n} msr_bits[] = {\n#if defined(CONFIG_PPC64) && !defined(CONFIG_BOOKE)\n\t{MSR_SF,\t\"SF\"},\n\t{MSR_HV,\t\"HV\"},\n#endif\n\t{MSR_VEC,\t\"VEC\"},\n\t{MSR_VSX,\t\"VSX\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_CE,\t\"CE\"},\n#endif\n\t{MSR_EE,\t\"EE\"},\n\t{MSR_PR,\t\"PR\"},\n\t{MSR_FP,\t\"FP\"},\n\t{MSR_ME,\t\"ME\"},\n#ifdef CONFIG_BOOKE\n\t{MSR_DE,\t\"DE\"},\n#else\n\t{MSR_SE,\t\"SE\"},\n\t{MSR_BE,\t\"BE\"},\n#endif\n\t{MSR_IR,\t\"IR\"},\n\t{MSR_DR,\t\"DR\"},\n\t{MSR_PMM,\t\"PMM\"},\n#ifndef CONFIG_BOOKE\n\t{MSR_RI,\t\"RI\"},\n\t{MSR_LE,\t\"LE\"},\n#endif\n\t{0,\t\tNULL}\n};\n\nvoid show_regs(struct pt_regs * regs)\n{\n\tint i, trap;\n\n\tshow_regs_print_info(KERN_DEFAULT);\n\n\tprintk(\"NIP: \"REG\" LR: \"REG\" CTR: \"REG\"\\n\",\n\t       regs->nip, regs->link, regs->ctr);\n\tprintk(\"REGS: %p TRAP: %04lx   %s  (%s)\\n\",\n\t       regs, regs->trap, print_tainted(), init_utsname()->release);\n\tprintk(\"MSR: \"REG\" \", regs->msr);\n\tprintbits(regs->msr, msr_bits);\n\tprintk(\"  CR: %08lx  XER: %08lx\\n\", regs->ccr, regs->xer);\n\ttrap = TRAP(regs);\n\tif ((regs->trap != 0xc00) && cpu_has_feature(CPU_FTR_CFAR))\n\t\tprintk(\"CFAR: \"REG\" \", regs->orig_gpr3);\n\tif (trap == 0x200 || trap == 0x300 || trap == 0x600)\n#if defined(CONFIG_4xx) || defined(CONFIG_BOOKE)\n\t\tprintk(\"DEAR: \"REG\" ESR: \"REG\" \", regs->dar, regs->dsisr);\n#else\n\t\tprintk(\"DAR: \"REG\" DSISR: %08lx \", regs->dar, regs->dsisr);\n#endif\n#ifdef CONFIG_PPC64\n\tprintk(\"SOFTE: %ld \", regs->softe);\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tif (MSR_TM_ACTIVE(regs->msr))\n\t\tprintk(\"\\nPACATMSCRATCH: %016llx \", get_paca()->tm_scratch);\n#endif\n\n\tfor (i = 0;  i < 32;  i++) {\n\t\tif ((i % REGS_PER_LINE) == 0)\n\t\t\tprintk(\"\\nGPR%02d: \", i);\n\t\tprintk(REG \" \", regs->gpr[i]);\n\t\tif (i == LAST_VOLATILE && !FULL_REGS(regs))\n\t\t\tbreak;\n\t}\n\tprintk(\"\\n\");\n#ifdef CONFIG_KALLSYMS\n\t/*\n\t * Lookup NIP late so we have the best change of getting the\n\t * above info out without failing\n\t */\n\tprintk(\"NIP [\"REG\"] %pS\\n\", regs->nip, (void *)regs->nip);\n\tprintk(\"LR [\"REG\"] %pS\\n\", regs->link, (void *)regs->link);\n#endif\n\tshow_stack(current, (unsigned long *) regs->gpr[1]);\n\tif (!user_mode(regs))\n\t\tshow_instructions(regs);\n}"
  },
  {
    "function_name": "printbits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "970-981",
    "snippet": "static void printbits(unsigned long val, struct regbit *bits)\n{\n\tconst char *sep = \"\";\n\n\tprintk(\"<\");\n\tfor (; bits->bit; ++bits)\n\t\tif (val & bits->bit) {\n\t\t\tprintk(\"%s%s\", sep, bits->name);\n\t\t\tsep = \",\";\n\t\t}\n\tprintk(\">\");\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\">\""
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s%s\"",
            "sep",
            "bits->name"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"<\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void printbits(unsigned long val, struct regbit *bits)\n{\n\tconst char *sep = \"\";\n\n\tprintk(\"<\");\n\tfor (; bits->bit; ++bits)\n\t\tif (val & bits->bit) {\n\t\t\tprintk(\"%s%s\", sep, bits->name);\n\t\t\tsep = \",\";\n\t\t}\n\tprintk(\">\");\n}"
  },
  {
    "function_name": "show_instructions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "899-935",
    "snippet": "static void show_instructions(struct pt_regs *regs)\n{\n\tint i;\n\tunsigned long pc = regs->nip - (instructions_to_print * 3 / 4 *\n\t\t\tsizeof(int));\n\n\tprintk(\"Instruction dump:\");\n\n\tfor (i = 0; i < instructions_to_print; i++) {\n\t\tint instr;\n\n\t\tif (!(i % 8))\n\t\t\tprintk(\"\\n\");\n\n#if !defined(CONFIG_BOOKE)\n\t\t/* If executing with the IMMU off, adjust pc rather\n\t\t * than print XXXXXXXX.\n\t\t */\n\t\tif (!(regs->msr & MSR_IR))\n\t\t\tpc = (unsigned long)phys_to_virt(pc);\n#endif\n\n\t\tif (!__kernel_text_address(pc) ||\n\t\t     probe_kernel_address((unsigned int __user *)pc, instr)) {\n\t\t\tprintk(KERN_CONT \"XXXXXXXX \");\n\t\t} else {\n\t\t\tif (regs->nip == pc)\n\t\t\t\tprintk(KERN_CONT \"<%08x> \", instr);\n\t\t\telse\n\t\t\t\tprintk(KERN_CONT \"%08x \", instr);\n\t\t}\n\n\t\tpc += sizeof(int);\n\t}\n\n\tprintk(\"\\n\");\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int instructions_to_print = 16;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"%08x \"",
            "instr"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"XXXXXXXX \""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_address",
          "args": [
            "(unsigned int __user *)pc",
            "instr"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernel_text_address",
          "args": [
            "pc"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "phys_to_virt",
          "args": [
            "pc"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"\\n\""
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Instruction dump:\""
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic int instructions_to_print = 16;\n\nstatic void show_instructions(struct pt_regs *regs)\n{\n\tint i;\n\tunsigned long pc = regs->nip - (instructions_to_print * 3 / 4 *\n\t\t\tsizeof(int));\n\n\tprintk(\"Instruction dump:\");\n\n\tfor (i = 0; i < instructions_to_print; i++) {\n\t\tint instr;\n\n\t\tif (!(i % 8))\n\t\t\tprintk(\"\\n\");\n\n#if !defined(CONFIG_BOOKE)\n\t\t/* If executing with the IMMU off, adjust pc rather\n\t\t * than print XXXXXXXX.\n\t\t */\n\t\tif (!(regs->msr & MSR_IR))\n\t\t\tpc = (unsigned long)phys_to_virt(pc);\n#endif\n\n\t\tif (!__kernel_text_address(pc) ||\n\t\t     probe_kernel_address((unsigned int __user *)pc, instr)) {\n\t\t\tprintk(KERN_CONT \"XXXXXXXX \");\n\t\t} else {\n\t\t\tif (regs->nip == pc)\n\t\t\t\tprintk(KERN_CONT \"<%08x> \", instr);\n\t\t\telse\n\t\t\t\tprintk(KERN_CONT \"%08x \", instr);\n\t\t}\n\n\t\tpc += sizeof(int);\n\t}\n\n\tprintk(\"\\n\");\n}"
  },
  {
    "function_name": "__switch_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "745-895",
    "snippet": "struct task_struct *__switch_to(struct task_struct *prev,\n\tstruct task_struct *new)\n{\n\tstruct thread_struct *new_thread, *old_thread;\n\tstruct task_struct *last;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tstruct ppc64_tlb_batch *batch;\n#endif\n\n\tWARN_ON(!irqs_disabled());\n\n\t/* Back up the TAR and DSCR across context switches.\n\t * Note that the TAR is not available for use in the kernel.  (To\n\t * provide this, the TAR should be backed up/restored on exception\n\t * entry/exit instead, and be in pt_regs.  FIXME, this should be in\n\t * pt_regs anyway (for debug).)\n\t * Save the TAR and DSCR here before we do treclaim/trecheckpoint as\n\t * these will change them.\n\t */\n\tsave_early_sprs(&prev->thread);\n\n\t__switch_to_tm(prev);\n\n#ifdef CONFIG_SMP\n\t/* avoid complexity of lazy save/restore of fpu\n\t * by just saving it every time we switch out if\n\t * this task used the fpu during the last quantum.\n\t *\n\t * If it tries to use the fpu again, it'll trap and\n\t * reload its fp regs.  So we don't have to do a restore\n\t * every switch, just a save.\n\t *  -- Cort\n\t */\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_FP))\n\t\tgiveup_fpu(prev);\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * If the previous thread used altivec in the last quantum\n\t * (thus changing altivec regs) then save them.\n\t * We used to check the VRSAVE register but not all apps\n\t * set it, so we don't rely on it now (and in fact we need\n\t * to save & restore VSCR even if VRSAVE == 0).  -- paulus\n\t *\n\t * On SMP we always save/restore altivec regs just to avoid the\n\t * complexity of changing processors.\n\t *  -- Cort\n\t */\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_VEC))\n\t\tgiveup_altivec(prev);\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_VSX))\n\t\t/* VMX and FPU registers are already save here */\n\t\t__giveup_vsx(prev);\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/*\n\t * If the previous thread used spe in the last quantum\n\t * (thus changing spe regs) then save them.\n\t *\n\t * On SMP we always save/restore spe regs just to avoid the\n\t * complexity of changing processors.\n\t */\n\tif ((prev->thread.regs && (prev->thread.regs->msr & MSR_SPE)))\n\t\tgiveup_spe(prev);\n#endif /* CONFIG_SPE */\n\n#else  /* CONFIG_SMP */\n#ifdef CONFIG_ALTIVEC\n\t/* Avoid the trap.  On smp this this never happens since\n\t * we don't set last_task_used_altivec -- Cort\n\t */\n\tif (new->thread.regs && last_task_used_altivec == new)\n\t\tnew->thread.regs->msr |= MSR_VEC;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (new->thread.regs && last_task_used_vsx == new)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* Avoid the trap.  On smp this this never happens since\n\t * we don't set last_task_used_spe\n\t */\n\tif (new->thread.regs && last_task_used_spe == new)\n\t\tnew->thread.regs->msr |= MSR_SPE;\n#endif /* CONFIG_SPE */\n\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tswitch_booke_debug_regs(&new->thread.debug);\n#else\n/*\n * For PPC_BOOK3S_64, we use the hw-breakpoint interfaces that would\n * schedule DABR\n */\n#ifndef CONFIG_HAVE_HW_BREAKPOINT\n\tif (unlikely(!hw_brk_match(this_cpu_ptr(&current_brk), &new->thread.hw_brk)))\n\t\t__set_breakpoint(&new->thread.hw_brk);\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#endif\n\n\n\tnew_thread = &new->thread;\n\told_thread = &current->thread;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Collect processor utilization data per process\n\t */\n\tif (firmware_has_feature(FW_FEATURE_SPLPAR)) {\n\t\tstruct cpu_usage *cu = this_cpu_ptr(&cpu_usage_array);\n\t\tlong unsigned start_tb, current_tb;\n\t\tstart_tb = old_thread->start_tb;\n\t\tcu->current_tb = current_tb = mfspr(SPRN_PURR);\n\t\told_thread->accum_tb += (current_tb - start_tb);\n\t\tnew_thread->start_tb = current_tb;\n\t}\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tbatch = this_cpu_ptr(&ppc64_tlb_batch);\n\tif (batch->active) {\n\t\tcurrent_thread_info()->local_flags |= _TLF_LAZY_MMU;\n\t\tif (batch->index)\n\t\t\t__flush_tlb_pending(batch);\n\t\tbatch->active = 0;\n\t}\n#endif /* CONFIG_PPC_BOOK3S_64 */\n\n\t/*\n\t * We can't take a PMU exception inside _switch() since there is a\n\t * window where the kernel stack SLB and the kernel stack are out\n\t * of sync. Hard disable here.\n\t */\n\thard_irq_disable();\n\n\ttm_recheckpoint_new_task(new);\n\n\tlast = _switch(old_thread, new_thread);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (current_thread_info()->local_flags & _TLF_LAZY_MMU) {\n\t\tcurrent_thread_info()->local_flags &= ~_TLF_LAZY_MMU;\n\t\tbatch = this_cpu_ptr(&ppc64_tlb_batch);\n\t\tbatch->active = 1;\n\t}\n#endif /* CONFIG_PPC_BOOK3S_64 */\n\n\treturn last;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&ppc64_tlb_batch"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_switch",
          "args": [
            "old_thread",
            "new_thread"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "__switch_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "745-895",
          "snippet": "struct task_struct *__switch_to(struct task_struct *prev,\n\tstruct task_struct *new)\n{\n\tstruct thread_struct *new_thread, *old_thread;\n\tstruct task_struct *last;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tstruct ppc64_tlb_batch *batch;\n#endif\n\n\tWARN_ON(!irqs_disabled());\n\n\t/* Back up the TAR and DSCR across context switches.\n\t * Note that the TAR is not available for use in the kernel.  (To\n\t * provide this, the TAR should be backed up/restored on exception\n\t * entry/exit instead, and be in pt_regs.  FIXME, this should be in\n\t * pt_regs anyway (for debug).)\n\t * Save the TAR and DSCR here before we do treclaim/trecheckpoint as\n\t * these will change them.\n\t */\n\tsave_early_sprs(&prev->thread);\n\n\t__switch_to_tm(prev);\n\n#ifdef CONFIG_SMP\n\t/* avoid complexity of lazy save/restore of fpu\n\t * by just saving it every time we switch out if\n\t * this task used the fpu during the last quantum.\n\t *\n\t * If it tries to use the fpu again, it'll trap and\n\t * reload its fp regs.  So we don't have to do a restore\n\t * every switch, just a save.\n\t *  -- Cort\n\t */\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_FP))\n\t\tgiveup_fpu(prev);\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * If the previous thread used altivec in the last quantum\n\t * (thus changing altivec regs) then save them.\n\t * We used to check the VRSAVE register but not all apps\n\t * set it, so we don't rely on it now (and in fact we need\n\t * to save & restore VSCR even if VRSAVE == 0).  -- paulus\n\t *\n\t * On SMP we always save/restore altivec regs just to avoid the\n\t * complexity of changing processors.\n\t *  -- Cort\n\t */\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_VEC))\n\t\tgiveup_altivec(prev);\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_VSX))\n\t\t/* VMX and FPU registers are already save here */\n\t\t__giveup_vsx(prev);\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/*\n\t * If the previous thread used spe in the last quantum\n\t * (thus changing spe regs) then save them.\n\t *\n\t * On SMP we always save/restore spe regs just to avoid the\n\t * complexity of changing processors.\n\t */\n\tif ((prev->thread.regs && (prev->thread.regs->msr & MSR_SPE)))\n\t\tgiveup_spe(prev);\n#endif /* CONFIG_SPE */\n\n#else  /* CONFIG_SMP */\n#ifdef CONFIG_ALTIVEC\n\t/* Avoid the trap.  On smp this this never happens since\n\t * we don't set last_task_used_altivec -- Cort\n\t */\n\tif (new->thread.regs && last_task_used_altivec == new)\n\t\tnew->thread.regs->msr |= MSR_VEC;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (new->thread.regs && last_task_used_vsx == new)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* Avoid the trap.  On smp this this never happens since\n\t * we don't set last_task_used_spe\n\t */\n\tif (new->thread.regs && last_task_used_spe == new)\n\t\tnew->thread.regs->msr |= MSR_SPE;\n#endif /* CONFIG_SPE */\n\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tswitch_booke_debug_regs(&new->thread.debug);\n#else\n/*\n * For PPC_BOOK3S_64, we use the hw-breakpoint interfaces that would\n * schedule DABR\n */\n#ifndef CONFIG_HAVE_HW_BREAKPOINT\n\tif (unlikely(!hw_brk_match(this_cpu_ptr(&current_brk), &new->thread.hw_brk)))\n\t\t__set_breakpoint(&new->thread.hw_brk);\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#endif\n\n\n\tnew_thread = &new->thread;\n\told_thread = &current->thread;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Collect processor utilization data per process\n\t */\n\tif (firmware_has_feature(FW_FEATURE_SPLPAR)) {\n\t\tstruct cpu_usage *cu = this_cpu_ptr(&cpu_usage_array);\n\t\tlong unsigned start_tb, current_tb;\n\t\tstart_tb = old_thread->start_tb;\n\t\tcu->current_tb = current_tb = mfspr(SPRN_PURR);\n\t\told_thread->accum_tb += (current_tb - start_tb);\n\t\tnew_thread->start_tb = current_tb;\n\t}\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tbatch = this_cpu_ptr(&ppc64_tlb_batch);\n\tif (batch->active) {\n\t\tcurrent_thread_info()->local_flags |= _TLF_LAZY_MMU;\n\t\tif (batch->index)\n\t\t\t__flush_tlb_pending(batch);\n\t\tbatch->active = 0;\n\t}\n#endif /* CONFIG_PPC_BOOK3S_64 */\n\n\t/*\n\t * We can't take a PMU exception inside _switch() since there is a\n\t * window where the kernel stack SLB and the kernel stack are out\n\t * of sync. Hard disable here.\n\t */\n\thard_irq_disable();\n\n\ttm_recheckpoint_new_task(new);\n\n\tlast = _switch(old_thread, new_thread);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (current_thread_info()->local_flags & _TLF_LAZY_MMU) {\n\t\tcurrent_thread_info()->local_flags &= ~_TLF_LAZY_MMU;\n\t\tbatch = this_cpu_ptr(&ppc64_tlb_batch);\n\t\tbatch->active = 1;\n\t}\n#endif /* CONFIG_PPC_BOOK3S_64 */\n\n\treturn last;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint_new_task",
          "args": [
            "new"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint_new_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "644-694",
          "snippet": "static inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tunsigned long msr;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavoidable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!new->thread.regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\tmsr = new->thread.ckpt_regs.msr;\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d \"\n\t\t \"(new->msr 0x%lx, new->origmsr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr, msr);\n\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&new->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&new->thread);\n\t\tnew->thread.regs->msr |=\n\t\t\t(MSR_FP | new->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&new->thread);\n\t\tnew->thread.regs->msr |= MSR_VEC;\n\t}\n#endif\n\t/* We may as well turn on VSX too since all the state is restored now */\n\tif (msr & MSR_VSX)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tunsigned long msr;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavoidable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!new->thread.regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\tmsr = new->thread.ckpt_regs.msr;\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d \"\n\t\t \"(new->msr 0x%lx, new->origmsr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr, msr);\n\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&new->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&new->thread);\n\t\tnew->thread.regs->msr |=\n\t\t\t(MSR_FP | new->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&new->thread);\n\t\tnew->thread.regs->msr |= MSR_VEC;\n\t}\n#endif\n\t/* We may as well turn on VSX too since all the state is restored now */\n\tif (msr & MSR_VSX)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}"
        }
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__flush_tlb_pending",
          "args": [
            "batch"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&ppc64_tlb_batch"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_PURR"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&cpu_usage_array"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "firmware_has_feature",
          "args": [
            "FW_FEATURE_SPLPAR"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "&new->thread.hw_brk"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "497-505",
          "snippet": "void __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nvoid __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!hw_brk_match(this_cpu_ptr(&current_brk), &new->thread.hw_brk)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_brk_match",
          "args": [
            "this_cpu_ptr(&current_brk)",
            "&new->thread.hw_brk"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "hw_brk_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "518-528",
          "snippet": "static inline bool hw_brk_match(struct arch_hw_breakpoint *a,\n\t\t\t      struct arch_hw_breakpoint *b)\n{\n\tif (a->address != b->address)\n\t\treturn false;\n\tif (a->type != b->type)\n\t\treturn false;\n\tif (a->len != b->len)\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool hw_brk_match(struct arch_hw_breakpoint *a,\n\t\t\t      struct arch_hw_breakpoint *b)\n{\n\tif (a->address != b->address)\n\t\treturn false;\n\tif (a->type != b->type)\n\t\treturn false;\n\tif (a->len != b->len)\n\t\treturn false;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&current_brk"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_booke_debug_regs",
          "args": [
            "&new->thread.debug"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "switch_booke_debug_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "414-419",
          "snippet": "void switch_booke_debug_regs(struct debug_reg *new_debug)\n{\n\tif ((current->thread.debug.dbcr0 & DBCR0_IDM)\n\t\t|| (new_debug->dbcr0 & DBCR0_IDM))\n\t\t\tprime_debug_regs(new_debug);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid switch_booke_debug_regs(struct debug_reg *new_debug)\n{\n\tif ((current->thread.debug.dbcr0 & DBCR0_IDM)\n\t\t|| (new_debug->dbcr0 & DBCR0_IDM))\n\t\t\tprime_debug_regs(new_debug);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giveup_spe",
          "args": [
            "prev"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__giveup_vsx",
          "args": [
            "prev"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_altivec",
          "args": [
            "prev"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_altivec_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "96-112",
          "snippet": "void giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giveup_fpu",
          "args": [
            "prev"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_fpu_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "78-94",
          "snippet": "void giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__switch_to_tm",
          "args": [
            "prev"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "__switch_to_tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "696-702",
          "snippet": "static inline void __switch_to_tm(struct task_struct *prev)\n{\n\tif (cpu_has_feature(CPU_FTR_TM)) {\n\t\ttm_enable();\n\t\ttm_reclaim_task(prev);\n\t}\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void __switch_to_tm(struct task_struct *prev)\n{\n\tif (cpu_has_feature(CPU_FTR_TM)) {\n\t\ttm_enable();\n\t\ttm_reclaim_task(prev);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_early_sprs",
          "args": [
            "&prev->thread"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!irqs_disabled()"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nstruct task_struct *__switch_to(struct task_struct *prev,\n\tstruct task_struct *new)\n{\n\tstruct thread_struct *new_thread, *old_thread;\n\tstruct task_struct *last;\n#ifdef CONFIG_PPC_BOOK3S_64\n\tstruct ppc64_tlb_batch *batch;\n#endif\n\n\tWARN_ON(!irqs_disabled());\n\n\t/* Back up the TAR and DSCR across context switches.\n\t * Note that the TAR is not available for use in the kernel.  (To\n\t * provide this, the TAR should be backed up/restored on exception\n\t * entry/exit instead, and be in pt_regs.  FIXME, this should be in\n\t * pt_regs anyway (for debug).)\n\t * Save the TAR and DSCR here before we do treclaim/trecheckpoint as\n\t * these will change them.\n\t */\n\tsave_early_sprs(&prev->thread);\n\n\t__switch_to_tm(prev);\n\n#ifdef CONFIG_SMP\n\t/* avoid complexity of lazy save/restore of fpu\n\t * by just saving it every time we switch out if\n\t * this task used the fpu during the last quantum.\n\t *\n\t * If it tries to use the fpu again, it'll trap and\n\t * reload its fp regs.  So we don't have to do a restore\n\t * every switch, just a save.\n\t *  -- Cort\n\t */\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_FP))\n\t\tgiveup_fpu(prev);\n#ifdef CONFIG_ALTIVEC\n\t/*\n\t * If the previous thread used altivec in the last quantum\n\t * (thus changing altivec regs) then save them.\n\t * We used to check the VRSAVE register but not all apps\n\t * set it, so we don't rely on it now (and in fact we need\n\t * to save & restore VSCR even if VRSAVE == 0).  -- paulus\n\t *\n\t * On SMP we always save/restore altivec regs just to avoid the\n\t * complexity of changing processors.\n\t *  -- Cort\n\t */\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_VEC))\n\t\tgiveup_altivec(prev);\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (prev->thread.regs && (prev->thread.regs->msr & MSR_VSX))\n\t\t/* VMX and FPU registers are already save here */\n\t\t__giveup_vsx(prev);\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/*\n\t * If the previous thread used spe in the last quantum\n\t * (thus changing spe regs) then save them.\n\t *\n\t * On SMP we always save/restore spe regs just to avoid the\n\t * complexity of changing processors.\n\t */\n\tif ((prev->thread.regs && (prev->thread.regs->msr & MSR_SPE)))\n\t\tgiveup_spe(prev);\n#endif /* CONFIG_SPE */\n\n#else  /* CONFIG_SMP */\n#ifdef CONFIG_ALTIVEC\n\t/* Avoid the trap.  On smp this this never happens since\n\t * we don't set last_task_used_altivec -- Cort\n\t */\n\tif (new->thread.regs && last_task_used_altivec == new)\n\t\tnew->thread.regs->msr |= MSR_VEC;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (new->thread.regs && last_task_used_vsx == new)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* Avoid the trap.  On smp this this never happens since\n\t * we don't set last_task_used_spe\n\t */\n\tif (new->thread.regs && last_task_used_spe == new)\n\t\tnew->thread.regs->msr |= MSR_SPE;\n#endif /* CONFIG_SPE */\n\n#endif /* CONFIG_SMP */\n\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tswitch_booke_debug_regs(&new->thread.debug);\n#else\n/*\n * For PPC_BOOK3S_64, we use the hw-breakpoint interfaces that would\n * schedule DABR\n */\n#ifndef CONFIG_HAVE_HW_BREAKPOINT\n\tif (unlikely(!hw_brk_match(this_cpu_ptr(&current_brk), &new->thread.hw_brk)))\n\t\t__set_breakpoint(&new->thread.hw_brk);\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#endif\n\n\n\tnew_thread = &new->thread;\n\told_thread = &current->thread;\n\n#ifdef CONFIG_PPC64\n\t/*\n\t * Collect processor utilization data per process\n\t */\n\tif (firmware_has_feature(FW_FEATURE_SPLPAR)) {\n\t\tstruct cpu_usage *cu = this_cpu_ptr(&cpu_usage_array);\n\t\tlong unsigned start_tb, current_tb;\n\t\tstart_tb = old_thread->start_tb;\n\t\tcu->current_tb = current_tb = mfspr(SPRN_PURR);\n\t\told_thread->accum_tb += (current_tb - start_tb);\n\t\tnew_thread->start_tb = current_tb;\n\t}\n#endif /* CONFIG_PPC64 */\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tbatch = this_cpu_ptr(&ppc64_tlb_batch);\n\tif (batch->active) {\n\t\tcurrent_thread_info()->local_flags |= _TLF_LAZY_MMU;\n\t\tif (batch->index)\n\t\t\t__flush_tlb_pending(batch);\n\t\tbatch->active = 0;\n\t}\n#endif /* CONFIG_PPC_BOOK3S_64 */\n\n\t/*\n\t * We can't take a PMU exception inside _switch() since there is a\n\t * window where the kernel stack SLB and the kernel stack are out\n\t * of sync. Hard disable here.\n\t */\n\thard_irq_disable();\n\n\ttm_recheckpoint_new_task(new);\n\n\tlast = _switch(old_thread, new_thread);\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\tif (current_thread_info()->local_flags & _TLF_LAZY_MMU) {\n\t\tcurrent_thread_info()->local_flags &= ~_TLF_LAZY_MMU;\n\t\tbatch = this_cpu_ptr(&ppc64_tlb_batch);\n\t\tbatch->active = 1;\n\t}\n#endif /* CONFIG_PPC_BOOK3S_64 */\n\n\treturn last;\n}"
  },
  {
    "function_name": "restore_tm_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "718-738",
    "snippet": "void restore_tm_state(struct pt_regs *regs)\n{\n\tunsigned long msr_diff;\n\n\tclear_thread_flag(TIF_RESTORE_TM);\n\tif (!MSR_TM_ACTIVE(regs->msr))\n\t\treturn;\n\n\tmsr_diff = current->thread.ckpt_regs.msr & ~regs->msr;\n\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX;\n\tif (msr_diff & MSR_FP) {\n\t\tfp_enable();\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tregs->msr |= current->thread.fpexc_mode;\n\t}\n\tif (msr_diff & MSR_VEC) {\n\t\tvec_enable();\n\t\tload_vr_state(&current->thread.vr_state);\n\t}\n\tregs->msr |= msr_diff;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_vr_state",
          "args": [
            "&current->thread.vr_state"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vec_enable",
          "args": [],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_fp_state",
          "args": [
            "&current->thread.fp_state"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fp_enable",
          "args": [],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "regs->msr"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_RESTORE_TM"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid restore_tm_state(struct pt_regs *regs)\n{\n\tunsigned long msr_diff;\n\n\tclear_thread_flag(TIF_RESTORE_TM);\n\tif (!MSR_TM_ACTIVE(regs->msr))\n\t\treturn;\n\n\tmsr_diff = current->thread.ckpt_regs.msr & ~regs->msr;\n\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX;\n\tif (msr_diff & MSR_FP) {\n\t\tfp_enable();\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tregs->msr |= current->thread.fpexc_mode;\n\t}\n\tif (msr_diff & MSR_VEC) {\n\t\tvec_enable();\n\t\tload_vr_state(&current->thread.vr_state);\n\t}\n\tregs->msr |= msr_diff;\n}"
  },
  {
    "function_name": "__switch_to_tm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "696-702",
    "snippet": "static inline void __switch_to_tm(struct task_struct *prev)\n{\n\tif (cpu_has_feature(CPU_FTR_TM)) {\n\t\ttm_enable();\n\t\ttm_reclaim_task(prev);\n\t}\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_reclaim_task",
          "args": [
            "prev"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "571-617",
          "snippet": "static inline void tm_reclaim_task(struct task_struct *tsk)\n{\n\t/* We have to work out if we're switching from/to a task that's in the\n\t * middle of a transaction.\n\t *\n\t * In switching we need to maintain a 2nd register state as\n\t * oldtask->thread.ckpt_regs.  We tm_reclaim(oldproc); this saves the\n\t * checkpointed (tbegin) state in ckpt_regs and saves the transactional\n\t * (current) FPRs into oldtask->thread.transact_fpr[].\n\t *\n\t * We also context switch (save) TFHAR/TEXASR/TFIAR in here.\n\t */\n\tstruct thread_struct *thr = &tsk->thread;\n\n\tif (!thr->regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(thr->regs->msr))\n\t\tgoto out_and_saveregs;\n\n\t/* Stash the original thread MSR, as giveup_fpu et al will\n\t * modify it.  We hold onto it to see whether the task used\n\t * FP & vector regs.  If the TIF_RESTORE_TM flag is set,\n\t * ckpt_regs.msr is already set.\n\t */\n\tif (!test_ti_thread_flag(task_thread_info(tsk), TIF_RESTORE_TM))\n\t\tthr->ckpt_regs.msr = thr->regs->msr;\n\n\tTM_DEBUG(\"--- tm_reclaim on pid %d (NIP=%lx, \"\n\t\t \"ccr=%lx, msr=%lx, trap=%lx)\\n\",\n\t\t tsk->pid, thr->regs->nip,\n\t\t thr->regs->ccr, thr->regs->msr,\n\t\t thr->regs->trap);\n\n\ttm_reclaim_thread(thr, task_thread_info(tsk), TM_CAUSE_RESCHED);\n\n\tTM_DEBUG(\"--- tm_reclaim on pid %d complete\\n\",\n\t\t tsk->pid);\n\nout_and_saveregs:\n\t/* Always save the regs here, even if a transaction's not active.\n\t * This context-switches a thread's TM info SPRs.  We do it here to\n\t * be consistent with the restore path (in recheckpoint) which\n\t * cannot happen later in _switch().\n\t */\n\ttm_save_sprs(thr);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_reclaim_task(struct task_struct *tsk)\n{\n\t/* We have to work out if we're switching from/to a task that's in the\n\t * middle of a transaction.\n\t *\n\t * In switching we need to maintain a 2nd register state as\n\t * oldtask->thread.ckpt_regs.  We tm_reclaim(oldproc); this saves the\n\t * checkpointed (tbegin) state in ckpt_regs and saves the transactional\n\t * (current) FPRs into oldtask->thread.transact_fpr[].\n\t *\n\t * We also context switch (save) TFHAR/TEXASR/TFIAR in here.\n\t */\n\tstruct thread_struct *thr = &tsk->thread;\n\n\tif (!thr->regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(thr->regs->msr))\n\t\tgoto out_and_saveregs;\n\n\t/* Stash the original thread MSR, as giveup_fpu et al will\n\t * modify it.  We hold onto it to see whether the task used\n\t * FP & vector regs.  If the TIF_RESTORE_TM flag is set,\n\t * ckpt_regs.msr is already set.\n\t */\n\tif (!test_ti_thread_flag(task_thread_info(tsk), TIF_RESTORE_TM))\n\t\tthr->ckpt_regs.msr = thr->regs->msr;\n\n\tTM_DEBUG(\"--- tm_reclaim on pid %d (NIP=%lx, \"\n\t\t \"ccr=%lx, msr=%lx, trap=%lx)\\n\",\n\t\t tsk->pid, thr->regs->nip,\n\t\t thr->regs->ccr, thr->regs->msr,\n\t\t thr->regs->trap);\n\n\ttm_reclaim_thread(thr, task_thread_info(tsk), TM_CAUSE_RESCHED);\n\n\tTM_DEBUG(\"--- tm_reclaim on pid %d complete\\n\",\n\t\t tsk->pid);\n\nout_and_saveregs:\n\t/* Always save the regs here, even if a transaction's not active.\n\t * This context-switches a thread's TM info SPRs.  We do it here to\n\t * be consistent with the restore path (in recheckpoint) which\n\t * cannot happen later in _switch().\n\t */\n\ttm_save_sprs(thr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void __switch_to_tm(struct task_struct *prev)\n{\n\tif (cpu_has_feature(CPU_FTR_TM)) {\n\t\ttm_enable();\n\t\ttm_reclaim_task(prev);\n\t}\n}"
  },
  {
    "function_name": "tm_recheckpoint_new_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "644-694",
    "snippet": "static inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tunsigned long msr;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavoidable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!new->thread.regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\tmsr = new->thread.ckpt_regs.msr;\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d \"\n\t\t \"(new->msr 0x%lx, new->origmsr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr, msr);\n\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&new->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&new->thread);\n\t\tnew->thread.regs->msr |=\n\t\t\t(MSR_FP | new->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&new->thread);\n\t\tnew->thread.regs->msr |= MSR_VEC;\n\t}\n#endif\n\t/* We may as well turn on VSX too since all the state is restored now */\n\tif (msr & MSR_VSX)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\"",
            "new->pid",
            "mfmsr()"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_load_up_transact_altivec",
          "args": [
            "&new->thread"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_load_up_transact_fpu",
          "args": [
            "&new->thread"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_recheckpoint",
          "args": [
            "&new->thread",
            "msr"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "tm_recheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "622-642",
          "snippet": "void tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"*** tm_recheckpoint of pid %d \"\n\t\t \"(new->msr 0x%lx, new->origmsr 0x%lx)\\n\"",
            "new->pid",
            "new->thread.regs->msr",
            "msr"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_restore_sprs",
          "args": [
            "&new->thread"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "new->thread.regs->msr"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_TM"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_recheckpoint_new_task(struct task_struct *new)\n{\n\tunsigned long msr;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn;\n\n\t/* Recheckpoint the registers of the thread we're about to switch to.\n\t *\n\t * If the task was using FP, we non-lazily reload both the original and\n\t * the speculative FP register states.  This is because the kernel\n\t * doesn't see if/when a TM rollback occurs, so if we take an FP\n\t * unavoidable later, we are unable to determine which set of FP regs\n\t * need to be restored.\n\t */\n\tif (!new->thread.regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(new->thread.regs->msr)){\n\t\ttm_restore_sprs(&new->thread);\n\t\treturn;\n\t}\n\tmsr = new->thread.ckpt_regs.msr;\n\t/* Recheckpoint to restore original checkpointed register state. */\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d \"\n\t\t \"(new->msr 0x%lx, new->origmsr 0x%lx)\\n\",\n\t\t new->pid, new->thread.regs->msr, msr);\n\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&new->thread, msr);\n\n\t/* This loads the speculative FP/VEC state, if used */\n\tif (msr & MSR_FP) {\n\t\tdo_load_up_transact_fpu(&new->thread);\n\t\tnew->thread.regs->msr |=\n\t\t\t(MSR_FP | new->thread.fpexc_mode);\n\t}\n#ifdef CONFIG_ALTIVEC\n\tif (msr & MSR_VEC) {\n\t\tdo_load_up_transact_altivec(&new->thread);\n\t\tnew->thread.regs->msr |= MSR_VEC;\n\t}\n#endif\n\t/* We may as well turn on VSX too since all the state is restored now */\n\tif (msr & MSR_VSX)\n\t\tnew->thread.regs->msr |= MSR_VSX;\n\n\tTM_DEBUG(\"*** tm_recheckpoint of pid %d complete \"\n\t\t \"(kernel msr 0x%lx)\\n\",\n\t\t new->pid, mfmsr());\n}"
  },
  {
    "function_name": "tm_recheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "622-642",
    "snippet": "void tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "arch_local_irq_restore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/irq.c",
          "lines": "202-277",
          "snippet": "notrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}",
          "includes": [
            "#include <asm/trace.h>",
            "#include <asm/lv1call.h>",
            "#include <asm/firmware.h>",
            "#include <asm/paca.h>",
            "#include <asm/debug.h>",
            "#include <asm/smp.h>",
            "#include <asm/udbg.h>",
            "#include <asm/machdep.h>",
            "#include <asm/ptrace.h>",
            "#include <asm/prom.h>",
            "#include <asm/cache.h>",
            "#include <asm/irq.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pci.h>",
            "#include <linux/mutex.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/profile.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/irq.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/timex.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/ioport.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/threads.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/trace.h>\n#include <asm/lv1call.h>\n#include <asm/firmware.h>\n#include <asm/paca.h>\n#include <asm/debug.h>\n#include <asm/smp.h>\n#include <asm/udbg.h>\n#include <asm/machdep.h>\n#include <asm/ptrace.h>\n#include <asm/prom.h>\n#include <asm/cache.h>\n#include <asm/irq.h>\n#include <asm/pgtable.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/of_irq.h>\n#include <linux/of.h>\n#include <linux/debugfs.h>\n#include <linux/pci.h>\n#include <linux/mutex.h>\n#include <linux/radix-tree.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/profile.h>\n#include <linux/cpumask.h>\n#include <linux/seq_file.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/timex.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/ptrace.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n#include <linux/kernel_stat.h>\n#include <linux/threads.h>\n#include <linux/export.h>\n\nnotrace void arch_local_irq_restore(unsigned long en)\n{\n\tunsigned char irq_happened;\n\tunsigned int replay;\n\n\t/* Write the new soft-enabled value */\n\tset_soft_enabled(en);\n\tif (!en)\n\t\treturn;\n\t/*\n\t * From this point onward, we can take interrupts, preempt,\n\t * etc... unless we got hard-disabled. We check if an event\n\t * happened. If none happened, we know we can just return.\n\t *\n\t * We may have preempted before the check below, in which case\n\t * we are checking the \"new\" CPU instead of the old one. This\n\t * is only a problem if an event happened on the \"old\" CPU.\n\t *\n\t * External interrupt events will have caused interrupts to\n\t * be hard-disabled, so there is no problem, we\n\t * cannot have preempted.\n\t */\n\tirq_happened = get_irq_happened();\n\tif (!irq_happened)\n\t\treturn;\n\n\t/*\n\t * We need to hard disable to get a trusted value from\n\t * __check_irq_replay(). We also need to soft-disable\n\t * again to avoid warnings in there due to the use of\n\t * per-cpu variables.\n\t *\n\t * We know that if the value in irq_happened is exactly 0x01\n\t * then we are already hard disabled (there are other less\n\t * common cases that we'll ignore for now), so we skip the\n\t * (expensive) mtmsrd.\n\t */\n\tif (unlikely(irq_happened != PACA_IRQ_HARD_DIS))\n\t\t__hard_irq_disable();\n#ifdef CONFIG_TRACE_IRQFLAGS\n\telse {\n\t\t/*\n\t\t * We should already be hard disabled here. We had bugs\n\t\t * where that wasn't the case so let's dbl check it and\n\t\t * warn if we are wrong. Only do that when IRQ tracing\n\t\t * is enabled as mfmsr() can be costly.\n\t\t */\n\t\tif (WARN_ON(mfmsr() & MSR_EE))\n\t\t\t__hard_irq_disable();\n\t}\n#endif /* CONFIG_TRACE_IRQFLAG */\n\n\tset_soft_enabled(0);\n\n\t/*\n\t * Check if anything needs to be re-emitted. We haven't\n\t * soft-enabled yet to avoid warnings in decrementer_check_overflow\n\t * accessing per-cpu variables\n\t */\n\treplay = __check_irq_replay();\n\n\t/* We can soft-enable now */\n\tset_soft_enabled(1);\n\n\t/*\n\t * And replay if we have to. This will return with interrupts\n\t * hard-enabled.\n\t */\n\tif (replay) {\n\t\t__replay_interrupt(replay);\n\t\treturn;\n\t}\n\n\t/* Finally, let's ensure we are hard enabled */\n\t__hard_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tm_recheckpoint",
          "args": [
            "thread",
            "orig_msr"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_restore_sprs",
          "args": [
            "thread"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hard_irq_disable",
          "args": [],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_recheckpoint(struct thread_struct *thread,\n\t\t     unsigned long orig_msr)\n{\n\tunsigned long flags;\n\n\t/* We really can't be interrupted here as the TEXASR registers can't\n\t * change and later in the trecheckpoint code, we have a userspace R1.\n\t * So let's hard disable over this region.\n\t */\n\tlocal_irq_save(flags);\n\thard_irq_disable();\n\n\t/* The TM SPRs are restored here, so that TEXASR.FS can be set\n\t * before the trecheckpoint and no explosion occurs.\n\t */\n\ttm_restore_sprs(thread);\n\n\t__tm_recheckpoint(thread, orig_msr);\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "tm_reclaim_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "571-617",
    "snippet": "static inline void tm_reclaim_task(struct task_struct *tsk)\n{\n\t/* We have to work out if we're switching from/to a task that's in the\n\t * middle of a transaction.\n\t *\n\t * In switching we need to maintain a 2nd register state as\n\t * oldtask->thread.ckpt_regs.  We tm_reclaim(oldproc); this saves the\n\t * checkpointed (tbegin) state in ckpt_regs and saves the transactional\n\t * (current) FPRs into oldtask->thread.transact_fpr[].\n\t *\n\t * We also context switch (save) TFHAR/TEXASR/TFIAR in here.\n\t */\n\tstruct thread_struct *thr = &tsk->thread;\n\n\tif (!thr->regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(thr->regs->msr))\n\t\tgoto out_and_saveregs;\n\n\t/* Stash the original thread MSR, as giveup_fpu et al will\n\t * modify it.  We hold onto it to see whether the task used\n\t * FP & vector regs.  If the TIF_RESTORE_TM flag is set,\n\t * ckpt_regs.msr is already set.\n\t */\n\tif (!test_ti_thread_flag(task_thread_info(tsk), TIF_RESTORE_TM))\n\t\tthr->ckpt_regs.msr = thr->regs->msr;\n\n\tTM_DEBUG(\"--- tm_reclaim on pid %d (NIP=%lx, \"\n\t\t \"ccr=%lx, msr=%lx, trap=%lx)\\n\",\n\t\t tsk->pid, thr->regs->nip,\n\t\t thr->regs->ccr, thr->regs->msr,\n\t\t thr->regs->trap);\n\n\ttm_reclaim_thread(thr, task_thread_info(tsk), TM_CAUSE_RESCHED);\n\n\tTM_DEBUG(\"--- tm_reclaim on pid %d complete\\n\",\n\t\t tsk->pid);\n\nout_and_saveregs:\n\t/* Always save the regs here, even if a transaction's not active.\n\t * This context-switches a thread's TM info SPRs.  We do it here to\n\t * be consistent with the restore path (in recheckpoint) which\n\t * cannot happen later in _switch().\n\t */\n\ttm_save_sprs(thr);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_save_sprs",
          "args": [
            "thr"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"--- tm_reclaim on pid %d complete\\n\"",
            "tsk->pid"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_reclaim_thread",
          "args": [
            "thr",
            "task_thread_info(tsk)",
            "TM_CAUSE_RESCHED"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "531-563",
          "snippet": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_thread_info",
          "args": [
            "tsk"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TM_DEBUG",
          "args": [
            "\"--- tm_reclaim on pid %d (NIP=%lx, \"\n\t\t \"ccr=%lx, msr=%lx, trap=%lx)\\n\"",
            "tsk->pid",
            "thr->regs->nip",
            "thr->regs->ccr",
            "thr->regs->msr",
            "thr->regs->trap"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_ti_thread_flag",
          "args": [
            "task_thread_info(tsk)",
            "TIF_RESTORE_TM"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_thread_info",
          "args": [
            "tsk"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "thr->regs->msr"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline void tm_reclaim_task(struct task_struct *tsk)\n{\n\t/* We have to work out if we're switching from/to a task that's in the\n\t * middle of a transaction.\n\t *\n\t * In switching we need to maintain a 2nd register state as\n\t * oldtask->thread.ckpt_regs.  We tm_reclaim(oldproc); this saves the\n\t * checkpointed (tbegin) state in ckpt_regs and saves the transactional\n\t * (current) FPRs into oldtask->thread.transact_fpr[].\n\t *\n\t * We also context switch (save) TFHAR/TEXASR/TFIAR in here.\n\t */\n\tstruct thread_struct *thr = &tsk->thread;\n\n\tif (!thr->regs)\n\t\treturn;\n\n\tif (!MSR_TM_ACTIVE(thr->regs->msr))\n\t\tgoto out_and_saveregs;\n\n\t/* Stash the original thread MSR, as giveup_fpu et al will\n\t * modify it.  We hold onto it to see whether the task used\n\t * FP & vector regs.  If the TIF_RESTORE_TM flag is set,\n\t * ckpt_regs.msr is already set.\n\t */\n\tif (!test_ti_thread_flag(task_thread_info(tsk), TIF_RESTORE_TM))\n\t\tthr->ckpt_regs.msr = thr->regs->msr;\n\n\tTM_DEBUG(\"--- tm_reclaim on pid %d (NIP=%lx, \"\n\t\t \"ccr=%lx, msr=%lx, trap=%lx)\\n\",\n\t\t tsk->pid, thr->regs->nip,\n\t\t thr->regs->ccr, thr->regs->msr,\n\t\t thr->regs->trap);\n\n\ttm_reclaim_thread(thr, task_thread_info(tsk), TM_CAUSE_RESCHED);\n\n\tTM_DEBUG(\"--- tm_reclaim on pid %d complete\\n\",\n\t\t tsk->pid);\n\nout_and_saveregs:\n\t/* Always save the regs here, even if a transaction's not active.\n\t * This context-switches a thread's TM info SPRs.  We do it here to\n\t * be consistent with the restore path (in recheckpoint) which\n\t * cannot happen later in _switch().\n\t */\n\ttm_save_sprs(thr);\n}"
  },
  {
    "function_name": "tm_reclaim_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "565-569",
    "snippet": "void tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_reclaim_thread",
          "args": [
            "&current->thread",
            "current_thread_info()",
            "cause"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "531-563",
          "snippet": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_thread_info",
          "args": [],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tm_enable",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid tm_reclaim_current(uint8_t cause)\n{\n\ttm_enable();\n\ttm_reclaim_thread(&current->thread, current_thread_info(), cause);\n}"
  },
  {
    "function_name": "tm_reclaim_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "531-563",
    "snippet": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tm_reclaim",
          "args": [
            "thr",
            "thr->regs->msr",
            "cause"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "tm_reclaim_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "531-563",
          "snippet": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "clear_ti_thread_flag",
          "args": [
            "ti",
            "TIF_RESTORE_TM"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&thr->transact_vr",
            "&thr->vr_state",
            "sizeof(struct thread_vr_state)"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_ti_thread_flag",
          "args": [
            "ti",
            "TIF_RESTORE_TM"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}"
  },
  {
    "function_name": "hw_brk_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "518-528",
    "snippet": "static inline bool hw_brk_match(struct arch_hw_breakpoint *a,\n\t\t\t      struct arch_hw_breakpoint *b)\n{\n\tif (a->address != b->address)\n\t\treturn false;\n\tif (a->type != b->type)\n\t\treturn false;\n\tif (a->len != b->len)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline bool hw_brk_match(struct arch_hw_breakpoint *a,\n\t\t\t      struct arch_hw_breakpoint *b)\n{\n\tif (a->address != b->address)\n\t\treturn false;\n\tif (a->type != b->type)\n\t\treturn false;\n\tif (a->len != b->len)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "set_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "507-512",
    "snippet": "void set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tpreempt_disable();\n\t__set_breakpoint(brk);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_breakpoint",
          "args": [
            "brk"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "__set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "497-505",
          "snippet": "void __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nvoid __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tpreempt_disable();\n\t__set_breakpoint(brk);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "__set_breakpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "497-505",
    "snippet": "void __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_dabr",
          "args": [
            "brk"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "set_dabr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "456-467",
          "snippet": "static inline int set_dabr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dabr, dabrx;\n\n\tdabr = brk->address | (brk->type & HW_BRK_TYPE_DABR);\n\tdabrx = ((brk->type >> 3) & 0x7);\n\n\tif (ppc_md.set_dabr)\n\t\treturn ppc_md.set_dabr(dabr, dabrx);\n\n\treturn __set_dabr(dabr, dabrx);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int set_dabr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dabr, dabrx;\n\n\tdabr = brk->address | (brk->type & HW_BRK_TYPE_DABR);\n\tdabrx = ((brk->type >> 3) & 0x7);\n\n\tif (ppc_md.set_dabr)\n\t\treturn ppc_md.set_dabr(dabr, dabrx);\n\n\treturn __set_dabr(dabr, dabrx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_dawr",
          "args": [
            "brk"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "set_dawr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "469-495",
          "snippet": "static inline int set_dawr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE)) \\\n\t\t                   << (63 - 58); //* read/write bits */\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) \\\n\t\t                   << (63 - 59); //* translate */\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) \\\n\t\t                   >> 3; //* PRIM bits */\n\t/* dawr length is stored in field MDR bits 48:53.  Matches range in\n\t   doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t   0b111111=64DW.\n\t   brk->len is in bytes.\n\t   This aligns up to double word size, shifts and does the bias.\n\t*/\n\tmrd = ((brk->len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(dawr, dawrx);\n\tmtspr(SPRN_DAWR, dawr);\n\tmtspr(SPRN_DAWRX, dawrx);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int set_dawr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE)) \\\n\t\t                   << (63 - 58); //* read/write bits */\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) \\\n\t\t                   << (63 - 59); //* translate */\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) \\\n\t\t                   >> 3; //* PRIM bits */\n\t/* dawr length is stored in field MDR bits 48:53.  Matches range in\n\t   doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t   0b111111=64DW.\n\t   brk->len is in bytes.\n\t   This aligns up to double word size, shifts and does the bias.\n\t*/\n\tmrd = ((brk->len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(dawr, dawrx);\n\tmtspr(SPRN_DAWR, dawr);\n\tmtspr(SPRN_DAWRX, dawrx);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DAWR"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "this_cpu_ptr(&current_brk)",
            "brk",
            "sizeof(*brk)"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&current_brk"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic DEFINE_PER_CPU(struct arch_hw_breakpoint, current_brk);\n\nvoid __set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tmemcpy(this_cpu_ptr(&current_brk), brk, sizeof(*brk));\n\n\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\tset_dawr(brk);\n\telse\n\t\tset_dabr(brk);\n}"
  },
  {
    "function_name": "set_dawr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "469-495",
    "snippet": "static inline int set_dawr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE)) \\\n\t\t                   << (63 - 58); //* read/write bits */\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) \\\n\t\t                   << (63 - 59); //* translate */\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) \\\n\t\t                   >> 3; //* PRIM bits */\n\t/* dawr length is stored in field MDR bits 48:53.  Matches range in\n\t   doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t   0b111111=64DW.\n\t   brk->len is in bytes.\n\t   This aligns up to double word size, shifts and does the bias.\n\t*/\n\tmrd = ((brk->len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(dawr, dawrx);\n\tmtspr(SPRN_DAWR, dawr);\n\tmtspr(SPRN_DAWRX, dawrx);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAWRX",
            "dawrx"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAWR",
            "dawr"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc_md.set_dawr",
          "args": [
            "dawr",
            "dawrx"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int set_dawr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dawr, dawrx, mrd;\n\n\tdawr = brk->address;\n\n\tdawrx  = (brk->type & (HW_BRK_TYPE_READ | HW_BRK_TYPE_WRITE)) \\\n\t\t                   << (63 - 58); //* read/write bits */\n\tdawrx |= ((brk->type & (HW_BRK_TYPE_TRANSLATE)) >> 2) \\\n\t\t                   << (63 - 59); //* translate */\n\tdawrx |= (brk->type & (HW_BRK_TYPE_PRIV_ALL)) \\\n\t\t                   >> 3; //* PRIM bits */\n\t/* dawr length is stored in field MDR bits 48:53.  Matches range in\n\t   doublewords (64 bits) baised by -1 eg. 0b000000=1DW and\n\t   0b111111=64DW.\n\t   brk->len is in bytes.\n\t   This aligns up to double word size, shifts and does the bias.\n\t*/\n\tmrd = ((brk->len + 7) >> 3) - 1;\n\tdawrx |= (mrd & 0x3f) << (63 - 53);\n\n\tif (ppc_md.set_dawr)\n\t\treturn ppc_md.set_dawr(dawr, dawrx);\n\tmtspr(SPRN_DAWR, dawr);\n\tmtspr(SPRN_DAWRX, dawrx);\n\treturn 0;\n}"
  },
  {
    "function_name": "set_dabr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "456-467",
    "snippet": "static inline int set_dabr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dabr, dabrx;\n\n\tdabr = brk->address | (brk->type & HW_BRK_TYPE_DABR);\n\tdabrx = ((brk->type >> 3) & 0x7);\n\n\tif (ppc_md.set_dabr)\n\t\treturn ppc_md.set_dabr(dabr, dabrx);\n\n\treturn __set_dabr(dabr, dabrx);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_dabr",
          "args": [
            "dabr",
            "dabrx"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__set_dabr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "450-453",
          "snippet": "static inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.set_dabr",
          "args": [
            "dabr",
            "dabrx"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int set_dabr(struct arch_hw_breakpoint *brk)\n{\n\tunsigned long dabr, dabrx;\n\n\tdabr = brk->address | (brk->type & HW_BRK_TYPE_DABR);\n\tdabrx = ((brk->type >> 3) & 0x7);\n\n\tif (ppc_md.set_dabr)\n\t\treturn ppc_md.set_dabr(dabr, dabrx);\n\n\treturn __set_dabr(dabr, dabrx);\n}"
  },
  {
    "function_name": "__set_dabr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "450-453",
    "snippet": "static inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "__set_dabr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "442-448",
    "snippet": "static inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\tmtspr(SPRN_DABR, dabr);\n\tif (cpu_has_feature(CPU_FTR_DABRX))\n\t\tmtspr(SPRN_DABRX, dabrx);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DABRX",
            "dabrx"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_feature",
          "args": [
            "CPU_FTR_DABRX"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DABR",
            "dabr"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\tmtspr(SPRN_DABR, dabr);\n\tif (cpu_has_feature(CPU_FTR_DABRX))\n\t\tmtspr(SPRN_DABRX, dabrx);\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_dabr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "433-440",
    "snippet": "static inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\tmtspr(SPRN_DAC1, dabr);\n#ifdef CONFIG_PPC_47x\n\tisync();\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isync",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAC1",
            "dabr"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __set_dabr(unsigned long dabr, unsigned long dabrx)\n{\n\tmtspr(SPRN_DAC1, dabr);\n#ifdef CONFIG_PPC_47x\n\tisync();\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "set_debug_reg_defaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "423-428",
    "snippet": "static void set_debug_reg_defaults(struct thread_struct *thread)\n{\n\tthread->hw_brk.address = 0;\n\tthread->hw_brk.type = 0;\n\tset_breakpoint(&thread->hw_brk);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_breakpoint",
          "args": [
            "&thread->hw_brk"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "set_breakpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "507-512",
          "snippet": "void set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tpreempt_disable();\n\t__set_breakpoint(brk);\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid set_breakpoint(struct arch_hw_breakpoint *brk)\n{\n\tpreempt_disable();\n\t__set_breakpoint(brk);\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void set_debug_reg_defaults(struct thread_struct *thread)\n{\n\tthread->hw_brk.address = 0;\n\tthread->hw_brk.type = 0;\n\tset_breakpoint(&thread->hw_brk);\n}"
  },
  {
    "function_name": "switch_booke_debug_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "414-419",
    "snippet": "void switch_booke_debug_regs(struct debug_reg *new_debug)\n{\n\tif ((current->thread.debug.dbcr0 & DBCR0_IDM)\n\t\t|| (new_debug->dbcr0 & DBCR0_IDM))\n\t\t\tprime_debug_regs(new_debug);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "prime_debug_regs",
          "args": [
            "new_debug"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "prime_debug_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "382-408",
          "snippet": "static void prime_debug_regs(struct debug_reg *debug)\n{\n\t/*\n\t * We could have inherited MSR_DE from userspace, since\n\t * it doesn't get cleared on exception entry.  Make sure\n\t * MSR_DE is clear before we enable any debug events.\n\t */\n\tmtmsr(mfmsr() & ~MSR_DE);\n\n\tmtspr(SPRN_IAC1, debug->iac1);\n\tmtspr(SPRN_IAC2, debug->iac2);\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tmtspr(SPRN_IAC3, debug->iac3);\n\tmtspr(SPRN_IAC4, debug->iac4);\n#endif\n\tmtspr(SPRN_DAC1, debug->dac1);\n\tmtspr(SPRN_DAC2, debug->dac2);\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\tmtspr(SPRN_DVC1, debug->dvc1);\n\tmtspr(SPRN_DVC2, debug->dvc2);\n#endif\n\tmtspr(SPRN_DBCR0, debug->dbcr0);\n\tmtspr(SPRN_DBCR1, debug->dbcr1);\n#ifdef CONFIG_BOOKE\n\tmtspr(SPRN_DBCR2, debug->dbcr2);\n#endif\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void prime_debug_regs(struct debug_reg *debug)\n{\n\t/*\n\t * We could have inherited MSR_DE from userspace, since\n\t * it doesn't get cleared on exception entry.  Make sure\n\t * MSR_DE is clear before we enable any debug events.\n\t */\n\tmtmsr(mfmsr() & ~MSR_DE);\n\n\tmtspr(SPRN_IAC1, debug->iac1);\n\tmtspr(SPRN_IAC2, debug->iac2);\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tmtspr(SPRN_IAC3, debug->iac3);\n\tmtspr(SPRN_IAC4, debug->iac4);\n#endif\n\tmtspr(SPRN_DAC1, debug->dac1);\n\tmtspr(SPRN_DAC2, debug->dac2);\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\tmtspr(SPRN_DVC1, debug->dvc1);\n\tmtspr(SPRN_DVC2, debug->dvc2);\n#endif\n\tmtspr(SPRN_DBCR0, debug->dbcr0);\n\tmtspr(SPRN_DBCR1, debug->dbcr1);\n#ifdef CONFIG_BOOKE\n\tmtspr(SPRN_DBCR2, debug->dbcr2);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid switch_booke_debug_regs(struct debug_reg *new_debug)\n{\n\tif ((current->thread.debug.dbcr0 & DBCR0_IDM)\n\t\t|| (new_debug->dbcr0 & DBCR0_IDM))\n\t\t\tprime_debug_regs(new_debug);\n}"
  },
  {
    "function_name": "prime_debug_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "382-408",
    "snippet": "static void prime_debug_regs(struct debug_reg *debug)\n{\n\t/*\n\t * We could have inherited MSR_DE from userspace, since\n\t * it doesn't get cleared on exception entry.  Make sure\n\t * MSR_DE is clear before we enable any debug events.\n\t */\n\tmtmsr(mfmsr() & ~MSR_DE);\n\n\tmtspr(SPRN_IAC1, debug->iac1);\n\tmtspr(SPRN_IAC2, debug->iac2);\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tmtspr(SPRN_IAC3, debug->iac3);\n\tmtspr(SPRN_IAC4, debug->iac4);\n#endif\n\tmtspr(SPRN_DAC1, debug->dac1);\n\tmtspr(SPRN_DAC2, debug->dac2);\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\tmtspr(SPRN_DVC1, debug->dvc1);\n\tmtspr(SPRN_DVC2, debug->dvc2);\n#endif\n\tmtspr(SPRN_DBCR0, debug->dbcr0);\n\tmtspr(SPRN_DBCR1, debug->dbcr1);\n#ifdef CONFIG_BOOKE\n\tmtspr(SPRN_DBCR2, debug->dbcr2);\n#endif\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR2",
            "debug->dbcr2"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR1",
            "debug->dbcr1"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DBCR0",
            "debug->dbcr0"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DVC2",
            "debug->dvc2"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DVC1",
            "debug->dvc1"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAC2",
            "debug->dac2"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_DAC1",
            "debug->dac1"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_IAC4",
            "debug->iac4"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_IAC3",
            "debug->iac3"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_IAC2",
            "debug->iac2"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_IAC1",
            "debug->iac1"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtmsr",
          "args": [
            "mfmsr() & ~MSR_DE"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfmsr",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void prime_debug_regs(struct debug_reg *debug)\n{\n\t/*\n\t * We could have inherited MSR_DE from userspace, since\n\t * it doesn't get cleared on exception entry.  Make sure\n\t * MSR_DE is clear before we enable any debug events.\n\t */\n\tmtmsr(mfmsr() & ~MSR_DE);\n\n\tmtspr(SPRN_IAC1, debug->iac1);\n\tmtspr(SPRN_IAC2, debug->iac2);\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tmtspr(SPRN_IAC3, debug->iac3);\n\tmtspr(SPRN_IAC4, debug->iac4);\n#endif\n\tmtspr(SPRN_DAC1, debug->dac1);\n\tmtspr(SPRN_DAC2, debug->dac2);\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\tmtspr(SPRN_DVC1, debug->dvc1);\n\tmtspr(SPRN_DVC2, debug->dvc2);\n#endif\n\tmtspr(SPRN_DBCR0, debug->dbcr0);\n\tmtspr(SPRN_DBCR1, debug->dbcr1);\n#ifdef CONFIG_BOOKE\n\tmtspr(SPRN_DBCR2, debug->dbcr2);\n#endif\n}"
  },
  {
    "function_name": "set_debug_reg_defaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "355-380",
    "snippet": "static void set_debug_reg_defaults(struct thread_struct *thread)\n{\n\tthread->debug.iac1 = thread->debug.iac2 = 0;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tthread->debug.iac3 = thread->debug.iac4 = 0;\n#endif\n\tthread->debug.dac1 = thread->debug.dac2 = 0;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\tthread->debug.dvc1 = thread->debug.dvc2 = 0;\n#endif\n\tthread->debug.dbcr0 = 0;\n#ifdef CONFIG_BOOKE\n\t/*\n\t * Force User/Supervisor bits to b11 (user-only MSR[PR]=1)\n\t */\n\tthread->debug.dbcr1 = DBCR1_IAC1US | DBCR1_IAC2US |\n\t\t\tDBCR1_IAC3US | DBCR1_IAC4US;\n\t/*\n\t * Force Data Address Compare User/Supervisor bits to be User-only\n\t * (0b11 MSR[PR]=1) and set all other bits in DBCR2 register to be 0.\n\t */\n\tthread->debug.dbcr2 = DBCR2_DAC1US | DBCR2_DAC2US;\n#else\n\tthread->debug.dbcr1 = 0;\n#endif\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void set_debug_reg_defaults(struct thread_struct *thread)\n{\n\tthread->debug.iac1 = thread->debug.iac2 = 0;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tthread->debug.iac3 = thread->debug.iac4 = 0;\n#endif\n\tthread->debug.dac1 = thread->debug.dac2 = 0;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\tthread->debug.dvc1 = thread->debug.dvc2 = 0;\n#endif\n\tthread->debug.dbcr0 = 0;\n#ifdef CONFIG_BOOKE\n\t/*\n\t * Force User/Supervisor bits to b11 (user-only MSR[PR]=1)\n\t */\n\tthread->debug.dbcr1 = DBCR1_IAC1US | DBCR1_IAC2US |\n\t\t\tDBCR1_IAC3US | DBCR1_IAC4US;\n\t/*\n\t * Force Data Address Compare User/Supervisor bits to be User-only\n\t * (0b11 MSR[PR]=1) and set all other bits in DBCR2 register to be 0.\n\t */\n\tthread->debug.dbcr2 = DBCR2_DAC1US | DBCR2_DAC2US;\n#else\n\tthread->debug.dbcr1 = 0;\n#endif\n}"
  },
  {
    "function_name": "do_break",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "324-346",
    "snippet": "void do_break (struct pt_regs *regs, unsigned long address,\n\t\t    unsigned long error_code)\n{\n\tsiginfo_t info;\n\n\tcurrent->thread.trap_nr = TRAP_HWBKPT;\n\tif (notify_die(DIE_DABR_MATCH, \"dabr_match\", regs, error_code,\n\t\t\t11, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\n\tif (debugger_break_match(regs))\n\t\treturn;\n\n\t/* Clear the breakpoint */\n\thw_breakpoint_disable();\n\n\t/* Deliver the signal to userspace */\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = 0;\n\tinfo.si_code = TRAP_HWBKPT;\n\tinfo.si_addr = (void __user *)address;\n\tforce_sig_info(SIGTRAP, &info, current);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "SIGTRAP",
            "&info",
            "current"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hw_breakpoint_disable",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugger_break_match",
          "args": [
            "regs"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_DABR_MATCH",
            "\"dabr_match\"",
            "regs",
            "error_code",
            "11",
            "SIGSEGV"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid do_break (struct pt_regs *regs, unsigned long address,\n\t\t    unsigned long error_code)\n{\n\tsiginfo_t info;\n\n\tcurrent->thread.trap_nr = TRAP_HWBKPT;\n\tif (notify_die(DIE_DABR_MATCH, \"dabr_match\", regs, error_code,\n\t\t\t11, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\n\tif (debugger_break_match(regs))\n\t\treturn;\n\n\t/* Clear the breakpoint */\n\thw_breakpoint_disable();\n\n\t/* Deliver the signal to userspace */\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = 0;\n\tinfo.si_code = TRAP_HWBKPT;\n\tinfo.si_addr = (void __user *)address;\n\tforce_sig_info(SIGTRAP, &info, current);\n}"
  },
  {
    "function_name": "do_send_trap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "306-322",
    "snippet": "void do_send_trap(struct pt_regs *regs, unsigned long address,\n\t\t  unsigned long error_code, int signal_code, int breakpt)\n{\n\tsiginfo_t info;\n\n\tcurrent->thread.trap_nr = signal_code;\n\tif (notify_die(DIE_DABR_MATCH, \"dabr_match\", regs, error_code,\n\t\t\t11, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\n\t/* Deliver the signal to userspace */\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = breakpt;\t/* breakpoint or watchpoint id */\n\tinfo.si_code = signal_code;\n\tinfo.si_addr = (void __user *)address;\n\tforce_sig_info(SIGTRAP, &info, current);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "SIGTRAP",
            "&info",
            "current"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_die",
          "args": [
            "DIE_DABR_MATCH",
            "\"dabr_match\"",
            "regs",
            "error_code",
            "11",
            "SIGSEGV"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid do_send_trap(struct pt_regs *regs, unsigned long address,\n\t\t  unsigned long error_code, int signal_code, int breakpt)\n{\n\tsiginfo_t info;\n\n\tcurrent->thread.trap_nr = signal_code;\n\tif (notify_die(DIE_DABR_MATCH, \"dabr_match\", regs, error_code,\n\t\t\t11, SIGSEGV) == NOTIFY_STOP)\n\t\treturn;\n\n\t/* Deliver the signal to userspace */\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = breakpt;\t/* breakpoint or watchpoint id */\n\tinfo.si_code = signal_code;\n\tinfo.si_addr = (void __user *)address;\n\tforce_sig_info(SIGTRAP, &info, current);\n}"
  },
  {
    "function_name": "discard_lazy_cpu_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "284-302",
    "snippet": "void discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid discard_lazy_cpu_state(void)\n{\n\tpreempt_disable();\n\tif (last_task_used_math == current)\n\t\tlast_task_used_math = NULL;\n#ifdef CONFIG_ALTIVEC\n\tif (last_task_used_altivec == current)\n\t\tlast_task_used_altivec = NULL;\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\tif (last_task_used_vsx == current)\n\t\tlast_task_used_vsx = NULL;\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\tif (last_task_used_spe == current)\n\t\tlast_task_used_spe = NULL;\n#endif\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "flush_spe_to_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "263-276",
    "snippet": "void flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_spe",
          "args": [
            "tsk"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_SPEFSCR"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_spe_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_SPE) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\ttsk->thread.spefscr = mfspr(SPRN_SPEFSCR);\n\t\t\tgiveup_spe(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "enable_kernel_spe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "248-260",
    "snippet": "void enable_kernel_spe(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_SPE))\n\t\tgiveup_spe(current);\n\telse\n\t\tgiveup_spe(NULL);\t/* just enable SPE for kernel - force */\n#else\n\tgiveup_spe(last_task_used_spe);\n#endif /* __SMP __ */\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giveup_spe",
          "args": [
            "last_task_used_spe"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_spe",
          "args": [
            "NULL"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_spe",
          "args": [
            "current"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid enable_kernel_spe(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_SPE))\n\t\tgiveup_spe(current);\n\telse\n\t\tgiveup_spe(NULL);\t/* just enable SPE for kernel - force */\n#else\n\tgiveup_spe(last_task_used_spe);\n#endif /* __SMP __ */\n}"
  },
  {
    "function_name": "flush_vsx_to_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "230-242",
    "snippet": "void flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_vsx",
          "args": [
            "tsk"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_vsx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "222-227",
          "snippet": "void giveup_vsx(struct task_struct *tsk)\n{\n\tgiveup_fpu_maybe_transactional(tsk);\n\tgiveup_altivec_maybe_transactional(tsk);\n\t__giveup_vsx(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_vsx(struct task_struct *tsk)\n{\n\tgiveup_fpu_maybe_transactional(tsk);\n\tgiveup_altivec_maybe_transactional(tsk);\n\t__giveup_vsx(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_vsx_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VSX) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_vsx(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "giveup_vsx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "222-227",
    "snippet": "void giveup_vsx(struct task_struct *tsk)\n{\n\tgiveup_fpu_maybe_transactional(tsk);\n\tgiveup_altivec_maybe_transactional(tsk);\n\t__giveup_vsx(tsk);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__giveup_vsx",
          "args": [
            "tsk"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_altivec_maybe_transactional",
          "args": [
            "tsk"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_altivec_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "96-112",
          "snippet": "void giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giveup_fpu_maybe_transactional",
          "args": [
            "tsk"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_fpu_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "78-94",
          "snippet": "void giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_vsx(struct task_struct *tsk)\n{\n\tgiveup_fpu_maybe_transactional(tsk);\n\tgiveup_altivec_maybe_transactional(tsk);\n\t__giveup_vsx(tsk);\n}"
  },
  {
    "function_name": "enable_kernel_vsx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "207-219",
    "snippet": "void enable_kernel_vsx(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_VSX))\n\t\tgiveup_vsx(current);\n\telse\n\t\tgiveup_vsx(NULL);\t/* just enable vsx for kernel - force */\n#else\n\tgiveup_vsx(last_task_used_vsx);\n#endif /* CONFIG_SMP */\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giveup_vsx",
          "args": [
            "last_task_used_vsx"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_vsx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "222-227",
          "snippet": "void giveup_vsx(struct task_struct *tsk)\n{\n\tgiveup_fpu_maybe_transactional(tsk);\n\tgiveup_altivec_maybe_transactional(tsk);\n\t__giveup_vsx(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_vsx(struct task_struct *tsk)\n{\n\tgiveup_fpu_maybe_transactional(tsk);\n\tgiveup_altivec_maybe_transactional(tsk);\n\t__giveup_vsx(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid enable_kernel_vsx(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_VSX))\n\t\tgiveup_vsx(current);\n\telse\n\t\tgiveup_vsx(NULL);\t/* just enable vsx for kernel - force */\n#else\n\tgiveup_vsx(last_task_used_vsx);\n#endif /* CONFIG_SMP */\n}"
  },
  {
    "function_name": "flush_altivec_to_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "190-202",
    "snippet": "void flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_altivec_maybe_transactional",
          "args": [
            "tsk"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_altivec_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "96-112",
          "snippet": "void giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_altivec_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_VEC) {\n#ifdef CONFIG_SMP\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_altivec_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "enable_kernel_altivec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "171-183",
    "snippet": "void enable_kernel_altivec(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_VEC))\n\t\tgiveup_altivec_maybe_transactional(current);\n\telse\n\t\tgiveup_altivec_notask();\n#else\n\tgiveup_altivec_maybe_transactional(last_task_used_altivec);\n#endif /* CONFIG_SMP */\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giveup_altivec_maybe_transactional",
          "args": [
            "last_task_used_altivec"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_altivec_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "96-112",
          "snippet": "void giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "giveup_altivec_notask",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid enable_kernel_altivec(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_VEC))\n\t\tgiveup_altivec_maybe_transactional(current);\n\telse\n\t\tgiveup_altivec_notask();\n#else\n\tgiveup_altivec_maybe_transactional(last_task_used_altivec);\n#endif /* CONFIG_SMP */\n}"
  },
  {
    "function_name": "enable_kernel_fp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "155-167",
    "snippet": "void enable_kernel_fp(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_FP))\n\t\tgiveup_fpu_maybe_transactional(current);\n\telse\n\t\tgiveup_fpu(NULL);\t/* just enables FP for kernel */\n#else\n\tgiveup_fpu_maybe_transactional(last_task_used_math);\n#endif /* CONFIG_SMP */\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giveup_fpu_maybe_transactional",
          "args": [
            "last_task_used_math"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_fpu_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "78-94",
          "snippet": "void giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid enable_kernel_fp(void)\n{\n\tWARN_ON(preemptible());\n\n#ifdef CONFIG_SMP\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_FP))\n\t\tgiveup_fpu_maybe_transactional(current);\n\telse\n\t\tgiveup_fpu(NULL);\t/* just enables FP for kernel */\n#else\n\tgiveup_fpu_maybe_transactional(last_task_used_math);\n#endif /* CONFIG_SMP */\n}"
  },
  {
    "function_name": "flush_fp_to_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "124-151",
    "snippet": "void flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "giveup_fpu_maybe_transactional",
          "args": [
            "tsk"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_fpu_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "78-94",
          "snippet": "void giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}",
          "includes": [
            "#include <linux/kdebug.h>",
            "#include <linux/kprobes.h>",
            "#include <asm/code-patching.h>",
            "#include <asm/firmware.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/syscalls.h>",
            "#include <asm/runlatch.h>",
            "#include <asm/time.h>",
            "#include <asm/machdep.h>",
            "#include <asm/prom.h>",
            "#include <asm/mmu.h>",
            "#include <asm/processor.h>",
            "#include <asm/io.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/random.h>",
            "#include <linux/personality.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/export.h>",
            "#include <linux/init_task.h>",
            "#include <linux/prctl.h>",
            "#include <linux/elf.h>",
            "#include <linux/user.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/smp.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tsk != current"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid flush_fp_to_thread(struct task_struct *tsk)\n{\n\tif (tsk->thread.regs) {\n\t\t/*\n\t\t * We need to disable preemption here because if we didn't,\n\t\t * another process could get scheduled after the regs->msr\n\t\t * test but before we have finished saving the FP registers\n\t\t * to the thread_struct.  That process could take over the\n\t\t * FPU, and then when we get scheduled again we would store\n\t\t * bogus values for the remaining FP registers.\n\t\t */\n\t\tpreempt_disable();\n\t\tif (tsk->thread.regs->msr & MSR_FP) {\n#ifdef CONFIG_SMP\n\t\t\t/*\n\t\t\t * This should only ever be called for current or\n\t\t\t * for a stopped child process.  Since we save away\n\t\t\t * the FP register state on context switch on SMP,\n\t\t\t * there is something wrong if a stopped child appears\n\t\t\t * to still have its FP state in the CPU registers.\n\t\t\t */\n\t\t\tBUG_ON(tsk != current);\n#endif\n\t\t\tgiveup_fpu_maybe_transactional(tsk);\n\t\t}\n\t\tpreempt_enable();\n\t}\n}"
  },
  {
    "function_name": "giveup_altivec_maybe_transactional",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "96-112",
    "snippet": "void giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giveup_altivec",
          "args": [
            "tsk"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_altivec_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "96-112",
          "snippet": "void giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTORE_TM"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_RESTORE_TM"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "tsk->thread.regs->msr"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_altivec_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_altivec(tsk);\n}"
  },
  {
    "function_name": "giveup_fpu_maybe_transactional",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
    "lines": "78-94",
    "snippet": "void giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}",
    "includes": [
      "#include <linux/kdebug.h>",
      "#include <linux/kprobes.h>",
      "#include <asm/code-patching.h>",
      "#include <asm/firmware.h>",
      "#include <asm/debug.h>",
      "#include <asm/tm.h>",
      "#include <asm/switch_to.h>",
      "#include <asm/syscalls.h>",
      "#include <asm/runlatch.h>",
      "#include <asm/time.h>",
      "#include <asm/machdep.h>",
      "#include <asm/prom.h>",
      "#include <asm/mmu.h>",
      "#include <asm/processor.h>",
      "#include <asm/io.h>",
      "#include <asm/pgtable.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/hw_breakpoint.h>",
      "#include <linux/random.h>",
      "#include <linux/personality.h>",
      "#include <linux/kernel_stat.h>",
      "#include <linux/ftrace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/export.h>",
      "#include <linux/init_task.h>",
      "#include <linux/prctl.h>",
      "#include <linux/elf.h>",
      "#include <linux/user.h>",
      "#include <linux/slab.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/unistd.h>",
      "#include <linux/stddef.h>",
      "#include <linux/smp.h>",
      "#include <linux/mm.h>",
      "#include <linux/kernel.h>",
      "#include <linux/sched.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "giveup_fpu",
          "args": [
            "tsk"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "giveup_fpu_maybe_transactional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
          "lines": "78-94",
          "snippet": "void giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "set_thread_flag",
          "args": [
            "TIF_RESTORE_TM"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_thread_flag",
          "args": [
            "TIF_RESTORE_TM"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_TM_ACTIVE",
          "args": [
            "tsk->thread.regs->msr"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nvoid giveup_fpu_maybe_transactional(struct task_struct *tsk)\n{\n\t/*\n\t * If we are saving the current thread's registers, and the\n\t * thread is in a transactional state, set the TIF_RESTORE_TM\n\t * bit so that we know to restore the registers before\n\t * returning to userspace.\n\t */\n\tif (tsk == current && tsk->thread.regs &&\n\t    MSR_TM_ACTIVE(tsk->thread.regs->msr) &&\n\t    !test_thread_flag(TIF_RESTORE_TM)) {\n\t\ttsk->thread.ckpt_regs.msr = tsk->thread.regs->msr;\n\t\tset_thread_flag(TIF_RESTORE_TM);\n\t}\n\n\tgiveup_fpu(tsk);\n}"
  }
]