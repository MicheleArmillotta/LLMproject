[
  {
    "function_name": "arch_match_cpu_phys_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "824-827",
    "snippet": "bool arch_match_cpu_phys_id(int cpu, u64 phys_id)\n{\n\treturn (int)phys_id == get_hard_smp_processor_id(cpu);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_hard_smp_processor_id",
          "args": [
            "cpu"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nbool arch_match_cpu_phys_id(int cpu, u64 phys_id)\n{\n\treturn (int)phys_id == get_hard_smp_processor_id(cpu);\n}"
  },
  {
    "function_name": "cpu_to_chip_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "811-821",
    "snippet": "int cpu_to_chip_id(int cpu)\n{\n\tstruct device_node *np;\n\n\tnp = of_get_cpu_node(cpu, NULL);\n\tif (!np)\n\t\treturn -1;\n\n\tof_node_put(np);\n\treturn of_get_ibm_chip_id(np);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_ibm_chip_id",
          "args": [
            "np"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "of_get_ibm_chip_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "783-801",
          "snippet": "int of_get_ibm_chip_id(struct device_node *np)\n{\n\tof_node_get(np);\n\twhile (np) {\n\t\tu32 chip_id;\n\n\t\t/*\n\t\t * Skiboot may produce memory nodes that contain more than one\n\t\t * cell in chip-id, we only read the first one here.\n\t\t */\n\t\tif (!of_property_read_u32(np, \"ibm,chip-id\", &chip_id)) {\n\t\t\tof_node_put(np);\n\t\t\treturn chip_id;\n\t\t}\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint of_get_ibm_chip_id(struct device_node *np)\n{\n\tof_node_get(np);\n\twhile (np) {\n\t\tu32 chip_id;\n\n\t\t/*\n\t\t * Skiboot may produce memory nodes that contain more than one\n\t\t * cell in chip-id, we only read the first one here.\n\t\t */\n\t\tif (!of_property_read_u32(np, \"ibm,chip-id\", &chip_id)) {\n\t\t\tof_node_put(np);\n\t\t\treturn chip_id;\n\t\t}\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "np"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_cpu_node",
          "args": [
            "cpu",
            "NULL"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint cpu_to_chip_id(int cpu)\n{\n\tstruct device_node *np;\n\n\tnp = of_get_cpu_node(cpu, NULL);\n\tif (!np)\n\t\treturn -1;\n\n\tof_node_put(np);\n\treturn of_get_ibm_chip_id(np);\n}"
  },
  {
    "function_name": "of_get_ibm_chip_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "783-801",
    "snippet": "int of_get_ibm_chip_id(struct device_node *np)\n{\n\tof_node_get(np);\n\twhile (np) {\n\t\tu32 chip_id;\n\n\t\t/*\n\t\t * Skiboot may produce memory nodes that contain more than one\n\t\t * cell in chip-id, we only read the first one here.\n\t\t */\n\t\tif (!of_property_read_u32(np, \"ibm,chip-id\", &chip_id)) {\n\t\t\tof_node_put(np);\n\t\t\treturn chip_id;\n\t\t}\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_next_parent",
          "args": [
            "np"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "np"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_property_read_u32",
          "args": [
            "np",
            "\"ibm,chip-id\"",
            "&chip_id"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "np"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nint of_get_ibm_chip_id(struct device_node *np)\n{\n\tof_node_get(np);\n\twhile (np) {\n\t\tu32 chip_id;\n\n\t\t/*\n\t\t * Skiboot may produce memory nodes that contain more than one\n\t\t * cell in chip-id, we only read the first one here.\n\t\t */\n\t\tif (!of_property_read_u32(np, \"ibm,chip-id\", &chip_id)) {\n\t\t\tof_node_put(np);\n\t\t\treturn chip_id;\n\t\t}\n\n\t\tnp = of_get_next_parent(np);\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "early_get_first_memblock_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "745-761",
    "snippet": "void __init early_get_first_memblock_info(void *params, phys_addr_t *size)\n{\n\t/* Setup flat device-tree pointer */\n\tinitial_boot_params = params;\n\n\t/*\n\t * Scan the memory nodes and set add_mem_to_memblock to 0 to avoid\n\t * mess the memblock.\n\t */\n\tadd_mem_to_memblock = 0;\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\tadd_mem_to_memblock = 1;\n\n\tif (size)\n\t\t*size = first_memblock_size;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define add_mem_to_memblock 1"
    ],
    "globals_used": [
      "static phys_addr_t first_memblock_size;",
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_memory_ppc",
            "NULL"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_root",
            "NULL"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\n#define add_mem_to_memblock 1\n\nstatic phys_addr_t first_memblock_size;\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};\n\nvoid __init early_get_first_memblock_info(void *params, phys_addr_t *size)\n{\n\t/* Setup flat device-tree pointer */\n\tinitial_boot_params = params;\n\n\t/*\n\t * Scan the memory nodes and set add_mem_to_memblock to 0 to avoid\n\t * mess the memblock.\n\t */\n\tadd_mem_to_memblock = 0;\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\tadd_mem_to_memblock = 1;\n\n\tif (size)\n\t\t*size = first_memblock_size;\n}"
  },
  {
    "function_name": "early_init_devtree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "642-738",
    "snippet": "void __init early_init_devtree(void *params)\n{\n\tphys_addr_t limit;\n\n\tDBG(\" -> early_init_devtree(%p)\\n\", params);\n\n\t/* Too early to BUG_ON(), do it by hand */\n\tif (!early_init_dt_verify(params))\n\t\tpanic(\"BUG: Failed verifying flat device tree, bad version?\");\n\n#ifdef CONFIG_PPC_RTAS\n\t/* Some machines might need RTAS info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_rtas, NULL);\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Some machines might need OPAL info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_opal, NULL);\n#endif\n\n#ifdef CONFIG_FA_DUMP\n\t/* scan tree to see if dump is active during last boot */\n\tof_scan_flat_dt(early_init_dt_scan_fw_dump, NULL);\n#endif\n\n\t/* Retrieve various informations from the /chosen node of the\n\t * device-tree, including the platform type, initrd location and\n\t * size, TCE reserve, and more ...\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_chosen_ppc, boot_command_line);\n\n\t/* Scan memory nodes and rebuild MEMBLOCKs */\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\n\tparse_early_param();\n\n\t/* make sure we've parsed cmdline for mem= before this */\n\tif (memory_limit)\n\t\tfirst_memblock_size = min_t(u64, first_memblock_size, memory_limit);\n\tsetup_initial_memory_limit(memstart_addr, first_memblock_size);\n\t/* Reserve MEMBLOCK regions used by kernel, initrd, dt, etc... */\n\tmemblock_reserve(PHYSICAL_START, __pa(klimit) - PHYSICAL_START);\n\t/* If relocatable, reserve first 32k for interrupt vectors etc. */\n\tif (PHYSICAL_START > MEMORY_START)\n\t\tmemblock_reserve(MEMORY_START, 0x8000);\n\treserve_kdump_trampoline();\n#ifdef CONFIG_FA_DUMP\n\t/*\n\t * If we fail to reserve memory for firmware-assisted dump then\n\t * fallback to kexec based kdump.\n\t */\n\tif (fadump_reserve_mem() == 0)\n#endif\n\t\treserve_crashkernel();\n\tearly_reserve_mem();\n\n\t/* Ensure that total memory size is page-aligned. */\n\tlimit = ALIGN(memory_limit ?: memblock_phys_mem_size(), PAGE_SIZE);\n\tmemblock_enforce_memory_limit(limit);\n\n\tmemblock_allow_resize();\n\tmemblock_dump_all();\n\n\tDBG(\"Phys. mem: %llx\\n\", memblock_phys_mem_size());\n\n\t/* We may need to relocate the flat tree, do it now.\n\t * FIXME .. and the initrd too? */\n\tmove_device_tree();\n\n\tallocate_pacas();\n\n\tDBG(\"Scanning CPUs ...\\n\");\n\n\t/* Retrieve CPU related informations from the flat tree\n\t * (altivec support, boot CPU ID, ...)\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_cpus, NULL);\n\tif (boot_cpuid < 0) {\n\t\tprintk(\"Failed to identify boot CPU !\\n\");\n\t\tBUG();\n\t}\n\n#if defined(CONFIG_SMP) && defined(CONFIG_PPC64)\n\t/* We'll later wait for secondaries to check in; there are\n\t * NCPUS-1 non-boot CPUs  :-)\n\t */\n\tspinning_secondaries = boot_cpu_count - 1;\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Scan and build the list of machine check recoverable ranges */\n\tof_scan_flat_dt(early_init_dt_scan_recoverable_ranges, NULL);\n#endif\n\n\tDBG(\" <- early_init_devtree()\\n\");\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static phys_addr_t first_memblock_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" <- early_init_devtree()\\n\""
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_recoverable_ranges",
            "NULL"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Failed to identify boot CPU !\\n\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_cpus",
            "NULL"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Scanning CPUs ...\\n\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_pacas",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_pacas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/paca.c",
          "lines": "205-236",
          "snippet": "void __init allocate_pacas(void)\n{\n\tu64 limit;\n\tint cpu;\n\n\tlimit = ppc64_rma_size;\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/*\n\t * We can't take SLB misses on the paca, and we want to access them\n\t * in real mode, so allocate them within the RMA and also within\n\t * the first segment.\n\t */\n\tlimit = min(0x10000000ULL, limit);\n#endif\n\n\tpaca_size = PAGE_ALIGN(sizeof(struct paca_struct) * nr_cpu_ids);\n\n\tpaca = __va(memblock_alloc_base(paca_size, PAGE_SIZE, limit));\n\tmemset(paca, 0, paca_size);\n\n\tprintk(KERN_DEBUG \"Allocated %u bytes for %d pacas at %p\\n\",\n\t\tpaca_size, nr_cpu_ids, paca);\n\n\tallocate_lppacas(nr_cpu_ids, limit);\n\n\tallocate_slb_shadows(nr_cpu_ids, limit);\n\n\t/* Can't use for_each_*_cpu, as they aren't functional yet */\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tinitialise_paca(&paca[cpu], cpu);\n}",
          "includes": [
            "#include <asm/kexec.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/sections.h>",
            "#include <asm/paca.h>",
            "#include <asm/lppaca.h>",
            "#include <linux/memblock.h>",
            "#include <linux/export.h>",
            "#include <linux/smp.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct paca_struct *paca;",
            "static int __initdata paca_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/kexec.h>\n#include <asm/pgtable.h>\n#include <asm/sections.h>\n#include <asm/paca.h>\n#include <asm/lppaca.h>\n#include <linux/memblock.h>\n#include <linux/export.h>\n#include <linux/smp.h>\n\nstruct paca_struct *paca;\nstatic int __initdata paca_size;\n\nvoid __init allocate_pacas(void)\n{\n\tu64 limit;\n\tint cpu;\n\n\tlimit = ppc64_rma_size;\n\n#ifdef CONFIG_PPC_BOOK3S_64\n\t/*\n\t * We can't take SLB misses on the paca, and we want to access them\n\t * in real mode, so allocate them within the RMA and also within\n\t * the first segment.\n\t */\n\tlimit = min(0x10000000ULL, limit);\n#endif\n\n\tpaca_size = PAGE_ALIGN(sizeof(struct paca_struct) * nr_cpu_ids);\n\n\tpaca = __va(memblock_alloc_base(paca_size, PAGE_SIZE, limit));\n\tmemset(paca, 0, paca_size);\n\n\tprintk(KERN_DEBUG \"Allocated %u bytes for %d pacas at %p\\n\",\n\t\tpaca_size, nr_cpu_ids, paca);\n\n\tallocate_lppacas(nr_cpu_ids, limit);\n\n\tallocate_slb_shadows(nr_cpu_ids, limit);\n\n\t/* Can't use for_each_*_cpu, as they aren't functional yet */\n\tfor (cpu = 0; cpu < nr_cpu_ids; cpu++)\n\t\tinitialise_paca(&paca[cpu], cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_device_tree",
          "args": [],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "move_device_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "112-132",
          "snippet": "static void __init move_device_tree(void)\n{\n\tunsigned long start, size;\n\tvoid *p;\n\n\tDBG(\"-> move_device_tree\\n\");\n\n\tstart = __pa(initial_boot_params);\n\tsize = fdt_totalsize(initial_boot_params);\n\n\tif ((memory_limit && (start + size) > PHYSICAL_START + memory_limit) ||\n\t\t\toverlaps_crashkernel(start, size) ||\n\t\t\toverlaps_initrd(start, size)) {\n\t\tp = __va(memblock_alloc(size, PAGE_SIZE));\n\t\tmemcpy(p, initial_boot_params, size);\n\t\tinitial_boot_params = p;\n\t\tDBG(\"Moved device tree to 0x%p\\n\", p);\n\t}\n\n\tDBG(\"<- move_device_tree\\n\");\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init move_device_tree(void)\n{\n\tunsigned long start, size;\n\tvoid *p;\n\n\tDBG(\"-> move_device_tree\\n\");\n\n\tstart = __pa(initial_boot_params);\n\tsize = fdt_totalsize(initial_boot_params);\n\n\tif ((memory_limit && (start + size) > PHYSICAL_START + memory_limit) ||\n\t\t\toverlaps_crashkernel(start, size) ||\n\t\t\toverlaps_initrd(start, size)) {\n\t\tp = __va(memblock_alloc(size, PAGE_SIZE));\n\t\tmemcpy(p, initial_boot_params, size);\n\t\tinitial_boot_params = p;\n\t\tDBG(\"Moved device tree to 0x%p\\n\", p);\n\t}\n\n\tDBG(\"<- move_device_tree\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Phys. mem: %llx\\n\"",
            "memblock_phys_mem_size()"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_dump_all",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_allow_resize",
          "args": [],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_enforce_memory_limit",
          "args": [
            "limit"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "memory_limit ?: memblock_phys_mem_size()",
            "PAGE_SIZE"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_phys_mem_size",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_reserve_mem",
          "args": [],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "early_reserve_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "599-640",
          "snippet": "static void __init early_reserve_mem(void)\n{\n\t__be64 *reserve_map;\n\n\treserve_map = (__be64 *)(((unsigned long)initial_boot_params) +\n\t\t\tfdt_off_mem_rsvmap(initial_boot_params));\n\n\t/* Look for the new \"reserved-regions\" property in the DT */\n\tearly_reserve_mem_dt();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\t/* Then reserve the initrd, if any */\n\tif (initrd_start && (initrd_end > initrd_start)) {\n\t\tmemblock_reserve(_ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE),\n\t\t\t_ALIGN_UP(initrd_end, PAGE_SIZE) -\n\t\t\t_ALIGN_DOWN(initrd_start, PAGE_SIZE));\n\t}\n#endif /* CONFIG_BLK_DEV_INITRD */\n\n#ifdef CONFIG_PPC32\n\t/* \n\t * Handle the case where we might be booting from an old kexec\n\t * image that setup the mem_rsvmap as pairs of 32-bit values\n\t */\n\tif (be64_to_cpup(reserve_map) > 0xffffffffull) {\n\t\tu32 base_32, size_32;\n\t\t__be32 *reserve_map_32 = (__be32 *)reserve_map;\n\n\t\tDBG(\"Found old 32-bit reserve map\\n\");\n\n\t\twhile (1) {\n\t\t\tbase_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tsize_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tif (size_32 == 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"reserving: %x -> %x\\n\", base_32, size_32);\n\t\t\tmemblock_reserve(base_32, size_32);\n\t\t}\n\t\treturn;\n\t}\n#endif\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init early_reserve_mem(void)\n{\n\t__be64 *reserve_map;\n\n\treserve_map = (__be64 *)(((unsigned long)initial_boot_params) +\n\t\t\tfdt_off_mem_rsvmap(initial_boot_params));\n\n\t/* Look for the new \"reserved-regions\" property in the DT */\n\tearly_reserve_mem_dt();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\t/* Then reserve the initrd, if any */\n\tif (initrd_start && (initrd_end > initrd_start)) {\n\t\tmemblock_reserve(_ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE),\n\t\t\t_ALIGN_UP(initrd_end, PAGE_SIZE) -\n\t\t\t_ALIGN_DOWN(initrd_start, PAGE_SIZE));\n\t}\n#endif /* CONFIG_BLK_DEV_INITRD */\n\n#ifdef CONFIG_PPC32\n\t/* \n\t * Handle the case where we might be booting from an old kexec\n\t * image that setup the mem_rsvmap as pairs of 32-bit values\n\t */\n\tif (be64_to_cpup(reserve_map) > 0xffffffffull) {\n\t\tu32 base_32, size_32;\n\t\t__be32 *reserve_map_32 = (__be32 *)reserve_map;\n\n\t\tDBG(\"Found old 32-bit reserve map\\n\");\n\n\t\twhile (1) {\n\t\t\tbase_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tsize_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tif (size_32 == 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"reserving: %x -> %x\\n\", base_32, size_32);\n\t\t\tmemblock_reserve(base_32, size_32);\n\t\t}\n\t\treturn;\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_crashkernel",
          "args": [],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_crashkernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "114-190",
          "snippet": "void __init reserve_crashkernel(void)\n{\n\tunsigned long long crash_size, crash_base;\n\tint ret;\n\n\t/* use common parsing */\n\tret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),\n\t\t\t&crash_size, &crash_base);\n\tif (ret == 0 && crash_size > 0) {\n\t\tcrashk_res.start = crash_base;\n\t\tcrashk_res.end = crash_base + crash_size - 1;\n\t}\n\n\tif (crashk_res.end == crashk_res.start) {\n\t\tcrashk_res.start = crashk_res.end = 0;\n\t\treturn;\n\t}\n\n\t/* We might have got these values via the command line or the\n\t * device tree, either way sanitise them now. */\n\n\tcrash_size = resource_size(&crashk_res);\n\n#ifndef CONFIG_NONSTATIC_KERNEL\n\tif (crashk_res.start != KDUMP_KERNELBASE)\n\t\tprintk(\"Crash kernel location must be 0x%x\\n\",\n\t\t\t\tKDUMP_KERNELBASE);\n\n\tcrashk_res.start = KDUMP_KERNELBASE;\n#else\n\tif (!crashk_res.start) {\n#ifdef CONFIG_PPC64\n\t\t/*\n\t\t * On 64bit we split the RMO in half but cap it at half of\n\t\t * a small SLB (128MB) since the crash kernel needs to place\n\t\t * itself and some stacks to be in the first segment.\n\t\t */\n\t\tcrashk_res.start = min(0x8000000ULL, (ppc64_rma_size / 2));\n#else\n\t\tcrashk_res.start = KDUMP_KERNELBASE;\n#endif\n\t}\n\n\tcrash_base = PAGE_ALIGN(crashk_res.start);\n\tif (crash_base != crashk_res.start) {\n\t\tprintk(\"Crash kernel base must be aligned to 0x%lx\\n\",\n\t\t\t\tPAGE_SIZE);\n\t\tcrashk_res.start = crash_base;\n\t}\n\n#endif\n\tcrash_size = PAGE_ALIGN(crash_size);\n\tcrashk_res.end = crashk_res.start + crash_size - 1;\n\n\t/* The crash region must not overlap the current kernel */\n\tif (overlaps_crashkernel(__pa(_stext), _end - _stext)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"Crash kernel can not overlap current kernel\\n\");\n\t\tcrashk_res.start = crashk_res.end = 0;\n\t\treturn;\n\t}\n\n\t/* Crash kernel trumps memory limit */\n\tif (memory_limit && memory_limit <= crashk_res.end) {\n\t\tmemory_limit = crashk_res.end + 1;\n\t\tprintk(\"Adjusted memory limit for crashkernel, now 0x%llx\\n\",\n\t\t       memory_limit);\n\t}\n\n\tprintk(KERN_INFO \"Reserving %ldMB of memory at %ldMB \"\n\t\t\t\"for crashkernel (System RAM: %ldMB)\\n\",\n\t\t\t(unsigned long)(crash_size >> 20),\n\t\t\t(unsigned long)(crashk_res.start >> 20),\n\t\t\t(unsigned long)(memblock_phys_mem_size() >> 20));\n\n\tmemblock_reserve(crashk_res.start, crash_size);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/irq.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/threads.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nvoid __init reserve_crashkernel(void)\n{\n\tunsigned long long crash_size, crash_base;\n\tint ret;\n\n\t/* use common parsing */\n\tret = parse_crashkernel(boot_command_line, memblock_phys_mem_size(),\n\t\t\t&crash_size, &crash_base);\n\tif (ret == 0 && crash_size > 0) {\n\t\tcrashk_res.start = crash_base;\n\t\tcrashk_res.end = crash_base + crash_size - 1;\n\t}\n\n\tif (crashk_res.end == crashk_res.start) {\n\t\tcrashk_res.start = crashk_res.end = 0;\n\t\treturn;\n\t}\n\n\t/* We might have got these values via the command line or the\n\t * device tree, either way sanitise them now. */\n\n\tcrash_size = resource_size(&crashk_res);\n\n#ifndef CONFIG_NONSTATIC_KERNEL\n\tif (crashk_res.start != KDUMP_KERNELBASE)\n\t\tprintk(\"Crash kernel location must be 0x%x\\n\",\n\t\t\t\tKDUMP_KERNELBASE);\n\n\tcrashk_res.start = KDUMP_KERNELBASE;\n#else\n\tif (!crashk_res.start) {\n#ifdef CONFIG_PPC64\n\t\t/*\n\t\t * On 64bit we split the RMO in half but cap it at half of\n\t\t * a small SLB (128MB) since the crash kernel needs to place\n\t\t * itself and some stacks to be in the first segment.\n\t\t */\n\t\tcrashk_res.start = min(0x8000000ULL, (ppc64_rma_size / 2));\n#else\n\t\tcrashk_res.start = KDUMP_KERNELBASE;\n#endif\n\t}\n\n\tcrash_base = PAGE_ALIGN(crashk_res.start);\n\tif (crash_base != crashk_res.start) {\n\t\tprintk(\"Crash kernel base must be aligned to 0x%lx\\n\",\n\t\t\t\tPAGE_SIZE);\n\t\tcrashk_res.start = crash_base;\n\t}\n\n#endif\n\tcrash_size = PAGE_ALIGN(crash_size);\n\tcrashk_res.end = crashk_res.start + crash_size - 1;\n\n\t/* The crash region must not overlap the current kernel */\n\tif (overlaps_crashkernel(__pa(_stext), _end - _stext)) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"Crash kernel can not overlap current kernel\\n\");\n\t\tcrashk_res.start = crashk_res.end = 0;\n\t\treturn;\n\t}\n\n\t/* Crash kernel trumps memory limit */\n\tif (memory_limit && memory_limit <= crashk_res.end) {\n\t\tmemory_limit = crashk_res.end + 1;\n\t\tprintk(\"Adjusted memory limit for crashkernel, now 0x%llx\\n\",\n\t\t       memory_limit);\n\t}\n\n\tprintk(KERN_INFO \"Reserving %ldMB of memory at %ldMB \"\n\t\t\t\"for crashkernel (System RAM: %ldMB)\\n\",\n\t\t\t(unsigned long)(crash_size >> 20),\n\t\t\t(unsigned long)(crashk_res.start >> 20),\n\t\t\t(unsigned long)(memblock_phys_mem_size() >> 20));\n\n\tmemblock_reserve(crashk_res.start, crash_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fadump_reserve_mem",
          "args": [],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "fadump_reserve_mem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/fadump.c",
          "lines": "256-334",
          "snippet": "int __init fadump_reserve_mem(void)\n{\n\tunsigned long base, size, memory_boundary;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tif (!fw_dump.fadump_supported) {\n\t\tprintk(KERN_INFO \"Firmware-assisted dump is not supported on\"\n\t\t\t\t\" this hardware\\n\");\n\t\tfw_dump.fadump_enabled = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Initialize boot memory size\n\t * If dump is active then we have already calculated the size during\n\t * first kernel.\n\t */\n\tif (fdm_active)\n\t\tfw_dump.boot_memory_size = be64_to_cpu(fdm_active->rmr_region.source_len);\n\telse\n\t\tfw_dump.boot_memory_size = fadump_calculate_reserve_size();\n\n\t/*\n\t * Calculate the memory boundary.\n\t * If memory_limit is less than actual memory boundary then reserve\n\t * the memory for fadump beyond the memory_limit and adjust the\n\t * memory_limit accordingly, so that the running kernel can run with\n\t * specified memory_limit.\n\t */\n\tif (memory_limit && memory_limit < memblock_end_of_DRAM()) {\n\t\tsize = get_fadump_area_size();\n\t\tif ((memory_limit + size) < memblock_end_of_DRAM())\n\t\t\tmemory_limit += size;\n\t\telse\n\t\t\tmemory_limit = memblock_end_of_DRAM();\n\t\tprintk(KERN_INFO \"Adjusted memory_limit for firmware-assisted\"\n\t\t\t\t\" dump, now %#016llx\\n\", memory_limit);\n\t}\n\tif (memory_limit)\n\t\tmemory_boundary = memory_limit;\n\telse\n\t\tmemory_boundary = memblock_end_of_DRAM();\n\n\tif (fw_dump.dump_active) {\n\t\tprintk(KERN_INFO \"Firmware-assisted dump is active.\\n\");\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot_memory_size so that we don't touch it until\n\t\t * dump is written to disk by userspace tool. This memory\n\t\t * will be released for general use once the dump is saved.\n\t\t */\n\t\tbase = fw_dump.boot_memory_size;\n\t\tsize = memory_boundary - base;\n\t\tmemblock_reserve(base, size);\n\t\tprintk(KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for saving crash dump\\n\",\n\t\t\t\t(unsigned long)(size >> 20),\n\t\t\t\t(unsigned long)(base >> 20));\n\n\t\tfw_dump.fadumphdr_addr =\n\t\t\t\tbe64_to_cpu(fdm_active->rmr_region.destination_address) +\n\t\t\t\tbe64_to_cpu(fdm_active->rmr_region.source_len);\n\t\tpr_debug(\"fadumphdr_addr = %p\\n\",\n\t\t\t\t(void *) fw_dump.fadumphdr_addr);\n\t} else {\n\t\t/* Reserve the memory at the top of memory. */\n\t\tsize = get_fadump_area_size();\n\t\tbase = memory_boundary - size;\n\t\tmemblock_reserve(base, size);\n\t\tprintk(KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for firmware-assisted dump\\n\",\n\t\t\t\t(unsigned long)(size >> 20),\n\t\t\t\t(unsigned long)(base >> 20));\n\t}\n\tfw_dump.reserve_dump_area_start = base;\n\tfw_dump.reserve_dump_area_size = size;\n\treturn 1;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <asm/page.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/crash_dump.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>",
            "#include <linux/memblock.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fw_dump fw_dump;",
            "static const struct fadump_mem_struct *fdm_active;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <asm/page.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/crash_dump.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/memblock.h>\n#include <linux/string.h>\n\nstatic struct fw_dump fw_dump;\nstatic const struct fadump_mem_struct *fdm_active;\n\nint __init fadump_reserve_mem(void)\n{\n\tunsigned long base, size, memory_boundary;\n\n\tif (!fw_dump.fadump_enabled)\n\t\treturn 0;\n\n\tif (!fw_dump.fadump_supported) {\n\t\tprintk(KERN_INFO \"Firmware-assisted dump is not supported on\"\n\t\t\t\t\" this hardware\\n\");\n\t\tfw_dump.fadump_enabled = 0;\n\t\treturn 0;\n\t}\n\t/*\n\t * Initialize boot memory size\n\t * If dump is active then we have already calculated the size during\n\t * first kernel.\n\t */\n\tif (fdm_active)\n\t\tfw_dump.boot_memory_size = be64_to_cpu(fdm_active->rmr_region.source_len);\n\telse\n\t\tfw_dump.boot_memory_size = fadump_calculate_reserve_size();\n\n\t/*\n\t * Calculate the memory boundary.\n\t * If memory_limit is less than actual memory boundary then reserve\n\t * the memory for fadump beyond the memory_limit and adjust the\n\t * memory_limit accordingly, so that the running kernel can run with\n\t * specified memory_limit.\n\t */\n\tif (memory_limit && memory_limit < memblock_end_of_DRAM()) {\n\t\tsize = get_fadump_area_size();\n\t\tif ((memory_limit + size) < memblock_end_of_DRAM())\n\t\t\tmemory_limit += size;\n\t\telse\n\t\t\tmemory_limit = memblock_end_of_DRAM();\n\t\tprintk(KERN_INFO \"Adjusted memory_limit for firmware-assisted\"\n\t\t\t\t\" dump, now %#016llx\\n\", memory_limit);\n\t}\n\tif (memory_limit)\n\t\tmemory_boundary = memory_limit;\n\telse\n\t\tmemory_boundary = memblock_end_of_DRAM();\n\n\tif (fw_dump.dump_active) {\n\t\tprintk(KERN_INFO \"Firmware-assisted dump is active.\\n\");\n\t\t/*\n\t\t * If last boot has crashed then reserve all the memory\n\t\t * above boot_memory_size so that we don't touch it until\n\t\t * dump is written to disk by userspace tool. This memory\n\t\t * will be released for general use once the dump is saved.\n\t\t */\n\t\tbase = fw_dump.boot_memory_size;\n\t\tsize = memory_boundary - base;\n\t\tmemblock_reserve(base, size);\n\t\tprintk(KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for saving crash dump\\n\",\n\t\t\t\t(unsigned long)(size >> 20),\n\t\t\t\t(unsigned long)(base >> 20));\n\n\t\tfw_dump.fadumphdr_addr =\n\t\t\t\tbe64_to_cpu(fdm_active->rmr_region.destination_address) +\n\t\t\t\tbe64_to_cpu(fdm_active->rmr_region.source_len);\n\t\tpr_debug(\"fadumphdr_addr = %p\\n\",\n\t\t\t\t(void *) fw_dump.fadumphdr_addr);\n\t} else {\n\t\t/* Reserve the memory at the top of memory. */\n\t\tsize = get_fadump_area_size();\n\t\tbase = memory_boundary - size;\n\t\tmemblock_reserve(base, size);\n\t\tprintk(KERN_INFO \"Reserved %ldMB of memory at %ldMB \"\n\t\t\t\t\"for firmware-assisted dump\\n\",\n\t\t\t\t(unsigned long)(size >> 20),\n\t\t\t\t(unsigned long)(base >> 20));\n\t}\n\tfw_dump.reserve_dump_area_start = base;\n\tfw_dump.reserve_dump_area_size = size;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reserve_kdump_trampoline",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "reserve_kdump_trampoline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/crash_dump.c",
          "lines": "32-35",
          "snippet": "void __init reserve_kdump_trampoline(void)\n{\n\tmemblock_reserve(0, KDUMP_RESERVE_LIMIT);\n}",
          "includes": [
            "#include <asm/udbg.h>",
            "#include <asm/rtas.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/firmware.h>",
            "#include <asm/prom.h>",
            "#include <asm/kdump.h>",
            "#include <asm/code-patching.h>",
            "#include <linux/memblock.h>",
            "#include <linux/io.h>",
            "#include <linux/crash_dump.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/udbg.h>\n#include <asm/rtas.h>\n#include <asm/uaccess.h>\n#include <asm/firmware.h>\n#include <asm/prom.h>\n#include <asm/kdump.h>\n#include <asm/code-patching.h>\n#include <linux/memblock.h>\n#include <linux/io.h>\n#include <linux/crash_dump.h>\n\nvoid __init reserve_kdump_trampoline(void)\n{\n\tmemblock_reserve(0, KDUMP_RESERVE_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "MEMORY_START",
            "0x8000"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "PHYSICAL_START",
            "__pa(klimit) - PHYSICAL_START"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "klimit"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_initial_memory_limit",
          "args": [
            "memstart_addr",
            "first_memblock_size"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "first_memblock_size",
            "memory_limit"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_early_param",
          "args": [],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_memory_ppc",
            "NULL"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_root",
            "NULL"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_chosen_ppc",
            "boot_command_line"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_fw_dump",
            "NULL"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_opal",
            "NULL"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_scan_flat_dt",
          "args": [
            "early_init_dt_scan_rtas",
            "NULL"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"BUG: Failed verifying flat device tree, bad version?\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_dt_verify",
          "args": [
            "params"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\" -> early_init_devtree(%p)\\n\"",
            "params"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic phys_addr_t first_memblock_size;\n\nvoid __init early_init_devtree(void *params)\n{\n\tphys_addr_t limit;\n\n\tDBG(\" -> early_init_devtree(%p)\\n\", params);\n\n\t/* Too early to BUG_ON(), do it by hand */\n\tif (!early_init_dt_verify(params))\n\t\tpanic(\"BUG: Failed verifying flat device tree, bad version?\");\n\n#ifdef CONFIG_PPC_RTAS\n\t/* Some machines might need RTAS info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_rtas, NULL);\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Some machines might need OPAL info for debugging, grab it now. */\n\tof_scan_flat_dt(early_init_dt_scan_opal, NULL);\n#endif\n\n#ifdef CONFIG_FA_DUMP\n\t/* scan tree to see if dump is active during last boot */\n\tof_scan_flat_dt(early_init_dt_scan_fw_dump, NULL);\n#endif\n\n\t/* Retrieve various informations from the /chosen node of the\n\t * device-tree, including the platform type, initrd location and\n\t * size, TCE reserve, and more ...\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_chosen_ppc, boot_command_line);\n\n\t/* Scan memory nodes and rebuild MEMBLOCKs */\n\tof_scan_flat_dt(early_init_dt_scan_root, NULL);\n\tof_scan_flat_dt(early_init_dt_scan_memory_ppc, NULL);\n\n\tparse_early_param();\n\n\t/* make sure we've parsed cmdline for mem= before this */\n\tif (memory_limit)\n\t\tfirst_memblock_size = min_t(u64, first_memblock_size, memory_limit);\n\tsetup_initial_memory_limit(memstart_addr, first_memblock_size);\n\t/* Reserve MEMBLOCK regions used by kernel, initrd, dt, etc... */\n\tmemblock_reserve(PHYSICAL_START, __pa(klimit) - PHYSICAL_START);\n\t/* If relocatable, reserve first 32k for interrupt vectors etc. */\n\tif (PHYSICAL_START > MEMORY_START)\n\t\tmemblock_reserve(MEMORY_START, 0x8000);\n\treserve_kdump_trampoline();\n#ifdef CONFIG_FA_DUMP\n\t/*\n\t * If we fail to reserve memory for firmware-assisted dump then\n\t * fallback to kexec based kdump.\n\t */\n\tif (fadump_reserve_mem() == 0)\n#endif\n\t\treserve_crashkernel();\n\tearly_reserve_mem();\n\n\t/* Ensure that total memory size is page-aligned. */\n\tlimit = ALIGN(memory_limit ?: memblock_phys_mem_size(), PAGE_SIZE);\n\tmemblock_enforce_memory_limit(limit);\n\n\tmemblock_allow_resize();\n\tmemblock_dump_all();\n\n\tDBG(\"Phys. mem: %llx\\n\", memblock_phys_mem_size());\n\n\t/* We may need to relocate the flat tree, do it now.\n\t * FIXME .. and the initrd too? */\n\tmove_device_tree();\n\n\tallocate_pacas();\n\n\tDBG(\"Scanning CPUs ...\\n\");\n\n\t/* Retrieve CPU related informations from the flat tree\n\t * (altivec support, boot CPU ID, ...)\n\t */\n\tof_scan_flat_dt(early_init_dt_scan_cpus, NULL);\n\tif (boot_cpuid < 0) {\n\t\tprintk(\"Failed to identify boot CPU !\\n\");\n\t\tBUG();\n\t}\n\n#if defined(CONFIG_SMP) && defined(CONFIG_PPC64)\n\t/* We'll later wait for secondaries to check in; there are\n\t * NCPUS-1 non-boot CPUs  :-)\n\t */\n\tspinning_secondaries = boot_cpu_count - 1;\n#endif\n\n#ifdef CONFIG_PPC_POWERNV\n\t/* Scan and build the list of machine check recoverable ranges */\n\tof_scan_flat_dt(early_init_dt_scan_recoverable_ranges, NULL);\n#endif\n\n\tDBG(\" <- early_init_devtree()\\n\");\n}"
  },
  {
    "function_name": "early_reserve_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "599-640",
    "snippet": "static void __init early_reserve_mem(void)\n{\n\t__be64 *reserve_map;\n\n\treserve_map = (__be64 *)(((unsigned long)initial_boot_params) +\n\t\t\tfdt_off_mem_rsvmap(initial_boot_params));\n\n\t/* Look for the new \"reserved-regions\" property in the DT */\n\tearly_reserve_mem_dt();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\t/* Then reserve the initrd, if any */\n\tif (initrd_start && (initrd_end > initrd_start)) {\n\t\tmemblock_reserve(_ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE),\n\t\t\t_ALIGN_UP(initrd_end, PAGE_SIZE) -\n\t\t\t_ALIGN_DOWN(initrd_start, PAGE_SIZE));\n\t}\n#endif /* CONFIG_BLK_DEV_INITRD */\n\n#ifdef CONFIG_PPC32\n\t/* \n\t * Handle the case where we might be booting from an old kexec\n\t * image that setup the mem_rsvmap as pairs of 32-bit values\n\t */\n\tif (be64_to_cpup(reserve_map) > 0xffffffffull) {\n\t\tu32 base_32, size_32;\n\t\t__be32 *reserve_map_32 = (__be32 *)reserve_map;\n\n\t\tDBG(\"Found old 32-bit reserve map\\n\");\n\n\t\twhile (1) {\n\t\t\tbase_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tsize_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tif (size_32 == 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"reserving: %x -> %x\\n\", base_32, size_32);\n\t\t\tmemblock_reserve(base_32, size_32);\n\t\t}\n\t\treturn;\n\t}\n#endif\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "base_32",
            "size_32"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"reserving: %x -> %x\\n\"",
            "base_32",
            "size_32"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "reserve_map_32++"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "reserve_map_32++"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Found old 32-bit reserve map\\n\""
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpup",
          "args": [
            "reserve_map"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "_ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE)",
            "_ALIGN_UP(initrd_end, PAGE_SIZE) -\n\t\t\t_ALIGN_DOWN(initrd_start, PAGE_SIZE)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ALIGN_DOWN",
          "args": [
            "initrd_start",
            "PAGE_SIZE"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ALIGN_UP",
          "args": [
            "initrd_end",
            "PAGE_SIZE"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ALIGN_DOWN",
          "args": [
            "__pa(initrd_start)",
            "PAGE_SIZE"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "initrd_start"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "early_reserve_mem_dt",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "early_reserve_mem_dt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "566-597",
          "snippet": "static void __init early_reserve_mem_dt(void)\n{\n\tunsigned long i, dt_root;\n\tint len;\n\tconst __be32 *prop;\n\n\tearly_init_fdt_reserve_self();\n\tearly_init_fdt_scan_reserved_mem();\n\n\tdt_root = of_get_flat_dt_root();\n\n\tprop = of_get_flat_dt_prop(dt_root, \"reserved-ranges\", &len);\n\n\tif (!prop)\n\t\treturn;\n\n\tDBG(\"Found new-style reserved-ranges\\n\");\n\n\t/* Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range. */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tDBG(\"reserving: %llx -> %llx\\n\", base, size);\n\t\t\tmemblock_reserve(base, size);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init early_reserve_mem_dt(void)\n{\n\tunsigned long i, dt_root;\n\tint len;\n\tconst __be32 *prop;\n\n\tearly_init_fdt_reserve_self();\n\tearly_init_fdt_scan_reserved_mem();\n\n\tdt_root = of_get_flat_dt_root();\n\n\tprop = of_get_flat_dt_prop(dt_root, \"reserved-ranges\", &len);\n\n\tif (!prop)\n\t\treturn;\n\n\tDBG(\"Found new-style reserved-ranges\\n\");\n\n\t/* Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range. */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tDBG(\"reserving: %llx -> %llx\\n\", base, size);\n\t\t\tmemblock_reserve(base, size);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdt_off_mem_rsvmap",
          "args": [
            "initial_boot_params"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init early_reserve_mem(void)\n{\n\t__be64 *reserve_map;\n\n\treserve_map = (__be64 *)(((unsigned long)initial_boot_params) +\n\t\t\tfdt_off_mem_rsvmap(initial_boot_params));\n\n\t/* Look for the new \"reserved-regions\" property in the DT */\n\tearly_reserve_mem_dt();\n\n#ifdef CONFIG_BLK_DEV_INITRD\n\t/* Then reserve the initrd, if any */\n\tif (initrd_start && (initrd_end > initrd_start)) {\n\t\tmemblock_reserve(_ALIGN_DOWN(__pa(initrd_start), PAGE_SIZE),\n\t\t\t_ALIGN_UP(initrd_end, PAGE_SIZE) -\n\t\t\t_ALIGN_DOWN(initrd_start, PAGE_SIZE));\n\t}\n#endif /* CONFIG_BLK_DEV_INITRD */\n\n#ifdef CONFIG_PPC32\n\t/* \n\t * Handle the case where we might be booting from an old kexec\n\t * image that setup the mem_rsvmap as pairs of 32-bit values\n\t */\n\tif (be64_to_cpup(reserve_map) > 0xffffffffull) {\n\t\tu32 base_32, size_32;\n\t\t__be32 *reserve_map_32 = (__be32 *)reserve_map;\n\n\t\tDBG(\"Found old 32-bit reserve map\\n\");\n\n\t\twhile (1) {\n\t\t\tbase_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tsize_32 = be32_to_cpup(reserve_map_32++);\n\t\t\tif (size_32 == 0)\n\t\t\t\tbreak;\n\t\t\tDBG(\"reserving: %x -> %x\\n\", base_32, size_32);\n\t\t\tmemblock_reserve(base_32, size_32);\n\t\t}\n\t\treturn;\n\t}\n#endif\n}"
  },
  {
    "function_name": "early_reserve_mem_dt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "566-597",
    "snippet": "static void __init early_reserve_mem_dt(void)\n{\n\tunsigned long i, dt_root;\n\tint len;\n\tconst __be32 *prop;\n\n\tearly_init_fdt_reserve_self();\n\tearly_init_fdt_scan_reserved_mem();\n\n\tdt_root = of_get_flat_dt_root();\n\n\tprop = of_get_flat_dt_prop(dt_root, \"reserved-ranges\", &len);\n\n\tif (!prop)\n\t\treturn;\n\n\tDBG(\"Found new-style reserved-ranges\\n\");\n\n\t/* Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range. */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tDBG(\"reserving: %llx -> %llx\\n\", base, size);\n\t\t\tmemblock_reserve(base, size);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_reserve",
          "args": [
            "base",
            "size"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"reserving: %llx -> %llx\\n\"",
            "base",
            "size"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop + (i * 4) + 2",
            "2"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "prop + (i * 4) + 0",
            "2"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Found new-style reserved-ranges\\n\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "dt_root",
            "\"reserved-ranges\"",
            "&len"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_root",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_fdt_scan_reserved_mem",
          "args": [],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_fdt_reserve_self",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init early_reserve_mem_dt(void)\n{\n\tunsigned long i, dt_root;\n\tint len;\n\tconst __be32 *prop;\n\n\tearly_init_fdt_reserve_self();\n\tearly_init_fdt_scan_reserved_mem();\n\n\tdt_root = of_get_flat_dt_root();\n\n\tprop = of_get_flat_dt_prop(dt_root, \"reserved-ranges\", &len);\n\n\tif (!prop)\n\t\treturn;\n\n\tDBG(\"Found new-style reserved-ranges\\n\");\n\n\t/* Each reserved range is an (address,size) pair, 2 cells each,\n\t * totalling 4 cells per range. */\n\tfor (i = 0; i < len / (sizeof(*prop) * 4); i++) {\n\t\tu64 base, size;\n\n\t\tbase = of_read_number(prop + (i * 4) + 0, 2);\n\t\tsize = of_read_number(prop + (i * 4) + 2, 2);\n\n\t\tif (size) {\n\t\t\tDBG(\"reserving: %llx -> %llx\\n\", base, size);\n\t\t\tmemblock_reserve(base, size);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "early_init_dt_add_memory_arch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "542-564",
    "snippet": "void __init early_init_dt_add_memory_arch(u64 base, u64 size)\n{\n#ifdef CONFIG_PPC64\n\tif (iommu_is_off) {\n\t\tif (base >= 0x80000000ul)\n\t\t\treturn;\n\t\tif ((base + size) > 0x80000000ul)\n\t\t\tsize = 0x80000000ul - base;\n\t}\n#endif\n\t/* Keep track of the beginning of memory -and- the size of\n\t * the very first block in the device-tree as it represents\n\t * the RMA on ppc64 server\n\t */\n\tif (base < memstart_addr) {\n\t\tmemstart_addr = base;\n\t\tfirst_memblock_size = size;\n\t}\n\n\t/* Add the chunk to the MEMBLOCK list */\n\tif (add_mem_to_memblock)\n\t\tmemblock_add(base, size);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [
      "#define add_mem_to_memblock 1"
    ],
    "globals_used": [
      "static phys_addr_t first_memblock_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_add",
          "args": [
            "base",
            "size"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\n#define add_mem_to_memblock 1\n\nstatic phys_addr_t first_memblock_size;\n\nvoid __init early_init_dt_add_memory_arch(u64 base, u64 size)\n{\n#ifdef CONFIG_PPC64\n\tif (iommu_is_off) {\n\t\tif (base >= 0x80000000ul)\n\t\t\treturn;\n\t\tif ((base + size) > 0x80000000ul)\n\t\t\tsize = 0x80000000ul - base;\n\t}\n#endif\n\t/* Keep track of the beginning of memory -and- the size of\n\t * the very first block in the device-tree as it represents\n\t * the RMA on ppc64 server\n\t */\n\tif (base < memstart_addr) {\n\t\tmemstart_addr = base;\n\t\tfirst_memblock_size = size;\n\t}\n\n\t/* Add the chunk to the MEMBLOCK list */\n\tif (add_mem_to_memblock)\n\t\tmemblock_add(base, size);\n}"
  },
  {
    "function_name": "early_init_dt_scan_memory_ppc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "517-526",
    "snippet": "static int __init early_init_dt_scan_memory_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tif (depth == 1 &&\n\t    strcmp(uname, \"ibm,dynamic-reconfiguration-memory\") == 0)\n\t\treturn early_init_dt_scan_drconf_memory(node);\n\t\n\treturn early_init_dt_scan_memory(node, uname, depth, data);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "early_init_dt_scan_memory",
          "args": [
            "node",
            "uname",
            "depth",
            "data"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "early_init_dt_scan_memory_ppc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "517-526",
          "snippet": "static int __init early_init_dt_scan_memory_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tif (depth == 1 &&\n\t    strcmp(uname, \"ibm,dynamic-reconfiguration-memory\") == 0)\n\t\treturn early_init_dt_scan_drconf_memory(node);\n\t\n\treturn early_init_dt_scan_memory(node, uname, depth, data);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "early_init_dt_scan_drconf_memory",
          "args": [
            "node"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "early_init_dt_scan_drconf_memory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "443-512",
          "snippet": "static int __init early_init_dt_scan_drconf_memory(unsigned long node)\n{\n\tconst __be32 *dm, *ls, *usm;\n\tint l;\n\tunsigned long n, flags;\n\tu64 base, size, memblock_size;\n\tunsigned int is_kexec_kdump = 0, rngs;\n\n\tls = of_get_flat_dt_prop(node, \"ibm,lmb-size\", &l);\n\tif (ls == NULL || l < dt_root_size_cells * sizeof(__be32))\n\t\treturn 0;\n\tmemblock_size = dt_mem_next_cell(dt_root_size_cells, &ls);\n\n\tdm = of_get_flat_dt_prop(node, \"ibm,dynamic-memory\", &l);\n\tif (dm == NULL || l < sizeof(__be32))\n\t\treturn 0;\n\n\tn = of_read_number(dm++, 1);\t/* number of entries */\n\tif (l < (n * (dt_root_addr_cells + 4) + 1) * sizeof(__be32))\n\t\treturn 0;\n\n\t/* check if this is a kexec/kdump kernel. */\n\tusm = of_get_flat_dt_prop(node, \"linux,drconf-usable-memory\",\n\t\t\t\t\t\t &l);\n\tif (usm != NULL)\n\t\tis_kexec_kdump = 1;\n\n\tfor (; n != 0; --n) {\n\t\tbase = dt_mem_next_cell(dt_root_addr_cells, &dm);\n\t\tflags = of_read_number(&dm[3], 1);\n\t\t/* skip DRC index, pad, assoc. list index, flags */\n\t\tdm += 4;\n\t\t/* skip this block if the reserved bit is set in flags\n\t\t   or if the block is not assigned to this partition */\n\t\tif ((flags & DRCONF_MEM_RESERVED) ||\n\t\t\t\t!(flags & DRCONF_MEM_ASSIGNED))\n\t\t\tcontinue;\n\t\tsize = memblock_size;\n\t\trngs = 1;\n\t\tif (is_kexec_kdump) {\n\t\t\t/*\n\t\t\t * For each memblock in ibm,dynamic-memory, a corresponding\n\t\t\t * entry in linux,drconf-usable-memory property contains\n\t\t\t * a counter 'p' followed by 'p' (base, size) duple.\n\t\t\t * Now read the counter from\n\t\t\t * linux,drconf-usable-memory property\n\t\t\t */\n\t\t\trngs = dt_mem_next_cell(dt_root_size_cells, &usm);\n\t\t\tif (!rngs) /* there are no (base, size) duple */\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tif (is_kexec_kdump) {\n\t\t\t\tbase = dt_mem_next_cell(dt_root_addr_cells,\n\t\t\t\t\t\t\t &usm);\n\t\t\t\tsize = dt_mem_next_cell(dt_root_size_cells,\n\t\t\t\t\t\t\t &usm);\n\t\t\t}\n\t\t\tif (iommu_is_off) {\n\t\t\t\tif (base >= 0x80000000ul)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((base + size) > 0x80000000ul)\n\t\t\t\t\tsize = 0x80000000ul - base;\n\t\t\t}\n\t\t\tmemblock_add(base, size);\n\t\t} while (--rngs);\n\t}\n\tmemblock_dump_all();\n\treturn 0;\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};\n\nstatic int __init early_init_dt_scan_drconf_memory(unsigned long node)\n{\n\tconst __be32 *dm, *ls, *usm;\n\tint l;\n\tunsigned long n, flags;\n\tu64 base, size, memblock_size;\n\tunsigned int is_kexec_kdump = 0, rngs;\n\n\tls = of_get_flat_dt_prop(node, \"ibm,lmb-size\", &l);\n\tif (ls == NULL || l < dt_root_size_cells * sizeof(__be32))\n\t\treturn 0;\n\tmemblock_size = dt_mem_next_cell(dt_root_size_cells, &ls);\n\n\tdm = of_get_flat_dt_prop(node, \"ibm,dynamic-memory\", &l);\n\tif (dm == NULL || l < sizeof(__be32))\n\t\treturn 0;\n\n\tn = of_read_number(dm++, 1);\t/* number of entries */\n\tif (l < (n * (dt_root_addr_cells + 4) + 1) * sizeof(__be32))\n\t\treturn 0;\n\n\t/* check if this is a kexec/kdump kernel. */\n\tusm = of_get_flat_dt_prop(node, \"linux,drconf-usable-memory\",\n\t\t\t\t\t\t &l);\n\tif (usm != NULL)\n\t\tis_kexec_kdump = 1;\n\n\tfor (; n != 0; --n) {\n\t\tbase = dt_mem_next_cell(dt_root_addr_cells, &dm);\n\t\tflags = of_read_number(&dm[3], 1);\n\t\t/* skip DRC index, pad, assoc. list index, flags */\n\t\tdm += 4;\n\t\t/* skip this block if the reserved bit is set in flags\n\t\t   or if the block is not assigned to this partition */\n\t\tif ((flags & DRCONF_MEM_RESERVED) ||\n\t\t\t\t!(flags & DRCONF_MEM_ASSIGNED))\n\t\t\tcontinue;\n\t\tsize = memblock_size;\n\t\trngs = 1;\n\t\tif (is_kexec_kdump) {\n\t\t\t/*\n\t\t\t * For each memblock in ibm,dynamic-memory, a corresponding\n\t\t\t * entry in linux,drconf-usable-memory property contains\n\t\t\t * a counter 'p' followed by 'p' (base, size) duple.\n\t\t\t * Now read the counter from\n\t\t\t * linux,drconf-usable-memory property\n\t\t\t */\n\t\t\trngs = dt_mem_next_cell(dt_root_size_cells, &usm);\n\t\t\tif (!rngs) /* there are no (base, size) duple */\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tif (is_kexec_kdump) {\n\t\t\t\tbase = dt_mem_next_cell(dt_root_addr_cells,\n\t\t\t\t\t\t\t &usm);\n\t\t\t\tsize = dt_mem_next_cell(dt_root_size_cells,\n\t\t\t\t\t\t\t &usm);\n\t\t\t}\n\t\t\tif (iommu_is_off) {\n\t\t\t\tif (base >= 0x80000000ul)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((base + size) > 0x80000000ul)\n\t\t\t\t\tsize = 0x80000000ul - base;\n\t\t\t}\n\t\t\tmemblock_add(base, size);\n\t\t} while (--rngs);\n\t}\n\tmemblock_dump_all();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "uname",
            "\"ibm,dynamic-reconfiguration-memory\""
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __init early_init_dt_scan_memory_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tif (depth == 1 &&\n\t    strcmp(uname, \"ibm,dynamic-reconfiguration-memory\") == 0)\n\t\treturn early_init_dt_scan_drconf_memory(node);\n\t\n\treturn early_init_dt_scan_memory(node, uname, depth, data);\n}"
  },
  {
    "function_name": "early_init_dt_scan_drconf_memory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "443-512",
    "snippet": "static int __init early_init_dt_scan_drconf_memory(unsigned long node)\n{\n\tconst __be32 *dm, *ls, *usm;\n\tint l;\n\tunsigned long n, flags;\n\tu64 base, size, memblock_size;\n\tunsigned int is_kexec_kdump = 0, rngs;\n\n\tls = of_get_flat_dt_prop(node, \"ibm,lmb-size\", &l);\n\tif (ls == NULL || l < dt_root_size_cells * sizeof(__be32))\n\t\treturn 0;\n\tmemblock_size = dt_mem_next_cell(dt_root_size_cells, &ls);\n\n\tdm = of_get_flat_dt_prop(node, \"ibm,dynamic-memory\", &l);\n\tif (dm == NULL || l < sizeof(__be32))\n\t\treturn 0;\n\n\tn = of_read_number(dm++, 1);\t/* number of entries */\n\tif (l < (n * (dt_root_addr_cells + 4) + 1) * sizeof(__be32))\n\t\treturn 0;\n\n\t/* check if this is a kexec/kdump kernel. */\n\tusm = of_get_flat_dt_prop(node, \"linux,drconf-usable-memory\",\n\t\t\t\t\t\t &l);\n\tif (usm != NULL)\n\t\tis_kexec_kdump = 1;\n\n\tfor (; n != 0; --n) {\n\t\tbase = dt_mem_next_cell(dt_root_addr_cells, &dm);\n\t\tflags = of_read_number(&dm[3], 1);\n\t\t/* skip DRC index, pad, assoc. list index, flags */\n\t\tdm += 4;\n\t\t/* skip this block if the reserved bit is set in flags\n\t\t   or if the block is not assigned to this partition */\n\t\tif ((flags & DRCONF_MEM_RESERVED) ||\n\t\t\t\t!(flags & DRCONF_MEM_ASSIGNED))\n\t\t\tcontinue;\n\t\tsize = memblock_size;\n\t\trngs = 1;\n\t\tif (is_kexec_kdump) {\n\t\t\t/*\n\t\t\t * For each memblock in ibm,dynamic-memory, a corresponding\n\t\t\t * entry in linux,drconf-usable-memory property contains\n\t\t\t * a counter 'p' followed by 'p' (base, size) duple.\n\t\t\t * Now read the counter from\n\t\t\t * linux,drconf-usable-memory property\n\t\t\t */\n\t\t\trngs = dt_mem_next_cell(dt_root_size_cells, &usm);\n\t\t\tif (!rngs) /* there are no (base, size) duple */\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tif (is_kexec_kdump) {\n\t\t\t\tbase = dt_mem_next_cell(dt_root_addr_cells,\n\t\t\t\t\t\t\t &usm);\n\t\t\t\tsize = dt_mem_next_cell(dt_root_size_cells,\n\t\t\t\t\t\t\t &usm);\n\t\t\t}\n\t\t\tif (iommu_is_off) {\n\t\t\t\tif (base >= 0x80000000ul)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((base + size) > 0x80000000ul)\n\t\t\t\t\tsize = 0x80000000ul - base;\n\t\t\t}\n\t\t\tmemblock_add(base, size);\n\t\t} while (--rngs);\n\t}\n\tmemblock_dump_all();\n\treturn 0;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memblock_dump_all",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_add",
          "args": [
            "base",
            "size"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_mem_next_cell",
          "args": [
            "dt_root_size_cells",
            "&usm"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_mem_next_cell",
          "args": [
            "dt_root_addr_cells",
            "&usm"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_mem_next_cell",
          "args": [
            "dt_root_size_cells",
            "&usm"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "&dm[3]",
            "1"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_mem_next_cell",
          "args": [
            "dt_root_addr_cells",
            "&dm"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,drconf-usable-memory\"",
            "&l"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_read_number",
          "args": [
            "dm++",
            "1"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,dynamic-memory\"",
            "&l"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dt_mem_next_cell",
          "args": [
            "dt_root_size_cells",
            "&ls"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,lmb-size\"",
            "&l"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};\n\nstatic int __init early_init_dt_scan_drconf_memory(unsigned long node)\n{\n\tconst __be32 *dm, *ls, *usm;\n\tint l;\n\tunsigned long n, flags;\n\tu64 base, size, memblock_size;\n\tunsigned int is_kexec_kdump = 0, rngs;\n\n\tls = of_get_flat_dt_prop(node, \"ibm,lmb-size\", &l);\n\tif (ls == NULL || l < dt_root_size_cells * sizeof(__be32))\n\t\treturn 0;\n\tmemblock_size = dt_mem_next_cell(dt_root_size_cells, &ls);\n\n\tdm = of_get_flat_dt_prop(node, \"ibm,dynamic-memory\", &l);\n\tif (dm == NULL || l < sizeof(__be32))\n\t\treturn 0;\n\n\tn = of_read_number(dm++, 1);\t/* number of entries */\n\tif (l < (n * (dt_root_addr_cells + 4) + 1) * sizeof(__be32))\n\t\treturn 0;\n\n\t/* check if this is a kexec/kdump kernel. */\n\tusm = of_get_flat_dt_prop(node, \"linux,drconf-usable-memory\",\n\t\t\t\t\t\t &l);\n\tif (usm != NULL)\n\t\tis_kexec_kdump = 1;\n\n\tfor (; n != 0; --n) {\n\t\tbase = dt_mem_next_cell(dt_root_addr_cells, &dm);\n\t\tflags = of_read_number(&dm[3], 1);\n\t\t/* skip DRC index, pad, assoc. list index, flags */\n\t\tdm += 4;\n\t\t/* skip this block if the reserved bit is set in flags\n\t\t   or if the block is not assigned to this partition */\n\t\tif ((flags & DRCONF_MEM_RESERVED) ||\n\t\t\t\t!(flags & DRCONF_MEM_ASSIGNED))\n\t\t\tcontinue;\n\t\tsize = memblock_size;\n\t\trngs = 1;\n\t\tif (is_kexec_kdump) {\n\t\t\t/*\n\t\t\t * For each memblock in ibm,dynamic-memory, a corresponding\n\t\t\t * entry in linux,drconf-usable-memory property contains\n\t\t\t * a counter 'p' followed by 'p' (base, size) duple.\n\t\t\t * Now read the counter from\n\t\t\t * linux,drconf-usable-memory property\n\t\t\t */\n\t\t\trngs = dt_mem_next_cell(dt_root_size_cells, &usm);\n\t\t\tif (!rngs) /* there are no (base, size) duple */\n\t\t\t\tcontinue;\n\t\t}\n\t\tdo {\n\t\t\tif (is_kexec_kdump) {\n\t\t\t\tbase = dt_mem_next_cell(dt_root_addr_cells,\n\t\t\t\t\t\t\t &usm);\n\t\t\t\tsize = dt_mem_next_cell(dt_root_size_cells,\n\t\t\t\t\t\t\t &usm);\n\t\t\t}\n\t\t\tif (iommu_is_off) {\n\t\t\t\tif (base >= 0x80000000ul)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((base + size) > 0x80000000ul)\n\t\t\t\t\tsize = 0x80000000ul - base;\n\t\t\t}\n\t\t\tmemblock_add(base, size);\n\t\t} while (--rngs);\n\t}\n\tmemblock_dump_all();\n\treturn 0;\n}"
  },
  {
    "function_name": "early_init_dt_scan_chosen_ppc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "390-434",
    "snippet": "static int __init early_init_dt_scan_chosen_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tconst unsigned long *lprop; /* All these set by kernel, so no need to convert endian */\n\n\t/* Use common scan routine to determine if this is the chosen node */\n\tif (early_init_dt_scan_chosen(node, uname, depth, data) == 0)\n\t\treturn 0;\n\n#ifdef CONFIG_PPC64\n\t/* check if iommu is forced on or off */\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-off\", NULL) != NULL)\n\t\tiommu_is_off = 1;\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-force-on\", NULL) != NULL)\n\t\tiommu_force_on = 1;\n#endif\n\n\t/* mem=x on the command line is the preferred mechanism */\n\tlprop = of_get_flat_dt_prop(node, \"linux,memory-limit\", NULL);\n\tif (lprop)\n\t\tmemory_limit = *lprop;\n\n#ifdef CONFIG_PPC64\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-start\", NULL);\n\tif (lprop)\n\t\ttce_alloc_start = *lprop;\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-end\", NULL);\n\tif (lprop)\n\t\ttce_alloc_end = *lprop;\n#endif\n\n#ifdef CONFIG_KEXEC\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-base\", NULL);\n\tif (lprop)\n\t\tcrashk_res.start = *lprop;\n\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-size\", NULL);\n\tif (lprop)\n\t\tcrashk_res.end = crashk_res.start + *lprop - 1;\n#endif\n\n\t/* break now */\n\treturn 1;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,crashkernel-size\"",
            "NULL"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,crashkernel-base\"",
            "NULL"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,tce-alloc-end\"",
            "NULL"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,tce-alloc-start\"",
            "NULL"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,memory-limit\"",
            "NULL"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,iommu-force-on\"",
            "NULL"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,iommu-off\"",
            "NULL"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "early_init_dt_scan_chosen",
          "args": [
            "node",
            "uname",
            "depth",
            "data"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "early_init_dt_scan_chosen_ppc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "390-434",
          "snippet": "static int __init early_init_dt_scan_chosen_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tconst unsigned long *lprop; /* All these set by kernel, so no need to convert endian */\n\n\t/* Use common scan routine to determine if this is the chosen node */\n\tif (early_init_dt_scan_chosen(node, uname, depth, data) == 0)\n\t\treturn 0;\n\n#ifdef CONFIG_PPC64\n\t/* check if iommu is forced on or off */\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-off\", NULL) != NULL)\n\t\tiommu_is_off = 1;\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-force-on\", NULL) != NULL)\n\t\tiommu_force_on = 1;\n#endif\n\n\t/* mem=x on the command line is the preferred mechanism */\n\tlprop = of_get_flat_dt_prop(node, \"linux,memory-limit\", NULL);\n\tif (lprop)\n\t\tmemory_limit = *lprop;\n\n#ifdef CONFIG_PPC64\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-start\", NULL);\n\tif (lprop)\n\t\ttce_alloc_start = *lprop;\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-end\", NULL);\n\tif (lprop)\n\t\ttce_alloc_end = *lprop;\n#endif\n\n#ifdef CONFIG_KEXEC\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-base\", NULL);\n\tif (lprop)\n\t\tcrashk_res.start = *lprop;\n\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-size\", NULL);\n\tif (lprop)\n\t\tcrashk_res.end = crashk_res.start + *lprop - 1;\n#endif\n\n\t/* break now */\n\treturn 1;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};\n\nstatic int __init early_init_dt_scan_chosen_ppc(unsigned long node,\n\t\t\t\t\t\tconst char *uname,\n\t\t\t\t\t\tint depth, void *data)\n{\n\tconst unsigned long *lprop; /* All these set by kernel, so no need to convert endian */\n\n\t/* Use common scan routine to determine if this is the chosen node */\n\tif (early_init_dt_scan_chosen(node, uname, depth, data) == 0)\n\t\treturn 0;\n\n#ifdef CONFIG_PPC64\n\t/* check if iommu is forced on or off */\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-off\", NULL) != NULL)\n\t\tiommu_is_off = 1;\n\tif (of_get_flat_dt_prop(node, \"linux,iommu-force-on\", NULL) != NULL)\n\t\tiommu_force_on = 1;\n#endif\n\n\t/* mem=x on the command line is the preferred mechanism */\n\tlprop = of_get_flat_dt_prop(node, \"linux,memory-limit\", NULL);\n\tif (lprop)\n\t\tmemory_limit = *lprop;\n\n#ifdef CONFIG_PPC64\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-start\", NULL);\n\tif (lprop)\n\t\ttce_alloc_start = *lprop;\n\tlprop = of_get_flat_dt_prop(node, \"linux,tce-alloc-end\", NULL);\n\tif (lprop)\n\t\ttce_alloc_end = *lprop;\n#endif\n\n#ifdef CONFIG_KEXEC\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-base\", NULL);\n\tif (lprop)\n\t\tcrashk_res.start = *lprop;\n\n\tlprop = of_get_flat_dt_prop(node, \"linux,crashkernel-size\", NULL);\n\tif (lprop)\n\t\tcrashk_res.end = crashk_res.start + *lprop - 1;\n#endif\n\n\t/* break now */\n\treturn 1;\n}"
  },
  {
    "function_name": "early_init_dt_scan_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "294-388",
    "snippet": "static int __init early_init_dt_scan_cpus(unsigned long node,\n\t\t\t\t\t  const char *uname, int depth,\n\t\t\t\t\t  void *data)\n{\n\tconst char *type = of_get_flat_dt_prop(node, \"device_type\", NULL);\n\tconst __be32 *prop;\n\tconst __be32 *intserv;\n\tint i, nthreads;\n\tint len;\n\tint found = -1;\n\tint found_thread = 0;\n\n\t/* We are scanning \"cpu\" nodes only */\n\tif (type == NULL || strcmp(type, \"cpu\") != 0)\n\t\treturn 0;\n\n\t/* Get physical cpuid */\n\tintserv = of_get_flat_dt_prop(node, \"ibm,ppc-interrupt-server#s\", &len);\n\tif (!intserv)\n\t\tintserv = of_get_flat_dt_prop(node, \"reg\", &len);\n\n\tnthreads = len / sizeof(int);\n\n\t/*\n\t * Now see if any of these threads match our boot cpu.\n\t * NOTE: This must match the parsing done in smp_setup_cpu_maps.\n\t */\n\tfor (i = 0; i < nthreads; i++) {\n\t\t/*\n\t\t * version 2 of the kexec param format adds the phys cpuid of\n\t\t * booted proc.\n\t\t */\n\t\tif (fdt_version(initial_boot_params) >= 2) {\n\t\t\tif (be32_to_cpu(intserv[i]) ==\n\t\t\t    fdt_boot_cpuid_phys(initial_boot_params)) {\n\t\t\t\tfound = boot_cpu_count;\n\t\t\t\tfound_thread = i;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check if it's the boot-cpu, set it's hw index now,\n\t\t\t * unfortunately this format did not support booting\n\t\t\t * off secondary threads.\n\t\t\t */\n\t\t\tif (of_get_flat_dt_prop(node,\n\t\t\t\t\t\"linux,boot-cpu\", NULL) != NULL)\n\t\t\t\tfound = boot_cpu_count;\n\t\t}\n#ifdef CONFIG_SMP\n\t\t/* logical cpu id is always 0 on UP kernels */\n\t\tboot_cpu_count++;\n#endif\n\t}\n\n\t/* Not the boot CPU */\n\tif (found < 0)\n\t\treturn 0;\n\n\tDBG(\"boot cpu: logical %d physical %d\\n\", found,\n\t    be32_to_cpu(intserv[found_thread]));\n\tboot_cpuid = found;\n\tset_hard_smp_processor_id(found, be32_to_cpu(intserv[found_thread]));\n\n\t/*\n\t * PAPR defines \"logical\" PVR values for cpus that\n\t * meet various levels of the architecture:\n\t * 0x0f000001\tArchitecture version 2.04\n\t * 0x0f000002\tArchitecture version 2.05\n\t * If the cpu-version property in the cpu node contains\n\t * such a value, we call identify_cpu again with the\n\t * logical PVR value in order to use the cpu feature\n\t * bits appropriate for the architecture level.\n\t *\n\t * A POWER6 partition in \"POWER6 architected\" mode\n\t * uses the 0x0f000002 PVR value; in POWER5+ mode\n\t * it uses 0x0f000001.\n\t */\n\tprop = of_get_flat_dt_prop(node, \"cpu-version\", NULL);\n\tif (prop && (be32_to_cpup(prop) & 0xff000000) == 0x0f000000)\n\t\tidentify_cpu(0, be32_to_cpup(prop));\n\n\tidentical_pvr_fixup(node);\n\n\tcheck_cpu_feature_properties(node);\n\tcheck_cpu_pa_features(node);\n\tinit_mmu_slb_size(node);\n\n#ifdef CONFIG_PPC64\n\tif (nthreads > 1)\n\t\tcur_cpu_spec->cpu_features |= CPU_FTR_SMT;\n\telse\n\t\tcur_cpu_spec->cpu_features &= ~CPU_FTR_SMT;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_mmu_slb_size",
          "args": [
            "node"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "init_mmu_slb_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "221-230",
          "snippet": "static void __init init_mmu_slb_size(unsigned long node)\n{\n\tconst __be32 *slb_size_ptr;\n\n\tslb_size_ptr = of_get_flat_dt_prop(node, \"slb-size\", NULL) ? :\n\t\t\tof_get_flat_dt_prop(node, \"ibm,slb-size\", NULL);\n\n\tif (slb_size_ptr)\n\t\tmmu_slb_size = be32_to_cpup(slb_size_ptr);\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init init_mmu_slb_size(unsigned long node)\n{\n\tconst __be32 *slb_size_ptr;\n\n\tslb_size_ptr = of_get_flat_dt_prop(node, \"slb-size\", NULL) ? :\n\t\t\tof_get_flat_dt_prop(node, \"ibm,slb-size\", NULL);\n\n\tif (slb_size_ptr)\n\t\tmmu_slb_size = be32_to_cpup(slb_size_ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cpu_pa_features",
          "args": [
            "node"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_pa_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "207-218",
          "snippet": "static void __init check_cpu_pa_features(unsigned long node)\n{\n\tconst unsigned char *pa_ftrs;\n\tint tablelen;\n\n\tpa_ftrs = of_get_flat_dt_prop(node, \"ibm,pa-features\", &tablelen);\n\tif (pa_ftrs == NULL)\n\t\treturn;\n\n\tscan_features(node, pa_ftrs, tablelen,\n\t\t      ibm_pa_features, ARRAY_SIZE(ibm_pa_features));\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init check_cpu_pa_features(unsigned long node)\n{\n\tconst unsigned char *pa_ftrs;\n\tint tablelen;\n\n\tpa_ftrs = of_get_flat_dt_prop(node, \"ibm,pa-features\", &tablelen);\n\tif (pa_ftrs == NULL)\n\t\treturn;\n\n\tscan_features(node, pa_ftrs, tablelen,\n\t\t      ibm_pa_features, ARRAY_SIZE(ibm_pa_features));\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cpu_feature_properties",
          "args": [
            "node"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpu_feature_properties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "279-292",
          "snippet": "static void __init check_cpu_feature_properties(unsigned long node)\n{\n\tunsigned long i;\n\tstruct feature_property *fp = feature_properties;\n\tconst __be32 *prop;\n\n\tfor (i = 0; i < ARRAY_SIZE(feature_properties); ++i, ++fp) {\n\t\tprop = of_get_flat_dt_prop(node, fp->name, NULL);\n\t\tif (prop && be32_to_cpup(prop) >= fp->min_value) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_feature;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftr;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct feature_property {\n\tconst char *name;\n\tu32 min_value;\n\tunsigned long cpu_feature;\n\tunsigned long cpu_user_ftr;\n} feature_properties[] __initdata = {\n#ifdef CONFIG_ALTIVEC\n\t{\"altivec\", 0, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n\t{\"ibm,vmx\", 1, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\t/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */\n\t{\"ibm,vmx\", 2, CPU_FTR_VSX, PPC_FEATURE_HAS_VSX},\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_PPC64\n\t{\"ibm,dfp\", 1, 0, PPC_FEATURE_HAS_DFP},\n\t{\"ibm,purr\", 1, CPU_FTR_PURR, 0},\n\t{\"ibm,spurr\", 1, CPU_FTR_SPURR, 0},\n#endif /* CONFIG_PPC64 */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct feature_property {\n\tconst char *name;\n\tu32 min_value;\n\tunsigned long cpu_feature;\n\tunsigned long cpu_user_ftr;\n} feature_properties[] __initdata = {\n#ifdef CONFIG_ALTIVEC\n\t{\"altivec\", 0, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n\t{\"ibm,vmx\", 1, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\t/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */\n\t{\"ibm,vmx\", 2, CPU_FTR_VSX, PPC_FEATURE_HAS_VSX},\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_PPC64\n\t{\"ibm,dfp\", 1, 0, PPC_FEATURE_HAS_DFP},\n\t{\"ibm,purr\", 1, CPU_FTR_PURR, 0},\n\t{\"ibm,spurr\", 1, CPU_FTR_SPURR, 0},\n#endif /* CONFIG_PPC64 */\n};\n\nstatic void __init check_cpu_feature_properties(unsigned long node)\n{\n\tunsigned long i;\n\tstruct feature_property *fp = feature_properties;\n\tconst __be32 *prop;\n\n\tfor (i = 0; i < ARRAY_SIZE(feature_properties); ++i, ++fp) {\n\t\tprop = of_get_flat_dt_prop(node, fp->name, NULL);\n\t\tif (prop && be32_to_cpup(prop) >= fp->min_value) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_feature;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftr;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "identical_pvr_fixup",
          "args": [
            "node"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "identical_pvr_fixup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "257-274",
          "snippet": "static inline void identical_pvr_fixup(unsigned long node)\n{\n\tunsigned int pvr;\n\tconst char *model = of_get_flat_dt_prop(node, \"model\", NULL);\n\n\t/*\n\t * Since 440GR(x)/440EP(x) processors have the same pvr,\n\t * we check the node path and set bit 28 in the cur_cpu_spec\n\t * pvr for EP(x) processor version. This bit is always 0 in\n\t * the \"real\" pvr. Then we call identify_cpu again with\n\t * the new logical pvr to enable FPU support.\n\t */\n\tif (model && strstr(model, \"440EP\")) {\n\t\tpvr = cur_cpu_spec->pvr_value | 0x8;\n\t\tidentify_cpu(0, pvr);\n\t\tDBG(\"Using logical pvr %x for %s\\n\", pvr, model);\n\t}\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};\n\nstatic inline void identical_pvr_fixup(unsigned long node)\n{\n\tunsigned int pvr;\n\tconst char *model = of_get_flat_dt_prop(node, \"model\", NULL);\n\n\t/*\n\t * Since 440GR(x)/440EP(x) processors have the same pvr,\n\t * we check the node path and set bit 28 in the cur_cpu_spec\n\t * pvr for EP(x) processor version. This bit is always 0 in\n\t * the \"real\" pvr. Then we call identify_cpu again with\n\t * the new logical pvr to enable FPU support.\n\t */\n\tif (model && strstr(model, \"440EP\")) {\n\t\tpvr = cur_cpu_spec->pvr_value | 0x8;\n\t\tidentify_cpu(0, pvr);\n\t\tDBG(\"Using logical pvr %x for %s\\n\", pvr, model);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "identify_cpu",
          "args": [
            "0",
            "be32_to_cpup(prop)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "identify_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/cputable.c",
          "lines": "2182-2197",
          "snippet": "struct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/mmu.h>",
            "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
            "#include <asm/cputable.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/threads.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "prop"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "prop"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"cpu-version\"",
            "NULL"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_hard_smp_processor_id",
          "args": [
            "found",
            "be32_to_cpu(intserv[found_thread])"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "intserv[found_thread]"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"boot cpu: logical %d physical %d\\n\"",
            "found",
            "be32_to_cpu(intserv[found_thread])"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "intserv[found_thread]"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"linux,boot-cpu\"",
            "NULL"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdt_boot_cpuid_phys",
          "args": [
            "initial_boot_params"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "intserv[i]"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdt_version",
          "args": [
            "initial_boot_params"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"reg\"",
            "&len"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,ppc-interrupt-server#s\"",
            "&len"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"cpu\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"device_type\"",
            "NULL"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};\n\nstatic int __init early_init_dt_scan_cpus(unsigned long node,\n\t\t\t\t\t  const char *uname, int depth,\n\t\t\t\t\t  void *data)\n{\n\tconst char *type = of_get_flat_dt_prop(node, \"device_type\", NULL);\n\tconst __be32 *prop;\n\tconst __be32 *intserv;\n\tint i, nthreads;\n\tint len;\n\tint found = -1;\n\tint found_thread = 0;\n\n\t/* We are scanning \"cpu\" nodes only */\n\tif (type == NULL || strcmp(type, \"cpu\") != 0)\n\t\treturn 0;\n\n\t/* Get physical cpuid */\n\tintserv = of_get_flat_dt_prop(node, \"ibm,ppc-interrupt-server#s\", &len);\n\tif (!intserv)\n\t\tintserv = of_get_flat_dt_prop(node, \"reg\", &len);\n\n\tnthreads = len / sizeof(int);\n\n\t/*\n\t * Now see if any of these threads match our boot cpu.\n\t * NOTE: This must match the parsing done in smp_setup_cpu_maps.\n\t */\n\tfor (i = 0; i < nthreads; i++) {\n\t\t/*\n\t\t * version 2 of the kexec param format adds the phys cpuid of\n\t\t * booted proc.\n\t\t */\n\t\tif (fdt_version(initial_boot_params) >= 2) {\n\t\t\tif (be32_to_cpu(intserv[i]) ==\n\t\t\t    fdt_boot_cpuid_phys(initial_boot_params)) {\n\t\t\t\tfound = boot_cpu_count;\n\t\t\t\tfound_thread = i;\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * Check if it's the boot-cpu, set it's hw index now,\n\t\t\t * unfortunately this format did not support booting\n\t\t\t * off secondary threads.\n\t\t\t */\n\t\t\tif (of_get_flat_dt_prop(node,\n\t\t\t\t\t\"linux,boot-cpu\", NULL) != NULL)\n\t\t\t\tfound = boot_cpu_count;\n\t\t}\n#ifdef CONFIG_SMP\n\t\t/* logical cpu id is always 0 on UP kernels */\n\t\tboot_cpu_count++;\n#endif\n\t}\n\n\t/* Not the boot CPU */\n\tif (found < 0)\n\t\treturn 0;\n\n\tDBG(\"boot cpu: logical %d physical %d\\n\", found,\n\t    be32_to_cpu(intserv[found_thread]));\n\tboot_cpuid = found;\n\tset_hard_smp_processor_id(found, be32_to_cpu(intserv[found_thread]));\n\n\t/*\n\t * PAPR defines \"logical\" PVR values for cpus that\n\t * meet various levels of the architecture:\n\t * 0x0f000001\tArchitecture version 2.04\n\t * 0x0f000002\tArchitecture version 2.05\n\t * If the cpu-version property in the cpu node contains\n\t * such a value, we call identify_cpu again with the\n\t * logical PVR value in order to use the cpu feature\n\t * bits appropriate for the architecture level.\n\t *\n\t * A POWER6 partition in \"POWER6 architected\" mode\n\t * uses the 0x0f000002 PVR value; in POWER5+ mode\n\t * it uses 0x0f000001.\n\t */\n\tprop = of_get_flat_dt_prop(node, \"cpu-version\", NULL);\n\tif (prop && (be32_to_cpup(prop) & 0xff000000) == 0x0f000000)\n\t\tidentify_cpu(0, be32_to_cpup(prop));\n\n\tidentical_pvr_fixup(node);\n\n\tcheck_cpu_feature_properties(node);\n\tcheck_cpu_pa_features(node);\n\tinit_mmu_slb_size(node);\n\n#ifdef CONFIG_PPC64\n\tif (nthreads > 1)\n\t\tcur_cpu_spec->cpu_features |= CPU_FTR_SMT;\n\telse\n\t\tcur_cpu_spec->cpu_features &= ~CPU_FTR_SMT;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "check_cpu_feature_properties",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "279-292",
    "snippet": "static void __init check_cpu_feature_properties(unsigned long node)\n{\n\tunsigned long i;\n\tstruct feature_property *fp = feature_properties;\n\tconst __be32 *prop;\n\n\tfor (i = 0; i < ARRAY_SIZE(feature_properties); ++i, ++fp) {\n\t\tprop = of_get_flat_dt_prop(node, fp->name, NULL);\n\t\tif (prop && be32_to_cpup(prop) >= fp->min_value) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_feature;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftr;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct feature_property {\n\tconst char *name;\n\tu32 min_value;\n\tunsigned long cpu_feature;\n\tunsigned long cpu_user_ftr;\n} feature_properties[] __initdata = {\n#ifdef CONFIG_ALTIVEC\n\t{\"altivec\", 0, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n\t{\"ibm,vmx\", 1, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\t/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */\n\t{\"ibm,vmx\", 2, CPU_FTR_VSX, PPC_FEATURE_HAS_VSX},\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_PPC64\n\t{\"ibm,dfp\", 1, 0, PPC_FEATURE_HAS_DFP},\n\t{\"ibm,purr\", 1, CPU_FTR_PURR, 0},\n\t{\"ibm,spurr\", 1, CPU_FTR_SPURR, 0},\n#endif /* CONFIG_PPC64 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "prop"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "fp->name",
            "NULL"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "feature_properties"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct feature_property {\n\tconst char *name;\n\tu32 min_value;\n\tunsigned long cpu_feature;\n\tunsigned long cpu_user_ftr;\n} feature_properties[] __initdata = {\n#ifdef CONFIG_ALTIVEC\n\t{\"altivec\", 0, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n\t{\"ibm,vmx\", 1, CPU_FTR_ALTIVEC, PPC_FEATURE_HAS_ALTIVEC},\n#endif /* CONFIG_ALTIVEC */\n#ifdef CONFIG_VSX\n\t/* Yes, this _really_ is ibm,vmx == 2 to enable VSX */\n\t{\"ibm,vmx\", 2, CPU_FTR_VSX, PPC_FEATURE_HAS_VSX},\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_PPC64\n\t{\"ibm,dfp\", 1, 0, PPC_FEATURE_HAS_DFP},\n\t{\"ibm,purr\", 1, CPU_FTR_PURR, 0},\n\t{\"ibm,spurr\", 1, CPU_FTR_SPURR, 0},\n#endif /* CONFIG_PPC64 */\n};\n\nstatic void __init check_cpu_feature_properties(unsigned long node)\n{\n\tunsigned long i;\n\tstruct feature_property *fp = feature_properties;\n\tconst __be32 *prop;\n\n\tfor (i = 0; i < ARRAY_SIZE(feature_properties); ++i, ++fp) {\n\t\tprop = of_get_flat_dt_prop(node, fp->name, NULL);\n\t\tif (prop && be32_to_cpup(prop) >= fp->min_value) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_feature;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftr;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "identical_pvr_fixup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "257-274",
    "snippet": "static inline void identical_pvr_fixup(unsigned long node)\n{\n\tunsigned int pvr;\n\tconst char *model = of_get_flat_dt_prop(node, \"model\", NULL);\n\n\t/*\n\t * Since 440GR(x)/440EP(x) processors have the same pvr,\n\t * we check the node path and set bit 28 in the cur_cpu_spec\n\t * pvr for EP(x) processor version. This bit is always 0 in\n\t * the \"real\" pvr. Then we call identify_cpu again with\n\t * the new logical pvr to enable FPU support.\n\t */\n\tif (model && strstr(model, \"440EP\")) {\n\t\tpvr = cur_cpu_spec->pvr_value | 0x8;\n\t\tidentify_cpu(0, pvr);\n\t\tDBG(\"Using logical pvr %x for %s\\n\", pvr, model);\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Using logical pvr %x for %s\\n\"",
            "pvr",
            "model"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "identify_cpu",
          "args": [
            "0",
            "pvr"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "identify_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/cputable.c",
          "lines": "2182-2197",
          "snippet": "struct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/setup.h>",
            "#include <asm/mmu.h>",
            "#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */",
            "#include <asm/cputable.h>",
            "#include <asm/oprofile_impl.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>",
            "#include <linux/threads.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/setup.h>\n#include <asm/mmu.h>\n#include <asm/prom.h>\t\t/* for PTRRELOC on ARCH=ppc */\n#include <asm/cputable.h>\n#include <asm/oprofile_impl.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/threads.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n\nstruct cpu_spec * __init identify_cpu(unsigned long offset, unsigned int pvr)\n{\n\tstruct cpu_spec *s = cpu_specs;\n\tint i;\n\n\ts = PTRRELOC(s);\n\n\tfor (i = 0; i < ARRAY_SIZE(cpu_specs); i++,s++) {\n\t\tif ((pvr & s->pvr_mask) == s->pvr_value)\n\t\t\treturn setup_cpu_spec(offset, s);\n\t}\n\n\tBUG();\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "model",
            "\"440EP\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"model\"",
            "NULL"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic struct ibm_pa_feature {\n\tunsigned long\tcpu_features;\t/* CPU_FTR_xxx bit */\n\tunsigned long\tmmu_features;\t/* MMU_FTR_xxx bit */\n\tunsigned int\tcpu_user_ftrs;\t/* PPC_FEATURE_xxx bit */\n\tunsigned char\tpabyte;\t\t/* byte number in ibm,pa-features */\n\tunsigned char\tpabit;\t\t/* bit number (big-endian) */\n\tunsigned char\tinvert;\t\t/* if 1, pa bit set => clear feature */\n} ibm_pa_features[] __initdata = {\n\t{0, 0, PPC_FEATURE_HAS_MMU,\t0, 0, 0},\n\t{0, 0, PPC_FEATURE_HAS_FPU,\t0, 1, 0},\n\t{CPU_FTR_CTRL, 0, 0,\t\t0, 3, 0},\n\t{CPU_FTR_NOEXECUTE, 0, 0,\t0, 6, 0},\n\t{CPU_FTR_NODSISRALIGN, 0, 0,\t1, 1, 1},\n\t{0, MMU_FTR_CI_LARGE_PAGE, 0,\t1, 2, 0},\n\t{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},\n\t/*\n\t * If the kernel doesn't support TM (ie. CONFIG_PPC_TRANSACTIONAL_MEM=n),\n\t * we don't want to turn on CPU_FTR_TM here, so we use CPU_FTR_TM_COMP\n\t * which is 0 if the kernel doesn't support TM.\n\t */\n\t{CPU_FTR_TM_COMP, 0, 0,\t\t22, 0, 0},\n};\n\nstatic inline void identical_pvr_fixup(unsigned long node)\n{\n\tunsigned int pvr;\n\tconst char *model = of_get_flat_dt_prop(node, \"model\", NULL);\n\n\t/*\n\t * Since 440GR(x)/440EP(x) processors have the same pvr,\n\t * we check the node path and set bit 28 in the cur_cpu_spec\n\t * pvr for EP(x) processor version. This bit is always 0 in\n\t * the \"real\" pvr. Then we call identify_cpu again with\n\t * the new logical pvr to enable FPU support.\n\t */\n\tif (model && strstr(model, \"440EP\")) {\n\t\tpvr = cur_cpu_spec->pvr_value | 0x8;\n\t\tidentify_cpu(0, pvr);\n\t\tDBG(\"Using logical pvr %x for %s\\n\", pvr, model);\n\t}\n}"
  },
  {
    "function_name": "init_mmu_slb_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "221-230",
    "snippet": "static void __init init_mmu_slb_size(unsigned long node)\n{\n\tconst __be32 *slb_size_ptr;\n\n\tslb_size_ptr = of_get_flat_dt_prop(node, \"slb-size\", NULL) ? :\n\t\t\tof_get_flat_dt_prop(node, \"ibm,slb-size\", NULL);\n\n\tif (slb_size_ptr)\n\t\tmmu_slb_size = be32_to_cpup(slb_size_ptr);\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "slb_size_ptr"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,slb-size\"",
            "NULL"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"slb-size\"",
            "NULL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init init_mmu_slb_size(unsigned long node)\n{\n\tconst __be32 *slb_size_ptr;\n\n\tslb_size_ptr = of_get_flat_dt_prop(node, \"slb-size\", NULL) ? :\n\t\t\tof_get_flat_dt_prop(node, \"ibm,slb-size\", NULL);\n\n\tif (slb_size_ptr)\n\t\tmmu_slb_size = be32_to_cpup(slb_size_ptr);\n}"
  },
  {
    "function_name": "check_cpu_pa_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "207-218",
    "snippet": "static void __init check_cpu_pa_features(unsigned long node)\n{\n\tconst unsigned char *pa_ftrs;\n\tint tablelen;\n\n\tpa_ftrs = of_get_flat_dt_prop(node, \"ibm,pa-features\", &tablelen);\n\tif (pa_ftrs == NULL)\n\t\treturn;\n\n\tscan_features(node, pa_ftrs, tablelen,\n\t\t      ibm_pa_features, ARRAY_SIZE(ibm_pa_features));\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scan_features",
          "args": [
            "node",
            "pa_ftrs",
            "tablelen",
            "ibm_pa_features",
            "ARRAY_SIZE(ibm_pa_features)"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "scan_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "170-205",
          "snippet": "static void __init scan_features(unsigned long node, const unsigned char *ftrs,\n\t\t\t\t unsigned long tablelen,\n\t\t\t\t struct ibm_pa_feature *fp,\n\t\t\t\t unsigned long ft_size)\n{\n\tunsigned long i, len, bit;\n\n\t/* find descriptor with type == 0 */\n\tfor (;;) {\n\t\tif (tablelen < 3)\n\t\t\treturn;\n\t\tlen = 2 + ftrs[0];\n\t\tif (tablelen < len)\n\t\t\treturn;\t\t/* descriptor 0 not found */\n\t\tif (ftrs[1] == 0)\n\t\t\tbreak;\n\t\ttablelen -= len;\n\t\tftrs += len;\n\t}\n\n\t/* loop over bits we know about */\n\tfor (i = 0; i < ft_size; ++i, ++fp) {\n\t\tif (fp->pabyte >= ftrs[0])\n\t\t\tcontinue;\n\t\tbit = (ftrs[2 + fp->pabyte] >> (7 - fp->pabit)) & 1;\n\t\tif (bit ^ fp->invert) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->mmu_features |= fp->mmu_features;\n\t\t} else {\n\t\t\tcur_cpu_spec->cpu_features &= ~fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features &= ~fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->mmu_features &= ~fp->mmu_features;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init scan_features(unsigned long node, const unsigned char *ftrs,\n\t\t\t\t unsigned long tablelen,\n\t\t\t\t struct ibm_pa_feature *fp,\n\t\t\t\t unsigned long ft_size)\n{\n\tunsigned long i, len, bit;\n\n\t/* find descriptor with type == 0 */\n\tfor (;;) {\n\t\tif (tablelen < 3)\n\t\t\treturn;\n\t\tlen = 2 + ftrs[0];\n\t\tif (tablelen < len)\n\t\t\treturn;\t\t/* descriptor 0 not found */\n\t\tif (ftrs[1] == 0)\n\t\t\tbreak;\n\t\ttablelen -= len;\n\t\tftrs += len;\n\t}\n\n\t/* loop over bits we know about */\n\tfor (i = 0; i < ft_size; ++i, ++fp) {\n\t\tif (fp->pabyte >= ftrs[0])\n\t\t\tcontinue;\n\t\tbit = (ftrs[2 + fp->pabyte] >> (7 - fp->pabit)) & 1;\n\t\tif (bit ^ fp->invert) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->mmu_features |= fp->mmu_features;\n\t\t} else {\n\t\t\tcur_cpu_spec->cpu_features &= ~fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features &= ~fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->mmu_features &= ~fp->mmu_features;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "ibm_pa_features"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_get_flat_dt_prop",
          "args": [
            "node",
            "\"ibm,pa-features\"",
            "&tablelen"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init check_cpu_pa_features(unsigned long node)\n{\n\tconst unsigned char *pa_ftrs;\n\tint tablelen;\n\n\tpa_ftrs = of_get_flat_dt_prop(node, \"ibm,pa-features\", &tablelen);\n\tif (pa_ftrs == NULL)\n\t\treturn;\n\n\tscan_features(node, pa_ftrs, tablelen,\n\t\t      ibm_pa_features, ARRAY_SIZE(ibm_pa_features));\n}"
  },
  {
    "function_name": "scan_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "170-205",
    "snippet": "static void __init scan_features(unsigned long node, const unsigned char *ftrs,\n\t\t\t\t unsigned long tablelen,\n\t\t\t\t struct ibm_pa_feature *fp,\n\t\t\t\t unsigned long ft_size)\n{\n\tunsigned long i, len, bit;\n\n\t/* find descriptor with type == 0 */\n\tfor (;;) {\n\t\tif (tablelen < 3)\n\t\t\treturn;\n\t\tlen = 2 + ftrs[0];\n\t\tif (tablelen < len)\n\t\t\treturn;\t\t/* descriptor 0 not found */\n\t\tif (ftrs[1] == 0)\n\t\t\tbreak;\n\t\ttablelen -= len;\n\t\tftrs += len;\n\t}\n\n\t/* loop over bits we know about */\n\tfor (i = 0; i < ft_size; ++i, ++fp) {\n\t\tif (fp->pabyte >= ftrs[0])\n\t\t\tcontinue;\n\t\tbit = (ftrs[2 + fp->pabyte] >> (7 - fp->pabit)) & 1;\n\t\tif (bit ^ fp->invert) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->mmu_features |= fp->mmu_features;\n\t\t} else {\n\t\t\tcur_cpu_spec->cpu_features &= ~fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features &= ~fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->mmu_features &= ~fp->mmu_features;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init scan_features(unsigned long node, const unsigned char *ftrs,\n\t\t\t\t unsigned long tablelen,\n\t\t\t\t struct ibm_pa_feature *fp,\n\t\t\t\t unsigned long ft_size)\n{\n\tunsigned long i, len, bit;\n\n\t/* find descriptor with type == 0 */\n\tfor (;;) {\n\t\tif (tablelen < 3)\n\t\t\treturn;\n\t\tlen = 2 + ftrs[0];\n\t\tif (tablelen < len)\n\t\t\treturn;\t\t/* descriptor 0 not found */\n\t\tif (ftrs[1] == 0)\n\t\t\tbreak;\n\t\ttablelen -= len;\n\t\tftrs += len;\n\t}\n\n\t/* loop over bits we know about */\n\tfor (i = 0; i < ft_size; ++i, ++fp) {\n\t\tif (fp->pabyte >= ftrs[0])\n\t\t\tcontinue;\n\t\tbit = (ftrs[2 + fp->pabyte] >> (7 - fp->pabit)) & 1;\n\t\tif (bit ^ fp->invert) {\n\t\t\tcur_cpu_spec->cpu_features |= fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features |= fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->mmu_features |= fp->mmu_features;\n\t\t} else {\n\t\t\tcur_cpu_spec->cpu_features &= ~fp->cpu_features;\n\t\t\tcur_cpu_spec->cpu_user_features &= ~fp->cpu_user_ftrs;\n\t\t\tcur_cpu_spec->mmu_features &= ~fp->mmu_features;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "move_device_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "112-132",
    "snippet": "static void __init move_device_tree(void)\n{\n\tunsigned long start, size;\n\tvoid *p;\n\n\tDBG(\"-> move_device_tree\\n\");\n\n\tstart = __pa(initial_boot_params);\n\tsize = fdt_totalsize(initial_boot_params);\n\n\tif ((memory_limit && (start + size) > PHYSICAL_START + memory_limit) ||\n\t\t\toverlaps_crashkernel(start, size) ||\n\t\t\toverlaps_initrd(start, size)) {\n\t\tp = __va(memblock_alloc(size, PAGE_SIZE));\n\t\tmemcpy(p, initial_boot_params, size);\n\t\tinitial_boot_params = p;\n\t\tDBG(\"Moved device tree to 0x%p\\n\", p);\n\t}\n\n\tDBG(\"<- move_device_tree\\n\");\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"<- move_device_tree\\n\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"Moved device tree to 0x%p\\n\"",
            "p"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "initial_boot_params",
            "size"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "memblock_alloc(size, PAGE_SIZE)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memblock_alloc",
          "args": [
            "size",
            "PAGE_SIZE"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "overlaps_initrd",
          "args": [
            "start",
            "size"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "overlaps_initrd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
          "lines": "92-103",
          "snippet": "static inline int overlaps_initrd(unsigned long start, unsigned long size)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (!initrd_start)\n\t\treturn 0;\n\n\treturn\t(start + size) > _ALIGN_DOWN(initrd_start, PAGE_SIZE) &&\n\t\t\tstart <= _ALIGN_UP(initrd_end, PAGE_SIZE);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <mm/mmu_decl.h>",
            "#include <asm/debug.h>",
            "#include <asm/fadump.h>",
            "#include <asm/opal.h>",
            "#include <asm/kexec.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/paca.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/kdump.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/libfdt.h>",
            "#include <linux/of_fdt.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/irq.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic inline int overlaps_initrd(unsigned long start, unsigned long size)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (!initrd_start)\n\t\treturn 0;\n\n\treturn\t(start + size) > _ALIGN_DOWN(initrd_start, PAGE_SIZE) &&\n\t\t\tstart <= _ALIGN_UP(initrd_end, PAGE_SIZE);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "overlaps_crashkernel",
          "args": [
            "start",
            "size"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "overlaps_crashkernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/machine_kexec.c",
          "lines": "192-195",
          "snippet": "int overlaps_crashkernel(unsigned long start, unsigned long size)\n{\n\treturn (start + size) > crashk_res.start && start <= crashk_res.end;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <asm/prom.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/machdep.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/irq.h>",
            "#include <linux/of.h>",
            "#include <linux/memblock.h>",
            "#include <linux/threads.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kexec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <asm/prom.h>\n#include <asm/pgalloc.h>\n#include <asm/machdep.h>\n#include <linux/ftrace.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/threads.h>\n#include <linux/reboot.h>\n#include <linux/kexec.h>\n\nint overlaps_crashkernel(unsigned long start, unsigned long size)\n{\n\treturn (start + size) > crashk_res.start && start <= crashk_res.end;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdt_totalsize",
          "args": [
            "initial_boot_params"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "initial_boot_params"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "__parse_fpscr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/traps.c",
          "lines": "829-854",
          "snippet": "static inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}",
          "includes": [
            "#include <sysdev/fsl_pci.h>",
            "#include <asm/debug.h>",
            "#include <asm/tm.h>",
            "#include <asm/switch_to.h>",
            "#include <asm/fadump.h>",
            "#include <asm/rio.h>",
            "#include <asm/ppc-opcode.h>",
            "#include <asm/kexec.h>",
            "#include <asm/tm.h>",
            "#include <asm/processor.h>",
            "#include <asm/firmware.h>",
            "#include <asm/backlight.h>",
            "#include <asm/reg.h>",
            "#include <asm/pmc.h>",
            "#include <asm/rtas.h>",
            "#include <asm/machdep.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/emulated_ops.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/bug.h>",
            "#include <linux/backlight.h>",
            "#include <linux/kexec.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/delay.h>",
            "#include <linux/prctl.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/user.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/unistd.h>",
            "#include <linux/stddef.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sysdev/fsl_pci.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/fadump.h>\n#include <asm/rio.h>\n#include <asm/ppc-opcode.h>\n#include <asm/kexec.h>\n#include <asm/tm.h>\n#include <asm/processor.h>\n#include <asm/firmware.h>\n#include <asm/backlight.h>\n#include <asm/reg.h>\n#include <asm/pmc.h>\n#include <asm/rtas.h>\n#include <asm/machdep.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <asm/pgtable.h>\n#include <asm/emulated_ops.h>\n#include <linux/context_tracking.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/kdebug.h>\n#include <linux/bug.h>\n#include <linux/backlight.h>\n#include <linux/kexec.h>\n#include <linux/kprobes.h>\n#include <linux/delay.h>\n#include <linux/prctl.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/user.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic inline int __parse_fpscr(unsigned long fpscr)\n{\n\tint ret = 0;\n\n\t/* Invalid operation */\n\tif ((fpscr & FPSCR_VE) && (fpscr & FPSCR_VX))\n\t\tret = FPE_FLTINV;\n\n\t/* Overflow */\n\telse if ((fpscr & FPSCR_OE) && (fpscr & FPSCR_OX))\n\t\tret = FPE_FLTOVF;\n\n\t/* Underflow */\n\telse if ((fpscr & FPSCR_UE) && (fpscr & FPSCR_UX))\n\t\tret = FPE_FLTUND;\n\n\t/* Divide by zero */\n\telse if ((fpscr & FPSCR_ZE) && (fpscr & FPSCR_ZX))\n\t\tret = FPE_FLTDIV;\n\n\t/* Inexact result */\n\telse if ((fpscr & FPSCR_XE) && (fpscr & FPSCR_XX))\n\t\tret = FPE_FLTRES;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"-> move_device_tree\\n\""
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic void __init move_device_tree(void)\n{\n\tunsigned long start, size;\n\tvoid *p;\n\n\tDBG(\"-> move_device_tree\\n\");\n\n\tstart = __pa(initial_boot_params);\n\tsize = fdt_totalsize(initial_boot_params);\n\n\tif ((memory_limit && (start + size) > PHYSICAL_START + memory_limit) ||\n\t\t\toverlaps_crashkernel(start, size) ||\n\t\t\toverlaps_initrd(start, size)) {\n\t\tp = __va(memblock_alloc(size, PAGE_SIZE));\n\t\tmemcpy(p, initial_boot_params, size);\n\t\tinitial_boot_params = p;\n\t\tDBG(\"Moved device tree to 0x%p\\n\", p);\n\t}\n\n\tDBG(\"<- move_device_tree\\n\");\n}"
  },
  {
    "function_name": "overlaps_initrd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "92-103",
    "snippet": "static inline int overlaps_initrd(unsigned long start, unsigned long size)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (!initrd_start)\n\t\treturn 0;\n\n\treturn\t(start + size) > _ALIGN_DOWN(initrd_start, PAGE_SIZE) &&\n\t\t\tstart <= _ALIGN_UP(initrd_end, PAGE_SIZE);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ALIGN_UP",
          "args": [
            "initrd_end",
            "PAGE_SIZE"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ALIGN_DOWN",
          "args": [
            "initrd_start",
            "PAGE_SIZE"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic inline int overlaps_initrd(unsigned long start, unsigned long size)\n{\n#ifdef CONFIG_BLK_DEV_INITRD\n\tif (!initrd_start)\n\t\treturn 0;\n\n\treturn\t(start + size) > _ALIGN_DOWN(initrd_start, PAGE_SIZE) &&\n\t\t\tstart <= _ALIGN_UP(initrd_end, PAGE_SIZE);\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "early_parse_mem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom.c",
    "lines": "76-85",
    "snippet": "static int __init early_parse_mem(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\n\tmemory_limit = PAGE_ALIGN(memparse(p, &p));\n\tDBG(\"memory limit = 0x%llx\\n\", memory_limit);\n\n\treturn 0;\n}",
    "includes": [
      "#include <mm/mmu_decl.h>",
      "#include <asm/debug.h>",
      "#include <asm/fadump.h>",
      "#include <asm/opal.h>",
      "#include <asm/kexec.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/machdep.h>",
      "#include <asm/sections.h>",
      "#include <asm/btext.h>",
      "#include <asm/iommu.h>",
      "#include <asm/pgtable.h>",
      "#include <asm/paca.h>",
      "#include <asm/mmu.h>",
      "#include <asm/smp.h>",
      "#include <asm/kdump.h>",
      "#include <asm/io.h>",
      "#include <asm/irq.h>",
      "#include <asm/processor.h>",
      "#include <asm/page.h>",
      "#include <asm/rtas.h>",
      "#include <asm/prom.h>",
      "#include <linux/libfdt.h>",
      "#include <linux/of_fdt.h>",
      "#include <linux/of.h>",
      "#include <linux/memblock.h>",
      "#include <linux/irq.h>",
      "#include <linux/kexec.h>",
      "#include <linux/export.h>",
      "#include <linux/bitops.h>",
      "#include <linux/initrd.h>",
      "#include <linux/delay.h>",
      "#include <linux/stringify.h>",
      "#include <linux/pci.h>",
      "#include <linux/types.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/threads.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/kernel.h>",
      "#include <stdarg.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DBG",
          "args": [
            "\"memory limit = 0x%llx\\n\"",
            "memory_limit"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "memparse(p, &p)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "p",
            "&p"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "prom_memparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/prom_init.c",
          "lines": "556-581",
          "snippet": "static unsigned long prom_memparse(const char *ptr, const char **retptr)\n{\n\tunsigned long ret = prom_strtoul(ptr, retptr);\n\tint shift = 0;\n\n\t/*\n\t * We can't use a switch here because GCC *may* generate a\n\t * jump table which won't work, because we're not running at\n\t * the address we're linked at.\n\t */\n\tif ('G' == **retptr || 'g' == **retptr)\n\t\tshift = 30;\n\n\tif ('M' == **retptr || 'm' == **retptr)\n\t\tshift = 20;\n\n\tif ('K' == **retptr || 'k' == **retptr)\n\t\tshift = 10;\n\n\tif (shift) {\n\t\tret <<= shift;\n\t\t(*retptr)++;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/linux_logo.h>",
            "#include <asm/opal.h>",
            "#include <asm/machdep.h>",
            "#include <asm/sections.h>",
            "#include <asm/btext.h>",
            "#include <asm/iommu.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu.h>",
            "#include <asm/smp.h>",
            "#include <asm/io.h>",
            "#include <asm/irq.h>",
            "#include <asm/processor.h>",
            "#include <asm/page.h>",
            "#include <asm/rtas.h>",
            "#include <asm/prom.h>",
            "#include <linux/bitops.h>",
            "#include <linux/initrd.h>",
            "#include <linux/delay.h>",
            "#include <linux/stringify.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pci.h>",
            "#include <linux/types.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/threads.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/linux_logo.h>\n#include <asm/opal.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/proc_fs.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic unsigned long prom_memparse(const char *ptr, const char **retptr)\n{\n\tunsigned long ret = prom_strtoul(ptr, retptr);\n\tint shift = 0;\n\n\t/*\n\t * We can't use a switch here because GCC *may* generate a\n\t * jump table which won't work, because we're not running at\n\t * the address we're linked at.\n\t */\n\tif ('G' == **retptr || 'g' == **retptr)\n\t\tshift = 30;\n\n\tif ('M' == **retptr || 'm' == **retptr)\n\t\tshift = 20;\n\n\tif ('K' == **retptr || 'k' == **retptr)\n\t\tshift = 10;\n\n\tif (shift) {\n\t\tret <<= shift;\n\t\t(*retptr)++;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <mm/mmu_decl.h>\n#include <asm/debug.h>\n#include <asm/fadump.h>\n#include <asm/opal.h>\n#include <asm/kexec.h>\n#include <asm/pci-bridge.h>\n#include <asm/machdep.h>\n#include <asm/sections.h>\n#include <asm/btext.h>\n#include <asm/iommu.h>\n#include <asm/pgtable.h>\n#include <asm/paca.h>\n#include <asm/mmu.h>\n#include <asm/smp.h>\n#include <asm/kdump.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/processor.h>\n#include <asm/page.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/libfdt.h>\n#include <linux/of_fdt.h>\n#include <linux/of.h>\n#include <linux/memblock.h>\n#include <linux/irq.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/initrd.h>\n#include <linux/delay.h>\n#include <linux/stringify.h>\n#include <linux/pci.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/threads.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nstatic int __init early_parse_mem(char *p)\n{\n\tif (!p)\n\t\treturn 1;\n\n\tmemory_limit = PAGE_ALIGN(memparse(p, &p));\n\tDBG(\"memory limit = 0x%llx\\n\", memory_limit);\n\n\treturn 0;\n}"
  }
]