[
  {
    "function_name": "power4_enable_pmcs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pmc.c",
    "lines": "82-101",
    "snippet": "void power4_enable_pmcs(void)\n{\n\tunsigned long hid0;\n\n\thid0 = mfspr(SPRN_HID0);\n\thid0 |= 1UL << (63 - 20);\n\n\t/* POWER4 requires the following sequence */\n\tasm volatile(\n\t\t\"sync\\n\"\n\t\t\"mtspr     %1, %0\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"isync\" : \"=&r\" (hid0) : \"i\" (SPRN_HID0), \"0\" (hid0):\n\t\t\"memory\");\n}",
    "includes": [
      "#include <asm/pmc.h>",
      "#include <asm/cputable.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bug.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_HID0"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pmc.h>\n#include <asm/cputable.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/bug.h>\n#include <linux/errno.h>\n\nvoid power4_enable_pmcs(void)\n{\n\tunsigned long hid0;\n\n\thid0 = mfspr(SPRN_HID0);\n\thid0 |= 1UL << (63 - 20);\n\n\t/* POWER4 requires the following sequence */\n\tasm volatile(\n\t\t\"sync\\n\"\n\t\t\"mtspr     %1, %0\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"mfspr     %0, %1\\n\"\n\t\t\"isync\" : \"=&r\" (hid0) : \"i\" (SPRN_HID0), \"0\" (hid0):\n\t\t\"memory\");\n}"
  },
  {
    "function_name": "release_pmc_hardware",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pmc.c",
    "lines": "68-78",
    "snippet": "void release_pmc_hardware(void)\n{\n\traw_spin_lock(&pmc_owner_lock);\n\n\tWARN_ON(! pmc_owner_caller);\n\n\tpmc_owner_caller = NULL;\n\tperf_irq = dummy_perf;\n\n\traw_spin_unlock(&pmc_owner_lock);\n}",
    "includes": [
      "#include <asm/pmc.h>",
      "#include <asm/cputable.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bug.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(pmc_owner_lock);",
      "static void *pmc_owner_caller;",
      "perf_irq_t perf_irq = dummy_perf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&pmc_owner_lock"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "! pmc_owner_caller"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&pmc_owner_lock"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pmc.h>\n#include <asm/cputable.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/bug.h>\n#include <linux/errno.h>\n\nstatic DEFINE_RAW_SPINLOCK(pmc_owner_lock);\nstatic void *pmc_owner_caller;\nperf_irq_t perf_irq = dummy_perf;\n\nvoid release_pmc_hardware(void)\n{\n\traw_spin_lock(&pmc_owner_lock);\n\n\tWARN_ON(! pmc_owner_caller);\n\n\tpmc_owner_caller = NULL;\n\tperf_irq = dummy_perf;\n\n\traw_spin_unlock(&pmc_owner_lock);\n}"
  },
  {
    "function_name": "reserve_pmc_hardware",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pmc.c",
    "lines": "45-65",
    "snippet": "int reserve_pmc_hardware(perf_irq_t new_perf_irq)\n{\n\tint err = 0;\n\n\traw_spin_lock(&pmc_owner_lock);\n\n\tif (pmc_owner_caller) {\n\t\tprintk(KERN_WARNING \"reserve_pmc_hardware: \"\n\t\t       \"PMC hardware busy (reserved by caller %p)\\n\",\n\t\t       pmc_owner_caller);\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpmc_owner_caller = __builtin_return_address(0);\n\tperf_irq = new_perf_irq ? new_perf_irq : dummy_perf;\n\n out:\n\traw_spin_unlock(&pmc_owner_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/pmc.h>",
      "#include <asm/cputable.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bug.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RAW_SPINLOCK(pmc_owner_lock);",
      "static void *pmc_owner_caller;",
      "perf_irq_t perf_irq = dummy_perf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&pmc_owner_lock"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"reserve_pmc_hardware: \"\n\t\t       \"PMC hardware busy (reserved by caller %p)\\n\"",
            "pmc_owner_caller"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&pmc_owner_lock"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pmc.h>\n#include <asm/cputable.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/bug.h>\n#include <linux/errno.h>\n\nstatic DEFINE_RAW_SPINLOCK(pmc_owner_lock);\nstatic void *pmc_owner_caller;\nperf_irq_t perf_irq = dummy_perf;\n\nint reserve_pmc_hardware(perf_irq_t new_perf_irq)\n{\n\tint err = 0;\n\n\traw_spin_lock(&pmc_owner_lock);\n\n\tif (pmc_owner_caller) {\n\t\tprintk(KERN_WARNING \"reserve_pmc_hardware: \"\n\t\t       \"PMC hardware busy (reserved by caller %p)\\n\",\n\t\t       pmc_owner_caller);\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tpmc_owner_caller = __builtin_return_address(0);\n\tperf_irq = new_perf_irq ? new_perf_irq : dummy_perf;\n\n out:\n\traw_spin_unlock(&pmc_owner_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "dummy_perf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pmc.c",
    "lines": "28-38",
    "snippet": "static void dummy_perf(struct pt_regs *regs)\n{\n#if defined(CONFIG_FSL_EMB_PERFMON)\n\tmtpmr(PMRN_PMGC0, mfpmr(PMRN_PMGC0) & ~PMGC0_PMIE);\n#elif defined(CONFIG_PPC64) || defined(CONFIG_6xx)\n\tif (cur_cpu_spec->pmc_type == PPC_PMC_IBM)\n\t\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~(MMCR0_PMXE|MMCR0_PMAO));\n#else\n\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~MMCR0_PMXE);\n#endif\n}",
    "includes": [
      "#include <asm/pmc.h>",
      "#include <asm/cputable.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/bug.h>",
      "#include <linux/errno.h>"
    ],
    "macros_used": [
      "#define MMCR0_PMAO\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_MMCR0",
            "mfspr(SPRN_MMCR0) & ~MMCR0_PMXE"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MMCR0"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtspr",
          "args": [
            "SPRN_MMCR0",
            "mfspr(SPRN_MMCR0) & ~(MMCR0_PMXE|MMCR0_PMAO)"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfspr",
          "args": [
            "SPRN_MMCR0"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtpmr",
          "args": [
            "PMRN_PMGC0",
            "mfpmr(PMRN_PMGC0) & ~PMGC0_PMIE"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mfpmr",
          "args": [
            "PMRN_PMGC0"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/pmc.h>\n#include <asm/cputable.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/bug.h>\n#include <linux/errno.h>\n\n#define MMCR0_PMAO\t0\n\nstatic void dummy_perf(struct pt_regs *regs)\n{\n#if defined(CONFIG_FSL_EMB_PERFMON)\n\tmtpmr(PMRN_PMGC0, mfpmr(PMRN_PMGC0) & ~PMGC0_PMIE);\n#elif defined(CONFIG_PPC64) || defined(CONFIG_6xx)\n\tif (cur_cpu_spec->pmc_type == PPC_PMC_IBM)\n\t\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~(MMCR0_PMXE|MMCR0_PMAO));\n#else\n\tmtspr(SPRN_MMCR0, mfspr(SPRN_MMCR0) & ~MMCR0_PMXE);\n#endif\n}"
  }
]