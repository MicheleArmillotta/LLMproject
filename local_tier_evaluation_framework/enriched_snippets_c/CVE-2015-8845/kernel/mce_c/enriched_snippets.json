[
  {
    "function_name": "get_mce_fault_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
    "lines": "327-351",
    "snippet": "uint64_t get_mce_fault_addr(struct machine_check_event *evt)\n{\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\treturn evt->u.ue_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\treturn evt->u.slb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\treturn evt->u.erat_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\treturn evt->u.tlb_error.effective_address;\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/mce.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nuint64_t get_mce_fault_addr(struct machine_check_event *evt)\n{\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\treturn evt->u.ue_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\treturn evt->u.slb_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\treturn evt->u.erat_error.effective_address;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\treturn evt->u.tlb_error.effective_address;\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "machine_check_print_event_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
    "lines": "219-325",
    "snippet": "void machine_check_print_event_info(struct machine_check_event *evt)\n{\n\tconst char *level, *sevstr, *subtype;\n\tstatic const char *mc_ue_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch\",\n\t\t\"Page table walk ifetch\",\n\t\t\"Load/Store\",\n\t\t\"Page table walk Load/Store\",\n\t};\n\tstatic const char *mc_slb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_erat_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_tlb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\n\t/* Print things out */\n\tif (evt->version != MCE_V1) {\n\t\tpr_err(\"Machine Check Exception, Unknown event version %d !\\n\",\n\t\t       evt->version);\n\t\treturn;\n\t}\n\tswitch (evt->severity) {\n\tcase MCE_SEV_NO_ERROR:\n\t\tlevel = KERN_INFO;\n\t\tsevstr = \"Harmless\";\n\t\tbreak;\n\tcase MCE_SEV_WARNING:\n\t\tlevel = KERN_WARNING;\n\t\tsevstr = \"\";\n\t\tbreak;\n\tcase MCE_SEV_ERROR_SYNC:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Severe\";\n\t\tbreak;\n\tcase MCE_SEV_FATAL:\n\tdefault:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Fatal\";\n\t\tbreak;\n\t}\n\n\tprintk(\"%s%s Machine check interrupt [%s]\\n\", level, sevstr,\n\t       evt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t       \"Recovered\" : \"[Not recovered\");\n\tprintk(\"%s  Initiator: %s\\n\", level,\n\t       evt->initiator == MCE_INITIATOR_CPU ? \"CPU\" : \"Unknown\");\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tsubtype = evt->u.ue_error.ue_error_type <\n\t\t\tARRAY_SIZE(mc_ue_types) ?\n\t\t\tmc_ue_types[evt->u.ue_error.ue_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: UE [%s]\\n\", level, subtype);\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.ue_error.effective_address);\n\t\tif (evt->u.ue_error.physical_address_provided)\n\t\t\tprintk(\"%s      Physial address: %016llx\\n\",\n\t\t\t       level, evt->u.ue_error.physical_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tsubtype = evt->u.slb_error.slb_error_type <\n\t\t\tARRAY_SIZE(mc_slb_types) ?\n\t\t\tmc_slb_types[evt->u.slb_error.slb_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: SLB [%s]\\n\", level, subtype);\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.slb_error.effective_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tsubtype = evt->u.erat_error.erat_error_type <\n\t\t\tARRAY_SIZE(mc_erat_types) ?\n\t\t\tmc_erat_types[evt->u.erat_error.erat_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: ERAT [%s]\\n\", level, subtype);\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.erat_error.effective_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tsubtype = evt->u.tlb_error.tlb_error_type <\n\t\t\tARRAY_SIZE(mc_tlb_types) ?\n\t\t\tmc_tlb_types[evt->u.tlb_error.tlb_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: TLB [%s]\\n\", level, subtype);\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.tlb_error.effective_address);\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\tprintk(\"%s  Error type: Unknown\\n\", level);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/mce.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s  Error type: Unknown\\n\"",
            "level"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "printk_log_rtas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/rtasd.c",
          "lines": "111-156",
          "snippet": "static void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}",
          "includes": [
            "#include <asm/topology.h>",
            "#include <asm/machdep.h>",
            "#include <linux/atomic.h>",
            "#include <asm/nvram.h>",
            "#include <asm/prom.h>",
            "#include <asm/rtas.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/cpu.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int full_rtas_msgs = 0;",
            "static int error_log_cnt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/topology.h>\n#include <asm/machdep.h>\n#include <linux/atomic.h>\n#include <asm/nvram.h>\n#include <asm/prom.h>\n#include <asm/rtas.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/cpu.h>\n#include <linux/spinlock.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n\nstatic int full_rtas_msgs = 0;\nstatic int error_log_cnt;\n\nstatic void printk_log_rtas(char *buf, int len)\n{\n\n\tint i,j,n = 0;\n\tint perline = 16;\n\tchar buffer[64];\n\tchar * str = \"RTAS event\";\n\n\tif (full_rtas_msgs) {\n\t\tprintk(RTAS_DEBUG \"%d -------- %s begin --------\\n\",\n\t\t       error_log_cnt, str);\n\n\t\t/*\n\t\t * Print perline bytes on each line, each line will start\n\t\t * with RTAS and a changing number, so syslogd will\n\t\t * print lines that are otherwise the same.  Separate every\n\t\t * 4 bytes with a space.\n\t\t */\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tj = i % perline;\n\t\t\tif (j == 0) {\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tn = sprintf(buffer, \"RTAS %d:\", i/perline);\n\t\t\t}\n\n\t\t\tif ((i % 4) == 0)\n\t\t\t\tn += sprintf(buffer+n, \" \");\n\n\t\t\tn += sprintf(buffer+n, \"%02x\", (unsigned char)buf[i]);\n\n\t\t\tif (j == (perline-1))\n\t\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\t\t}\n\t\tif ((i % perline) != 0)\n\t\t\tprintk(KERN_DEBUG \"%s\\n\", buffer);\n\n\t\tprintk(RTAS_DEBUG \"%d -------- %s end ----------\\n\",\n\t\t       error_log_cnt, str);\n\t} else {\n\t\tstruct rtas_error_log *errlog = (struct rtas_error_log *)buf;\n\n\t\tprintk(RTAS_DEBUG \"event: %d, Type: %s, Severity: %d\\n\",\n\t\t       error_log_cnt, rtas_event_type(rtas_error_type(errlog)),\n\t\t       rtas_error_severity(errlog));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s    Effective address: %016llx\\n\"",
            "level",
            "evt->u.tlb_error.effective_address"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s  Error type: TLB [%s]\\n\"",
            "level",
            "subtype"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_tlb_types"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s    Effective address: %016llx\\n\"",
            "level",
            "evt->u.erat_error.effective_address"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s  Error type: ERAT [%s]\\n\"",
            "level",
            "subtype"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_erat_types"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s    Effective address: %016llx\\n\"",
            "level",
            "evt->u.slb_error.effective_address"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s  Error type: SLB [%s]\\n\"",
            "level",
            "subtype"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_slb_types"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s      Physial address: %016llx\\n\"",
            "level",
            "evt->u.ue_error.physical_address"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s    Effective address: %016llx\\n\"",
            "level",
            "evt->u.ue_error.effective_address"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s  Error type: UE [%s]\\n\"",
            "level",
            "subtype"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mc_ue_types"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s  Initiator: %s\\n\"",
            "level",
            "evt->initiator == MCE_INITIATOR_CPU ? \"CPU\" : \"Unknown\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s%s Machine check interrupt [%s]\\n\"",
            "level",
            "sevstr",
            "evt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t       \"Recovered\" : \"[Not recovered\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Machine Check Exception, Unknown event version %d !\\n\"",
            "evt->version"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nvoid machine_check_print_event_info(struct machine_check_event *evt)\n{\n\tconst char *level, *sevstr, *subtype;\n\tstatic const char *mc_ue_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch\",\n\t\t\"Page table walk ifetch\",\n\t\t\"Load/Store\",\n\t\t\"Page table walk Load/Store\",\n\t};\n\tstatic const char *mc_slb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_erat_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_tlb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\n\t/* Print things out */\n\tif (evt->version != MCE_V1) {\n\t\tpr_err(\"Machine Check Exception, Unknown event version %d !\\n\",\n\t\t       evt->version);\n\t\treturn;\n\t}\n\tswitch (evt->severity) {\n\tcase MCE_SEV_NO_ERROR:\n\t\tlevel = KERN_INFO;\n\t\tsevstr = \"Harmless\";\n\t\tbreak;\n\tcase MCE_SEV_WARNING:\n\t\tlevel = KERN_WARNING;\n\t\tsevstr = \"\";\n\t\tbreak;\n\tcase MCE_SEV_ERROR_SYNC:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Severe\";\n\t\tbreak;\n\tcase MCE_SEV_FATAL:\n\tdefault:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Fatal\";\n\t\tbreak;\n\t}\n\n\tprintk(\"%s%s Machine check interrupt [%s]\\n\", level, sevstr,\n\t       evt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t       \"Recovered\" : \"[Not recovered\");\n\tprintk(\"%s  Initiator: %s\\n\", level,\n\t       evt->initiator == MCE_INITIATOR_CPU ? \"CPU\" : \"Unknown\");\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tsubtype = evt->u.ue_error.ue_error_type <\n\t\t\tARRAY_SIZE(mc_ue_types) ?\n\t\t\tmc_ue_types[evt->u.ue_error.ue_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: UE [%s]\\n\", level, subtype);\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.ue_error.effective_address);\n\t\tif (evt->u.ue_error.physical_address_provided)\n\t\t\tprintk(\"%s      Physial address: %016llx\\n\",\n\t\t\t       level, evt->u.ue_error.physical_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tsubtype = evt->u.slb_error.slb_error_type <\n\t\t\tARRAY_SIZE(mc_slb_types) ?\n\t\t\tmc_slb_types[evt->u.slb_error.slb_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: SLB [%s]\\n\", level, subtype);\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.slb_error.effective_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tsubtype = evt->u.erat_error.erat_error_type <\n\t\t\tARRAY_SIZE(mc_erat_types) ?\n\t\t\tmc_erat_types[evt->u.erat_error.erat_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: ERAT [%s]\\n\", level, subtype);\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.erat_error.effective_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tsubtype = evt->u.tlb_error.tlb_error_type <\n\t\t\tARRAY_SIZE(mc_tlb_types) ?\n\t\t\tmc_tlb_types[evt->u.tlb_error.tlb_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: TLB [%s]\\n\", level, subtype);\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.tlb_error.effective_address);\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\tprintk(\"%s  Error type: Unknown\\n\", level);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "machine_check_process_queued_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
    "lines": "203-217",
    "snippet": "static void machine_check_process_queued_event(struct irq_work *work)\n{\n\tint index;\n\n\t/*\n\t * For now just print it to console.\n\t * TODO: log this error event to FSP or nvram.\n\t */\n\twhile (__this_cpu_read(mce_queue_count) > 0) {\n\t\tindex = __this_cpu_read(mce_queue_count) - 1;\n\t\tmachine_check_print_event_info(\n\t\t\t\tthis_cpu_ptr(&mce_event_queue[index]));\n\t\t__this_cpu_dec(mce_queue_count);\n\t}\n}",
    "includes": [
      "#include <asm/mce.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, mce_queue_count);",
      "static void machine_check_process_queued_event(struct irq_work *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_queue_count"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "machine_check_print_event_info",
          "args": [
            "this_cpu_ptr(&mce_event_queue[index])"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "machine_check_print_event_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
          "lines": "219-325",
          "snippet": "void machine_check_print_event_info(struct machine_check_event *evt)\n{\n\tconst char *level, *sevstr, *subtype;\n\tstatic const char *mc_ue_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch\",\n\t\t\"Page table walk ifetch\",\n\t\t\"Load/Store\",\n\t\t\"Page table walk Load/Store\",\n\t};\n\tstatic const char *mc_slb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_erat_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_tlb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\n\t/* Print things out */\n\tif (evt->version != MCE_V1) {\n\t\tpr_err(\"Machine Check Exception, Unknown event version %d !\\n\",\n\t\t       evt->version);\n\t\treturn;\n\t}\n\tswitch (evt->severity) {\n\tcase MCE_SEV_NO_ERROR:\n\t\tlevel = KERN_INFO;\n\t\tsevstr = \"Harmless\";\n\t\tbreak;\n\tcase MCE_SEV_WARNING:\n\t\tlevel = KERN_WARNING;\n\t\tsevstr = \"\";\n\t\tbreak;\n\tcase MCE_SEV_ERROR_SYNC:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Severe\";\n\t\tbreak;\n\tcase MCE_SEV_FATAL:\n\tdefault:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Fatal\";\n\t\tbreak;\n\t}\n\n\tprintk(\"%s%s Machine check interrupt [%s]\\n\", level, sevstr,\n\t       evt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t       \"Recovered\" : \"[Not recovered\");\n\tprintk(\"%s  Initiator: %s\\n\", level,\n\t       evt->initiator == MCE_INITIATOR_CPU ? \"CPU\" : \"Unknown\");\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tsubtype = evt->u.ue_error.ue_error_type <\n\t\t\tARRAY_SIZE(mc_ue_types) ?\n\t\t\tmc_ue_types[evt->u.ue_error.ue_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: UE [%s]\\n\", level, subtype);\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.ue_error.effective_address);\n\t\tif (evt->u.ue_error.physical_address_provided)\n\t\t\tprintk(\"%s      Physial address: %016llx\\n\",\n\t\t\t       level, evt->u.ue_error.physical_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tsubtype = evt->u.slb_error.slb_error_type <\n\t\t\tARRAY_SIZE(mc_slb_types) ?\n\t\t\tmc_slb_types[evt->u.slb_error.slb_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: SLB [%s]\\n\", level, subtype);\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.slb_error.effective_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tsubtype = evt->u.erat_error.erat_error_type <\n\t\t\tARRAY_SIZE(mc_erat_types) ?\n\t\t\tmc_erat_types[evt->u.erat_error.erat_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: ERAT [%s]\\n\", level, subtype);\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.erat_error.effective_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tsubtype = evt->u.tlb_error.tlb_error_type <\n\t\t\tARRAY_SIZE(mc_tlb_types) ?\n\t\t\tmc_tlb_types[evt->u.tlb_error.tlb_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: TLB [%s]\\n\", level, subtype);\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.tlb_error.effective_address);\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\tprintk(\"%s  Error type: Unknown\\n\", level);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/mce.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nvoid machine_check_print_event_info(struct machine_check_event *evt)\n{\n\tconst char *level, *sevstr, *subtype;\n\tstatic const char *mc_ue_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Instruction fetch\",\n\t\t\"Page table walk ifetch\",\n\t\t\"Load/Store\",\n\t\t\"Page table walk Load/Store\",\n\t};\n\tstatic const char *mc_slb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_erat_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\tstatic const char *mc_tlb_types[] = {\n\t\t\"Indeterminate\",\n\t\t\"Parity\",\n\t\t\"Multihit\",\n\t};\n\n\t/* Print things out */\n\tif (evt->version != MCE_V1) {\n\t\tpr_err(\"Machine Check Exception, Unknown event version %d !\\n\",\n\t\t       evt->version);\n\t\treturn;\n\t}\n\tswitch (evt->severity) {\n\tcase MCE_SEV_NO_ERROR:\n\t\tlevel = KERN_INFO;\n\t\tsevstr = \"Harmless\";\n\t\tbreak;\n\tcase MCE_SEV_WARNING:\n\t\tlevel = KERN_WARNING;\n\t\tsevstr = \"\";\n\t\tbreak;\n\tcase MCE_SEV_ERROR_SYNC:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Severe\";\n\t\tbreak;\n\tcase MCE_SEV_FATAL:\n\tdefault:\n\t\tlevel = KERN_ERR;\n\t\tsevstr = \"Fatal\";\n\t\tbreak;\n\t}\n\n\tprintk(\"%s%s Machine check interrupt [%s]\\n\", level, sevstr,\n\t       evt->disposition == MCE_DISPOSITION_RECOVERED ?\n\t       \"Recovered\" : \"[Not recovered\");\n\tprintk(\"%s  Initiator: %s\\n\", level,\n\t       evt->initiator == MCE_INITIATOR_CPU ? \"CPU\" : \"Unknown\");\n\tswitch (evt->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tsubtype = evt->u.ue_error.ue_error_type <\n\t\t\tARRAY_SIZE(mc_ue_types) ?\n\t\t\tmc_ue_types[evt->u.ue_error.ue_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: UE [%s]\\n\", level, subtype);\n\t\tif (evt->u.ue_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.ue_error.effective_address);\n\t\tif (evt->u.ue_error.physical_address_provided)\n\t\t\tprintk(\"%s      Physial address: %016llx\\n\",\n\t\t\t       level, evt->u.ue_error.physical_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tsubtype = evt->u.slb_error.slb_error_type <\n\t\t\tARRAY_SIZE(mc_slb_types) ?\n\t\t\tmc_slb_types[evt->u.slb_error.slb_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: SLB [%s]\\n\", level, subtype);\n\t\tif (evt->u.slb_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.slb_error.effective_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tsubtype = evt->u.erat_error.erat_error_type <\n\t\t\tARRAY_SIZE(mc_erat_types) ?\n\t\t\tmc_erat_types[evt->u.erat_error.erat_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: ERAT [%s]\\n\", level, subtype);\n\t\tif (evt->u.erat_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.erat_error.effective_address);\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tsubtype = evt->u.tlb_error.tlb_error_type <\n\t\t\tARRAY_SIZE(mc_tlb_types) ?\n\t\t\tmc_tlb_types[evt->u.tlb_error.tlb_error_type]\n\t\t\t: \"Unknown\";\n\t\tprintk(\"%s  Error type: TLB [%s]\\n\", level, subtype);\n\t\tif (evt->u.tlb_error.effective_address_provided)\n\t\t\tprintk(\"%s    Effective address: %016llx\\n\",\n\t\t\t       level, evt->u.tlb_error.effective_address);\n\t\tbreak;\n\tdefault:\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\t\tprintk(\"%s  Error type: Unknown\\n\", level);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_event_queue[index]"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "mce_queue_count"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "mce_queue_count"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(int, mce_queue_count);\nstatic void machine_check_process_queued_event(struct irq_work *work);\n\nstatic void machine_check_process_queued_event(struct irq_work *work)\n{\n\tint index;\n\n\t/*\n\t * For now just print it to console.\n\t * TODO: log this error event to FSP or nvram.\n\t */\n\twhile (__this_cpu_read(mce_queue_count) > 0) {\n\t\tindex = __this_cpu_read(mce_queue_count) - 1;\n\t\tmachine_check_print_event_info(\n\t\t\t\tthis_cpu_ptr(&mce_event_queue[index]));\n\t\t__this_cpu_dec(mce_queue_count);\n\t}\n}"
  },
  {
    "function_name": "machine_check_queue_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
    "lines": "179-197",
    "snippet": "void machine_check_queue_event(void)\n{\n\tint index;\n\tstruct machine_check_event evt;\n\n\tif (!get_mce_event(&evt, MCE_EVENT_RELEASE))\n\t\treturn;\n\n\tindex = __this_cpu_inc_return(mce_queue_count) - 1;\n\t/* If queue is full, just return for now. */\n\tif (index >= MAX_MC_EVT) {\n\t\t__this_cpu_dec(mce_queue_count);\n\t\treturn;\n\t}\n\tmemcpy(this_cpu_ptr(&mce_event_queue[index]), &evt, sizeof(evt));\n\n\t/* Queue irq work to process this event later. */\n\tirq_work_queue(&mce_event_process_work);\n}",
    "includes": [
      "#include <asm/mce.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(int, mce_queue_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);",
      "static void machine_check_process_queued_event(struct irq_work *work);",
      "struct irq_work mce_event_process_work = {\n        .func = machine_check_process_queued_event,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&mce_event_process_work"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "this_cpu_ptr(&mce_event_queue[index])",
            "&evt",
            "sizeof(evt)"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "_memcpy_toio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/io.c",
          "lines": "185-209",
          "snippet": "void _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}",
          "includes": [
            "#include <asm/bug.h>",
            "#include <asm/firmware.h>",
            "#include <asm/io.h>",
            "#include <linux/export.h>",
            "#include <linux/compiler.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/bug.h>\n#include <asm/firmware.h>\n#include <asm/io.h>\n#include <linux/export.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_event_queue[index]"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_queue_count"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "mce_queue_count"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mce_event",
          "args": [
            "&evt",
            "MCE_EVENT_RELEASE"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "get_mce_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
          "lines": "144-169",
          "snippet": "int get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mce.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, mce_nest_count);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nint get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(int, mce_queue_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\nstatic void machine_check_process_queued_event(struct irq_work *work);\nstruct irq_work mce_event_process_work = {\n        .func = machine_check_process_queued_event,\n};\n\nvoid machine_check_queue_event(void)\n{\n\tint index;\n\tstruct machine_check_event evt;\n\n\tif (!get_mce_event(&evt, MCE_EVENT_RELEASE))\n\t\treturn;\n\n\tindex = __this_cpu_inc_return(mce_queue_count) - 1;\n\t/* If queue is full, just return for now. */\n\tif (index >= MAX_MC_EVT) {\n\t\t__this_cpu_dec(mce_queue_count);\n\t\treturn;\n\t}\n\tmemcpy(this_cpu_ptr(&mce_event_queue[index]), &evt, sizeof(evt));\n\n\t/* Queue irq work to process this event later. */\n\tirq_work_queue(&mce_event_process_work);\n}"
  },
  {
    "function_name": "release_mce_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
    "lines": "171-174",
    "snippet": "void release_mce_event(void)\n{\n\tget_mce_event(NULL, true);\n}",
    "includes": [
      "#include <asm/mce.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_mce_event",
          "args": [
            "NULL",
            "true"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "get_mce_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
          "lines": "144-169",
          "snippet": "int get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/mce.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(int, mce_nest_count);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nint get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nvoid release_mce_event(void)\n{\n\tget_mce_event(NULL, true);\n}"
  },
  {
    "function_name": "get_mce_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
    "lines": "144-169",
    "snippet": "int get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/mce.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, mce_nest_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "mce_nest_count"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_event[index]"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "mce_nest_count"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nint get_mce_event(struct machine_check_event *mce, bool release)\n{\n\tint index = __this_cpu_read(mce_nest_count) - 1;\n\tstruct machine_check_event *mc_evt;\n\tint ret = 0;\n\n\t/* Sanity check */\n\tif (index < 0)\n\t\treturn ret;\n\n\t/* Check if we have MCE info to process. */\n\tif (index < MAX_MC_EVT) {\n\t\tmc_evt = this_cpu_ptr(&mce_event[index]);\n\t\t/* Copy the event structure and release the original */\n\t\tif (mce)\n\t\t\t*mce = *mc_evt;\n\t\tif (release)\n\t\t\tmc_evt->in_use = 0;\n\t\tret = 1;\n\t}\n\t/* Decrement the count to free the slot. */\n\tif (release)\n\t\t__this_cpu_dec(mce_nest_count);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "save_mce_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
    "lines": "71-125",
    "snippet": "void save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr)\n{\n\tuint64_t srr1;\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\n\tmce->initiator = MCE_INITIATOR_CPU;\n\tif (handled)\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\tmce->severity = MCE_SEV_ERROR_SYNC;\n\n\tsrr1 = regs->msr;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t}\n\treturn;\n}",
    "includes": [
      "#include <asm/mce.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(int, mce_nest_count);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mce_set_error_info",
          "args": [
            "mce",
            "mce_err"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "mce_set_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
          "lines": "44-65",
          "snippet": "static void mce_set_error_info(struct machine_check_event *mce,\n\t\t\t       struct mce_error_info *mce_err)\n{\n\tmce->error_type = mce_err->error_type;\n\tswitch (mce_err->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tmce->u.ue_error.ue_error_type = mce_err->u.ue_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tmce->u.slb_error.slb_error_type = mce_err->u.slb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tmce->u.erat_error.erat_error_type = mce_err->u.erat_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tmce->u.tlb_error.tlb_error_type = mce_err->u.tlb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <asm/mce.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
            "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nstatic void mce_set_error_info(struct machine_check_event *mce,\n\t\t\t       struct mce_error_info *mce_err)\n{\n\tmce->error_type = mce_err->error_type;\n\tswitch (mce_err->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tmce->u.ue_error.ue_error_type = mce_err->u.ue_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tmce->u.slb_error.slb_error_type = mce_err->u.slb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tmce->u.erat_error.erat_error_type = mce_err->u.erat_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tmce->u.tlb_error.tlb_error_type = mce_err->u.tlb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&mce_event[index]"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc_return",
          "args": [
            "mce_nest_count"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(int, mce_nest_count);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nvoid save_mce_event(struct pt_regs *regs, long handled,\n\t\t    struct mce_error_info *mce_err,\n\t\t    uint64_t nip, uint64_t addr)\n{\n\tuint64_t srr1;\n\tint index = __this_cpu_inc_return(mce_nest_count) - 1;\n\tstruct machine_check_event *mce = this_cpu_ptr(&mce_event[index]);\n\n\t/*\n\t * Return if we don't have enough space to log mce event.\n\t * mce_nest_count may go beyond MAX_MC_EVT but that's ok,\n\t * the check below will stop buffer overrun.\n\t */\n\tif (index >= MAX_MC_EVT)\n\t\treturn;\n\n\t/* Populate generic machine check info */\n\tmce->version = MCE_V1;\n\tmce->srr0 = nip;\n\tmce->srr1 = regs->msr;\n\tmce->gpr3 = regs->gpr[3];\n\tmce->in_use = 1;\n\n\tmce->initiator = MCE_INITIATOR_CPU;\n\tif (handled)\n\t\tmce->disposition = MCE_DISPOSITION_RECOVERED;\n\telse\n\t\tmce->disposition = MCE_DISPOSITION_NOT_RECOVERED;\n\tmce->severity = MCE_SEV_ERROR_SYNC;\n\n\tsrr1 = regs->msr;\n\n\t/*\n\t * Populate the mce error_type and type-specific error_type.\n\t */\n\tmce_set_error_info(mce, mce_err);\n\n\tif (!addr)\n\t\treturn;\n\n\tif (mce->error_type == MCE_ERROR_TYPE_TLB) {\n\t\tmce->u.tlb_error.effective_address_provided = true;\n\t\tmce->u.tlb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_SLB) {\n\t\tmce->u.slb_error.effective_address_provided = true;\n\t\tmce->u.slb_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_ERAT) {\n\t\tmce->u.erat_error.effective_address_provided = true;\n\t\tmce->u.erat_error.effective_address = addr;\n\t} else if (mce->error_type == MCE_ERROR_TYPE_UE) {\n\t\tmce->u.ue_error.effective_address_provided = true;\n\t\tmce->u.ue_error.effective_address = addr;\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "mce_set_error_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/mce.c",
    "lines": "44-65",
    "snippet": "static void mce_set_error_info(struct machine_check_event *mce,\n\t\t\t       struct mce_error_info *mce_err)\n{\n\tmce->error_type = mce_err->error_type;\n\tswitch (mce_err->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tmce->u.ue_error.ue_error_type = mce_err->u.ue_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tmce->u.slb_error.slb_error_type = mce_err->u.slb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tmce->u.erat_error.erat_error_type = mce_err->u.erat_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tmce->u.tlb_error.tlb_error_type = mce_err->u.tlb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <asm/mce.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/export.h>",
      "#include <linux/percpu.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);",
      "static DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <asm/mce.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/ptrace.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event);\nstatic DEFINE_PER_CPU(struct machine_check_event[MAX_MC_EVT], mce_event_queue);\n\nstatic void mce_set_error_info(struct machine_check_event *mce,\n\t\t\t       struct mce_error_info *mce_err)\n{\n\tmce->error_type = mce_err->error_type;\n\tswitch (mce_err->error_type) {\n\tcase MCE_ERROR_TYPE_UE:\n\t\tmce->u.ue_error.ue_error_type = mce_err->u.ue_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_SLB:\n\t\tmce->u.slb_error.slb_error_type = mce_err->u.slb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_ERAT:\n\t\tmce->u.erat_error.erat_error_type = mce_err->u.erat_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_TLB:\n\t\tmce->u.tlb_error.tlb_error_type = mce_err->u.tlb_error_type;\n\t\tbreak;\n\tcase MCE_ERROR_TYPE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}"
  }
]