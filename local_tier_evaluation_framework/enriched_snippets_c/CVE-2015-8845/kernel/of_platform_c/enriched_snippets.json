[
  {
    "function_name": "of_pci_phb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/of_platform.c",
    "lines": "117-120",
    "snippet": "static __init int of_pci_phb_init(void)\n{\n\treturn platform_driver_register(&of_pci_phb_driver);\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/topology.h>",
      "#include <asm/errno.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of_platform.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of.h>",
      "#include <linux/pci.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "platform_driver_register",
          "args": [
            "&of_pci_phb_driver"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/topology.h>\n#include <asm/errno.h>\n#include <linux/atomic.h>\n#include <linux/of_platform.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/mod_devicetable.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic __init int of_pci_phb_init(void)\n{\n\treturn platform_driver_register(&of_pci_phb_driver);\n}"
  },
  {
    "function_name": "of_pci_phb_probe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/of_platform.c",
    "lines": "40-98",
    "snippet": "static int of_pci_phb_probe(struct platform_device *dev)\n{\n\tstruct pci_controller *phb;\n\n\t/* Check if we can do that ... */\n\tif (ppc_md.pci_setup_phb == NULL)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Setting up PCI bus %s\\n\", dev->dev.of_node->full_name);\n\n\t/* Alloc and setup PHB data structure */\n\tphb = pcibios_alloc_controller(dev->dev.of_node);\n\tif (!phb)\n\t\treturn -ENODEV;\n\n\t/* Setup parent in sysfs */\n\tphb->parent = &dev->dev;\n\n\t/* Setup the PHB using arch provided callback */\n\tif (ppc_md.pci_setup_phb(phb)) {\n\t\tpcibios_free_controller(phb);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Process \"ranges\" property */\n\tpci_process_bridge_OF_ranges(phb, dev->dev.of_node, 0);\n\n\t/* Init pci_dn data structures */\n\tpci_devs_phb_init_dynamic(phb);\n\n\t/* Create EEH devices for the PHB */\n\teeh_dev_phb_init_dynamic(phb);\n\n\t/* Register devices with EEH */\n\tif (dev->dev.of_node->child)\n\t\teeh_add_device_tree_early(PCI_DN(dev->dev.of_node));\n\n\t/* Scan the bus */\n\tpcibios_scan_phb(phb);\n\tif (phb->bus == NULL)\n\t\treturn -ENXIO;\n\n\t/* Claim resources. This might need some rework as well depending\n\t * whether we are doing probe-only or not, like assigning unassigned\n\t * resources etc...\n\t */\n\tpcibios_claim_one_bus(phb->bus);\n\n\t/* Finish EEH setup */\n\teeh_add_device_tree_late(phb->bus);\n\n\t/* Add probed PCI devices to the device model */\n\tpci_bus_add_devices(phb->bus);\n\n\t/* sysfs files should only be added after devices are added */\n\teeh_add_sysfs_files(phb->bus);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/eeh.h>",
      "#include <asm/ppc-pci.h>",
      "#include <asm/pci-bridge.h>",
      "#include <asm/topology.h>",
      "#include <asm/errno.h>",
      "#include <linux/atomic.h>",
      "#include <linux/of_platform.h>",
      "#include <linux/of_device.h>",
      "#include <linux/of.h>",
      "#include <linux/pci.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/export.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eeh_add_sysfs_files",
          "args": [
            "phb->bus"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_sysfs_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1198-1210",
          "snippet": "void eeh_add_sysfs_files(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_sysfs_add_device(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_sysfs_files(subbus);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_sysfs_files(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_sysfs_add_device(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_sysfs_files(subbus);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_bus_add_devices",
          "args": [
            "phb->bus"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_add_device_tree_late",
          "args": [
            "phb->bus"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_device_tree_late",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1175-1187",
          "snippet": "void eeh_add_device_tree_late(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_add_device_late(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_device_tree_late(subbus);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_device_tree_late(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\teeh_add_device_late(dev);\n\t\tif (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE) {\n\t\t\tstruct pci_bus *subbus = dev->subordinate;\n\t\t\tif (subbus)\n\t\t\t\teeh_add_device_tree_late(subbus);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_claim_one_bus",
          "args": [
            "phb->bus"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_claim_one_bus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1395-1421",
          "snippet": "void pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_claim_one_bus(struct pci_bus *bus)\n{\n\tstruct pci_dev *dev;\n\tstruct pci_bus *child_bus;\n\n\tlist_for_each_entry(dev, &bus->devices, bus_list) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tstruct resource *r = &dev->resource[i];\n\n\t\t\tif (r->parent || !r->start || !r->flags)\n\t\t\t\tcontinue;\n\n\t\t\tpr_debug(\"PCI: Claiming %s: Resource %d: %pR\\n\",\n\t\t\t\t pci_name(dev), i, r);\n\n\t\t\tif (pci_claim_resource(dev, i) == 0)\n\t\t\t\tcontinue;\n\n\t\t\tpci_claim_bridge_resource(dev, i);\n\t\t}\n\t}\n\n\tlist_for_each_entry(child_bus, &bus->children, node)\n\t\tpcibios_claim_one_bus(child_bus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_scan_phb",
          "args": [
            "phb"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_scan_phb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "1600-1657",
          "snippet": "void pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %s\\n\", of_node_full_name(node));\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pcibios_scan_phb(struct pci_controller *hose)\n{\n\tLIST_HEAD(resources);\n\tstruct pci_bus *bus;\n\tstruct device_node *node = hose->dn;\n\tint mode;\n\n\tpr_debug(\"PCI: Scanning PHB %s\\n\", of_node_full_name(node));\n\n\t/* Get some IO space for the new PHB */\n\tpcibios_setup_phb_io_space(hose);\n\n\t/* Wire up PHB bus resources */\n\tpcibios_setup_phb_resources(hose, &resources);\n\n\those->busn.start = hose->first_busno;\n\those->busn.end\t = hose->last_busno;\n\those->busn.flags = IORESOURCE_BUS;\n\tpci_add_resource(&resources, &hose->busn);\n\n\t/* Create an empty bus for the toplevel */\n\tbus = pci_create_root_bus(hose->parent, hose->first_busno,\n\t\t\t\t  hose->ops, hose, &resources);\n\tif (bus == NULL) {\n\t\tpr_err(\"Failed to create bus for PCI domain %04x\\n\",\n\t\t\those->global_number);\n\t\tpci_free_resource_list(&resources);\n\t\treturn;\n\t}\n\those->bus = bus;\n\n\t/* Get probe mode and perform scan */\n\tmode = PCI_PROBE_NORMAL;\n\tif (node && hose->controller_ops.probe_mode)\n\t\tmode = hose->controller_ops.probe_mode(bus);\n\tpr_debug(\"    probe mode: %d\\n\", mode);\n\tif (mode == PCI_PROBE_DEVTREE)\n\t\tof_scan_bus(node, bus);\n\n\tif (mode == PCI_PROBE_NORMAL) {\n\t\tpci_bus_update_busn_res_end(bus, 255);\n\t\those->last_busno = pci_scan_child_bus(bus);\n\t\tpci_bus_update_busn_res_end(bus, hose->last_busno);\n\t}\n\n\t/* Platform gets a chance to do some global fixups before\n\t * we proceed to resource allocation\n\t */\n\tif (ppc_md.pcibios_fixup_phb)\n\t\tppc_md.pcibios_fixup_phb(hose);\n\n\t/* Configure PCI Express settings */\n\tif (bus && !pci_has_flag(PCI_PROBE_ONLY)) {\n\t\tstruct pci_bus *child;\n\t\tlist_for_each_entry(child, &bus->children, node)\n\t\t\tpcie_bus_configure_settings(child);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eeh_add_device_tree_early",
          "args": [
            "PCI_DN(dev->dev.of_node)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_add_device_tree_early",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh.c",
          "lines": "1098-1108",
          "snippet": "void eeh_add_device_tree_early(struct pci_dn *pdn)\n{\n\tstruct pci_dn *n;\n\n\tif (!pdn)\n\t\treturn;\n\n\tlist_for_each_entry(n, &pdn->child_list, list)\n\t\teeh_add_device_tree_early(n);\n\teeh_add_device_early(pdn);\n}",
          "includes": [
            "#include <asm/rtas.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/iommu.h>",
            "#include <asm/io.h>",
            "#include <asm/eeh_event.h>",
            "#include <asm/eeh.h>",
            "#include <asm/debug.h>",
            "#include <linux/atomic.h>",
            "#include <linux/of.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/reboot.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/iommu.h>",
            "#include <linux/pci.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/rtas.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/iommu.h>\n#include <asm/io.h>\n#include <asm/eeh_event.h>\n#include <asm/eeh.h>\n#include <asm/debug.h>\n#include <linux/atomic.h>\n#include <linux/of.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/reboot.h>\n#include <linux/rbtree.h>\n#include <linux/proc_fs.h>\n#include <linux/iommu.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n\nvoid eeh_add_device_tree_early(struct pci_dn *pdn)\n{\n\tstruct pci_dn *n;\n\n\tif (!pdn)\n\t\treturn;\n\n\tlist_for_each_entry(n, &pdn->child_list, list)\n\t\teeh_add_device_tree_early(n);\n\teeh_add_device_early(pdn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PCI_DN",
          "args": [
            "dev->dev.of_node"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eeh_dev_phb_init_dynamic",
          "args": [
            "phb"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "eeh_dev_phb_init_dynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/eeh_dev.c",
          "lines": "81-93",
          "snippet": "void eeh_dev_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct pci_dn *root = phb->pci_data;\n\n\t/* EEH PE for PHB */\n\teeh_phb_pe_create(phb);\n\n\t/* EEH device for PHB */\n\teeh_dev_init(root, phb);\n\n\t/* EEH devices for children OF nodes */\n\ttraverse_pci_dn(root, eeh_dev_init, phb);\n}",
          "includes": [
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/export.h>\n\nvoid eeh_dev_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct pci_dn *root = phb->pci_data;\n\n\t/* EEH PE for PHB */\n\teeh_phb_pe_create(phb);\n\n\t/* EEH device for PHB */\n\teeh_dev_init(root, phb);\n\n\t/* EEH devices for children OF nodes */\n\ttraverse_pci_dn(root, eeh_dev_init, phb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_devs_phb_init_dynamic",
          "args": [
            "phb"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "pci_devs_phb_init_dynamic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci_dn.c",
          "lines": "426-443",
          "snippet": "void pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tupdate_dn_pci_info(dn, phb);\n\tpdn = dn->data;\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\ttraverse_pci_devices(dn, update_dn_pci_info, phb);\n}",
          "includes": [
            "#include <asm/firmware.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/firmware.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <linux/gfp.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nvoid pci_devs_phb_init_dynamic(struct pci_controller *phb)\n{\n\tstruct device_node *dn = phb->dn;\n\tstruct pci_dn *pdn;\n\n\t/* PHB nodes themselves must not match */\n\tupdate_dn_pci_info(dn, phb);\n\tpdn = dn->data;\n\tif (pdn) {\n\t\tpdn->devfn = pdn->busno = -1;\n\t\tpdn->vendor_id = pdn->device_id = pdn->class_code = 0;\n\t\tpdn->phb = phb;\n\t\tphb->pci_data = pdn;\n\t}\n\n\t/* Update dn->phb ptrs for new phb and children devices */\n\ttraverse_pci_devices(dn, update_dn_pci_info, phb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pci_process_bridge_OF_ranges",
          "args": [
            "phb",
            "dev->dev.of_node",
            "0"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "pci_process_bridge_OF_ranges",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "672-772",
          "snippet": "void pci_process_bridge_OF_ranges(struct pci_controller *hose,\n\t\t\t\t  struct device_node *dev, int primary)\n{\n\tint memno = 0;\n\tstruct resource *res;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\n\tprintk(KERN_INFO \"PCI host bridge %s %s ranges:\\n\",\n\t       dev->full_name, primary ? \"(primary)\" : \"\");\n\n\t/* Check for ranges property */\n\tif (of_pci_range_parser_init(&parser, dev))\n\t\treturn;\n\n\t/* Parse it */\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t/* If we failed translation or got a zero-sized region\n\t\t * (some FW try to feed us with non sensical zero sized regions\n\t\t * such as power3 which look like some kind of attempt at exposing\n\t\t * the VGA memory hole)\n\t\t */\n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\t/* Act based on address space type */\n\t\tres = NULL;\n\t\tswitch (range.flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_IO:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr);\n\n\t\t\t/* We support only one IO range */\n\t\t\tif (hose->pci_io_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef CONFIG_PPC32\n\t\t\t/* On 32 bits, limit I/O space to 16MB */\n\t\t\tif (range.size > 0x01000000)\n\t\t\t\trange.size = 0x01000000;\n\n\t\t\t/* 32 bits needs to map IOs here */\n\t\t\those->io_base_virt = ioremap(range.cpu_addr,\n\t\t\t\t\t\trange.size);\n\n\t\t\t/* Expect trouble if pci_addr is not 0 */\n\t\t\tif (primary)\n\t\t\t\tisa_io_base =\n\t\t\t\t\t(unsigned long)hose->io_base_virt;\n#endif /* CONFIG_PPC32 */\n\t\t\t/* pci_io_size and io_base_phys always represent IO\n\t\t\t * space starting at 0 so we factor in pci_addr\n\t\t\t */\n\t\t\those->pci_io_size = range.pci_addr + range.size;\n\t\t\those->io_base_phys = range.cpu_addr - range.pci_addr;\n\n\t\t\t/* Build resource */\n\t\t\tres = &hose->io_resource;\n\t\t\trange.cpu_addr = range.pci_addr;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr,\n\t\t\t       (range.pci_space & 0x40000000) ?\n\t\t\t       \"Prefetch\" : \"\");\n\n\t\t\t/* We support only 3 memory ranges */\n\t\t\tif (memno >= 3) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handles ISA memory hole space here */\n\t\t\tif (range.pci_addr == 0) {\n\t\t\t\tif (primary || isa_mem_base == 0)\n\t\t\t\t\tisa_mem_base = range.cpu_addr;\n\t\t\t\those->isa_mem_phys = range.cpu_addr;\n\t\t\t\those->isa_mem_size = range.size;\n\t\t\t}\n\n\t\t\t/* Build resource */\n\t\t\those->mem_offset[memno] = range.cpu_addr -\n\t\t\t\t\t\t\trange.pci_addr;\n\t\t\tres = &hose->mem_resources[memno++];\n\t\t\tbreak;\n\t\t}\n\t\tif (res != NULL) {\n\t\t\tres->name = dev->full_name;\n\t\t\tres->flags = range.flags;\n\t\t\tres->start = range.cpu_addr;\n\t\t\tres->end = range.cpu_addr + range.size - 1;\n\t\t\tres->parent = res->child = res->sibling = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "resource_size_t isa_mem_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nresource_size_t isa_mem_base;\n\nvoid pci_process_bridge_OF_ranges(struct pci_controller *hose,\n\t\t\t\t  struct device_node *dev, int primary)\n{\n\tint memno = 0;\n\tstruct resource *res;\n\tstruct of_pci_range range;\n\tstruct of_pci_range_parser parser;\n\n\tprintk(KERN_INFO \"PCI host bridge %s %s ranges:\\n\",\n\t       dev->full_name, primary ? \"(primary)\" : \"\");\n\n\t/* Check for ranges property */\n\tif (of_pci_range_parser_init(&parser, dev))\n\t\treturn;\n\n\t/* Parse it */\n\tfor_each_of_pci_range(&parser, &range) {\n\t\t/* If we failed translation or got a zero-sized region\n\t\t * (some FW try to feed us with non sensical zero sized regions\n\t\t * such as power3 which look like some kind of attempt at exposing\n\t\t * the VGA memory hole)\n\t\t */\n\t\tif (range.cpu_addr == OF_BAD_ADDR || range.size == 0)\n\t\t\tcontinue;\n\n\t\t/* Act based on address space type */\n\t\tres = NULL;\n\t\tswitch (range.flags & IORESOURCE_TYPE_BITS) {\n\t\tcase IORESOURCE_IO:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \"  IO 0x%016llx..0x%016llx -> 0x%016llx\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr);\n\n\t\t\t/* We support only one IO range */\n\t\t\tif (hose->pci_io_size) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n#ifdef CONFIG_PPC32\n\t\t\t/* On 32 bits, limit I/O space to 16MB */\n\t\t\tif (range.size > 0x01000000)\n\t\t\t\trange.size = 0x01000000;\n\n\t\t\t/* 32 bits needs to map IOs here */\n\t\t\those->io_base_virt = ioremap(range.cpu_addr,\n\t\t\t\t\t\trange.size);\n\n\t\t\t/* Expect trouble if pci_addr is not 0 */\n\t\t\tif (primary)\n\t\t\t\tisa_io_base =\n\t\t\t\t\t(unsigned long)hose->io_base_virt;\n#endif /* CONFIG_PPC32 */\n\t\t\t/* pci_io_size and io_base_phys always represent IO\n\t\t\t * space starting at 0 so we factor in pci_addr\n\t\t\t */\n\t\t\those->pci_io_size = range.pci_addr + range.size;\n\t\t\those->io_base_phys = range.cpu_addr - range.pci_addr;\n\n\t\t\t/* Build resource */\n\t\t\tres = &hose->io_resource;\n\t\t\trange.cpu_addr = range.pci_addr;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM:\n\t\t\tprintk(KERN_INFO\n\t\t\t       \" MEM 0x%016llx..0x%016llx -> 0x%016llx %s\\n\",\n\t\t\t       range.cpu_addr, range.cpu_addr + range.size - 1,\n\t\t\t       range.pci_addr,\n\t\t\t       (range.pci_space & 0x40000000) ?\n\t\t\t       \"Prefetch\" : \"\");\n\n\t\t\t/* We support only 3 memory ranges */\n\t\t\tif (memno >= 3) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \" \\\\--> Skipped (too many) !\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Handles ISA memory hole space here */\n\t\t\tif (range.pci_addr == 0) {\n\t\t\t\tif (primary || isa_mem_base == 0)\n\t\t\t\t\tisa_mem_base = range.cpu_addr;\n\t\t\t\those->isa_mem_phys = range.cpu_addr;\n\t\t\t\those->isa_mem_size = range.size;\n\t\t\t}\n\n\t\t\t/* Build resource */\n\t\t\those->mem_offset[memno] = range.cpu_addr -\n\t\t\t\t\t\t\trange.pci_addr;\n\t\t\tres = &hose->mem_resources[memno++];\n\t\t\tbreak;\n\t\t}\n\t\tif (res != NULL) {\n\t\t\tres->name = dev->full_name;\n\t\t\tres->flags = range.flags;\n\t\t\tres->start = range.cpu_addr;\n\t\t\tres->end = range.cpu_addr + range.size - 1;\n\t\t\tres->parent = res->child = res->sibling = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcibios_free_controller",
          "args": [
            "phb"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_free_controller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "94-102",
          "snippet": "void pcibios_free_controller(struct pci_controller *phb)\n{\n\tspin_lock(&hose_spinlock);\n\tlist_del(&phb->list_node);\n\tspin_unlock(&hose_spinlock);\n\n\tif (phb->is_dynamic)\n\t\tkfree(phb);\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hose_spinlock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\n\nvoid pcibios_free_controller(struct pci_controller *phb)\n{\n\tspin_lock(&hose_spinlock);\n\tlist_del(&phb->list_node);\n\tspin_unlock(&hose_spinlock);\n\n\tif (phb->is_dynamic)\n\t\tkfree(phb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc_md.pci_setup_phb",
          "args": [
            "phb"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcibios_alloc_controller",
          "args": [
            "dev->dev.of_node"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "pcibios_alloc_controller",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/pci-common.c",
          "lines": "67-91",
          "snippet": "struct pci_controller *pcibios_alloc_controller(struct device_node *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\n\tif (phb == NULL)\n\t\treturn NULL;\n\tspin_lock(&hose_spinlock);\n\tphb->global_number = global_phb_number++;\n\tlist_add_tail(&phb->list_node, &hose_list);\n\tspin_unlock(&hose_spinlock);\n\tphb->dn = dev;\n\tphb->is_dynamic = slab_is_available();\n#ifdef CONFIG_PPC64\n\tif (dev) {\n\t\tint nid = of_node_to_nid(dev);\n\n\t\tif (nid < 0 || !node_online(nid))\n\t\t\tnid = -1;\n\n\t\tPHB_SET_NODE(phb, nid);\n\t}\n#endif\n\treturn phb;\n}",
          "includes": [
            "#include <asm/eeh.h>",
            "#include <asm/ppc-pci.h>",
            "#include <asm/machdep.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/pci-bridge.h>",
            "#include <asm/prom.h>",
            "#include <asm/io.h>",
            "#include <asm/processor.h>",
            "#include <linux/vgaarb.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/irq.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/list.h>",
            "#include <linux/mm.h>",
            "#include <linux/of_pci.h>",
            "#include <linux/of_address.h>",
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/pci.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(hose_spinlock);",
            "static int global_phb_number;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/machdep.h>\n#include <asm/byteorder.h>\n#include <asm/pci-bridge.h>\n#include <asm/prom.h>\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/vgaarb.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/irq.h>\n#include <linux/syscalls.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/of_pci.h>\n#include <linux/of_address.h>\n#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_SPINLOCK(hose_spinlock);\nstatic int global_phb_number;\n\nstruct pci_controller *pcibios_alloc_controller(struct device_node *dev)\n{\n\tstruct pci_controller *phb;\n\n\tphb = zalloc_maybe_bootmem(sizeof(struct pci_controller), GFP_KERNEL);\n\tif (phb == NULL)\n\t\treturn NULL;\n\tspin_lock(&hose_spinlock);\n\tphb->global_number = global_phb_number++;\n\tlist_add_tail(&phb->list_node, &hose_list);\n\tspin_unlock(&hose_spinlock);\n\tphb->dn = dev;\n\tphb->is_dynamic = slab_is_available();\n#ifdef CONFIG_PPC64\n\tif (dev) {\n\t\tint nid = of_node_to_nid(dev);\n\n\t\tif (nid < 0 || !node_online(nid))\n\t\t\tnid = -1;\n\n\t\tPHB_SET_NODE(phb, nid);\n\t}\n#endif\n\treturn phb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Setting up PCI bus %s\\n\"",
            "dev->dev.of_node->full_name"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/eeh.h>\n#include <asm/ppc-pci.h>\n#include <asm/pci-bridge.h>\n#include <asm/topology.h>\n#include <asm/errno.h>\n#include <linux/atomic.h>\n#include <linux/of_platform.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/mod_devicetable.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nstatic int of_pci_phb_probe(struct platform_device *dev)\n{\n\tstruct pci_controller *phb;\n\n\t/* Check if we can do that ... */\n\tif (ppc_md.pci_setup_phb == NULL)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Setting up PCI bus %s\\n\", dev->dev.of_node->full_name);\n\n\t/* Alloc and setup PHB data structure */\n\tphb = pcibios_alloc_controller(dev->dev.of_node);\n\tif (!phb)\n\t\treturn -ENODEV;\n\n\t/* Setup parent in sysfs */\n\tphb->parent = &dev->dev;\n\n\t/* Setup the PHB using arch provided callback */\n\tif (ppc_md.pci_setup_phb(phb)) {\n\t\tpcibios_free_controller(phb);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Process \"ranges\" property */\n\tpci_process_bridge_OF_ranges(phb, dev->dev.of_node, 0);\n\n\t/* Init pci_dn data structures */\n\tpci_devs_phb_init_dynamic(phb);\n\n\t/* Create EEH devices for the PHB */\n\teeh_dev_phb_init_dynamic(phb);\n\n\t/* Register devices with EEH */\n\tif (dev->dev.of_node->child)\n\t\teeh_add_device_tree_early(PCI_DN(dev->dev.of_node));\n\n\t/* Scan the bus */\n\tpcibios_scan_phb(phb);\n\tif (phb->bus == NULL)\n\t\treturn -ENXIO;\n\n\t/* Claim resources. This might need some rework as well depending\n\t * whether we are doing probe-only or not, like assigning unassigned\n\t * resources etc...\n\t */\n\tpcibios_claim_one_bus(phb->bus);\n\n\t/* Finish EEH setup */\n\teeh_add_device_tree_late(phb->bus);\n\n\t/* Add probed PCI devices to the device model */\n\tpci_bus_add_devices(phb->bus);\n\n\t/* sysfs files should only be added after devices are added */\n\teeh_add_sysfs_files(phb->bus);\n\n\treturn 0;\n}"
  }
]